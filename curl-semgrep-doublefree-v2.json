{"version":"1.99.0","results":[{"check_id":"c.raptor-command-injection","path":"/home/qqq/curl-8.7.0/test.c","start":{"line":8,"col":5,"offset":151},"end":{"line":8,"col":18,"offset":164},"extra":{"metavars":{},"message":"The software constructs an OS command using externally-influenced input,  but it does not neutralize or incorrectly neutralizes special elements  that could modify the intended OS command.","metadata":{"author":"Marco Ivaldi <raptor@0xdeadbeef.info>","references":["https://cwe.mitre.org/data/definitions/676","https://cwe.mitre.org/data/definitions/78","https://cwe.mitre.org/data/definitions/88","https://g.co/kgs/PCHQjJ","https://www.sei.cmu.edu/downloads/sei-cert-c-coding-standard-2016-v01.pdf"],"confidence":"HIGH"},"severity":"ERROR","fingerprint":"540f85881c01982b3ee57d0e34b9b7fba6f10354649abd32a7d96915cbb4772bd5ba49d43b161e7698cf026da8c98672a382161351f84377693497fd391055cd_0","lines":"    system(input);  // Potential OS Command Injection Vulnerability","is_ignored":false,"validation_state":"NO_VALIDATOR","engine_kind":"OSS"}}],"errors":[{"code":3,"level":"warn","type":["PartialParsing",[{"path":"/home/qqq/curl-8.7.0/src/tool_getpass.c","start":{"line":72,"col":16,"offset":0},"end":{"line":72,"col":20,"offset":4}},{"path":"/home/qqq/curl-8.7.0/src/tool_getpass.c","start":{"line":73,"col":16,"offset":0},"end":{"line":73,"col":20,"offset":4}},{"path":"/home/qqq/curl-8.7.0/src/tool_getpass.c","start":{"line":80,"col":12,"offset":0},"end":{"line":80,"col":20,"offset":8}},{"path":"/home/qqq/curl-8.7.0/src/tool_getpass.c","start":{"line":80,"col":40,"offset":0},"end":{"line":80,"col":41,"offset":1}},{"path":"/home/qqq/curl-8.7.0/src/tool_getpass.c","start":{"line":82,"col":11,"offset":0},"end":{"line":82,"col":14,"offset":3}},{"path":"/home/qqq/curl-8.7.0/src/tool_getpass.c","start":{"line":83,"col":22,"offset":0},"end":{"line":83,"col":34,"offset":12}},{"path":"/home/qqq/curl-8.7.0/src/tool_getpass.c","start":{"line":83,"col":39,"offset":0},"end":{"line":83,"col":48,"offset":9}},{"path":"/home/qqq/curl-8.7.0/src/tool_getpass.c","start":{"line":87,"col":27,"offset":0},"end":{"line":87,"col":31,"offset":4}},{"path":"/home/qqq/curl-8.7.0/src/tool_getpass.c","start":{"line":88,"col":19,"offset":0},"end":{"line":88,"col":23,"offset":4}}]],"message":"Syntax error at line /home/qqq/curl-8.7.0/src/tool_getpass.c:72:\n `iosb` was unexpected","path":"/home/qqq/curl-8.7.0/src/tool_getpass.c","spans":[{"file":"/home/qqq/curl-8.7.0/src/tool_getpass.c","start":{"line":72,"col":16,"offset":0},"end":{"line":72,"col":20,"offset":4}},{"file":"/home/qqq/curl-8.7.0/src/tool_getpass.c","start":{"line":73,"col":16,"offset":0},"end":{"line":73,"col":20,"offset":4}},{"file":"/home/qqq/curl-8.7.0/src/tool_getpass.c","start":{"line":80,"col":12,"offset":0},"end":{"line":80,"col":20,"offset":8}},{"file":"/home/qqq/curl-8.7.0/src/tool_getpass.c","start":{"line":80,"col":40,"offset":0},"end":{"line":80,"col":41,"offset":1}},{"file":"/home/qqq/curl-8.7.0/src/tool_getpass.c","start":{"line":82,"col":11,"offset":0},"end":{"line":82,"col":14,"offset":3}},{"file":"/home/qqq/curl-8.7.0/src/tool_getpass.c","start":{"line":83,"col":22,"offset":0},"end":{"line":83,"col":34,"offset":12}},{"file":"/home/qqq/curl-8.7.0/src/tool_getpass.c","start":{"line":83,"col":39,"offset":0},"end":{"line":83,"col":48,"offset":9}},{"file":"/home/qqq/curl-8.7.0/src/tool_getpass.c","start":{"line":87,"col":27,"offset":0},"end":{"line":87,"col":31,"offset":4}},{"file":"/home/qqq/curl-8.7.0/src/tool_getpass.c","start":{"line":88,"col":19,"offset":0},"end":{"line":88,"col":23,"offset":4}}]},{"code":3,"level":"warn","type":["PartialParsing",[{"path":"/home/qqq/curl-8.7.0/lib/http.h","start":{"line":79,"col":1,"offset":0},"end":{"line":79,"col":8,"offset":7}},{"path":"/home/qqq/curl-8.7.0/lib/http.h","start":{"line":80,"col":33,"offset":0},"end":{"line":80,"col":46,"offset":13}},{"path":"/home/qqq/curl-8.7.0/lib/http.h","start":{"line":80,"col":48,"offset":0},"end":{"line":82,"col":37,"offset":46}},{"path":"/home/qqq/curl-8.7.0/lib/http.h","start":{"line":83,"col":1,"offset":0},"end":{"line":83,"col":7,"offset":6}},{"path":"/home/qqq/curl-8.7.0/lib/http.h","start":{"line":87,"col":1,"offset":0},"end":{"line":87,"col":8,"offset":7}},{"path":"/home/qqq/curl-8.7.0/lib/http.h","start":{"line":88,"col":34,"offset":0},"end":{"line":88,"col":47,"offset":13}},{"path":"/home/qqq/curl-8.7.0/lib/http.h","start":{"line":88,"col":49,"offset":0},"end":{"line":90,"col":38,"offset":47}},{"path":"/home/qqq/curl-8.7.0/lib/http.h","start":{"line":91,"col":1,"offset":0},"end":{"line":91,"col":7,"offset":6}}]],"message":"Syntax error at line /home/qqq/curl-8.7.0/lib/http.h:79:\n `#ifndef` was unexpected","path":"/home/qqq/curl-8.7.0/lib/http.h","spans":[{"file":"/home/qqq/curl-8.7.0/lib/http.h","start":{"line":79,"col":1,"offset":0},"end":{"line":79,"col":8,"offset":7}},{"file":"/home/qqq/curl-8.7.0/lib/http.h","start":{"line":80,"col":33,"offset":0},"end":{"line":80,"col":46,"offset":13}},{"file":"/home/qqq/curl-8.7.0/lib/http.h","start":{"line":80,"col":48,"offset":0},"end":{"line":82,"col":37,"offset":46}},{"file":"/home/qqq/curl-8.7.0/lib/http.h","start":{"line":83,"col":1,"offset":0},"end":{"line":83,"col":7,"offset":6}},{"file":"/home/qqq/curl-8.7.0/lib/http.h","start":{"line":87,"col":1,"offset":0},"end":{"line":87,"col":8,"offset":7}},{"file":"/home/qqq/curl-8.7.0/lib/http.h","start":{"line":88,"col":34,"offset":0},"end":{"line":88,"col":47,"offset":13}},{"file":"/home/qqq/curl-8.7.0/lib/http.h","start":{"line":88,"col":49,"offset":0},"end":{"line":90,"col":38,"offset":47}},{"file":"/home/qqq/curl-8.7.0/lib/http.h","start":{"line":91,"col":1,"offset":0},"end":{"line":91,"col":7,"offset":6}}]},{"code":3,"level":"warn","type":["PartialParsing",[{"path":"/home/qqq/curl-8.7.0/packages/OS400/os400sys.c","start":{"line":986,"col":11,"offset":0},"end":{"line":986,"col":15,"offset":4}},{"path":"/home/qqq/curl-8.7.0/packages/OS400/os400sys.c","start":{"line":1001,"col":11,"offset":0},"end":{"line":1001,"col":15,"offset":4}},{"path":"/home/qqq/curl-8.7.0/packages/OS400/os400sys.c","start":{"line":1015,"col":11,"offset":0},"end":{"line":1015,"col":15,"offset":4}},{"path":"/home/qqq/curl-8.7.0/packages/OS400/os400sys.c","start":{"line":1029,"col":11,"offset":0},"end":{"line":1029,"col":15,"offset":4}}]],"message":"Syntax error at line /home/qqq/curl-8.7.0/packages/OS400/os400sys.c:986:\n `char` was unexpected","path":"/home/qqq/curl-8.7.0/packages/OS400/os400sys.c","spans":[{"file":"/home/qqq/curl-8.7.0/packages/OS400/os400sys.c","start":{"line":986,"col":11,"offset":0},"end":{"line":986,"col":15,"offset":4}},{"file":"/home/qqq/curl-8.7.0/packages/OS400/os400sys.c","start":{"line":1001,"col":11,"offset":0},"end":{"line":1001,"col":15,"offset":4}},{"file":"/home/qqq/curl-8.7.0/packages/OS400/os400sys.c","start":{"line":1015,"col":11,"offset":0},"end":{"line":1015,"col":15,"offset":4}},{"file":"/home/qqq/curl-8.7.0/packages/OS400/os400sys.c","start":{"line":1029,"col":11,"offset":0},"end":{"line":1029,"col":15,"offset":4}}]},{"code":3,"level":"warn","type":"Syntax error","message":"Syntax error at line /home/qqq/curl-8.7.0/lib/smb.c:1:\n `/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.\n * Copyright (C) Bill Nagel <wnagel@tycoint.com>, Exacq Technologies\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n * SPDX-License-Identifier: curl\n *\n ***************************************************************************/\n\n#include \"curl_setup.h\"\n\n#if !defined(CURL_DISABLE_SMB) && defined(USE_CURL_NTLM_CORE)\n\n#ifdef _WIN32\n#define getpid GetCurrentProcessId\n#endif\n\n#include \"smb.h\"\n#include \"urldata.h\"\n#include \"sendf.h\"\n#include \"multiif.h\"\n#include \"cfilters.h\"\n#include \"connect.h\"\n#include \"progress.h\"\n#include \"transfer.h\"\n#include \"vtls/vtls.h\"\n#include \"curl_ntlm_core.h\"\n#include \"escape.h\"\n#include \"curl_endian.h\"\n\n/* The last #include files should be: */\n#include \"curl_memory.h\"\n#include \"memdebug.h\"\n\n/*\n * Definitions for SMB protocol data structures\n */\n#if defined(_MSC_VER) || defined(__ILEC400__)\n#  define PACK\n#  pragma pack(push)\n#  pragma pack(1)\n#elif defined(__GNUC__)\n#  define PACK __attribute__((packed))\n#else\n#  define PACK\n#endif\n\n#define SMB_COM_CLOSE                 0x04\n#define SMB_COM_READ_ANDX             0x2e\n#define SMB_COM_WRITE_ANDX            0x2f\n#define SMB_COM_TREE_DISCONNECT       0x71\n#define SMB_COM_NEGOTIATE             0x72\n#define SMB_COM_SETUP_ANDX            0x73\n#define SMB_COM_TREE_CONNECT_ANDX     0x75\n#define SMB_COM_NT_CREATE_ANDX        0xa2\n#define SMB_COM_NO_ANDX_COMMAND       0xff\n\n#define SMB_WC_CLOSE                  0x03\n#define SMB_WC_READ_ANDX              0x0c\n#define SMB_WC_WRITE_ANDX             0x0e\n#define SMB_WC_SETUP_ANDX             0x0d\n#define SMB_WC_TREE_CONNECT_ANDX      0x04\n#define SMB_WC_NT_CREATE_ANDX         0x18\n\n#define SMB_FLAGS_CANONICAL_PATHNAMES 0x10\n#define SMB_FLAGS_CASELESS_PATHNAMES  0x08\n#define SMB_FLAGS2_UNICODE_STRINGS    0x8000\n#define SMB_FLAGS2_IS_LONG_NAME       0x0040\n#define SMB_FLAGS2_KNOWS_LONG_NAME    0x0001\n\n#define SMB_CAP_LARGE_FILES           0x08\n#define SMB_GENERIC_WRITE             0x40000000\n#define SMB_GENERIC_READ              0x80000000\n#define SMB_FILE_SHARE_ALL            0x07\n#define SMB_FILE_OPEN                 0x01\n#define SMB_FILE_OVERWRITE_IF         0x05\n\n#define SMB_ERR_NOACCESS              0x00050001\n\nstruct smb_header {\n  unsigned char nbt_type;\n  unsigned char nbt_flags;\n  unsigned short nbt_length;\n  unsigned char magic[4];\n  unsigned char command;\n  unsigned int status;\n  unsigned char flags;\n  unsigned short flags2;\n  unsigned short pid_high;\n  unsigned char signature[8];\n  unsigned short pad;\n  unsigned short tid;\n  unsigned short pid;\n  unsigned short uid;\n  unsigned short mid;\n} PACK;\n\nstruct smb_negotiate_response {\n  struct smb_header h;\n  unsigned char word_count;\n  unsigned short dialect_index;\n  unsigned char security_mode;\n  unsigned short max_mpx_count;\n  unsigned short max_number_vcs;\n  unsigned int max_buffer_size;\n  unsigned int max_raw_size;\n  unsigned int session_key;\n  unsigned int capabilities;\n  unsigned int system_time_low;\n  unsigned int system_time_high;\n  unsigned short server_time_zone;\n  unsigned char encryption_key_length;\n  unsigned short byte_count;\n  char bytes[1];\n} PACK;\n\nstruct andx {\n  unsigned char command;\n  unsigned char pad;\n  unsigned short offset;\n} PACK;\n\nstruct smb_setup {\n  unsigned char word_count;\n  struct andx andx;\n  unsigned short max_buffer_size;\n  unsigned short max_mpx_count;\n  unsigned short vc_number;\n  unsigned int session_key;\n  unsigned short lengths[2];\n  unsigned int pad;\n  unsigned int capabilities;\n  unsigned short byte_count;\n  char bytes[1024];\n} PACK;\n\nstruct smb_tree_connect {\n  unsigned char word_count;\n  struct andx andx;\n  unsigned short flags;\n  unsigned short pw_len;\n  unsigned short byte_count;\n  char bytes[1024];\n} PACK;\n\nstruct smb_nt_create {\n  unsigned char word_count;\n  struct andx andx;\n  unsigned char pad;\n  unsigned short name_length;\n  unsigned int flags;\n  unsigned int root_fid;\n  unsigned int access;\n  curl_off_t allocation_size;\n  unsigned int ext_file_attributes;\n  unsigned int share_access;\n  unsigned int create_disposition;\n  unsigned int create_options;\n  unsigned int impersonation_level;\n  unsigned char security_flags;\n  unsigned short byte_count;\n  char bytes[1024];\n} PACK;\n\nstruct smb_nt_create_response {\n  struct smb_header h;\n  unsigned char word_count;\n  struct andx andx;\n  unsigned char op_lock_level;\n  unsigned short fid;\n  unsigned int create_disposition;\n\n  curl_off_t create_time;\n  curl_off_t last_access_time;\n  curl_off_t last_write_time;\n  curl_off_t last_change_time;\n  unsigned int ext_file_attributes;\n  curl_off_t allocation_size;\n  curl_off_t end_of_file;\n} PACK;\n\nstruct smb_read {\n  unsigned char word_count;\n  struct andx andx;\n  unsigned short fid;\n  unsigned int offset;\n  unsigned short max_bytes;\n  unsigned short min_bytes;\n  unsigned int timeout;\n  unsigned short remaining;\n  unsigned int offset_high;\n  unsigned short byte_count;\n} PACK;\n\nstruct smb_write {\n  struct smb_header h;\n  unsigned char word_count;\n  struct andx andx;\n  unsigned short fid;\n  unsigned int offset;\n  unsigned int timeout;\n  unsigned short write_mode;\n  unsigned short remaining;\n  unsigned short pad;\n  unsigned short data_length;\n  unsigned short data_offset;\n  unsigned int offset_high;\n  unsigned short byte_count;\n  unsigned char pad2;\n} PACK;\n\nstruct smb_close {\n  unsigned char word_count;\n  unsigned short fid;\n  unsigned int last_mtime;\n  unsigned short byte_count;\n} PACK;\n\nstruct smb_tree_disconnect {\n  unsigned char word_count;\n  unsigned short byte_count;\n} PACK;\n\n#if defined(_MSC_VER) || defined(__ILEC400__)\n#  pragma pack(pop)\n#endif\n\n/* Local API functions */\nstatic CURLcode smb_setup_connection(struct Curl_easy *data,\n                                     struct connectdata *conn);\nstatic CURLcode smb_connect(struct Curl_easy *data, bool *done);\nstatic CURLcode smb_connection_state(struct Curl_easy *data, bool *done);\nstatic CURLcode smb_do(struct Curl_easy *data, bool *done);\nstatic CURLcode smb_request_state(struct Curl_easy *data, bool *done);\nstatic CURLcode smb_disconnect(struct Curl_easy *data,\n                               struct connectdata *conn, bool dead);\nstatic int smb_getsock(struct Curl_easy *data, struct connectdata *conn,\n                       curl_socket_t *socks);\nstatic CURLcode smb_parse_url_path(struct Curl_easy *data,\n                                   struct connectdata *conn);\n\n/*\n * SMB handler interface\n */\nconst struct Curl_handler Curl_handler_smb = {\n  \"SMB\",                                /* scheme */\n  smb_setup_connection,                 /* setup_connection */\n  smb_do,                               /* do_it */\n  ZERO_NULL,                            /* done */\n  ZERO_NULL,                            /* do_more */\n  smb_connect,                          /* connect_it */\n  smb_connection_state,                 /* connecting */\n  smb_request_state,                    /* doing */\n  smb_getsock,                          /* proto_getsock */\n  smb_getsock,                          /* doing_getsock */\n  ZERO_NULL,                            /* domore_getsock */\n  ZERO_NULL,                            /* perform_getsock */\n  smb_disconnect,                       /* disconnect */\n  ZERO_NULL,                            /* write_resp */\n  ZERO_NULL,                            /* connection_check */\n  ZERO_NULL,                            /* attach connection */\n  PORT_SMB,                             /* defport */\n  CURLPROTO_SMB,                        /* protocol */\n  CURLPROTO_SMB,                        /* family */\n  PROTOPT_NONE                          /* flags */\n};\n\n#ifdef USE_SSL\n/*\n * SMBS handler interface\n */\nconst struct Curl_handler Curl_handler_smbs = {\n  \"SMBS\",                               /* scheme */\n  smb_setup_connection,                 /* setup_connection */\n  smb_do,                               /* do_it */\n  ZERO_NULL,                            /* done */\n  ZERO_NULL,                            /* do_more */\n  smb_connect,                          /* connect_it */\n  smb_connection_state,                 /* connecting */\n  smb_request_state,                    /* doing */\n  smb_getsock,                          /* proto_getsock */\n  smb_getsock,                          /* doing_getsock */\n  ZERO_NULL,                            /* domore_getsock */\n  ZERO_NULL,                            /* perform_getsock */\n  smb_disconnect,                       /* disconnect */\n  ZERO_NULL,                            /* write_resp */\n  ZERO_NULL,                            /* connection_check */\n  ZERO_NULL,                            /* attach connection */\n  PORT_SMBS,                            /* defport */\n  CURLPROTO_SMBS,                       /* protocol */\n  CURLPROTO_SMB,                        /* family */\n  PROTOPT_SSL                           /* flags */\n};\n#endif\n\n#define MAX_PAYLOAD_SIZE  0x8000\n#define MAX_MESSAGE_SIZE  (MAX_PAYLOAD_SIZE + 0x1000)\n#define CLIENTNAME        \"curl\"\n#define SERVICENAME       \"?????\"\n\n/* Append a string to an SMB message */\n#define MSGCAT(str)                             \\\n  do {                                          \\\n    strcpy(p, (str));                           \\\n    p += strlen(str);                           \\\n  } while(0)\n\n/* Append a null-terminated string to an SMB message */\n#define MSGCATNULL(str)                         \\\n  do {                                          \\\n    strcpy(p, (str));                           \\\n    p += strlen(str) + 1;                       \\\n  } while(0)\n\n/* SMB is mostly little endian */\n#if (defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__) || \\\n  defined(__OS400__)\nstatic unsigned short smb_swap16(unsigned short x)\n{\n  return (unsigned short) ((x << 8) | ((x >> 8) & 0xff));\n}\n\nstatic unsigned int smb_swap32(unsigned int x)\n{\n  return (x << 24) | ((x << 8) & 0xff0000) | ((x >> 8) & 0xff00) |\n    ((x >> 24) & 0xff);\n}\n\nstatic curl_off_t smb_swap64(curl_off_t x)\n{\n  return ((curl_off_t) smb_swap32((unsigned int) x) << 32) |\n    smb_swap32((unsigned int) (x >> 32));\n}\n\n#else\n#  define smb_swap16(x) (x)\n#  define smb_swap32(x) (x)\n#  define smb_swap64(x) (x)\n#endif\n\n/* SMB request state */\nenum smb_req_state {\n  SMB_REQUESTING,\n  SMB_TREE_CONNECT,\n  SMB_OPEN,\n  SMB_DOWNLOAD,\n  SMB_UPLOAD,\n  SMB_CLOSE,\n  SMB_TREE_DISCONNECT,\n  SMB_DONE\n};\n\n/* SMB request data */\nstruct smb_request {\n  enum smb_req_state state;\n  char *path;\n  unsigned short tid; /* Even if we connect to the same tree as another */\n  unsigned short fid; /* request, the tid will be different */\n  CURLcode result;\n};\n\nstatic void conn_state(struct Curl_easy *data, enum smb_conn_state newstate)\n{\n  struct smb_conn *smbc = &data->conn->proto.smbc;\n#if defined(DEBUGBUILD) && !defined(CURL_DISABLE_VERBOSE_STRINGS)\n  /* For debug purposes */\n  static const char * const names[] = {\n    \"SMB_NOT_CONNECTED\",\n    \"SMB_CONNECTING\",\n    \"SMB_NEGOTIATE\",\n    \"SMB_SETUP\",\n    \"SMB_CONNECTED\",\n    /* LAST */\n  };\n\n  if(smbc->state != newstate)\n    infof(data, \"SMB conn %p state change from %s to %s\",\n          (void *)smbc, names[smbc->state], names[newstate]);\n#endif\n\n  smbc->state = newstate;\n}\n\nstatic void request_state(struct Curl_easy *data,\n                          enum smb_req_state newstate)\n{\n  struct smb_request *req = data->req.p.smb;\n#if defined(DEBUGBUILD) && !defined(CURL_DISABLE_VERBOSE_STRINGS)\n  /* For debug purposes */\n  static const char * const names[] = {\n    \"SMB_REQUESTING\",\n    \"SMB_TREE_CONNECT\",\n    \"SMB_OPEN\",\n    \"SMB_DOWNLOAD\",\n    \"SMB_UPLOAD\",\n    \"SMB_CLOSE\",\n    \"SMB_TREE_DISCONNECT\",\n    \"SMB_DONE\",\n    /* LAST */\n  };\n\n  if(req->state != newstate)\n    infof(data, \"SMB request %p state change from %s to %s\",\n          (void *)req, names[req->state], names[newstate]);\n#endif\n\n  req->state = newstate;\n}\n\n/* this should setup things in the connection, not in the easy\n   handle */\nstatic CURLcode smb_setup_connection(struct Curl_easy *data,\n                                     struct connectdata *conn)\n{\n  struct smb_request *req;\n\n  /* Initialize the request state */\n  data->req.p.smb = req = calloc(1, sizeof(struct smb_request));\n  if(!req)\n    return CURLE_OUT_OF_MEMORY;\n\n  /* Parse the URL path */\n  return smb_parse_url_path(data, conn);\n}\n\nstatic CURLcode smb_connect(struct Curl_easy *data, bool *done)\n{\n  struct connectdata *conn = data->conn;\n  struct smb_conn *smbc = &conn->proto.smbc;\n  char *slash;\n\n  (void) done;\n\n  /* Check we have a username and password to authenticate with */\n  if(!data->state.aptr.user)\n    return CURLE_LOGIN_DENIED;\n\n  /* Initialize the connection state */\n  smbc->state = SMB_CONNECTING;\n  smbc->recv_buf = malloc(MAX_MESSAGE_SIZE);\n  if(!smbc->recv_buf)\n    return CURLE_OUT_OF_MEMORY;\n  smbc->send_buf = malloc(MAX_MESSAGE_SIZE);\n  if(!smbc->send_buf)\n    return CURLE_OUT_OF_MEMORY;\n\n  /* Multiple requests are allowed with this connection */\n  connkeep(conn, \"SMB default\");\n\n  /* Parse the username, domain, and password */\n  slash = strchr(conn->user, '/');\n  if(!slash)\n    slash = strchr(conn->user, '\\\\');\n\n  if(slash) {\n    smbc->user = slash + 1;\n    smbc->domain = strdup(conn->user);\n    if(!smbc->domain)\n      return CURLE_OUT_OF_MEMORY;\n    smbc->domain[slash - conn->user] = 0;\n  }\n  else {\n    smbc->user = conn->user;\n    smbc->domain = strdup(conn->host.name);\n    if(!smbc->domain)\n      return CURLE_OUT_OF_MEMORY;\n  }\n\n  return CURLE_OK;\n}\n\nstatic CURLcode smb_recv_message(struct Curl_easy *data, void **msg)\n{\n  struct connectdata *conn = data->conn;\n  struct smb_conn *smbc = &conn->proto.smbc;\n  char *buf = smbc->recv_buf;\n  ssize_t bytes_read;\n  size_t nbt_size;\n  size_t msg_size;\n  size_t len = MAX_MESSAGE_SIZE - smbc->got;\n  CURLcode result;\n\n  result = Curl_xfer_recv(data, buf + smbc->got, len, &bytes_read);\n  if(result)\n    return result;\n\n  if(!bytes_read)\n    return CURLE_OK;\n\n  smbc->got += bytes_read;\n\n  /* Check for a 32-bit nbt header */\n  if(smbc->got < sizeof(unsigned int))\n    return CURLE_OK;\n\n  nbt_size = Curl_read16_be((const unsigned char *)\n                            (buf + sizeof(unsigned short))) +\n    sizeof(unsigned int);\n  if(smbc->got < nbt_size)\n    return CURLE_OK;\n\n  msg_size = sizeof(struct smb_header);\n  if(nbt_size >= msg_size + 1) {\n    /* Add the word count */\n    msg_size += 1 + ((unsigned char) buf[msg_size]) * sizeof(unsigned short);\n    if(nbt_size >= msg_size + sizeof(unsigned short)) {\n      /* Add the byte count */\n      msg_size += sizeof(unsigned short) +\n        Curl_read16_le((const unsigned char *)&buf[msg_size]);\n      if(nbt_size < msg_size)\n        return CURLE_READ_ERROR;\n    }\n  }\n\n  *msg = buf;\n\n  return CURLE_OK;\n}\n\nstatic void smb_pop_message(struct connectdata *conn)\n{\n  struct smb_conn *smbc = &conn->proto.smbc;\n\n  smbc->got = 0;\n}\n\nstatic void smb_format_message(struct Curl_easy *data, struct smb_header *h,\n                               unsigned char cmd, size_t len)\n{\n  struct connectdata *conn = data->conn;\n  struct smb_conn *smbc = &conn->proto.smbc;\n  struct smb_request *req = data->req.p.smb;\n  unsigned int pid;\n\n  memset(h, 0, sizeof(*h));\n  h->nbt_length = htons((unsigned short) (sizeof(*h) - sizeof(unsigned int) +\n                                          len));\n  memcpy((char *)h->magic, \"\\xffSMB\", 4);\n  h->command = cmd;\n  h->flags = SMB_FLAGS_CANONICAL_PATHNAMES | SMB_FLAGS_CASELESS_PATHNAMES;\n  h->flags2 = smb_swap16(SMB_FLAGS2_IS_LONG_NAME | SMB_FLAGS2_KNOWS_LONG_NAME);\n  h->uid = smb_swap16(smbc->uid);\n  h->tid = smb_swap16(req->tid);\n  pid = getpid();\n  h->pid_high = smb_swap16((unsigned short)(pid >> 16));\n  h->pid = smb_swap16((unsigned short) pid);\n}\n\nstatic CURLcode smb_send(struct Curl_easy *data, size_t len,\n                         size_t upload_size)\n{\n  struct connectdata *conn = data->conn;\n  struct smb_conn *smbc = &conn->proto.smbc;\n  size_t bytes_written;\n  CURLcode result;\n\n  result = Curl_xfer_send(data, smbc->send_buf, len, &bytes_written);\n  if(result)\n    return result;\n\n  if(bytes_written != len) {\n    smbc->send_size = len;\n    smbc->sent = bytes_written;\n  }\n\n  smbc->upload_size = upload_size;\n\n  return CURLE_OK;\n}\n\nstatic CURLcode smb_flush(struct Curl_easy *data)\n{\n  struct connectdata *conn = data->conn;\n  struct smb_conn *smbc = &conn->proto.smbc;\n  size_t bytes_written;\n  size_t len = smbc->send_size - smbc->sent;\n  CURLcode result;\n\n  if(!smbc->send_size)\n    return CURLE_OK;\n\n  result = Curl_xfer_send(data, smbc->send_buf + smbc->sent, len,\n                          &bytes_written);\n  if(result)\n    return result;\n\n  if(bytes_written != len)\n    smbc->sent += bytes_written;\n  else\n    smbc->send_size = 0;\n\n  return CURLE_OK;\n}\n\nstatic CURLcode smb_send_message(struct Curl_easy *data, unsigned char cmd,\n                                 const void *msg, size_t msg_len)\n{\n  struct connectdata *conn = data->conn;\n  struct smb_conn *smbc = &conn->proto.smbc;\n\n  smb_format_message(data, (struct smb_header *)smbc->send_buf,\n                     cmd, msg_len);\n  DEBUGASSERT((sizeof(struct smb_header) + msg_len) <= MAX_MESSAGE_SIZE);\n  memcpy(smbc->send_buf + sizeof(struct smb_header), msg, msg_len);\n\n  return smb_send(data, sizeof(struct smb_header) + msg_len, 0);\n}\n\nstatic CURLcode smb_send_negotiate(struct Curl_easy *data)\n{\n  const char *msg = \"\\x00\\x0c\\x00\\x02NT LM 0.12\";\n\n  return smb_send_message(data, SMB_COM_NEGOTIATE, msg, 15);\n}\n\nstatic CURLcode smb_send_setup(struct Curl_easy *data)\n{\n  struct connectdata *conn = data->conn;\n  struct smb_conn *smbc = &conn->proto.smbc;\n  struct smb_setup msg;\n  char *p = msg.bytes;\n  unsigned char lm_hash[21];\n  unsigned char lm[24];\n  unsigned char nt_hash[21];\n  unsigned char nt[24];\n\n  size_t byte_count = sizeof(lm) + sizeof(nt);\n  byte_count += strlen(smbc->user) + strlen(smbc->domain);\n  byte_count += strlen(OS) + strlen(CLIENTNAME) + 4; /* 4 null chars */\n  if(byte_count > sizeof(msg.bytes))\n    return CURLE_FILESIZE_EXCEEDED;\n\n  Curl_ntlm_core_mk_lm_hash(conn->passwd, lm_hash);\n  Curl_ntlm_core_lm_resp(lm_hash, smbc->challenge, lm);\n  Curl_ntlm_core_mk_nt_hash(conn->passwd, nt_hash);\n  Curl_ntlm_core_lm_resp(nt_hash, smbc->challenge, nt);\n\n  memset(&msg, 0, sizeof(msg));\n  msg.word_count = SMB_WC_SETUP_ANDX;\n  msg.andx.command = SMB_COM_NO_ANDX_COMMAND;\n  msg.max_buffer_size = smb_swap16(MAX_MESSAGE_SIZE);\n  msg.max_mpx_count = smb_swap16(1);\n  msg.vc_number = smb_swap16(1);\n  msg.session_key = smb_swap32(smbc->session_key);\n  msg.capabilities = smb_swap32(SMB_CAP_LARGE_FILES);\n  msg.lengths[0] = smb_swap16(sizeof(lm));\n  msg.lengths[1] = smb_swap16(sizeof(nt));\n  memcpy(p, lm, sizeof(lm));\n  p += sizeof(lm);\n  memcpy(p, nt, sizeof(nt));\n  p += sizeof(nt);\n  MSGCATNULL(smbc->user);\n  MSGCATNULL(smbc->domain);\n  MSGCATNULL(OS);\n  MSGCATNULL(CLIENTNAME);\n  byte_count = p - msg.bytes;\n  msg.byte_count = smb_swap16((unsigned short)byte_count);\n\n  return smb_send_message(data, SMB_COM_SETUP_ANDX, &msg,\n                          sizeof(msg) - sizeof(msg.bytes) + byte_count);\n}\n\nstatic CURLcode smb_send_tree_connect(struct Curl_easy *data)\n{\n  struct smb_tree_connect msg;\n  struct connectdata *conn = data->conn;\n  struct smb_conn *smbc = &conn->proto.smbc;\n  char *p = msg.bytes;\n\n  size_t byte_count = strlen(conn->host.name) + strlen(smbc->share);\n  byte_count += strlen(SERVICENAME) + 5; /* 2 nulls and 3 backslashes */\n  if(byte_count > sizeof(msg.bytes))\n    return CURLE_FILESIZE_EXCEEDED;\n\n  memset(&msg, 0, sizeof(msg));\n  msg.word_count = SMB_WC_TREE_CONNECT_ANDX;\n  msg.andx.command = SMB_COM_NO_ANDX_COMMAND;\n  msg.pw_len = 0;\n  MSGCAT(\"\\\\\\\\\");\n  MSGCAT(conn->host.name);\n  MSGCAT(\"\\\\\");\n  MSGCATNULL(smbc->share);\n  MSGCATNULL(SERVICENAME); /* Match any type of service */\n  byte_count = p - msg.bytes;\n  msg.byte_count = smb_swap16((unsigned short)byte_count);\n\n  return smb_send_message(data, SMB_COM_TREE_CONNECT_ANDX, &msg,\n                          sizeof(msg) - sizeof(msg.bytes) + byte_count);\n}\n\nstatic CURLcode smb_send_open(struct Curl_easy *data)\n{\n  struct smb_request *req = data->req.p.smb;\n  struct smb_nt_create msg;\n  size_t byte_count;\n\n  if((strlen(req->path) + 1) > sizeof(msg.bytes))\n    return CURLE_FILESIZE_EXCEEDED;\n\n  memset(&msg, 0, sizeof(msg));\n  msg.word_count = SMB_WC_NT_CREATE_ANDX;\n  msg.andx.command = SMB_COM_NO_ANDX_COMMAND;\n  byte_count = strlen(req->path);\n  msg.name_length = smb_swap16((unsigned short)byte_count);\n  msg.share_access = smb_swap32(SMB_FILE_SHARE_ALL);\n  if(data->state.upload) {\n    msg.access = smb_swap32(SMB_GENERIC_READ | SMB_GENERIC_WRITE);\n    msg.create_disposition = smb_swap32(SMB_FILE_OVERWRITE_IF);\n  }\n  else {\n    msg.access = smb_swap32(SMB_GENERIC_READ);\n    msg.create_disposition = smb_swap32(SMB_FILE_OPEN);\n  }\n  msg.byte_count = smb_swap16((unsigned short) ++byte_count);\n  strcpy(msg.bytes, req->path);\n\n  return smb_send_message(data, SMB_COM_NT_CREATE_ANDX, &msg,\n                          sizeof(msg) - sizeof(msg.bytes) + byte_count);\n}\n\nstatic CURLcode smb_send_close(struct Curl_easy *data)\n{\n  struct smb_request *req = data->req.p.smb;\n  struct smb_close msg;\n\n  memset(&msg, 0, sizeof(msg));\n  msg.word_count = SMB_WC_CLOSE;\n  msg.fid = smb_swap16(req->fid);\n\n  return smb_send_message(data, SMB_COM_CLOSE, &msg, sizeof(msg));\n}\n\nstatic CURLcode smb_send_tree_disconnect(struct Curl_easy *data)\n{\n  struct smb_tree_disconnect msg;\n\n  memset(&msg, 0, sizeof(msg));\n\n  return smb_send_message(data, SMB_COM_TREE_DISCONNECT, &msg, sizeof(msg));\n}\n\nstatic CURLcode smb_send_read(struct Curl_easy *data)\n{\n  struct smb_request *req = data->req.p.smb;\n  curl_off_t offset = data->req.offset;\n  struct smb_read msg;\n\n  memset(&msg, 0, sizeof(msg));\n  msg.word_count = SMB_WC_READ_ANDX;\n  msg.andx.command = SMB_COM_NO_ANDX_COMMAND;\n  msg.fid = smb_swap16(req->fid);\n  msg.offset = smb_swap32((unsigned int) offset);\n  msg.offset_high = smb_swap32((unsigned int) (offset >> 32));\n  msg.min_bytes = smb_swap16(MAX_PAYLOAD_SIZE);\n  msg.max_bytes = smb_swap16(MAX_PAYLOAD_SIZE);\n\n  return smb_send_message(data, SMB_COM_READ_ANDX, &msg, sizeof(msg));\n}\n\nstatic CURLcode smb_send_write(struct Curl_easy *data)\n{\n  struct connectdata *conn = data->conn;\n  struct smb_conn *smbc = &conn->proto.smbc;\n  struct smb_write *msg;\n  struct smb_request *req = data->req.p.smb;\n  curl_off_t offset = data->req.offset;\n  curl_off_t upload_size = data->req.size - data->req.bytecount;\n\n  msg = (struct smb_write *)smbc->send_buf;\n  if(upload_size >= MAX_PAYLOAD_SIZE - 1) /* There is one byte of padding */\n    upload_size = MAX_PAYLOAD_SIZE - 1;\n\n  memset(msg, 0, sizeof(*msg));\n  msg->word_count = SMB_WC_WRITE_ANDX;\n  msg->andx.command = SMB_COM_NO_ANDX_COMMAND;\n  msg->fid = smb_swap16(req->fid);\n  msg->offset = smb_swap32((unsigned int) offset);\n  msg->offset_high = smb_swap32((unsigned int) (offset >> 32));\n  msg->data_length = smb_swap16((unsigned short) upload_size);\n  msg->data_offset = smb_swap16(sizeof(*msg) - sizeof(unsigned int));\n  msg->byte_count = smb_swap16((unsigned short) (upload_size + 1));\n\n  smb_format_message(data, &msg->h, SMB_COM_WRITE_ANDX,\n                     sizeof(*msg) - sizeof(msg->h) + (size_t) upload_size);\n\n  return smb_send(data, sizeof(*msg), (size_t) upload_size);\n}\n\nstatic CURLcode smb_send_and_recv(struct Curl_easy *data, void **msg)\n{\n  struct connectdata *conn = data->conn;\n  struct smb_conn *smbc = &conn->proto.smbc;\n  CURLcode result;\n  *msg = NULL; /* if it returns early */\n\n  /* Check if there is data in the transfer buffer */\n  if(!smbc->send_size && smbc->upload_size) {\n    size_t nread = smbc->upload_size > (size_t)MAX_MESSAGE_SIZE ?\n      (size_t)MAX_MESSAGE_SIZE : smbc->upload_size;\n    bool eos;\n\n    result = Curl_client_read(data, smbc->send_buf, nread, &nread, &eos);\n    if(result && result != CURLE_AGAIN)\n      return result;\n    if(!nread)\n      return CURLE_OK;\n\n    smbc->upload_size -= nread;\n    smbc->send_size = nread;\n    smbc->sent = 0;\n  }\n\n  /* Check if there is data to send */\n  if(smbc->send_size) {\n    result = smb_flush(data);\n    if(result)\n      return result;\n  }\n\n  /* Check if there is still data to be sent */\n  if(smbc->send_size || smbc->upload_size)\n    return CURLE_AGAIN;\n\n  return smb_recv_message(data, msg);\n}\n\nstatic CURLcode smb_connection_state(struct Curl_easy *data, bool *done)\n{\n  struct connectdata *conn = data->conn;\n  struct smb_conn *smbc = &conn->proto.smbc;\n  struct smb_negotiate_response *nrsp;\n  struct smb_header *h;\n  CURLcode result;\n  void *msg = NULL;\n\n  if(smbc->state == SMB_CONNECTING) {\n#ifdef USE_SSL\n    if((conn->handler->flags & PROTOPT_SSL)) {\n      bool ssl_done = FALSE;\n      result = Curl_conn_connect(data, FIRSTSOCKET, FALSE, &ssl_done);\n      if(result && result != CURLE_AGAIN)\n        return result;\n      if(!ssl_done)\n        return CURLE_OK;\n    }\n#endif\n\n    result = smb_send_negotiate(data);\n    if(result) {\n      connclose(conn, \"SMB: failed to send negotiate message\");\n      return result;\n    }\n\n    conn_state(data, SMB_NEGOTIATE);\n  }\n\n  /* Send the previous message and check for a response */\n  result = smb_send_and_recv(data, &msg);\n  if(result && result != CURLE_AGAIN) {\n    connclose(conn, \"SMB: failed to communicate\");\n    return result;\n  }\n\n  if(!msg)\n    return CURLE_OK;\n\n  h = msg;\n\n  switch(smbc->state) {\n  case SMB_NEGOTIATE:\n    if((smbc->got < sizeof(*nrsp) + sizeof(smbc->challenge) - 1) ||\n       h->status) {\n      connclose(conn, \"SMB: negotiation failed\");\n      return CURLE_COULDNT_CONNECT;\n    }\n    nrsp = msg;\n    memcpy(smbc->challenge, nrsp->bytes, sizeof(smbc->challenge));\n    smbc->session_key = smb_swap32(nrsp->session_key);\n    result = smb_send_setup(data);\n    if(result) {\n      connclose(conn, \"SMB: failed to send setup message\");\n      return result;\n    }\n    conn_state(data, SMB_SETUP);\n    break;\n\n  case SMB_SETUP:\n    if(h->status) {\n      connclose(conn, \"SMB: authentication failed\");\n      return CURLE_LOGIN_DENIED;\n    }\n    smbc->uid = smb_swap16(h->uid);\n    conn_state(data, SMB_CONNECTED);\n    *done = true;\n    break;\n\n  default:\n    smb_pop_message(conn);\n    return CURLE_OK; /* ignore */\n  }\n\n  smb_pop_message(conn);\n\n  return CURLE_OK;\n}\n\n/*\n * Convert a timestamp from the Windows world (100 nsec units from 1 Jan 1601)\n * to Posix time. Cap the output to fit within a time_t.\n */\nstatic void get_posix_time(time_t *out, curl_off_t timestamp)\n{\n  timestamp -= 116444736000000000;\n  timestamp /= 10000000;\n#if SIZEOF_TIME_T < SIZEOF_CURL_OFF_T\n  if(timestamp > TIME_T_MAX)\n    *out = TIME_T_MAX;\n  else if(timestamp < TIME_T_MIN)\n    *out = TIME_T_MIN;\n  else\n#endif\n    *out = (time_t) timestamp;\n}\n\nstatic CURLcode smb_request_state(struct Curl_easy *data, bool *done)\n{\n  struct connectdata *conn = data->conn;\n  struct smb_request *req = data->req.p.smb;\n  struct smb_header *h;\n  struct smb_conn *smbc = &conn->proto.smbc;\n  enum smb_req_state next_state = SMB_DONE;\n  unsigned short len;\n  unsigned short off;\n  CURLcode result;\n  void *msg = NULL;\n  const struct smb_nt_create_response *smb_m;\n\n  if(data->state.upload && (data->state.infilesize < 0)) {\n    failf(data, \"SMB upload needs to know the size up front\");\n    return CURLE_SEND_ERROR;\n  }\n\n  /* Start the request */\n  if(req->state == SMB_REQUESTING) {\n    result = smb_send_tree_connect(data);\n    if(result) {\n      connclose(conn, \"SMB: failed to send tree connect message\");\n      return result;\n    }\n\n    request_state(data, SMB_TREE_CONNECT);\n  }\n\n  /* Send the previous message and check for a response */\n  result = smb_send_and_recv(data, &msg);\n  if(result && result != CURLE_AGAIN) {\n    connclose(conn, \"SMB: failed to communicate\");\n    return result;\n  }\n\n  if(!msg)\n    return CURLE_OK;\n\n  h = msg;\n\n  switch(req->state) {\n  case SMB_TREE_CONNECT:\n    if(h->status) {\n      req->result = CURLE_REMOTE_FILE_NOT_FOUND;\n      if(h->status == smb_swap32(SMB_ERR_NOACCESS))\n        req->result = CURLE_REMOTE_ACCESS_DENIED;\n      break;\n    }\n    req->tid = smb_swap16(h->tid);\n    next_state = SMB_OPEN;\n    break;\n\n  case SMB_OPEN:\n    if(h->status || smbc->got < sizeof(struct smb_nt_create_response)) {\n      req->result = CURLE_REMOTE_FILE_NOT_FOUND;\n      if(h->status == smb_swap32(SMB_ERR_NOACCESS))\n        req->result = CURLE_REMOTE_ACCESS_DENIED;\n      next_state = SMB_TREE_DISCONNECT;\n      break;\n    }\n    smb_m = (const struct smb_nt_create_response*) msg;\n    req->fid = smb_swap16(smb_m->fid);\n    data->req.offset = 0;\n    if(data->state.upload) {\n      data->req.size = data->state.infilesize;\n      Curl_pgrsSetUploadSize(data, data->req.size);\n      next_state = SMB_UPLOAD;\n    }\n    else {\n      data->req.size = smb_swap64(smb_m->end_of_file);\n      if(data->req.size < 0) {\n        req->result = CURLE_WEIRD_SERVER_REPLY;\n        next_state = SMB_CLOSE;\n      }\n      else {\n        Curl_pgrsSetDownloadSize(data, data->req.size);\n        if(data->set.get_filetime)\n          get_posix_time(&data->info.filetime, smb_m->last_change_time);\n        next_state = SMB_DOWNLOAD;\n      }\n    }\n    break;\n\n  case SMB_DOWNLOAD:\n    if(h->status || smbc->got < sizeof(struct smb_header) + 14) {\n      req->result = CURLE_RECV_ERROR;\n      next_state = SMB_CLOSE;\n      break;\n    }\n    len = Curl_read16_le(((const unsigned char *) msg) +\n                         sizeof(struct smb_header) + 11);\n    off = Curl_read16_le(((const unsigned char *) msg) +\n                         sizeof(struct smb_header) + 13);\n    if(len > 0) {\n      if(off + sizeof(unsigned int) + len > smbc->got) {\n        failf(data, \"Invalid input packet\");\n        result = CURLE_RECV_ERROR;\n      }\n      else\n        result = Curl_client_write(data, CLIENTWRITE_BODY,\n                                   (char *)msg + off + sizeof(unsigned int),\n                                   len);\n      if(result) {\n        req->result = result;\n        next_state = SMB_CLOSE;\n        break;\n      }\n    }\n    data->req.offset += len;\n    next_state = (len < MAX_PAYLOAD_SIZE) ? SMB_CLOSE : SMB_DOWNLOAD;\n    break;\n\n  case SMB_UPLOAD:\n    if(h->status || smbc->got < sizeof(struct smb_header) + 6) {\n      req->result = CURLE_UPLOAD_FAILED;\n      next_state = SMB_CLOSE;\n      break;\n    }\n    len = Curl_read16_le(((const unsigned char *) msg) +\n                         sizeof(struct smb_header) + 5);\n    data->req.bytecount += len;\n    data->req.offset += len;\n    Curl_pgrsSetUploadCounter(data, data->req.bytecount);\n    if(data->req.bytecount >= data->req.size)\n      next_state = SMB_CLOSE;\n    else\n      next_state = SMB_UPLOAD;\n    break;\n\n  case SMB_CLOSE:\n    /* We don't care if the close failed, proceed to tree disconnect anyway */\n    next_state = SMB_TREE_DISCONNECT;\n    break;\n\n  case SMB_TREE_DISCONNECT:\n    next_state = SMB_DONE;\n    break;\n\n  default:\n    smb_pop_message(conn);\n    return CURLE_OK; /* ignore */\n  }\n\n  smb_pop_message(conn);\n\n  switch(next_state) {\n  case SMB_OPEN:\n    result = smb_send_open(data);\n    break;\n\n  case SMB_DOWNLOAD:\n    result = smb_send_read(data);\n    break;\n\n  case SMB_UPLOAD:\n    result = smb_send_write(data);\n    break;\n\n  case SMB_CLOSE:\n    result = smb_send_close(data);\n    break;\n\n  case SMB_TREE_DISCONNECT:\n    result = smb_send_tree_disconnect(data);\n    break;\n\n  case SMB_DONE:\n    result = req->result;\n    *done = true;\n    break;\n\n  default:\n    break;\n  }\n\n  if(result) {\n    connclose(conn, \"SMB: failed to send message\");\n    return result;\n  }\n\n  request_state(data, next_state);\n\n  return CURLE_OK;\n}\n\nstatic CURLcode smb_disconnect(struct Curl_easy *data,\n                               struct connectdata *conn, bool dead)\n{\n  struct smb_conn *smbc = &conn->proto.smbc;\n  (void) dead;\n  (void) data;\n  Curl_safefree(smbc->share);\n  Curl_safefree(smbc->domain);\n  Curl_safefree(smbc->recv_buf);\n  Curl_safefree(smbc->send_buf);\n  return CURLE_OK;\n}\n\nstatic int smb_getsock(struct Curl_easy *data,\n                       struct connectdata *conn, curl_socket_t *socks)\n{\n  (void)data;\n  socks[0] = conn->sock[FIRSTSOCKET];\n  return GETSOCK_READSOCK(0) | GETSOCK_WRITESOCK(0);\n}\n\nstatic CURLcode smb_do(struct Curl_easy *data, bool *done)\n{\n  struct connectdata *conn = data->conn;\n  struct smb_conn *smbc = &conn->proto.smbc;\n\n  *done = FALSE;\n  if(smbc->share) {\n    return CURLE_OK;\n  }\n  return CURLE_URL_MALFORMAT;\n}\n\nstatic CURLcode smb_parse_url_path(struct Curl_easy *data,\n                                   struct connectdata *conn)\n{\n  struct smb_request *req = data->req.p.smb;\n  struct smb_conn *smbc = &conn->proto.smbc;\n  char *path;\n  char *slash;\n\n  /* URL decode the path */\n  CURLcode result = Curl_urldecode(data->state.up.path, 0, &path, NULL,\n                                   REJECT_CTRL);\n  if(result)\n    return result;\n\n  /* Parse the path for the share */\n  smbc->share = strdup((*path == '/' || *path == '\\\\') ? path + 1 : path);\n  free(path);\n  if(!smbc->share)\n    return CURLE_OUT_OF_MEMORY;\n\n  slash = strchr(smbc->share, '/');\n  if(!slash)\n    slash = strchr(smbc->share, '\\\\');\n\n  /* The share must be present */\n  if(!slash) {\n    Curl_safefree(smbc->share);\n    failf(data, \"missing share in URL path for SMB\");\n    return CURLE_URL_MALFORMAT;\n  }\n\n  /* Parse the path for the file path converting any forward slashes into\n     backslashes */\n  *slash++ = 0;\n  req->path = slash;\n\n  for(; *slash; slash++) {\n    if(*slash == '/')\n      *slash = '\\\\';\n  }\n  return CURLE_OK;\n}\n\n#endif /* CURL_DISABLE_SMB && USE_CURL_NTLM_CORE &&\n          SIZEOF_CURL_OFF_T > 4 */\n` was unexpected","path":"/home/qqq/curl-8.7.0/lib/smb.c"},{"code":3,"level":"warn","type":"Syntax error","message":"Syntax error at line /home/qqq/curl-8.7.0/lib/vtls/mbedtls.c:1:\n `/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.\n * Copyright (C) Hoi-Ho Chan, <hoiho.chan@gmail.com>\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n * SPDX-License-Identifier: curl\n *\n ***************************************************************************/\n\n/*\n * Source file for all mbedTLS-specific code for the TLS/SSL layer. No code\n * but vtls.c should ever call or use these functions.\n *\n */\n\n#include \"curl_setup.h\"\n\n#ifdef USE_MBEDTLS\n\n/* Define this to enable lots of debugging for mbedTLS */\n/* #define MBEDTLS_DEBUG */\n\n#ifdef __GNUC__\n#pragma GCC diagnostic push\n/* mbedTLS (as of v3.5.1) has a duplicate function declaration\n   in its public headers. Disable the warning that detects it. */\n#pragma GCC diagnostic ignored \"-Wredundant-decls\"\n#endif\n\n#include <mbedtls/version.h>\n#if MBEDTLS_VERSION_NUMBER >= 0x02040000\n#include <mbedtls/net_sockets.h>\n#else\n#include <mbedtls/net.h>\n#endif\n#include <mbedtls/ssl.h>\n#include <mbedtls/x509.h>\n\n#include <mbedtls/error.h>\n#include <mbedtls/entropy.h>\n#include <mbedtls/ctr_drbg.h>\n#include <mbedtls/sha256.h>\n\n#if MBEDTLS_VERSION_MAJOR >= 2\n#  ifdef MBEDTLS_DEBUG\n#    include <mbedtls/debug.h>\n#  endif\n#endif\n\n#ifdef __GNUC__\n#pragma GCC diagnostic pop\n#endif\n\n#include \"urldata.h\"\n#include \"sendf.h\"\n#include \"inet_pton.h\"\n#include \"mbedtls.h\"\n#include \"vtls.h\"\n#include \"vtls_int.h\"\n#include \"parsedate.h\"\n#include \"connect.h\" /* for the connect timeout */\n#include \"select.h\"\n#include \"multiif.h\"\n#include \"mbedtls_threadlock.h\"\n#include \"strdup.h\"\n\n/* The last 3 #include files should be in this order */\n#include \"curl_printf.h\"\n#include \"curl_memory.h\"\n#include \"memdebug.h\"\n\n/* ALPN for http2 */\n#ifdef USE_HTTP2\n#  undef HAS_ALPN\n#  ifdef MBEDTLS_SSL_ALPN\n#    define HAS_ALPN\n#  endif\n#endif\n\nstruct mbed_ssl_backend_data {\n  mbedtls_ctr_drbg_context ctr_drbg;\n  mbedtls_entropy_context entropy;\n  mbedtls_ssl_context ssl;\n  mbedtls_x509_crt cacert;\n  mbedtls_x509_crt clicert;\n#ifdef MBEDTLS_X509_CRL_PARSE_C\n  mbedtls_x509_crl crl;\n#endif\n  mbedtls_pk_context pk;\n  mbedtls_ssl_config config;\n#ifdef HAS_ALPN\n  const char *protocols[3];\n#endif\n};\n\n/* apply threading? */\n#if (defined(USE_THREADS_POSIX) && defined(HAVE_PTHREAD_H)) || \\\n    defined(_WIN32)\n#define THREADING_SUPPORT\n#endif\n\n#ifndef MBEDTLS_ERROR_C\n#define mbedtls_strerror(a,b,c) b[0] = 0\n#endif\n\n#if defined(THREADING_SUPPORT)\nstatic mbedtls_entropy_context ts_entropy;\n\nstatic int entropy_init_initialized = 0;\n\nstatic void entropy_init_mutex(mbedtls_entropy_context *ctx)\n{\n  /* lock 0 = entropy_init_mutex() */\n  Curl_mbedtlsthreadlock_lock_function(0);\n  if(entropy_init_initialized == 0) {\n    mbedtls_entropy_init(ctx);\n    entropy_init_initialized = 1;\n  }\n  Curl_mbedtlsthreadlock_unlock_function(0);\n}\n\nstatic void entropy_cleanup_mutex(mbedtls_entropy_context *ctx)\n{\n  /* lock 0 = use same lock as init */\n  Curl_mbedtlsthreadlock_lock_function(0);\n  if(entropy_init_initialized == 1) {\n    mbedtls_entropy_free(ctx);\n    entropy_init_initialized = 0;\n  }\n  Curl_mbedtlsthreadlock_unlock_function(0);\n}\n\nstatic int entropy_func_mutex(void *data, unsigned char *output, size_t len)\n{\n  int ret;\n  /* lock 1 = entropy_func_mutex() */\n  Curl_mbedtlsthreadlock_lock_function(1);\n  ret = mbedtls_entropy_func(data, output, len);\n  Curl_mbedtlsthreadlock_unlock_function(1);\n\n  return ret;\n}\n\n#endif /* THREADING_SUPPORT */\n\n#ifdef MBEDTLS_DEBUG\nstatic void mbed_debug(void *context, int level, const char *f_name,\n                       int line_nb, const char *line)\n{\n  struct Curl_easy *data = NULL;\n\n  if(!context)\n    return;\n\n  data = (struct Curl_easy *)context;\n\n  infof(data, \"%s\", line);\n  (void) level;\n}\n#endif\n\nstatic int mbedtls_bio_cf_write(void *bio,\n                                const unsigned char *buf, size_t blen)\n{\n  struct Curl_cfilter *cf = bio;\n  struct Curl_easy *data = CF_DATA_CURRENT(cf);\n  ssize_t nwritten;\n  CURLcode result;\n\n  DEBUGASSERT(data);\n  if(!data)\n    return 0;\n\n  nwritten = Curl_conn_cf_send(cf->next, data, (char *)buf, blen, &result);\n  CURL_TRC_CF(data, cf, \"mbedtls_bio_cf_out_write(len=%zu) -> %zd, err=%d\",\n              blen, nwritten, result);\n  if(nwritten < 0 && CURLE_AGAIN == result) {\n    nwritten = MBEDTLS_ERR_SSL_WANT_WRITE;\n  }\n  return (int)nwritten;\n}\n\nstatic int mbedtls_bio_cf_read(void *bio, unsigned char *buf, size_t blen)\n{\n  struct Curl_cfilter *cf = bio;\n  struct Curl_easy *data = CF_DATA_CURRENT(cf);\n  ssize_t nread;\n  CURLcode result;\n\n  DEBUGASSERT(data);\n  if(!data)\n    return 0;\n  /* OpenSSL catches this case, so should we. */\n  if(!buf)\n    return 0;\n\n  nread = Curl_conn_cf_recv(cf->next, data, (char *)buf, blen, &result);\n  CURL_TRC_CF(data, cf, \"mbedtls_bio_cf_in_read(len=%zu) -> %zd, err=%d\",\n              blen, nread, result);\n  if(nread < 0 && CURLE_AGAIN == result) {\n    nread = MBEDTLS_ERR_SSL_WANT_READ;\n  }\n  return (int)nread;\n}\n\n/*\n *  profile\n */\nstatic const mbedtls_x509_crt_profile mbedtls_x509_crt_profile_fr =\n{\n  /* Hashes from SHA-1 and above */\n  MBEDTLS_X509_ID_FLAG(MBEDTLS_MD_SHA1) |\n  MBEDTLS_X509_ID_FLAG(MBEDTLS_MD_RIPEMD160) |\n  MBEDTLS_X509_ID_FLAG(MBEDTLS_MD_SHA224) |\n  MBEDTLS_X509_ID_FLAG(MBEDTLS_MD_SHA256) |\n  MBEDTLS_X509_ID_FLAG(MBEDTLS_MD_SHA384) |\n  MBEDTLS_X509_ID_FLAG(MBEDTLS_MD_SHA512),\n  0xFFFFFFF, /* Any PK alg    */\n  0xFFFFFFF, /* Any curve     */\n  1024,      /* RSA min key len */\n};\n\n/* See https://tls.mbed.org/discussions/generic/\n   howto-determine-exact-buffer-len-for-mbedtls_pk_write_pubkey_der\n*/\n#define RSA_PUB_DER_MAX_BYTES   (38 + 2 * MBEDTLS_MPI_MAX_SIZE)\n#define ECP_PUB_DER_MAX_BYTES   (30 + 2 * MBEDTLS_ECP_MAX_BYTES)\n\n#define PUB_DER_MAX_BYTES   (RSA_PUB_DER_MAX_BYTES > ECP_PUB_DER_MAX_BYTES ? \\\n                             RSA_PUB_DER_MAX_BYTES : ECP_PUB_DER_MAX_BYTES)\n\n#if MBEDTLS_VERSION_NUMBER >= 0x03020000\nstatic CURLcode mbedtls_version_from_curl(\n  mbedtls_ssl_protocol_version* mbedver, long version)\n{\n  switch(version) {\n  case CURL_SSLVERSION_TLSv1_0:\n  case CURL_SSLVERSION_TLSv1_1:\n  case CURL_SSLVERSION_TLSv1_2:\n    *mbedver = MBEDTLS_SSL_VERSION_TLS1_2;\n    return CURLE_OK;\n  case CURL_SSLVERSION_TLSv1_3:\n    break;\n  }\n\n  return CURLE_SSL_CONNECT_ERROR;\n}\n#else\nstatic CURLcode mbedtls_version_from_curl(int *mbedver, long version)\n{\n#if MBEDTLS_VERSION_NUMBER >= 0x03000000\n  switch(version) {\n    case CURL_SSLVERSION_TLSv1_0:\n    case CURL_SSLVERSION_TLSv1_1:\n    case CURL_SSLVERSION_TLSv1_2:\n      *mbedver = MBEDTLS_SSL_MINOR_VERSION_3;\n      return CURLE_OK;\n    case CURL_SSLVERSION_TLSv1_3:\n      break;\n  }\n#else\n  switch(version) {\n    case CURL_SSLVERSION_TLSv1_0:\n      *mbedver = MBEDTLS_SSL_MINOR_VERSION_1;\n      return CURLE_OK;\n    case CURL_SSLVERSION_TLSv1_1:\n      *mbedver = MBEDTLS_SSL_MINOR_VERSION_2;\n      return CURLE_OK;\n    case CURL_SSLVERSION_TLSv1_2:\n      *mbedver = MBEDTLS_SSL_MINOR_VERSION_3;\n      return CURLE_OK;\n    case CURL_SSLVERSION_TLSv1_3:\n      break;\n  }\n#endif\n\n  return CURLE_SSL_CONNECT_ERROR;\n}\n#endif\n\nstatic CURLcode\nset_ssl_version_min_max(struct Curl_cfilter *cf, struct Curl_easy *data)\n{\n  struct ssl_connect_data *connssl = cf->ctx;\n  struct mbed_ssl_backend_data *backend =\n    (struct mbed_ssl_backend_data *)connssl->backend;\n  struct ssl_primary_config *conn_config = Curl_ssl_cf_get_primary_config(cf);\n#if MBEDTLS_VERSION_NUMBER >= 0x03020000\n  mbedtls_ssl_protocol_version mbedtls_ver_min = MBEDTLS_SSL_VERSION_TLS1_2;\n  mbedtls_ssl_protocol_version mbedtls_ver_max = MBEDTLS_SSL_VERSION_TLS1_2;\n#elif MBEDTLS_VERSION_NUMBER >= 0x03000000\n  int mbedtls_ver_min = MBEDTLS_SSL_MINOR_VERSION_3;\n  int mbedtls_ver_max = MBEDTLS_SSL_MINOR_VERSION_3;\n#else\n  int mbedtls_ver_min = MBEDTLS_SSL_MINOR_VERSION_1;\n  int mbedtls_ver_max = MBEDTLS_SSL_MINOR_VERSION_1;\n#endif\n  long ssl_version = conn_config->version;\n  long ssl_version_max = conn_config->version_max;\n  CURLcode result = CURLE_OK;\n\n  DEBUGASSERT(backend);\n\n  switch(ssl_version) {\n    case CURL_SSLVERSION_DEFAULT:\n    case CURL_SSLVERSION_TLSv1:\n      ssl_version = CURL_SSLVERSION_TLSv1_0;\n      break;\n  }\n\n  switch(ssl_version_max) {\n    case CURL_SSLVERSION_MAX_NONE:\n    case CURL_SSLVERSION_MAX_DEFAULT:\n      ssl_version_max = CURL_SSLVERSION_MAX_TLSv1_2;\n      break;\n  }\n\n  result = mbedtls_version_from_curl(&mbedtls_ver_min, ssl_version);\n  if(result) {\n    failf(data, \"unsupported min version passed via CURLOPT_SSLVERSION\");\n    return result;\n  }\n  result = mbedtls_version_from_curl(&mbedtls_ver_max, ssl_version_max >> 16);\n  if(result) {\n    failf(data, \"unsupported max version passed via CURLOPT_SSLVERSION\");\n    return result;\n  }\n\n#if MBEDTLS_VERSION_NUMBER >= 0x03020000\n  mbedtls_ssl_conf_min_tls_version(&backend->config, mbedtls_ver_min);\n  mbedtls_ssl_conf_max_tls_version(&backend->config, mbedtls_ver_max);\n#else\n  mbedtls_ssl_conf_min_version(&backend->config, MBEDTLS_SSL_MAJOR_VERSION_3,\n                               mbedtls_ver_min);\n  mbedtls_ssl_conf_max_version(&backend->config, MBEDTLS_SSL_MAJOR_VERSION_3,\n                               mbedtls_ver_max);\n#endif\n\n  return result;\n}\n\nstatic CURLcode\nmbed_connect_step1(struct Curl_cfilter *cf, struct Curl_easy *data)\n{\n  struct ssl_connect_data *connssl = cf->ctx;\n  struct mbed_ssl_backend_data *backend =\n    (struct mbed_ssl_backend_data *)connssl->backend;\n  struct ssl_primary_config *conn_config = Curl_ssl_cf_get_primary_config(cf);\n  const struct curl_blob *ca_info_blob = conn_config->ca_info_blob;\n  struct ssl_config_data *ssl_config = Curl_ssl_cf_get_config(cf, data);\n  const char * const ssl_cafile =\n    /* CURLOPT_CAINFO_BLOB overrides CURLOPT_CAINFO */\n    (ca_info_blob ? NULL : conn_config->CAfile);\n  const bool verifypeer = conn_config->verifypeer;\n  const char * const ssl_capath = conn_config->CApath;\n  char * const ssl_cert = ssl_config->primary.clientcert;\n  const struct curl_blob *ssl_cert_blob = ssl_config->primary.cert_blob;\n  const char * const ssl_crlfile = ssl_config->primary.CRLfile;\n  const char *hostname = connssl->peer.hostname;\n  int ret = -1;\n  char errorbuf[128];\n\n  DEBUGASSERT(backend);\n\n  if((conn_config->version == CURL_SSLVERSION_SSLv2) ||\n     (conn_config->version == CURL_SSLVERSION_SSLv3)) {\n    failf(data, \"Not supported SSL version\");\n    return CURLE_NOT_BUILT_IN;\n  }\n\n#ifdef THREADING_SUPPORT\n  mbedtls_ctr_drbg_init(&backend->ctr_drbg);\n\n  ret = mbedtls_ctr_drbg_seed(&backend->ctr_drbg, entropy_func_mutex,\n                              &ts_entropy, NULL, 0);\n  if(ret) {\n    mbedtls_strerror(ret, errorbuf, sizeof(errorbuf));\n    failf(data, \"mbedtls_ctr_drbg_seed returned (-0x%04X) %s\",\n          -ret, errorbuf);\n    return CURLE_FAILED_INIT;\n  }\n#else\n  mbedtls_entropy_init(&backend->entropy);\n  mbedtls_ctr_drbg_init(&backend->ctr_drbg);\n\n  ret = mbedtls_ctr_drbg_seed(&backend->ctr_drbg, mbedtls_entropy_func,\n                              &backend->entropy, NULL, 0);\n  if(ret) {\n    mbedtls_strerror(ret, errorbuf, sizeof(errorbuf));\n    failf(data, \"mbedtls_ctr_drbg_seed returned (-0x%04X) %s\",\n          -ret, errorbuf);\n    return CURLE_FAILED_INIT;\n  }\n#endif /* THREADING_SUPPORT */\n\n  /* Load the trusted CA */\n  mbedtls_x509_crt_init(&backend->cacert);\n\n  if(ca_info_blob && verifypeer) {\n    /* Unfortunately, mbedtls_x509_crt_parse() requires the data to be null\n       terminated even when provided the exact length, forcing us to waste\n       extra memory here. */\n    unsigned char *newblob = Curl_memdup0(ca_info_blob->data,\n                                          ca_info_blob->len);\n    if(!newblob)\n      return CURLE_OUT_OF_MEMORY;\n    ret = mbedtls_x509_crt_parse(&backend->cacert, newblob,\n                                 ca_info_blob->len + 1);\n    free(newblob);\n    if(ret<0) {\n      mbedtls_strerror(ret, errorbuf, sizeof(errorbuf));\n      failf(data, \"Error importing ca cert blob - mbedTLS: (-0x%04X) %s\",\n            -ret, errorbuf);\n      return CURLE_SSL_CERTPROBLEM;\n    }\n  }\n\n  if(ssl_cafile && verifypeer) {\n#ifdef MBEDTLS_FS_IO\n    ret = mbedtls_x509_crt_parse_file(&backend->cacert, ssl_cafile);\n\n    if(ret<0) {\n      mbedtls_strerror(ret, errorbuf, sizeof(errorbuf));\n      failf(data, \"Error reading ca cert file %s - mbedTLS: (-0x%04X) %s\",\n            ssl_cafile, -ret, errorbuf);\n      return CURLE_SSL_CACERT_BADFILE;\n    }\n#else\n    failf(data, \"mbedtls: functions that use the filesystem not built in\");\n    return CURLE_NOT_BUILT_IN;\n#endif\n  }\n\n  if(ssl_capath) {\n#ifdef MBEDTLS_FS_IO\n    ret = mbedtls_x509_crt_parse_path(&backend->cacert, ssl_capath);\n\n    if(ret<0) {\n      mbedtls_strerror(ret, errorbuf, sizeof(errorbuf));\n      failf(data, \"Error reading ca cert path %s - mbedTLS: (-0x%04X) %s\",\n            ssl_capath, -ret, errorbuf);\n\n      if(verifypeer)\n        return CURLE_SSL_CACERT_BADFILE;\n    }\n#else\n    failf(data, \"mbedtls: functions that use the filesystem not built in\");\n    return CURLE_NOT_BUILT_IN;\n#endif\n  }\n\n  /* Load the client certificate */\n  mbedtls_x509_crt_init(&backend->clicert);\n\n  if(ssl_cert) {\n#ifdef MBEDTLS_FS_IO\n    ret = mbedtls_x509_crt_parse_file(&backend->clicert, ssl_cert);\n\n    if(ret) {\n      mbedtls_strerror(ret, errorbuf, sizeof(errorbuf));\n      failf(data, \"Error reading client cert file %s - mbedTLS: (-0x%04X) %s\",\n            ssl_cert, -ret, errorbuf);\n\n      return CURLE_SSL_CERTPROBLEM;\n    }\n#else\n    failf(data, \"mbedtls: functions that use the filesystem not built in\");\n    return CURLE_NOT_BUILT_IN;\n#endif\n  }\n\n  if(ssl_cert_blob) {\n    /* Unfortunately, mbedtls_x509_crt_parse() requires the data to be null\n       terminated even when provided the exact length, forcing us to waste\n       extra memory here. */\n    unsigned char *newblob = Curl_memdup0(ssl_cert_blob->data,\n                                          ssl_cert_blob->len);\n    if(!newblob)\n      return CURLE_OUT_OF_MEMORY;\n    ret = mbedtls_x509_crt_parse(&backend->clicert, newblob,\n                                 ssl_cert_blob->len + 1);\n    free(newblob);\n\n    if(ret) {\n      mbedtls_strerror(ret, errorbuf, sizeof(errorbuf));\n      failf(data, \"Error reading private key %s - mbedTLS: (-0x%04X) %s\",\n            ssl_config->key, -ret, errorbuf);\n      return CURLE_SSL_CERTPROBLEM;\n    }\n  }\n\n  /* Load the client private key */\n  mbedtls_pk_init(&backend->pk);\n\n  if(ssl_config->key || ssl_config->key_blob) {\n    if(ssl_config->key) {\n#ifdef MBEDTLS_FS_IO\n#if MBEDTLS_VERSION_NUMBER >= 0x03000000\n      ret = mbedtls_pk_parse_keyfile(&backend->pk, ssl_config->key,\n                                     ssl_config->key_passwd,\n                                     mbedtls_ctr_drbg_random,\n                                     &backend->ctr_drbg);\n#else\n      ret = mbedtls_pk_parse_keyfile(&backend->pk, ssl_config->key,\n                                     ssl_config->key_passwd);\n#endif\n\n      if(ret) {\n        mbedtls_strerror(ret, errorbuf, sizeof(errorbuf));\n        failf(data, \"Error reading private key %s - mbedTLS: (-0x%04X) %s\",\n              ssl_config->key, -ret, errorbuf);\n        return CURLE_SSL_CERTPROBLEM;\n      }\n#else\n      failf(data, \"mbedtls: functions that use the filesystem not built in\");\n      return CURLE_NOT_BUILT_IN;\n#endif\n    }\n    else {\n      const struct curl_blob *ssl_key_blob = ssl_config->key_blob;\n      const unsigned char *key_data =\n        (const unsigned char *)ssl_key_blob->data;\n      const char *passwd = ssl_config->key_passwd;\n#if MBEDTLS_VERSION_NUMBER >= 0x03000000\n      ret = mbedtls_pk_parse_key(&backend->pk, key_data, ssl_key_blob->len,\n                                 (const unsigned char *)passwd,\n                                 passwd ? strlen(passwd) : 0,\n                                 mbedtls_ctr_drbg_random,\n                                 &backend->ctr_drbg);\n#else\n      ret = mbedtls_pk_parse_key(&backend->pk, key_data, ssl_key_blob->len,\n                                 (const unsigned char *)passwd,\n                                 passwd ? strlen(passwd) : 0);\n#endif\n\n      if(ret) {\n        mbedtls_strerror(ret, errorbuf, sizeof(errorbuf));\n        failf(data, \"Error parsing private key - mbedTLS: (-0x%04X) %s\",\n              -ret, errorbuf);\n        return CURLE_SSL_CERTPROBLEM;\n      }\n    }\n\n    if(ret == 0 && !(mbedtls_pk_can_do(&backend->pk, MBEDTLS_PK_RSA) ||\n                     mbedtls_pk_can_do(&backend->pk, MBEDTLS_PK_ECKEY)))\n      ret = MBEDTLS_ERR_PK_TYPE_MISMATCH;\n  }\n\n  /* Load the CRL */\n#ifdef MBEDTLS_X509_CRL_PARSE_C\n  mbedtls_x509_crl_init(&backend->crl);\n\n  if(ssl_crlfile) {\n#ifdef MBEDTLS_FS_IO\n    ret = mbedtls_x509_crl_parse_file(&backend->crl, ssl_crlfile);\n\n    if(ret) {\n      mbedtls_strerror(ret, errorbuf, sizeof(errorbuf));\n      failf(data, \"Error reading CRL file %s - mbedTLS: (-0x%04X) %s\",\n            ssl_crlfile, -ret, errorbuf);\n\n      return CURLE_SSL_CRL_BADFILE;\n    }\n#else\n    failf(data, \"mbedtls: functions that use the filesystem not built in\");\n    return CURLE_NOT_BUILT_IN;\n#endif\n  }\n#else\n  if(ssl_crlfile) {\n    failf(data, \"mbedtls: crl support not built in\");\n    return CURLE_NOT_BUILT_IN;\n  }\n#endif\n\n  infof(data, \"mbedTLS: Connecting to %s:%d\", hostname, connssl->port);\n\n  mbedtls_ssl_config_init(&backend->config);\n  ret = mbedtls_ssl_config_defaults(&backend->config,\n                                    MBEDTLS_SSL_IS_CLIENT,\n                                    MBEDTLS_SSL_TRANSPORT_STREAM,\n                                    MBEDTLS_SSL_PRESET_DEFAULT);\n  if(ret) {\n    failf(data, \"mbedTLS: ssl_config failed\");\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n\n  mbedtls_ssl_init(&backend->ssl);\n  if(mbedtls_ssl_setup(&backend->ssl, &backend->config)) {\n    failf(data, \"mbedTLS: ssl_init failed\");\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n\n  /* new profile with RSA min key len = 1024 ... */\n  mbedtls_ssl_conf_cert_profile(&backend->config,\n                                &mbedtls_x509_crt_profile_fr);\n\n  switch(conn_config->version) {\n  case CURL_SSLVERSION_DEFAULT:\n  case CURL_SSLVERSION_TLSv1:\n#if MBEDTLS_VERSION_NUMBER < 0x03000000\n    mbedtls_ssl_conf_min_version(&backend->config, MBEDTLS_SSL_MAJOR_VERSION_3,\n                                 MBEDTLS_SSL_MINOR_VERSION_1);\n    infof(data, \"mbedTLS: Set min SSL version to TLS 1.0\");\n    break;\n#endif\n  case CURL_SSLVERSION_TLSv1_0:\n  case CURL_SSLVERSION_TLSv1_1:\n  case CURL_SSLVERSION_TLSv1_2:\n  case CURL_SSLVERSION_TLSv1_3:\n    {\n      CURLcode result = set_ssl_version_min_max(cf, data);\n      if(result != CURLE_OK)\n        return result;\n      break;\n    }\n  default:\n    failf(data, \"Unrecognized parameter passed via CURLOPT_SSLVERSION\");\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n\n  mbedtls_ssl_conf_authmode(&backend->config, MBEDTLS_SSL_VERIFY_OPTIONAL);\n\n  mbedtls_ssl_conf_rng(&backend->config, mbedtls_ctr_drbg_random,\n                       &backend->ctr_drbg);\n  mbedtls_ssl_set_bio(&backend->ssl, cf,\n                      mbedtls_bio_cf_write,\n                      mbedtls_bio_cf_read,\n                      NULL /*  rev_timeout() */);\n\n  mbedtls_ssl_conf_ciphersuites(&backend->config,\n                                mbedtls_ssl_list_ciphersuites());\n\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n  mbedtls_ssl_conf_renegotiation(&backend->config,\n                                 MBEDTLS_SSL_RENEGOTIATION_ENABLED);\n#endif\n\n#if defined(MBEDTLS_SSL_SESSION_TICKETS)\n  mbedtls_ssl_conf_session_tickets(&backend->config,\n                                   MBEDTLS_SSL_SESSION_TICKETS_DISABLED);\n#endif\n\n  /* Check if there's a cached ID we can/should use here! */\n  if(ssl_config->primary.sessionid) {\n    void *old_session = NULL;\n\n    Curl_ssl_sessionid_lock(data);\n    if(!Curl_ssl_getsessionid(cf, data, &old_session, NULL)) {\n      ret = mbedtls_ssl_set_session(&backend->ssl, old_session);\n      if(ret) {\n        Curl_ssl_sessionid_unlock(data);\n        failf(data, \"mbedtls_ssl_set_session returned -0x%x\", -ret);\n        return CURLE_SSL_CONNECT_ERROR;\n      }\n      infof(data, \"mbedTLS reusing session\");\n    }\n    Curl_ssl_sessionid_unlock(data);\n  }\n\n  mbedtls_ssl_conf_ca_chain(&backend->config,\n                            &backend->cacert,\n#ifdef MBEDTLS_X509_CRL_PARSE_C\n                            &backend->crl);\n#else\n                            NULL);\n#endif\n\n  if(ssl_config->key || ssl_config->key_blob) {\n    mbedtls_ssl_conf_own_cert(&backend->config,\n                              &backend->clicert, &backend->pk);\n  }\n\n  if(mbedtls_ssl_set_hostname(&backend->ssl, connssl->peer.sni?\n                              connssl->peer.sni : connssl->peer.hostname)) {\n    /* mbedtls_ssl_set_hostname() sets the name to use in CN/SAN checks and\n       the name to set in the SNI extension. So even if curl connects to a\n       host specified as an IP address, this function must be used. */\n    failf(data, \"Failed to set SNI\");\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n\n#ifdef HAS_ALPN\n  if(connssl->alpn) {\n    struct alpn_proto_buf proto;\n    size_t i;\n\n    for(i = 0; i < connssl->alpn->count; ++i) {\n      backend->protocols[i] = connssl->alpn->entries[i];\n    }\n    /* this function doesn't clone the protocols array, which is why we need\n       to keep it around */\n    if(mbedtls_ssl_conf_alpn_protocols(&backend->config,\n                                       &backend->protocols[0])) {\n      failf(data, \"Failed setting ALPN protocols\");\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n    Curl_alpn_to_proto_str(&proto, connssl->alpn);\n    infof(data, VTLS_INFOF_ALPN_OFFER_1STR, proto.data);\n  }\n#endif\n\n#ifdef MBEDTLS_DEBUG\n  /* In order to make that work in mbedtls MBEDTLS_DEBUG_C must be defined. */\n  mbedtls_ssl_conf_dbg(&backend->config, mbed_debug, data);\n  /* - 0 No debug\n   * - 1 Error\n   * - 2 State change\n   * - 3 Informational\n   * - 4 Verbose\n   */\n  mbedtls_debug_set_threshold(4);\n#endif\n\n  /* give application a chance to interfere with mbedTLS set up. */\n  if(data->set.ssl.fsslctx) {\n    ret = (*data->set.ssl.fsslctx)(data, &backend->config,\n                                   data->set.ssl.fsslctxp);\n    if(ret) {\n      failf(data, \"error signaled by ssl ctx callback\");\n      return ret;\n    }\n  }\n\n  connssl->connecting_state = ssl_connect_2;\n\n  return CURLE_OK;\n}\n\nstatic CURLcode\nmbed_connect_step2(struct Curl_cfilter *cf, struct Curl_easy *data)\n{\n  int ret;\n  struct ssl_connect_data *connssl = cf->ctx;\n  struct mbed_ssl_backend_data *backend =\n    (struct mbed_ssl_backend_data *)connssl->backend;\n  struct ssl_primary_config *conn_config = Curl_ssl_cf_get_primary_config(cf);\n  const mbedtls_x509_crt *peercert;\n  const char * const pinnedpubkey = Curl_ssl_cf_is_proxy(cf)?\n    data->set.str[STRING_SSL_PINNEDPUBLICKEY_PROXY]:\n    data->set.str[STRING_SSL_PINNEDPUBLICKEY];\n\n  DEBUGASSERT(backend);\n\n  ret = mbedtls_ssl_handshake(&backend->ssl);\n\n  if(ret == MBEDTLS_ERR_SSL_WANT_READ) {\n    connssl->connecting_state = ssl_connect_2_reading;\n    return CURLE_OK;\n  }\n  else if(ret == MBEDTLS_ERR_SSL_WANT_WRITE) {\n    connssl->connecting_state = ssl_connect_2_writing;\n    return CURLE_OK;\n  }\n  else if(ret) {\n    char errorbuf[128];\n    mbedtls_strerror(ret, errorbuf, sizeof(errorbuf));\n    failf(data, \"ssl_handshake returned - mbedTLS: (-0x%04X) %s\",\n          -ret, errorbuf);\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n\n  infof(data, \"mbedTLS: Handshake complete, cipher is %s\",\n        mbedtls_ssl_get_ciphersuite(&backend->ssl));\n\n  ret = mbedtls_ssl_get_verify_result(&backend->ssl);\n\n  if(!conn_config->verifyhost)\n    /* Ignore hostname errors if verifyhost is disabled */\n    ret &= ~MBEDTLS_X509_BADCERT_CN_MISMATCH;\n\n  if(ret && conn_config->verifypeer) {\n    if(ret & MBEDTLS_X509_BADCERT_EXPIRED)\n      failf(data, \"Cert verify failed: BADCERT_EXPIRED\");\n\n    else if(ret & MBEDTLS_X509_BADCERT_REVOKED)\n      failf(data, \"Cert verify failed: BADCERT_REVOKED\");\n\n    else if(ret & MBEDTLS_X509_BADCERT_CN_MISMATCH)\n      failf(data, \"Cert verify failed: BADCERT_CN_MISMATCH\");\n\n    else if(ret & MBEDTLS_X509_BADCERT_NOT_TRUSTED)\n      failf(data, \"Cert verify failed: BADCERT_NOT_TRUSTED\");\n\n    else if(ret & MBEDTLS_X509_BADCERT_FUTURE)\n      failf(data, \"Cert verify failed: BADCERT_FUTURE\");\n\n    return CURLE_PEER_FAILED_VERIFICATION;\n  }\n\n  peercert = mbedtls_ssl_get_peer_cert(&backend->ssl);\n\n  if(peercert && data->set.verbose) {\n#ifndef MBEDTLS_X509_REMOVE_INFO\n    const size_t bufsize = 16384;\n    char *buffer = malloc(bufsize);\n\n    if(!buffer)\n      return CURLE_OUT_OF_MEMORY;\n\n    if(mbedtls_x509_crt_info(buffer, bufsize, \"* \", peercert) > 0)\n      infof(data, \"Dumping cert info: %s\", buffer);\n    else\n      infof(data, \"Unable to dump certificate information\");\n\n    free(buffer);\n#else\n    infof(data, \"Unable to dump certificate information\");\n#endif\n  }\n\n  if(pinnedpubkey) {\n    int size;\n    CURLcode result;\n    mbedtls_x509_crt *p = NULL;\n    unsigned char *pubkey = NULL;\n\n#if MBEDTLS_VERSION_NUMBER == 0x03000000\n    if(!peercert || !peercert->MBEDTLS_PRIVATE(raw).MBEDTLS_PRIVATE(p) ||\n       !peercert->MBEDTLS_PRIVATE(raw).MBEDTLS_PRIVATE(len)) {\n#else\n    if(!peercert || !peercert->raw.p || !peercert->raw.len) {\n#endif\n      failf(data, \"Failed due to missing peer certificate\");\n      return CURLE_SSL_PINNEDPUBKEYNOTMATCH;\n    }\n\n    p = calloc(1, sizeof(*p));\n\n    if(!p)\n      return CURLE_OUT_OF_MEMORY;\n\n    pubkey = malloc(PUB_DER_MAX_BYTES);\n\n    if(!pubkey) {\n      result = CURLE_OUT_OF_MEMORY;\n      goto pinnedpubkey_error;\n    }\n\n    mbedtls_x509_crt_init(p);\n\n    /* Make a copy of our const peercert because mbedtls_pk_write_pubkey_der\n       needs a non-const key, for now.\n       https://github.com/ARMmbed/mbedtls/issues/396 */\n#if MBEDTLS_VERSION_NUMBER == 0x03000000\n    if(mbedtls_x509_crt_parse_der(p,\n                        peercert->MBEDTLS_PRIVATE(raw).MBEDTLS_PRIVATE(p),\n                        peercert->MBEDTLS_PRIVATE(raw).MBEDTLS_PRIVATE(len))) {\n#else\n    if(mbedtls_x509_crt_parse_der(p, peercert->raw.p, peercert->raw.len)) {\n#endif\n      failf(data, \"Failed copying peer certificate\");\n      result = CURLE_SSL_PINNEDPUBKEYNOTMATCH;\n      goto pinnedpubkey_error;\n    }\n\n#if MBEDTLS_VERSION_NUMBER == 0x03000000\n    size = mbedtls_pk_write_pubkey_der(&p->MBEDTLS_PRIVATE(pk), pubkey,\n                                       PUB_DER_MAX_BYTES);\n#else\n    size = mbedtls_pk_write_pubkey_der(&p->pk, pubkey, PUB_DER_MAX_BYTES);\n#endif\n\n    if(size <= 0) {\n      failf(data, \"Failed copying public key from peer certificate\");\n      result = CURLE_SSL_PINNEDPUBKEYNOTMATCH;\n      goto pinnedpubkey_error;\n    }\n\n    /* mbedtls_pk_write_pubkey_der writes data at the end of the buffer. */\n    result = Curl_pin_peer_pubkey(data,\n                                  pinnedpubkey,\n                                  &pubkey[PUB_DER_MAX_BYTES - size], size);\npinnedpubkey_error:\n    mbedtls_x509_crt_free(p);\n    free(p);\n    free(pubkey);\n    if(result) {\n      return result;\n    }\n  }\n\n#ifdef HAS_ALPN\n  if(connssl->alpn) {\n    const char *proto = mbedtls_ssl_get_alpn_protocol(&backend->ssl);\n\n    Curl_alpn_set_negotiated(cf, data, (const unsigned char *)proto,\n                             proto? strlen(proto) : 0);\n  }\n#endif\n\n  connssl->connecting_state = ssl_connect_3;\n  infof(data, \"SSL connected\");\n\n  return CURLE_OK;\n}\n\nstatic CURLcode\nmbed_connect_step3(struct Curl_cfilter *cf, struct Curl_easy *data)\n{\n  CURLcode retcode = CURLE_OK;\n  struct ssl_connect_data *connssl = cf->ctx;\n  struct mbed_ssl_backend_data *backend =\n    (struct mbed_ssl_backend_data *)connssl->backend;\n  struct ssl_config_data *ssl_config = Curl_ssl_cf_get_config(cf, data);\n\n  DEBUGASSERT(ssl_connect_3 == connssl->connecting_state);\n  DEBUGASSERT(backend);\n\n  if(ssl_config->primary.sessionid) {\n    int ret;\n    mbedtls_ssl_session *our_ssl_sessionid;\n    void *old_ssl_sessionid = NULL;\n    bool added = FALSE;\n\n    our_ssl_sessionid = malloc(sizeof(mbedtls_ssl_session));\n    if(!our_ssl_sessionid)\n      return CURLE_OUT_OF_MEMORY;\n\n    mbedtls_ssl_session_init(our_ssl_sessionid);\n\n    ret = mbedtls_ssl_get_session(&backend->ssl, our_ssl_sessionid);\n    if(ret) {\n      if(ret != MBEDTLS_ERR_SSL_ALLOC_FAILED)\n        mbedtls_ssl_session_free(our_ssl_sessionid);\n      free(our_ssl_sessionid);\n      failf(data, \"mbedtls_ssl_get_session returned -0x%x\", -ret);\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n\n    /* If there's already a matching session in the cache, delete it */\n    Curl_ssl_sessionid_lock(data);\n    if(!Curl_ssl_getsessionid(cf, data, &old_ssl_sessionid, NULL))\n      Curl_ssl_delsessionid(data, old_ssl_sessionid);\n\n    retcode = Curl_ssl_addsessionid(cf, data, our_ssl_sessionid,\n                                    0, &added);\n    Curl_ssl_sessionid_unlock(data);\n    if(!added) {\n      mbedtls_ssl_session_free(our_ssl_sessionid);\n      free(our_ssl_sessionid);\n    }\n    if(retcode) {\n      failf(data, \"failed to store ssl session\");\n      return retcode;\n    }\n  }\n\n  connssl->connecting_state = ssl_connect_done;\n\n  return CURLE_OK;\n}\n\nstatic ssize_t mbed_send(struct Curl_cfilter *cf, struct Curl_easy *data,\n                         const void *mem, size_t len,\n                         CURLcode *curlcode)\n{\n  struct ssl_connect_data *connssl = cf->ctx;\n  struct mbed_ssl_backend_data *backend =\n    (struct mbed_ssl_backend_data *)connssl->backend;\n  int ret = -1;\n\n  (void)data;\n  DEBUGASSERT(backend);\n  ret = mbedtls_ssl_write(&backend->ssl, (unsigned char *)mem, len);\n\n  if(ret < 0) {\n    *curlcode = (ret == MBEDTLS_ERR_SSL_WANT_WRITE) ?\n      CURLE_AGAIN : CURLE_SEND_ERROR;\n    ret = -1;\n  }\n\n  return ret;\n}\n\nstatic void mbedtls_close_all(struct Curl_easy *data)\n{\n  (void)data;\n}\n\nstatic void mbedtls_close(struct Curl_cfilter *cf, struct Curl_easy *data)\n{\n  struct ssl_connect_data *connssl = cf->ctx;\n  struct mbed_ssl_backend_data *backend =\n    (struct mbed_ssl_backend_data *)connssl->backend;\n  char buf[32];\n\n  (void)data;\n  DEBUGASSERT(backend);\n\n  /* Maybe the server has already sent a close notify alert.\n     Read it to avoid an RST on the TCP connection. */\n  (void)mbedtls_ssl_read(&backend->ssl, (unsigned char *)buf, sizeof(buf));\n\n  mbedtls_pk_free(&backend->pk);\n  mbedtls_x509_crt_free(&backend->clicert);\n  mbedtls_x509_crt_free(&backend->cacert);\n#ifdef MBEDTLS_X509_CRL_PARSE_C\n  mbedtls_x509_crl_free(&backend->crl);\n#endif\n  mbedtls_ssl_config_free(&backend->config);\n  mbedtls_ssl_free(&backend->ssl);\n  mbedtls_ctr_drbg_free(&backend->ctr_drbg);\n#ifndef THREADING_SUPPORT\n  mbedtls_entropy_free(&backend->entropy);\n#endif /* THREADING_SUPPORT */\n}\n\nstatic ssize_t mbed_recv(struct Curl_cfilter *cf, struct Curl_easy *data,\n                         char *buf, size_t buffersize,\n                         CURLcode *curlcode)\n{\n  struct ssl_connect_data *connssl = cf->ctx;\n  struct mbed_ssl_backend_data *backend =\n    (struct mbed_ssl_backend_data *)connssl->backend;\n  int ret = -1;\n  ssize_t len = -1;\n\n  (void)data;\n  DEBUGASSERT(backend);\n\n  ret = mbedtls_ssl_read(&backend->ssl, (unsigned char *)buf,\n                         buffersize);\n\n  if(ret <= 0) {\n    if(ret == MBEDTLS_ERR_SSL_PEER_CLOSE_NOTIFY)\n      return 0;\n\n    *curlcode = (ret == MBEDTLS_ERR_SSL_WANT_READ) ?\n      CURLE_AGAIN : CURLE_RECV_ERROR;\n    return -1;\n  }\n\n  len = ret;\n\n  return len;\n}\n\nstatic void mbedtls_session_free(void *ptr)\n{\n  mbedtls_ssl_session_free(ptr);\n  free(ptr);\n}\n\nstatic size_t mbedtls_version(char *buffer, size_t size)\n{\n#ifdef MBEDTLS_VERSION_C\n  /* if mbedtls_version_get_number() is available it is better */\n  unsigned int version = mbedtls_version_get_number();\n  return msnprintf(buffer, size, \"mbedTLS/%u.%u.%u\", version>>24,\n                   (version>>16)&0xff, (version>>8)&0xff);\n#else\n  return msnprintf(buffer, size, \"mbedTLS/%s\", MBEDTLS_VERSION_STRING);\n#endif\n}\n\nstatic CURLcode mbedtls_random(struct Curl_easy *data,\n                               unsigned char *entropy, size_t length)\n{\n#if defined(MBEDTLS_CTR_DRBG_C)\n  int ret = -1;\n  char errorbuf[128];\n  mbedtls_entropy_context ctr_entropy;\n  mbedtls_ctr_drbg_context ctr_drbg;\n  mbedtls_entropy_init(&ctr_entropy);\n  mbedtls_ctr_drbg_init(&ctr_drbg);\n\n  ret = mbedtls_ctr_drbg_seed(&ctr_drbg, mbedtls_entropy_func,\n                              &ctr_entropy, NULL, 0);\n\n  if(ret) {\n    mbedtls_strerror(ret, errorbuf, sizeof(errorbuf));\n    failf(data, \"mbedtls_ctr_drbg_seed returned (-0x%04X) %s\",\n          -ret, errorbuf);\n  }\n  else {\n    ret = mbedtls_ctr_drbg_random(&ctr_drbg, entropy, length);\n\n    if(ret) {\n      mbedtls_strerror(ret, errorbuf, sizeof(errorbuf));\n      failf(data, \"mbedtls_ctr_drbg_random returned (-0x%04X) %s\",\n            -ret, errorbuf);\n    }\n  }\n\n  mbedtls_ctr_drbg_free(&ctr_drbg);\n  mbedtls_entropy_free(&ctr_entropy);\n\n  return ret == 0 ? CURLE_OK : CURLE_FAILED_INIT;\n#elif defined(MBEDTLS_HAVEGE_C)\n  mbedtls_havege_state hs;\n  mbedtls_havege_init(&hs);\n  mbedtls_havege_random(&hs, entropy, length);\n  mbedtls_havege_free(&hs);\n  return CURLE_OK;\n#else\n  return CURLE_NOT_BUILT_IN;\n#endif\n}\n\nstatic CURLcode\nmbed_connect_common(struct Curl_cfilter *cf, struct Curl_easy *data,\n                    bool nonblocking,\n                    bool *done)\n{\n  CURLcode retcode;\n  struct ssl_connect_data *connssl = cf->ctx;\n  curl_socket_t sockfd = Curl_conn_cf_get_socket(cf, data);\n  timediff_t timeout_ms;\n  int what;\n\n  /* check if the connection has already been established */\n  if(ssl_connection_complete == connssl->state) {\n    *done = TRUE;\n    return CURLE_OK;\n  }\n\n  if(ssl_connect_1 == connssl->connecting_state) {\n    /* Find out how much more time we're allowed */\n    timeout_ms = Curl_timeleft(data, NULL, TRUE);\n\n    if(timeout_ms < 0) {\n      /* no need to continue if time already is up */\n      failf(data, \"SSL connection timeout\");\n      return CURLE_OPERATION_TIMEDOUT;\n    }\n    retcode = mbed_connect_step1(cf, data);\n    if(retcode)\n      return retcode;\n  }\n\n  while(ssl_connect_2 == connssl->connecting_state ||\n        ssl_connect_2_reading == connssl->connecting_state ||\n        ssl_connect_2_writing == connssl->connecting_state) {\n\n    /* check allowed time left */\n    timeout_ms = Curl_timeleft(data, NULL, TRUE);\n\n    if(timeout_ms < 0) {\n      /* no need to continue if time already is up */\n      failf(data, \"SSL connection timeout\");\n      return CURLE_OPERATION_TIMEDOUT;\n    }\n\n    /* if ssl is expecting something, check if it's available. */\n    if(connssl->connecting_state == ssl_connect_2_reading\n       || connssl->connecting_state == ssl_connect_2_writing) {\n\n      curl_socket_t writefd = ssl_connect_2_writing ==\n        connssl->connecting_state?sockfd:CURL_SOCKET_BAD;\n      curl_socket_t readfd = ssl_connect_2_reading ==\n        connssl->connecting_state?sockfd:CURL_SOCKET_BAD;\n\n      what = Curl_socket_check(readfd, CURL_SOCKET_BAD, writefd,\n                               nonblocking ? 0 : timeout_ms);\n      if(what < 0) {\n        /* fatal error */\n        failf(data, \"select/poll on SSL socket, errno: %d\", SOCKERRNO);\n        return CURLE_SSL_CONNECT_ERROR;\n      }\n      else if(0 == what) {\n        if(nonblocking) {\n          *done = FALSE;\n          return CURLE_OK;\n        }\n        else {\n          /* timeout */\n          failf(data, \"SSL connection timeout\");\n          return CURLE_OPERATION_TIMEDOUT;\n        }\n      }\n      /* socket is readable or writable */\n    }\n\n    /* Run transaction, and return to the caller if it failed or if\n     * this connection is part of a multi handle and this loop would\n     * execute again. This permits the owner of a multi handle to\n     * abort a connection attempt before step2 has completed while\n     * ensuring that a client using select() or epoll() will always\n     * have a valid fdset to wait on.\n     */\n    retcode = mbed_connect_step2(cf, data);\n    if(retcode || (nonblocking &&\n                   (ssl_connect_2 == connssl->connecting_state ||\n                    ssl_connect_2_reading == connssl->connecting_state ||\n                    ssl_connect_2_writing == connssl->connecting_state)))\n      return retcode;\n\n  } /* repeat step2 until all transactions are done. */\n\n  if(ssl_connect_3 == connssl->connecting_state) {\n    retcode = mbed_connect_step3(cf, data);\n    if(retcode)\n      return retcode;\n  }\n\n  if(ssl_connect_done == connssl->connecting_state) {\n    connssl->state = ssl_connection_complete;\n    *done = TRUE;\n  }\n  else\n    *done = FALSE;\n\n  /* Reset our connect state machine */\n  connssl->connecting_state = ssl_connect_1;\n\n  return CURLE_OK;\n}\n\nstatic CURLcode mbedtls_connect_nonblocking(struct Curl_cfilter *cf,\n                                            struct Curl_easy *data,\n                                            bool *done)\n{\n  return mbed_connect_common(cf, data, TRUE, done);\n}\n\n\nstatic CURLcode mbedtls_connect(struct Curl_cfilter *cf,\n                                struct Curl_easy *data)\n{\n  CURLcode retcode;\n  bool done = FALSE;\n\n  retcode = mbed_connect_common(cf, data, FALSE, &done);\n  if(retcode)\n    return retcode;\n\n  DEBUGASSERT(done);\n\n  return CURLE_OK;\n}\n\n/*\n * return 0 error initializing SSL\n * return 1 SSL initialized successfully\n */\nstatic int mbedtls_init(void)\n{\n  if(!Curl_mbedtlsthreadlock_thread_setup())\n    return 0;\n#ifdef THREADING_SUPPORT\n  entropy_init_mutex(&ts_entropy);\n#endif\n  return 1;\n}\n\nstatic void mbedtls_cleanup(void)\n{\n#ifdef THREADING_SUPPORT\n  entropy_cleanup_mutex(&ts_entropy);\n#endif\n  (void)Curl_mbedtlsthreadlock_thread_cleanup();\n}\n\nstatic bool mbedtls_data_pending(struct Curl_cfilter *cf,\n                                 const struct Curl_easy *data)\n{\n  struct ssl_connect_data *ctx = cf->ctx;\n  struct mbed_ssl_backend_data *backend;\n\n  (void)data;\n  DEBUGASSERT(ctx && ctx->backend);\n  backend = (struct mbed_ssl_backend_data *)ctx->backend;\n  return mbedtls_ssl_get_bytes_avail(&backend->ssl) != 0;\n}\n\nstatic CURLcode mbedtls_sha256sum(const unsigned char *input,\n                                  size_t inputlen,\n                                  unsigned char *sha256sum,\n                                  size_t sha256len UNUSED_PARAM)\n{\n  /* TODO: explain this for different mbedtls 2.x vs 3 version */\n  (void)sha256len;\n#if MBEDTLS_VERSION_NUMBER < 0x02070000\n  mbedtls_sha256(input, inputlen, sha256sum, 0);\n#else\n  /* returns 0 on success, otherwise failure */\n#if MBEDTLS_VERSION_NUMBER >= 0x03000000\n  if(mbedtls_sha256(input, inputlen, sha256sum, 0) != 0)\n#else\n  if(mbedtls_sha256_ret(input, inputlen, sha256sum, 0) != 0)\n#endif\n    return CURLE_BAD_FUNCTION_ARGUMENT;\n#endif\n  return CURLE_OK;\n}\n\nstatic void *mbedtls_get_internals(struct ssl_connect_data *connssl,\n                                   CURLINFO info UNUSED_PARAM)\n{\n  struct mbed_ssl_backend_data *backend =\n    (struct mbed_ssl_backend_data *)connssl->backend;\n  (void)info;\n  DEBUGASSERT(backend);\n  return &backend->ssl;\n}\n\nconst struct Curl_ssl Curl_ssl_mbedtls = {\n  { CURLSSLBACKEND_MBEDTLS, \"mbedtls\" }, /* info */\n\n  SSLSUPP_CA_PATH |\n  SSLSUPP_CAINFO_BLOB |\n  SSLSUPP_PINNEDPUBKEY |\n  SSLSUPP_SSL_CTX |\n  SSLSUPP_HTTPS_PROXY,\n\n  sizeof(struct mbed_ssl_backend_data),\n\n  mbedtls_init,                     /* init */\n  mbedtls_cleanup,                  /* cleanup */\n  mbedtls_version,                  /* version */\n  Curl_none_check_cxn,              /* check_cxn */\n  Curl_none_shutdown,               /* shutdown */\n  mbedtls_data_pending,             /* data_pending */\n  mbedtls_random,                   /* random */\n  Curl_none_cert_status_request,    /* cert_status_request */\n  mbedtls_connect,                  /* connect */\n  mbedtls_connect_nonblocking,      /* connect_nonblocking */\n  Curl_ssl_adjust_pollset,          /* adjust_pollset */\n  mbedtls_get_internals,            /* get_internals */\n  mbedtls_close,                    /* close_one */\n  mbedtls_close_all,                /* close_all */\n  mbedtls_session_free,             /* session_free */\n  Curl_none_set_engine,             /* set_engine */\n  Curl_none_set_engine_default,     /* set_engine_default */\n  Curl_none_engines_list,           /* engines_list */\n  Curl_none_false_start,            /* false_start */\n  mbedtls_sha256sum,                /* sha256sum */\n  NULL,                             /* associate_connection */\n  NULL,                             /* disassociate_connection */\n  NULL,                             /* free_multi_ssl_backend_data */\n  mbed_recv,                        /* recv decrypted data */\n  mbed_send,                        /* send data to encrypt */\n};\n\n#endif /* USE_MBEDTLS */\n` was unexpected","path":"/home/qqq/curl-8.7.0/lib/vtls/mbedtls.c"},{"code":3,"level":"warn","type":"Syntax error","message":"Syntax error at line /home/qqq/curl-8.7.0/lib/vtls/gtls.c:1:\n `/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n * SPDX-License-Identifier: curl\n *\n ***************************************************************************/\n\n/*\n * Source file for all GnuTLS-specific code for the TLS/SSL layer. No code\n * but vtls.c should ever call or use these functions.\n *\n * Note: don't use the GnuTLS' *_t variable type names in this source code,\n * since they were not present in 1.0.X.\n */\n\n#include \"curl_setup.h\"\n\n#ifdef USE_GNUTLS\n\n#include <gnutls/abstract.h>\n#include <gnutls/gnutls.h>\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <nettle/sha2.h>\n\n#include \"urldata.h\"\n#include \"sendf.h\"\n#include \"inet_pton.h\"\n#include \"gtls.h\"\n#include \"vtls.h\"\n#include \"vtls_int.h\"\n#include \"vauth/vauth.h\"\n#include \"parsedate.h\"\n#include \"connect.h\" /* for the connect timeout */\n#include \"select.h\"\n#include \"strcase.h\"\n#include \"warnless.h\"\n#include \"x509asn1.h\"\n#include \"multiif.h\"\n#include \"curl_printf.h\"\n#include \"curl_memory.h\"\n/* The last #include file should be: */\n#include \"memdebug.h\"\n\n/* Enable GnuTLS debugging by defining GTLSDEBUG */\n/*#define GTLSDEBUG */\n\n#ifdef GTLSDEBUG\nstatic void tls_log_func(int level, const char *str)\n{\n    fprintf(stderr, \"|<%d>| %s\", level, str);\n}\n#endif\nstatic bool gtls_inited = FALSE;\n\n#if !defined(GNUTLS_VERSION_NUMBER) || (GNUTLS_VERSION_NUMBER < 0x03010a)\n#error \"too old GnuTLS version\"\n#endif\n\n# include <gnutls/ocsp.h>\n\nstruct gtls_ssl_backend_data {\n  struct gtls_instance gtls;\n};\n\nstatic ssize_t gtls_push(void *s, const void *buf, size_t blen)\n{\n  struct Curl_cfilter *cf = s;\n  struct ssl_connect_data *connssl = cf->ctx;\n  struct Curl_easy *data = CF_DATA_CURRENT(cf);\n  ssize_t nwritten;\n  CURLcode result;\n\n  DEBUGASSERT(data);\n  nwritten = Curl_conn_cf_send(cf->next, data, buf, blen, &result);\n  if(nwritten < 0) {\n    struct gtls_ssl_backend_data *backend =\n      (struct gtls_ssl_backend_data *)connssl->backend;\n    gnutls_transport_set_errno(backend->gtls.session,\n                               (CURLE_AGAIN == result)? EAGAIN : EINVAL);\n    nwritten = -1;\n  }\n  return nwritten;\n}\n\nstatic ssize_t gtls_pull(void *s, void *buf, size_t blen)\n{\n  struct Curl_cfilter *cf = s;\n  struct ssl_connect_data *connssl = cf->ctx;\n  struct Curl_easy *data = CF_DATA_CURRENT(cf);\n  ssize_t nread;\n  CURLcode result;\n\n  DEBUGASSERT(data);\n  nread = Curl_conn_cf_recv(cf->next, data, buf, blen, &result);\n  if(nread < 0) {\n    struct gtls_ssl_backend_data *backend =\n      (struct gtls_ssl_backend_data *)connssl->backend;\n    gnutls_transport_set_errno(backend->gtls.session,\n                               (CURLE_AGAIN == result)? EAGAIN : EINVAL);\n    nread = -1;\n  }\n  else if(nread == 0)\n    connssl->peer_closed = TRUE;\n  return nread;\n}\n\n/* gtls_init()\n *\n * Global GnuTLS init, called from Curl_ssl_init(). This calls functions that\n * are not thread-safe and thus this function itself is not thread-safe and\n * must only be called from within curl_global_init() to keep the thread\n * situation under control!\n */\nstatic int gtls_init(void)\n{\n  int ret = 1;\n  if(!gtls_inited) {\n    ret = gnutls_global_init()?0:1;\n#ifdef GTLSDEBUG\n    gnutls_global_set_log_function(tls_log_func);\n    gnutls_global_set_log_level(2);\n#endif\n    gtls_inited = TRUE;\n  }\n  return ret;\n}\n\nstatic void gtls_cleanup(void)\n{\n  if(gtls_inited) {\n    gnutls_global_deinit();\n    gtls_inited = FALSE;\n  }\n}\n\n#ifndef CURL_DISABLE_VERBOSE_STRINGS\nstatic void showtime(struct Curl_easy *data,\n                     const char *text,\n                     time_t stamp)\n{\n  struct tm buffer;\n  const struct tm *tm = &buffer;\n  char str[96];\n  CURLcode result = Curl_gmtime(stamp, &buffer);\n  if(result)\n    return;\n\n  msnprintf(str,\n            sizeof(str),\n            \"  %s: %s, %02d %s %4d %02d:%02d:%02d GMT\",\n            text,\n            Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],\n            tm->tm_mday,\n            Curl_month[tm->tm_mon],\n            tm->tm_year + 1900,\n            tm->tm_hour,\n            tm->tm_min,\n            tm->tm_sec);\n  infof(data, \"%s\", str);\n}\n#endif\n\nstatic gnutls_datum_t load_file(const char *file)\n{\n  FILE *f;\n  gnutls_datum_t loaded_file = { NULL, 0 };\n  long filelen;\n  void *ptr;\n\n  f = fopen(file, \"rb\");\n  if(!f)\n    return loaded_file;\n  if(fseek(f, 0, SEEK_END) != 0\n     || (filelen = ftell(f)) < 0\n     || fseek(f, 0, SEEK_SET) != 0\n     || !(ptr = malloc((size_t)filelen)))\n    goto out;\n  if(fread(ptr, 1, (size_t)filelen, f) < (size_t)filelen) {\n    free(ptr);\n    goto out;\n  }\n\n  loaded_file.data = ptr;\n  loaded_file.size = (unsigned int)filelen;\nout:\n  fclose(f);\n  return loaded_file;\n}\n\nstatic void unload_file(gnutls_datum_t data)\n{\n  free(data.data);\n}\n\n\n/* this function does a SSL/TLS (re-)handshake */\nstatic CURLcode handshake(struct Curl_cfilter *cf,\n                          struct Curl_easy *data,\n                          bool duringconnect,\n                          bool nonblocking)\n{\n  struct ssl_connect_data *connssl = cf->ctx;\n  struct gtls_ssl_backend_data *backend =\n    (struct gtls_ssl_backend_data *)connssl->backend;\n  gnutls_session_t session;\n  curl_socket_t sockfd = Curl_conn_cf_get_socket(cf, data);\n\n  DEBUGASSERT(backend);\n  session = backend->gtls.session;\n\n  for(;;) {\n    timediff_t timeout_ms;\n    int rc;\n\n    /* check allowed time left */\n    timeout_ms = Curl_timeleft(data, NULL, duringconnect);\n\n    if(timeout_ms < 0) {\n      /* no need to continue if time already is up */\n      failf(data, \"SSL connection timeout\");\n      return CURLE_OPERATION_TIMEDOUT;\n    }\n\n    /* if ssl is expecting something, check if it's available. */\n    if(connssl->connecting_state == ssl_connect_2_reading\n       || connssl->connecting_state == ssl_connect_2_writing) {\n      int what;\n      curl_socket_t writefd = ssl_connect_2_writing ==\n        connssl->connecting_state?sockfd:CURL_SOCKET_BAD;\n      curl_socket_t readfd = ssl_connect_2_reading ==\n        connssl->connecting_state?sockfd:CURL_SOCKET_BAD;\n\n      what = Curl_socket_check(readfd, CURL_SOCKET_BAD, writefd,\n                               nonblocking?0:\n                               timeout_ms?timeout_ms:1000);\n      if(what < 0) {\n        /* fatal error */\n        failf(data, \"select/poll on SSL socket, errno: %d\", SOCKERRNO);\n        return CURLE_SSL_CONNECT_ERROR;\n      }\n      else if(0 == what) {\n        if(nonblocking)\n          return CURLE_OK;\n        else if(timeout_ms) {\n          /* timeout */\n          failf(data, \"SSL connection timeout at %ld\", (long)timeout_ms);\n          return CURLE_OPERATION_TIMEDOUT;\n        }\n      }\n      /* socket is readable or writable */\n    }\n\n    rc = gnutls_handshake(session);\n\n    if((rc == GNUTLS_E_AGAIN) || (rc == GNUTLS_E_INTERRUPTED)) {\n      connssl->connecting_state =\n        gnutls_record_get_direction(session)?\n        ssl_connect_2_writing:ssl_connect_2_reading;\n      continue;\n    }\n    else if((rc < 0) && !gnutls_error_is_fatal(rc)) {\n      const char *strerr = NULL;\n\n      if(rc == GNUTLS_E_WARNING_ALERT_RECEIVED) {\n        int alert = gnutls_alert_get(session);\n        strerr = gnutls_alert_get_name(alert);\n      }\n\n      if(!strerr)\n        strerr = gnutls_strerror(rc);\n\n      infof(data, \"gnutls_handshake() warning: %s\", strerr);\n      continue;\n    }\n    else if(rc < 0) {\n      const char *strerr = NULL;\n\n      if(rc == GNUTLS_E_FATAL_ALERT_RECEIVED) {\n        int alert = gnutls_alert_get(session);\n        strerr = gnutls_alert_get_name(alert);\n      }\n\n      if(!strerr)\n        strerr = gnutls_strerror(rc);\n\n      failf(data, \"gnutls_handshake() failed: %s\", strerr);\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n\n    /* Reset our connect state machine */\n    connssl->connecting_state = ssl_connect_1;\n    return CURLE_OK;\n  }\n}\n\nstatic gnutls_x509_crt_fmt_t do_file_type(const char *type)\n{\n  if(!type || !type[0])\n    return GNUTLS_X509_FMT_PEM;\n  if(strcasecompare(type, \"PEM\"))\n    return GNUTLS_X509_FMT_PEM;\n  if(strcasecompare(type, \"DER\"))\n    return GNUTLS_X509_FMT_DER;\n  return GNUTLS_X509_FMT_PEM; /* default to PEM */\n}\n\n#define GNUTLS_CIPHERS \"NORMAL:-ARCFOUR-128:-CTYPE-ALL:+CTYPE-X509\"\n/* If GnuTLS was compiled without support for SRP it will error out if SRP is\n   requested in the priority string, so treat it specially\n */\n#define GNUTLS_SRP \"+SRP\"\n\nstatic CURLcode\nset_ssl_version_min_max(struct Curl_easy *data,\n                        struct ssl_primary_config *conn_config,\n                        const char **prioritylist,\n                        const char *tls13support)\n{\n  long ssl_version = conn_config->version;\n  long ssl_version_max = conn_config->version_max;\n\n  if((ssl_version == CURL_SSLVERSION_DEFAULT) ||\n     (ssl_version == CURL_SSLVERSION_TLSv1))\n    ssl_version = CURL_SSLVERSION_TLSv1_0;\n  if(ssl_version_max == CURL_SSLVERSION_MAX_NONE)\n    ssl_version_max = CURL_SSLVERSION_MAX_DEFAULT;\n  if(!tls13support) {\n    /* If the running GnuTLS doesn't support TLS 1.3, we must not specify a\n       prioritylist involving that since it will make GnuTLS return an en\n       error back at us */\n    if((ssl_version_max == CURL_SSLVERSION_MAX_TLSv1_3) ||\n       (ssl_version_max == CURL_SSLVERSION_MAX_DEFAULT)) {\n      ssl_version_max = CURL_SSLVERSION_MAX_TLSv1_2;\n    }\n  }\n  else if(ssl_version_max == CURL_SSLVERSION_MAX_DEFAULT) {\n    ssl_version_max = CURL_SSLVERSION_MAX_TLSv1_3;\n  }\n\n  switch(ssl_version | ssl_version_max) {\n  case CURL_SSLVERSION_TLSv1_0 | CURL_SSLVERSION_MAX_TLSv1_0:\n    *prioritylist = GNUTLS_CIPHERS \":-VERS-SSL3.0:-VERS-TLS-ALL:\"\n      \"+VERS-TLS1.0\";\n    return CURLE_OK;\n  case CURL_SSLVERSION_TLSv1_0 | CURL_SSLVERSION_MAX_TLSv1_1:\n    *prioritylist = GNUTLS_CIPHERS \":-VERS-SSL3.0:-VERS-TLS-ALL:\"\n      \"+VERS-TLS1.1:+VERS-TLS1.0\";\n    return CURLE_OK;\n  case CURL_SSLVERSION_TLSv1_0 | CURL_SSLVERSION_MAX_TLSv1_2:\n    *prioritylist = GNUTLS_CIPHERS \":-VERS-SSL3.0:-VERS-TLS-ALL:\"\n      \"+VERS-TLS1.2:+VERS-TLS1.1:+VERS-TLS1.0\";\n    return CURLE_OK;\n  case CURL_SSLVERSION_TLSv1_1 | CURL_SSLVERSION_MAX_TLSv1_1:\n    *prioritylist = GNUTLS_CIPHERS \":-VERS-SSL3.0:-VERS-TLS-ALL:\"\n      \"+VERS-TLS1.1\";\n    return CURLE_OK;\n  case CURL_SSLVERSION_TLSv1_1 | CURL_SSLVERSION_MAX_TLSv1_2:\n    *prioritylist = GNUTLS_CIPHERS \":-VERS-SSL3.0:-VERS-TLS-ALL:\"\n      \"+VERS-TLS1.2:+VERS-TLS1.1\";\n    return CURLE_OK;\n  case CURL_SSLVERSION_TLSv1_2 | CURL_SSLVERSION_MAX_TLSv1_2:\n    *prioritylist = GNUTLS_CIPHERS \":-VERS-SSL3.0:-VERS-TLS-ALL:\"\n      \"+VERS-TLS1.2\";\n    return CURLE_OK;\n  case CURL_SSLVERSION_TLSv1_3 | CURL_SSLVERSION_MAX_TLSv1_3:\n    *prioritylist = GNUTLS_CIPHERS \":-VERS-SSL3.0:-VERS-TLS-ALL:\"\n      \"+VERS-TLS1.3\";\n    return CURLE_OK;\n  case CURL_SSLVERSION_TLSv1_0 | CURL_SSLVERSION_MAX_TLSv1_3:\n    *prioritylist = GNUTLS_CIPHERS \":-VERS-SSL3.0\";\n    return CURLE_OK;\n  case CURL_SSLVERSION_TLSv1_1 | CURL_SSLVERSION_MAX_TLSv1_3:\n    *prioritylist = GNUTLS_CIPHERS \":-VERS-SSL3.0:-VERS-TLS-ALL:\"\n      \"+VERS-TLS1.3:+VERS-TLS1.2:+VERS-TLS1.1\";\n    return CURLE_OK;\n  case CURL_SSLVERSION_TLSv1_2 | CURL_SSLVERSION_MAX_TLSv1_3:\n    *prioritylist = GNUTLS_CIPHERS \":-VERS-SSL3.0:-VERS-TLS-ALL:\"\n      \"+VERS-TLS1.3:+VERS-TLS1.2\";\n    return CURLE_OK;\n  }\n\n  failf(data, \"GnuTLS: cannot set ssl protocol\");\n  return CURLE_SSL_CONNECT_ERROR;\n}\n\nCURLcode gtls_client_init(struct Curl_easy *data,\n                          struct ssl_primary_config *config,\n                          struct ssl_config_data *ssl_config,\n                          struct ssl_peer *peer,\n                          struct gtls_instance *gtls,\n                          long *pverifyresult)\n{\n  unsigned int init_flags;\n  int rc;\n  bool sni = TRUE; /* default is SNI enabled */\n  const char *prioritylist;\n  const char *err = NULL;\n  const char *tls13support;\n  CURLcode result;\n\n  if(!gtls_inited)\n    gtls_init();\n\n  *pverifyresult = 0;\n\n  if(config->version == CURL_SSLVERSION_SSLv2) {\n    failf(data, \"GnuTLS does not support SSLv2\");\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n  else if(config->version == CURL_SSLVERSION_SSLv3)\n    sni = FALSE; /* SSLv3 has no SNI */\n\n  /* allocate a cred struct */\n  rc = gnutls_certificate_allocate_credentials(&gtls->cred);\n  if(rc != GNUTLS_E_SUCCESS) {\n    failf(data, \"gnutls_cert_all_cred() failed: %s\", gnutls_strerror(rc));\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n\n#ifdef USE_GNUTLS_SRP\n  if(config->username && Curl_auth_allowed_to_host(data)) {\n    infof(data, \"Using TLS-SRP username: %s\", config->username);\n\n    rc = gnutls_srp_allocate_client_credentials(&gtls->srp_client_cred);\n    if(rc != GNUTLS_E_SUCCESS) {\n      failf(data, \"gnutls_srp_allocate_client_cred() failed: %s\",\n            gnutls_strerror(rc));\n      return CURLE_OUT_OF_MEMORY;\n    }\n\n    rc = gnutls_srp_set_client_credentials(gtls->srp_client_cred,\n                                           config->username,\n                                           config->password);\n    if(rc != GNUTLS_E_SUCCESS) {\n      failf(data, \"gnutls_srp_set_client_cred() failed: %s\",\n            gnutls_strerror(rc));\n      return CURLE_BAD_FUNCTION_ARGUMENT;\n    }\n  }\n#endif\n\n  if(config->verifypeer) {\n    bool imported_native_ca = false;\n\n    if(ssl_config->native_ca_store) {\n      rc = gnutls_certificate_set_x509_system_trust(gtls->cred);\n      if(rc < 0)\n        infof(data, \"error reading native ca store (%s), continuing anyway\",\n              gnutls_strerror(rc));\n      else {\n        infof(data, \"found %d certificates in native ca store\", rc);\n        if(rc > 0)\n          imported_native_ca = true;\n      }\n    }\n\n    if(config->CAfile) {\n      /* set the trusted CA cert bundle file */\n      gnutls_certificate_set_verify_flags(gtls->cred,\n                                          GNUTLS_VERIFY_ALLOW_X509_V1_CA_CRT);\n\n      rc = gnutls_certificate_set_x509_trust_file(gtls->cred,\n                                                  config->CAfile,\n                                                  GNUTLS_X509_FMT_PEM);\n      if(rc < 0) {\n        infof(data, \"error reading ca cert file %s (%s)%s\",\n              config->CAfile, gnutls_strerror(rc),\n              (imported_native_ca ? \", continuing anyway\" : \"\"));\n        if(!imported_native_ca) {\n          *pverifyresult = rc;\n          return CURLE_SSL_CACERT_BADFILE;\n        }\n      }\n      else\n        infof(data, \"found %d certificates in %s\", rc, config->CAfile);\n    }\n\n    if(config->CApath) {\n      /* set the trusted CA cert directory */\n      rc = gnutls_certificate_set_x509_trust_dir(gtls->cred,\n                                                 config->CApath,\n                                                 GNUTLS_X509_FMT_PEM);\n      if(rc < 0) {\n        infof(data, \"error reading ca cert file %s (%s)%s\",\n              config->CApath, gnutls_strerror(rc),\n              (imported_native_ca ? \", continuing anyway\" : \"\"));\n        if(!imported_native_ca) {\n          *pverifyresult = rc;\n          return CURLE_SSL_CACERT_BADFILE;\n        }\n      }\n      else\n        infof(data, \"found %d certificates in %s\", rc, config->CApath);\n    }\n  }\n\n  if(config->CRLfile) {\n    /* set the CRL list file */\n    rc = gnutls_certificate_set_x509_crl_file(gtls->cred,\n                                              config->CRLfile,\n                                              GNUTLS_X509_FMT_PEM);\n    if(rc < 0) {\n      failf(data, \"error reading crl file %s (%s)\",\n            config->CRLfile, gnutls_strerror(rc));\n      return CURLE_SSL_CRL_BADFILE;\n    }\n    else\n      infof(data, \"found %d CRL in %s\", rc, config->CRLfile);\n  }\n\n  /* Initialize TLS session as a client */\n  init_flags = GNUTLS_CLIENT;\n\n#if defined(GNUTLS_FORCE_CLIENT_CERT)\n  init_flags |= GNUTLS_FORCE_CLIENT_CERT;\n#endif\n\n#if defined(GNUTLS_NO_TICKETS)\n  /* Disable TLS session tickets */\n  init_flags |= GNUTLS_NO_TICKETS;\n#endif\n\n  rc = gnutls_init(&gtls->session, init_flags);\n  if(rc != GNUTLS_E_SUCCESS) {\n    failf(data, \"gnutls_init() failed: %d\", rc);\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n\n  if(sni && peer->sni) {\n    if(gnutls_server_name_set(gtls->session, GNUTLS_NAME_DNS,\n                              peer->sni, strlen(peer->sni)) < 0) {\n      failf(data, \"Failed to set SNI\");\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n  }\n\n  /* Use default priorities */\n  rc = gnutls_set_default_priority(gtls->session);\n  if(rc != GNUTLS_E_SUCCESS)\n    return CURLE_SSL_CONNECT_ERROR;\n\n  /* \"In GnuTLS 3.6.5, TLS 1.3 is enabled by default\" */\n  tls13support = gnutls_check_version(\"3.6.5\");\n\n  /* Ensure +SRP comes at the *end* of all relevant strings so that it can be\n   * removed if a run-time error indicates that SRP is not supported by this\n   * GnuTLS version */\n\n  if(config->version == CURL_SSLVERSION_SSLv2 ||\n     config->version == CURL_SSLVERSION_SSLv3) {\n    failf(data, \"GnuTLS does not support SSLv2 or SSLv3\");\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n\n  if(config->version == CURL_SSLVERSION_TLSv1_3) {\n    if(!tls13support) {\n      failf(data, \"This GnuTLS installation does not support TLS 1.3\");\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n  }\n\n  /* At this point we know we have a supported TLS version, so set it */\n  result = set_ssl_version_min_max(data, config, &prioritylist, tls13support);\n  if(result)\n    return result;\n\n#ifdef USE_GNUTLS_SRP\n  /* Only add SRP to the cipher list if SRP is requested. Otherwise\n   * GnuTLS will disable TLS 1.3 support. */\n  if(config->username) {\n    char *prioritysrp = aprintf(\"%s:\" GNUTLS_SRP, prioritylist);\n    if(!prioritysrp)\n      return CURLE_OUT_OF_MEMORY;\n    rc = gnutls_priority_set_direct(gtls->session, prioritysrp, &err);\n    free(prioritysrp);\n\n    if((rc == GNUTLS_E_INVALID_REQUEST) && err) {\n      infof(data, \"This GnuTLS does not support SRP\");\n    }\n  }\n  else {\n#endif\n    infof(data, \"GnuTLS ciphers: %s\", prioritylist);\n    rc = gnutls_priority_set_direct(gtls->session, prioritylist, &err);\n#ifdef USE_GNUTLS_SRP\n  }\n#endif\n\n  if(rc != GNUTLS_E_SUCCESS) {\n    failf(data, \"Error %d setting GnuTLS cipher list starting with %s\",\n          rc, err);\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n\n  if(config->clientcert) {\n    if(ssl_config->key_passwd) {\n      const unsigned int supported_key_encryption_algorithms =\n        GNUTLS_PKCS_USE_PKCS12_3DES | GNUTLS_PKCS_USE_PKCS12_ARCFOUR |\n        GNUTLS_PKCS_USE_PKCS12_RC2_40 | GNUTLS_PKCS_USE_PBES2_3DES |\n        GNUTLS_PKCS_USE_PBES2_AES_128 | GNUTLS_PKCS_USE_PBES2_AES_192 |\n        GNUTLS_PKCS_USE_PBES2_AES_256;\n      rc = gnutls_certificate_set_x509_key_file2(\n           gtls->cred,\n           config->clientcert,\n           ssl_config->key ? ssl_config->key : config->clientcert,\n           do_file_type(ssl_config->cert_type),\n           ssl_config->key_passwd,\n           supported_key_encryption_algorithms);\n      if(rc != GNUTLS_E_SUCCESS) {\n        failf(data,\n              \"error reading X.509 potentially-encrypted key file: %s\",\n              gnutls_strerror(rc));\n        return CURLE_SSL_CONNECT_ERROR;\n      }\n    }\n    else {\n      if(gnutls_certificate_set_x509_key_file(\n           gtls->cred,\n           config->clientcert,\n           ssl_config->key ? ssl_config->key : config->clientcert,\n           do_file_type(ssl_config->cert_type) ) !=\n         GNUTLS_E_SUCCESS) {\n        failf(data, \"error reading X.509 key or certificate file\");\n        return CURLE_SSL_CONNECT_ERROR;\n      }\n    }\n  }\n\n#ifdef USE_GNUTLS_SRP\n  /* put the credentials to the current session */\n  if(config->username) {\n    rc = gnutls_credentials_set(gtls->session, GNUTLS_CRD_SRP,\n                                gtls->srp_client_cred);\n    if(rc != GNUTLS_E_SUCCESS) {\n      failf(data, \"gnutls_credentials_set() failed: %s\", gnutls_strerror(rc));\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n  }\n  else\n#endif\n  {\n    rc = gnutls_credentials_set(gtls->session, GNUTLS_CRD_CERTIFICATE,\n                                gtls->cred);\n    if(rc != GNUTLS_E_SUCCESS) {\n      failf(data, \"gnutls_credentials_set() failed: %s\", gnutls_strerror(rc));\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n  }\n\n  if(config->verifystatus) {\n    rc = gnutls_ocsp_status_request_enable_client(gtls->session,\n                                                  NULL, 0, NULL);\n    if(rc != GNUTLS_E_SUCCESS) {\n      failf(data, \"gnutls_ocsp_status_request_enable_client() failed: %d\", rc);\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n  }\n\n  return CURLE_OK;\n}\n\nstatic CURLcode\ngtls_connect_step1(struct Curl_cfilter *cf, struct Curl_easy *data)\n{\n  struct ssl_connect_data *connssl = cf->ctx;\n  struct gtls_ssl_backend_data *backend =\n    (struct gtls_ssl_backend_data *)connssl->backend;\n  struct ssl_primary_config *conn_config = Curl_ssl_cf_get_primary_config(cf);\n  struct ssl_config_data *ssl_config = Curl_ssl_cf_get_config(cf, data);\n  long * const pverifyresult = &ssl_config->certverifyresult;\n  CURLcode result;\n\n  DEBUGASSERT(backend);\n\n  if(connssl->state == ssl_connection_complete)\n    /* to make us tolerant against being called more than once for the\n       same connection */\n    return CURLE_OK;\n\n  result = gtls_client_init(data, conn_config, ssl_config,\n                            &connssl->peer,\n                            &backend->gtls, pverifyresult);\n  if(result)\n    return result;\n\n  if(connssl->alpn) {\n    struct alpn_proto_buf proto;\n    gnutls_datum_t alpn[ALPN_ENTRIES_MAX];\n    size_t i;\n\n    for(i = 0; i < connssl->alpn->count; ++i) {\n      alpn[i].data = (unsigned char *)connssl->alpn->entries[i];\n      alpn[i].size = (unsigned)strlen(connssl->alpn->entries[i]);\n    }\n    if(gnutls_alpn_set_protocols(backend->gtls.session, alpn,\n                                 (unsigned)connssl->alpn->count, 0)) {\n      failf(data, \"failed setting ALPN\");\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n    Curl_alpn_to_proto_str(&proto, connssl->alpn);\n    infof(data, VTLS_INFOF_ALPN_OFFER_1STR, proto.data);\n  }\n\n  /* This might be a reconnect, so we check for a session ID in the cache\n     to speed up things */\n  if(conn_config->sessionid) {\n    void *ssl_sessionid;\n    size_t ssl_idsize;\n\n    Curl_ssl_sessionid_lock(data);\n    if(!Curl_ssl_getsessionid(cf, data, &ssl_sessionid, &ssl_idsize)) {\n      /* we got a session id, use it! */\n      gnutls_session_set_data(backend->gtls.session,\n                              ssl_sessionid, ssl_idsize);\n\n      /* Informational message */\n      infof(data, \"SSL reusing session ID\");\n    }\n    Curl_ssl_sessionid_unlock(data);\n  }\n\n  /* register callback functions and handle to send and receive data. */\n  gnutls_transport_set_ptr(backend->gtls.session, cf);\n  gnutls_transport_set_push_function(backend->gtls.session, gtls_push);\n  gnutls_transport_set_pull_function(backend->gtls.session, gtls_pull);\n\n  return CURLE_OK;\n}\n\nstatic CURLcode pkp_pin_peer_pubkey(struct Curl_easy *data,\n                                    gnutls_x509_crt_t cert,\n                                    const char *pinnedpubkey)\n{\n  /* Scratch */\n  size_t len1 = 0, len2 = 0;\n  unsigned char *buff1 = NULL;\n\n  gnutls_pubkey_t key = NULL;\n\n  /* Result is returned to caller */\n  CURLcode result = CURLE_SSL_PINNEDPUBKEYNOTMATCH;\n\n  /* if a path wasn't specified, don't pin */\n  if(!pinnedpubkey)\n    return CURLE_OK;\n\n  if(!cert)\n    return result;\n\n  do {\n    int ret;\n\n    /* Begin Gyrations to get the public key     */\n    gnutls_pubkey_init(&key);\n\n    ret = gnutls_pubkey_import_x509(key, cert, 0);\n    if(ret < 0)\n      break; /* failed */\n\n    ret = gnutls_pubkey_export(key, GNUTLS_X509_FMT_DER, NULL, &len1);\n    if(ret != GNUTLS_E_SHORT_MEMORY_BUFFER || len1 == 0)\n      break; /* failed */\n\n    buff1 = malloc(len1);\n    if(!buff1)\n      break; /* failed */\n\n    len2 = len1;\n\n    ret = gnutls_pubkey_export(key, GNUTLS_X509_FMT_DER, buff1, &len2);\n    if(ret < 0 || len1 != len2)\n      break; /* failed */\n\n    /* End Gyrations */\n\n    /* The one good exit point */\n    result = Curl_pin_peer_pubkey(data, pinnedpubkey, buff1, len1);\n  } while(0);\n\n  if(key)\n    gnutls_pubkey_deinit(key);\n\n  Curl_safefree(buff1);\n\n  return result;\n}\n\nCURLcode\nCurl_gtls_verifyserver(struct Curl_easy *data,\n                       gnutls_session_t session,\n                       struct ssl_primary_config *config,\n                       struct ssl_config_data *ssl_config,\n                       struct ssl_peer *peer,\n                       const char *pinned_key)\n{\n  unsigned int cert_list_size;\n  const gnutls_datum_t *chainp;\n  unsigned int verify_status = 0;\n  gnutls_x509_crt_t x509_cert, x509_issuer;\n  gnutls_datum_t issuerp;\n  gnutls_datum_t certfields;\n  char certname[65] = \"\"; /* limited to 64 chars by ASN.1 */\n  size_t size;\n  time_t certclock;\n  int rc;\n  CURLcode result = CURLE_OK;\n#ifndef CURL_DISABLE_VERBOSE_STRINGS\n  const char *ptr;\n  unsigned int algo;\n  unsigned int bits;\n  gnutls_protocol_t version = gnutls_protocol_get_version(session);\n#endif\n  long * const certverifyresult = &ssl_config->certverifyresult;\n\n#ifndef CURL_DISABLE_VERBOSE_STRINGS\n  /* the name of the cipher suite used, e.g. ECDHE_RSA_AES_256_GCM_SHA384. */\n  ptr = gnutls_cipher_suite_get_name(gnutls_kx_get(session),\n                                     gnutls_cipher_get(session),\n                                     gnutls_mac_get(session));\n\n  infof(data, \"SSL connection using %s / %s\",\n        gnutls_protocol_get_name(version), ptr);\n#endif\n\n  /* This function will return the peer's raw certificate (chain) as sent by\n     the peer. These certificates are in raw format (DER encoded for\n     X.509). In case of a X.509 then a certificate list may be present. The\n     first certificate in the list is the peer's certificate, following the\n     issuer's certificate, then the issuer's issuer etc. */\n\n  chainp = gnutls_certificate_get_peers(session, &cert_list_size);\n  if(!chainp) {\n    if(config->verifypeer ||\n       config->verifyhost ||\n       config->issuercert) {\n#ifdef USE_GNUTLS_SRP\n      if(ssl_config->primary.username && !config->verifypeer &&\n         gnutls_cipher_get(session)) {\n        /* no peer cert, but auth is ok if we have SRP user and cipher and no\n           peer verify */\n      }\n      else {\n#endif\n        failf(data, \"failed to get server cert\");\n        *certverifyresult = GNUTLS_E_NO_CERTIFICATE_FOUND;\n        return CURLE_PEER_FAILED_VERIFICATION;\n#ifdef USE_GNUTLS_SRP\n      }\n#endif\n    }\n    infof(data, \" common name: WARNING couldn't obtain\");\n  }\n\n  if(data->set.ssl.certinfo && chainp) {\n    unsigned int i;\n\n    result = Curl_ssl_init_certinfo(data, cert_list_size);\n    if(result)\n      return result;\n\n    for(i = 0; i < cert_list_size; i++) {\n      const char *beg = (const char *) chainp[i].data;\n      const char *end = beg + chainp[i].size;\n\n      result = Curl_extract_certinfo(data, i, beg, end);\n      if(result)\n        return result;\n    }\n  }\n\n  if(config->verifypeer) {\n    /* This function will try to verify the peer's certificate and return its\n       status (trusted, invalid etc.). The value of status should be one or\n       more of the gnutls_certificate_status_t enumerated elements bitwise\n       or'd. To avoid denial of service attacks some default upper limits\n       regarding the certificate key size and chain size are set. To override\n       them use gnutls_certificate_set_verify_limits(). */\n\n    rc = gnutls_certificate_verify_peers2(session, &verify_status);\n    if(rc < 0) {\n      failf(data, \"server cert verify failed: %d\", rc);\n      *certverifyresult = rc;\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n\n    *certverifyresult = verify_status;\n\n    /* verify_status is a bitmask of gnutls_certificate_status bits */\n    if(verify_status & GNUTLS_CERT_INVALID) {\n      if(config->verifypeer) {\n        failf(data, \"server certificate verification failed. CAfile: %s \"\n              \"CRLfile: %s\", config->CAfile ? config->CAfile:\n              \"none\",\n              ssl_config->primary.CRLfile ?\n              ssl_config->primary.CRLfile : \"none\");\n        return CURLE_PEER_FAILED_VERIFICATION;\n      }\n      else\n        infof(data, \"  server certificate verification FAILED\");\n    }\n    else\n      infof(data, \"  server certificate verification OK\");\n  }\n  else\n    infof(data, \"  server certificate verification SKIPPED\");\n\n  if(config->verifystatus) {\n    if(gnutls_ocsp_status_request_is_checked(session, 0) == 0) {\n      gnutls_datum_t status_request;\n      gnutls_ocsp_resp_t ocsp_resp;\n\n      gnutls_ocsp_cert_status_t status;\n      gnutls_x509_crl_reason_t reason;\n\n      rc = gnutls_ocsp_status_request_get(session, &status_request);\n\n      infof(data, \" server certificate status verification FAILED\");\n\n      if(rc == GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE) {\n        failf(data, \"No OCSP response received\");\n        return CURLE_SSL_INVALIDCERTSTATUS;\n      }\n\n      if(rc < 0) {\n        failf(data, \"Invalid OCSP response received\");\n        return CURLE_SSL_INVALIDCERTSTATUS;\n      }\n\n      gnutls_ocsp_resp_init(&ocsp_resp);\n\n      rc = gnutls_ocsp_resp_import(ocsp_resp, &status_request);\n      if(rc < 0) {\n        failf(data, \"Invalid OCSP response received\");\n        return CURLE_SSL_INVALIDCERTSTATUS;\n      }\n\n      (void)gnutls_ocsp_resp_get_single(ocsp_resp, 0, NULL, NULL, NULL, NULL,\n                                        &status, NULL, NULL, NULL, &reason);\n\n      switch(status) {\n      case GNUTLS_OCSP_CERT_GOOD:\n        break;\n\n      case GNUTLS_OCSP_CERT_REVOKED: {\n        const char *crl_reason;\n\n        switch(reason) {\n          default:\n          case GNUTLS_X509_CRLREASON_UNSPECIFIED:\n            crl_reason = \"unspecified reason\";\n            break;\n\n          case GNUTLS_X509_CRLREASON_KEYCOMPROMISE:\n            crl_reason = \"private key compromised\";\n            break;\n\n          case GNUTLS_X509_CRLREASON_CACOMPROMISE:\n            crl_reason = \"CA compromised\";\n            break;\n\n          case GNUTLS_X509_CRLREASON_AFFILIATIONCHANGED:\n            crl_reason = \"affiliation has changed\";\n            break;\n\n          case GNUTLS_X509_CRLREASON_SUPERSEDED:\n            crl_reason = \"certificate superseded\";\n            break;\n\n          case GNUTLS_X509_CRLREASON_CESSATIONOFOPERATION:\n            crl_reason = \"operation has ceased\";\n            break;\n\n          case GNUTLS_X509_CRLREASON_CERTIFICATEHOLD:\n            crl_reason = \"certificate is on hold\";\n            break;\n\n          case GNUTLS_X509_CRLREASON_REMOVEFROMCRL:\n            crl_reason = \"will be removed from delta CRL\";\n            break;\n\n          case GNUTLS_X509_CRLREASON_PRIVILEGEWITHDRAWN:\n            crl_reason = \"privilege withdrawn\";\n            break;\n\n          case GNUTLS_X509_CRLREASON_AACOMPROMISE:\n            crl_reason = \"AA compromised\";\n            break;\n        }\n\n        failf(data, \"Server certificate was revoked: %s\", crl_reason);\n        break;\n      }\n\n      default:\n      case GNUTLS_OCSP_CERT_UNKNOWN:\n        failf(data, \"Server certificate status is unknown\");\n        break;\n      }\n\n      gnutls_ocsp_resp_deinit(ocsp_resp);\n\n      return CURLE_SSL_INVALIDCERTSTATUS;\n    }\n    else\n      infof(data, \"  server certificate status verification OK\");\n  }\n  else\n    infof(data, \"  server certificate status verification SKIPPED\");\n\n  /* initialize an X.509 certificate structure. */\n  gnutls_x509_crt_init(&x509_cert);\n\n  if(chainp)\n    /* convert the given DER or PEM encoded Certificate to the native\n       gnutls_x509_crt_t format */\n    gnutls_x509_crt_import(x509_cert, chainp, GNUTLS_X509_FMT_DER);\n\n  if(config->issuercert) {\n    gnutls_x509_crt_init(&x509_issuer);\n    issuerp = load_file(config->issuercert);\n    gnutls_x509_crt_import(x509_issuer, &issuerp, GNUTLS_X509_FMT_PEM);\n    rc = gnutls_x509_crt_check_issuer(x509_cert, x509_issuer);\n    gnutls_x509_crt_deinit(x509_issuer);\n    unload_file(issuerp);\n    if(rc <= 0) {\n      failf(data, \"server certificate issuer check failed (IssuerCert: %s)\",\n            config->issuercert?config->issuercert:\"none\");\n      gnutls_x509_crt_deinit(x509_cert);\n      return CURLE_SSL_ISSUER_ERROR;\n    }\n    infof(data, \"  server certificate issuer check OK (Issuer Cert: %s)\",\n          config->issuercert?config->issuercert:\"none\");\n  }\n\n  size = sizeof(certname);\n  rc = gnutls_x509_crt_get_dn_by_oid(x509_cert, GNUTLS_OID_X520_COMMON_NAME,\n                                     0, /* the first and only one */\n                                     FALSE,\n                                     certname,\n                                     &size);\n  if(rc) {\n    infof(data, \"error fetching CN from cert:%s\",\n          gnutls_strerror(rc));\n  }\n\n  /* This function will check if the given certificate's subject matches the\n     given hostname. This is a basic implementation of the matching described\n     in RFC2818 (HTTPS), which takes into account wildcards, and the subject\n     alternative name PKIX extension. Returns non zero on success, and zero on\n     failure. */\n  rc = gnutls_x509_crt_check_hostname(x509_cert, peer->hostname);\n#if GNUTLS_VERSION_NUMBER < 0x030306\n  /* Before 3.3.6, gnutls_x509_crt_check_hostname() didn't check IP\n     addresses. */\n  if(!rc) {\n#ifdef ENABLE_IPV6\n    #define use_addr in6_addr\n#else\n    #define use_addr in_addr\n#endif\n    unsigned char addrbuf[sizeof(struct use_addr)];\n    size_t addrlen = 0;\n\n    if(Curl_inet_pton(AF_INET, peer->hostname, addrbuf) > 0)\n      addrlen = 4;\n#ifdef ENABLE_IPV6\n    else if(Curl_inet_pton(AF_INET6, peer->hostname, addrbuf) > 0)\n      addrlen = 16;\n#endif\n\n    if(addrlen) {\n      unsigned char certaddr[sizeof(struct use_addr)];\n      int i;\n\n      for(i = 0; ; i++) {\n        size_t certaddrlen = sizeof(certaddr);\n        int ret = gnutls_x509_crt_get_subject_alt_name(x509_cert, i, certaddr,\n                                                       &certaddrlen, NULL);\n        /* If this happens, it wasn't an IP address. */\n        if(ret == GNUTLS_E_SHORT_MEMORY_BUFFER)\n          continue;\n        if(ret < 0)\n          break;\n        if(ret != GNUTLS_SAN_IPADDRESS)\n          continue;\n        if(certaddrlen == addrlen && !memcmp(addrbuf, certaddr, addrlen)) {\n          rc = 1;\n          break;\n        }\n      }\n    }\n  }\n#endif\n  if(!rc) {\n    if(config->verifyhost) {\n      failf(data, \"SSL: certificate subject name (%s) does not match \"\n            \"target host name '%s'\", certname, peer->dispname);\n      gnutls_x509_crt_deinit(x509_cert);\n      return CURLE_PEER_FAILED_VERIFICATION;\n    }\n    else\n      infof(data, \"  common name: %s (does not match '%s')\",\n            certname, peer->dispname);\n  }\n  else\n    infof(data, \"  common name: %s (matched)\", certname);\n\n  /* Check for time-based validity */\n  certclock = gnutls_x509_crt_get_expiration_time(x509_cert);\n\n  if(certclock == (time_t)-1) {\n    if(config->verifypeer) {\n      failf(data, \"server cert expiration date verify failed\");\n      *certverifyresult = GNUTLS_CERT_EXPIRED;\n      gnutls_x509_crt_deinit(x509_cert);\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n    else\n      infof(data, \"  server certificate expiration date verify FAILED\");\n  }\n  else {\n    if(certclock < time(NULL)) {\n      if(config->verifypeer) {\n        failf(data, \"server certificate expiration date has passed.\");\n        *certverifyresult = GNUTLS_CERT_EXPIRED;\n        gnutls_x509_crt_deinit(x509_cert);\n        return CURLE_PEER_FAILED_VERIFICATION;\n      }\n      else\n        infof(data, \"  server certificate expiration date FAILED\");\n    }\n    else\n      infof(data, \"  server certificate expiration date OK\");\n  }\n\n  certclock = gnutls_x509_crt_get_activation_time(x509_cert);\n\n  if(certclock == (time_t)-1) {\n    if(config->verifypeer) {\n      failf(data, \"server cert activation date verify failed\");\n      *certverifyresult = GNUTLS_CERT_NOT_ACTIVATED;\n      gnutls_x509_crt_deinit(x509_cert);\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n    else\n      infof(data, \"  server certificate activation date verify FAILED\");\n  }\n  else {\n    if(certclock > time(NULL)) {\n      if(config->verifypeer) {\n        failf(data, \"server certificate not activated yet.\");\n        *certverifyresult = GNUTLS_CERT_NOT_ACTIVATED;\n        gnutls_x509_crt_deinit(x509_cert);\n        return CURLE_PEER_FAILED_VERIFICATION;\n      }\n      else\n        infof(data, \"  server certificate activation date FAILED\");\n    }\n    else\n      infof(data, \"  server certificate activation date OK\");\n  }\n\n  if(pinned_key) {\n    result = pkp_pin_peer_pubkey(data, x509_cert, pinned_key);\n    if(result != CURLE_OK) {\n      failf(data, \"SSL: public key does not match pinned public key\");\n      gnutls_x509_crt_deinit(x509_cert);\n      return result;\n    }\n  }\n\n  /* Show:\n\n  - subject\n  - start date\n  - expire date\n  - common name\n  - issuer\n\n  */\n\n#ifndef CURL_DISABLE_VERBOSE_STRINGS\n  /* public key algorithm's parameters */\n  algo = gnutls_x509_crt_get_pk_algorithm(x509_cert, &bits);\n  infof(data, \"  certificate public key: %s\",\n        gnutls_pk_algorithm_get_name(algo));\n\n  /* version of the X.509 certificate. */\n  infof(data, \"  certificate version: #%d\",\n        gnutls_x509_crt_get_version(x509_cert));\n\n\n  rc = gnutls_x509_crt_get_dn2(x509_cert, &certfields);\n  if(rc)\n    infof(data, \"Failed to get certificate name\");\n  else {\n    infof(data, \"  subject: %s\", certfields.data);\n\n    certclock = gnutls_x509_crt_get_activation_time(x509_cert);\n    showtime(data, \"start date\", certclock);\n\n    certclock = gnutls_x509_crt_get_expiration_time(x509_cert);\n    showtime(data, \"expire date\", certclock);\n\n    gnutls_free(certfields.data);\n  }\n\n  rc = gnutls_x509_crt_get_issuer_dn2(x509_cert, &certfields);\n  if(rc)\n    infof(data, \"Failed to get certificate issuer\");\n  else {\n    infof(data, \"  issuer: %s\", certfields.data);\n\n    gnutls_free(certfields.data);\n  }\n#endif\n\n  gnutls_x509_crt_deinit(x509_cert);\n\n  return result;\n}\n\nstatic CURLcode gtls_verifyserver(struct Curl_cfilter *cf,\n                                  struct Curl_easy *data,\n                                  gnutls_session_t session)\n{\n  struct ssl_connect_data *connssl = cf->ctx;\n  struct ssl_primary_config *conn_config = Curl_ssl_cf_get_primary_config(cf);\n  struct ssl_config_data *ssl_config = Curl_ssl_cf_get_config(cf, data);\n  const char *pinned_key = Curl_ssl_cf_is_proxy(cf)?\n    data->set.str[STRING_SSL_PINNEDPUBLICKEY_PROXY]:\n    data->set.str[STRING_SSL_PINNEDPUBLICKEY];\n  CURLcode result;\n\n  result = Curl_gtls_verifyserver(data, session, conn_config, ssl_config,\n                                  &connssl->peer, pinned_key);\n  if(result)\n    goto out;\n\n  if(connssl->alpn) {\n    gnutls_datum_t proto;\n    int rc;\n\n    rc = gnutls_alpn_get_selected_protocol(session, &proto);\n    if(rc == 0)\n      Curl_alpn_set_negotiated(cf, data, proto.data, proto.size);\n    else\n      Curl_alpn_set_negotiated(cf, data, NULL, 0);\n  }\n\n  if(ssl_config->primary.sessionid) {\n    /* we always unconditionally get the session id here, as even if we\n       already got it from the cache and asked to use it in the connection, it\n       might've been rejected and then a new one is in use now and we need to\n       detect that. */\n    void *connect_sessionid;\n    size_t connect_idsize = 0;\n\n    /* get the session ID data size */\n    gnutls_session_get_data(session, NULL, &connect_idsize);\n    connect_sessionid = malloc(connect_idsize); /* get a buffer for it */\n\n    if(connect_sessionid) {\n      bool incache;\n      bool added = FALSE;\n      void *ssl_sessionid;\n\n      /* extract session ID to the allocated buffer */\n      gnutls_session_get_data(session, connect_sessionid, &connect_idsize);\n\n      Curl_ssl_sessionid_lock(data);\n      incache = !(Curl_ssl_getsessionid(cf, data, &ssl_sessionid, NULL));\n      if(incache) {\n        /* there was one before in the cache, so instead of risking that the\n           previous one was rejected, we just kill that and store the new */\n        Curl_ssl_delsessionid(data, ssl_sessionid);\n      }\n\n      /* store this session id */\n      result = Curl_ssl_addsessionid(cf, data, connect_sessionid,\n                                     connect_idsize, &added);\n      Curl_ssl_sessionid_unlock(data);\n      if(!added)\n        free(connect_sessionid);\n      if(result) {\n        result = CURLE_OUT_OF_MEMORY;\n      }\n    }\n    else\n      result = CURLE_OUT_OF_MEMORY;\n  }\n\nout:\n  return result;\n}\n\n/*\n * This function is called after the TCP connect has completed. Setup the TLS\n * layer and do all necessary magic.\n */\n/* We use connssl->connecting_state to keep track of the connection status;\n   there are three states: 'ssl_connect_1' (not started yet or complete),\n   'ssl_connect_2_reading' (waiting for data from server), and\n   'ssl_connect_2_writing' (waiting to be able to write).\n */\nstatic CURLcode\ngtls_connect_common(struct Curl_cfilter *cf,\n                    struct Curl_easy *data,\n                    bool nonblocking,\n                    bool *done)\n{\n  struct ssl_connect_data *connssl = cf->ctx;\n  int rc;\n  CURLcode result = CURLE_OK;\n\n  /* Initiate the connection, if not already done */\n  if(ssl_connect_1 == connssl->connecting_state) {\n    rc = gtls_connect_step1(cf, data);\n    if(rc) {\n      result = rc;\n      goto out;\n    }\n  }\n\n  rc = handshake(cf, data, TRUE, nonblocking);\n  if(rc) {\n    /* handshake() sets its own error message with failf() */\n    result = rc;\n    goto out;\n  }\n\n  /* Finish connecting once the handshake is done */\n  if(ssl_connect_1 == connssl->connecting_state) {\n    struct gtls_ssl_backend_data *backend =\n      (struct gtls_ssl_backend_data *)connssl->backend;\n    gnutls_session_t session;\n    DEBUGASSERT(backend);\n    session = backend->gtls.session;\n    rc = gtls_verifyserver(cf, data, session);\n    if(rc) {\n      result = rc;\n      goto out;\n    }\n    connssl->state = ssl_connection_complete;\n  }\n\nout:\n  *done = ssl_connect_1 == connssl->connecting_state;\n\n  return result;\n}\n\nstatic CURLcode gtls_connect_nonblocking(struct Curl_cfilter *cf,\n                                         struct Curl_easy *data,\n                                         bool *done)\n{\n  return gtls_connect_common(cf, data, TRUE, done);\n}\n\nstatic CURLcode gtls_connect(struct Curl_cfilter *cf,\n                             struct Curl_easy *data)\n{\n  CURLcode result;\n  bool done = FALSE;\n\n  result = gtls_connect_common(cf, data, FALSE, &done);\n  if(result)\n    return result;\n\n  DEBUGASSERT(done);\n\n  return CURLE_OK;\n}\n\nstatic bool gtls_data_pending(struct Curl_cfilter *cf,\n                              const struct Curl_easy *data)\n{\n  struct ssl_connect_data *ctx = cf->ctx;\n  struct gtls_ssl_backend_data *backend;\n\n  (void)data;\n  DEBUGASSERT(ctx && ctx->backend);\n  backend = (struct gtls_ssl_backend_data *)ctx->backend;\n  if(backend->gtls.session &&\n     0 != gnutls_record_check_pending(backend->gtls.session))\n    return TRUE;\n  return FALSE;\n}\n\nstatic ssize_t gtls_send(struct Curl_cfilter *cf,\n                         struct Curl_easy *data,\n                         const void *mem,\n                         size_t len,\n                         CURLcode *curlcode)\n{\n  struct ssl_connect_data *connssl = cf->ctx;\n  struct gtls_ssl_backend_data *backend =\n    (struct gtls_ssl_backend_data *)connssl->backend;\n  ssize_t rc;\n\n  (void)data;\n  DEBUGASSERT(backend);\n  rc = gnutls_record_send(backend->gtls.session, mem, len);\n\n  if(rc < 0) {\n    *curlcode = (rc == GNUTLS_E_AGAIN)\n      ? CURLE_AGAIN\n      : CURLE_SEND_ERROR;\n\n    rc = -1;\n  }\n\n  return rc;\n}\n\nstatic void gtls_close(struct Curl_cfilter *cf,\n                       struct Curl_easy *data)\n{\n  struct ssl_connect_data *connssl = cf->ctx;\n  struct gtls_ssl_backend_data *backend =\n    (struct gtls_ssl_backend_data *)connssl->backend;\n\n  (void) data;\n  DEBUGASSERT(backend);\n\n  if(backend->gtls.session) {\n    char buf[32];\n    /* Maybe the server has already sent a close notify alert.\n       Read it to avoid an RST on the TCP connection. */\n    (void)gnutls_record_recv(backend->gtls.session, buf, sizeof(buf));\n    gnutls_bye(backend->gtls.session, GNUTLS_SHUT_WR);\n    gnutls_deinit(backend->gtls.session);\n    backend->gtls.session = NULL;\n  }\n  if(backend->gtls.cred) {\n    gnutls_certificate_free_credentials(backend->gtls.cred);\n    backend->gtls.cred = NULL;\n  }\n#ifdef USE_GNUTLS_SRP\n  if(backend->gtls.srp_client_cred) {\n    gnutls_srp_free_client_credentials(backend->gtls.srp_client_cred);\n    backend->gtls.srp_client_cred = NULL;\n  }\n#endif\n}\n\n/*\n * This function is called to shut down the SSL layer but keep the\n * socket open (CCC - Clear Command Channel)\n */\nstatic int gtls_shutdown(struct Curl_cfilter *cf,\n                         struct Curl_easy *data)\n{\n  struct ssl_connect_data *connssl = cf->ctx;\n  struct gtls_ssl_backend_data *backend =\n    (struct gtls_ssl_backend_data *)connssl->backend;\n  int retval = 0;\n\n  DEBUGASSERT(backend);\n\n#ifndef CURL_DISABLE_FTP\n  /* This has only been tested on the proftpd server, and the mod_tls code\n     sends a close notify alert without waiting for a close notify alert in\n     response. Thus we wait for a close notify alert from the server, but\n     we do not send one. Let's hope other servers do the same... */\n\n  if(data->set.ftp_ccc == CURLFTPSSL_CCC_ACTIVE)\n    gnutls_bye(backend->gtls.session, GNUTLS_SHUT_WR);\n#endif\n\n  if(backend->gtls.session) {\n    ssize_t result;\n    bool done = FALSE;\n    char buf[120];\n\n    while(!done && !connssl->peer_closed) {\n      int what = SOCKET_READABLE(Curl_conn_cf_get_socket(cf, data),\n                                 SSL_SHUTDOWN_TIMEOUT);\n      if(what > 0) {\n        /* Something to read, let's do it and hope that it is the close\n           notify alert from the server */\n        result = gnutls_record_recv(backend->gtls.session,\n                                    buf, sizeof(buf));\n        switch(result) {\n        case 0:\n          /* This is the expected response. There was no data but only\n             the close notify alert */\n          done = TRUE;\n          break;\n        case GNUTLS_E_AGAIN:\n        case GNUTLS_E_INTERRUPTED:\n          infof(data, \"GNUTLS_E_AGAIN || GNUTLS_E_INTERRUPTED\");\n          break;\n        default:\n          retval = -1;\n          done = TRUE;\n          break;\n        }\n      }\n      else if(0 == what) {\n        /* timeout */\n        failf(data, \"SSL shutdown timeout\");\n        done = TRUE;\n      }\n      else {\n        /* anything that gets here is fatally bad */\n        failf(data, \"select/poll on SSL socket, errno: %d\", SOCKERRNO);\n        retval = -1;\n        done = TRUE;\n      }\n    }\n    gnutls_deinit(backend->gtls.session);\n  }\n  gnutls_certificate_free_credentials(backend->gtls.cred);\n\n#ifdef USE_GNUTLS_SRP\n  {\n    struct ssl_config_data *ssl_config = Curl_ssl_cf_get_config(cf, data);\n    if(ssl_config->primary.username)\n      gnutls_srp_free_client_credentials(backend->gtls.srp_client_cred);\n  }\n#endif\n\n  backend->gtls.cred = NULL;\n  backend->gtls.session = NULL;\n\n  return retval;\n}\n\nstatic ssize_t gtls_recv(struct Curl_cfilter *cf,\n                         struct Curl_easy *data,\n                         char *buf,\n                         size_t buffersize,\n                         CURLcode *curlcode)\n{\n  struct ssl_connect_data *connssl = cf->ctx;\n  struct gtls_ssl_backend_data *backend =\n    (struct gtls_ssl_backend_data *)connssl->backend;\n  ssize_t ret;\n\n  (void)data;\n  DEBUGASSERT(backend);\n\n  ret = gnutls_record_recv(backend->gtls.session, buf, buffersize);\n  if((ret == GNUTLS_E_AGAIN) || (ret == GNUTLS_E_INTERRUPTED)) {\n    *curlcode = CURLE_AGAIN;\n    ret = -1;\n    goto out;\n  }\n\n  if(ret == GNUTLS_E_REHANDSHAKE) {\n    /* BLOCKING call, this is bad but a work-around for now. Fixing this \"the\n       proper way\" takes a whole lot of work. */\n    CURLcode result = handshake(cf, data, FALSE, FALSE);\n    if(result)\n      /* handshake() writes error message on its own */\n      *curlcode = result;\n    else\n      *curlcode = CURLE_AGAIN; /* then return as if this was a wouldblock */\n    ret = -1;\n    goto out;\n  }\n\n  if(ret < 0) {\n    failf(data, \"GnuTLS recv error (%d): %s\",\n\n          (int)ret, gnutls_strerror((int)ret));\n    *curlcode = CURLE_RECV_ERROR;\n    ret = -1;\n    goto out;\n  }\n\nout:\n  return ret;\n}\n\nstatic void gtls_session_free(void *ptr)\n{\n  free(ptr);\n}\n\nstatic size_t gtls_version(char *buffer, size_t size)\n{\n  return msnprintf(buffer, size, \"GnuTLS/%s\", gnutls_check_version(NULL));\n}\n\n/* data might be NULL! */\nstatic CURLcode gtls_random(struct Curl_easy *data,\n                            unsigned char *entropy, size_t length)\n{\n  int rc;\n  (void)data;\n  rc = gnutls_rnd(GNUTLS_RND_RANDOM, entropy, length);\n  return rc?CURLE_FAILED_INIT:CURLE_OK;\n}\n\nstatic CURLcode gtls_sha256sum(const unsigned char *tmp, /* input */\n                               size_t tmplen,\n                               unsigned char *sha256sum, /* output */\n                               size_t sha256len)\n{\n  struct sha256_ctx SHA256pw;\n  sha256_init(&SHA256pw);\n  sha256_update(&SHA256pw, (unsigned int)tmplen, tmp);\n  sha256_digest(&SHA256pw, (unsigned int)sha256len, sha256sum);\n  return CURLE_OK;\n}\n\nstatic bool gtls_cert_status_request(void)\n{\n  return TRUE;\n}\n\nstatic void *gtls_get_internals(struct ssl_connect_data *connssl,\n                                CURLINFO info UNUSED_PARAM)\n{\n  struct gtls_ssl_backend_data *backend =\n    (struct gtls_ssl_backend_data *)connssl->backend;\n  (void)info;\n  DEBUGASSERT(backend);\n  return backend->gtls.session;\n}\n\nconst struct Curl_ssl Curl_ssl_gnutls = {\n  { CURLSSLBACKEND_GNUTLS, \"gnutls\" }, /* info */\n\n  SSLSUPP_CA_PATH  |\n  SSLSUPP_CERTINFO |\n  SSLSUPP_PINNEDPUBKEY |\n  SSLSUPP_HTTPS_PROXY,\n\n  sizeof(struct gtls_ssl_backend_data),\n\n  gtls_init,                     /* init */\n  gtls_cleanup,                  /* cleanup */\n  gtls_version,                  /* version */\n  Curl_none_check_cxn,           /* check_cxn */\n  gtls_shutdown,                 /* shutdown */\n  gtls_data_pending,             /* data_pending */\n  gtls_random,                   /* random */\n  gtls_cert_status_request,      /* cert_status_request */\n  gtls_connect,                  /* connect */\n  gtls_connect_nonblocking,      /* connect_nonblocking */\n  Curl_ssl_adjust_pollset,       /* adjust_pollset */\n  gtls_get_internals,            /* get_internals */\n  gtls_close,                    /* close_one */\n  Curl_none_close_all,           /* close_all */\n  gtls_session_free,             /* session_free */\n  Curl_none_set_engine,          /* set_engine */\n  Curl_none_set_engine_default,  /* set_engine_default */\n  Curl_none_engines_list,        /* engines_list */\n  Curl_none_false_start,         /* false_start */\n  gtls_sha256sum,                /* sha256sum */\n  NULL,                          /* associate_connection */\n  NULL,                          /* disassociate_connection */\n  NULL,                          /* free_multi_ssl_backend_data */\n  gtls_recv,                     /* recv decrypted data */\n  gtls_send,                     /* send data to encrypt */\n};\n\n#endif /* USE_GNUTLS */\n` was unexpected","path":"/home/qqq/curl-8.7.0/lib/vtls/gtls.c"},{"code":3,"level":"warn","type":["PartialParsing",[{"path":"/home/qqq/curl-8.7.0/src/tool_getparam.c","start":{"line":621,"col":1,"offset":0},"end":{"line":621,"col":7,"offset":6}},{"path":"/home/qqq/curl-8.7.0/src/tool_getparam.c","start":{"line":623,"col":1,"offset":0},"end":{"line":623,"col":7,"offset":6}},{"path":"/home/qqq/curl-8.7.0/src/tool_getparam.c","start":{"line":634,"col":1,"offset":0},"end":{"line":634,"col":7,"offset":6}},{"path":"/home/qqq/curl-8.7.0/src/tool_getparam.c","start":{"line":2527,"col":45,"offset":0},"end":{"line":2527,"col":48,"offset":3}}]],"message":"Syntax error at line /home/qqq/curl-8.7.0/src/tool_getparam.c:621:\n `#ifdef` was unexpected","path":"/home/qqq/curl-8.7.0/src/tool_getparam.c","spans":[{"file":"/home/qqq/curl-8.7.0/src/tool_getparam.c","start":{"line":621,"col":1,"offset":0},"end":{"line":621,"col":7,"offset":6}},{"file":"/home/qqq/curl-8.7.0/src/tool_getparam.c","start":{"line":623,"col":1,"offset":0},"end":{"line":623,"col":7,"offset":6}},{"file":"/home/qqq/curl-8.7.0/src/tool_getparam.c","start":{"line":634,"col":1,"offset":0},"end":{"line":634,"col":7,"offset":6}},{"file":"/home/qqq/curl-8.7.0/src/tool_getparam.c","start":{"line":2527,"col":45,"offset":0},"end":{"line":2527,"col":48,"offset":3}}]},{"code":3,"level":"warn","type":"Syntax error","message":"Syntax error at line /home/qqq/curl-8.7.0/src/tool_operate.c:1:\n `/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n * SPDX-License-Identifier: curl\n *\n ***************************************************************************/\n#include \"tool_setup.h\"\n\n#ifdef HAVE_FCNTL_H\n#  include <fcntl.h>\n#endif\n\n#ifdef HAVE_LOCALE_H\n#  include <locale.h>\n#endif\n\n#ifdef HAVE_SYS_SELECT_H\n#  include <sys/select.h>\n#elif defined(HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif\n\n#ifdef __VMS\n#  include <fabdef.h>\n#endif\n\n#ifdef __AMIGA__\n#  include <proto/dos.h>\n#endif\n\n#define ENABLE_CURLX_PRINTF\n/* use our own printf() functions */\n#include \"curlx.h\"\n\n#include \"tool_binmode.h\"\n#include \"tool_cfgable.h\"\n#include \"tool_cb_dbg.h\"\n#include \"tool_cb_hdr.h\"\n#include \"tool_cb_prg.h\"\n#include \"tool_cb_rea.h\"\n#include \"tool_cb_see.h\"\n#include \"tool_cb_wrt.h\"\n#include \"tool_dirhie.h\"\n#include \"tool_doswin.h\"\n#include \"tool_easysrc.h\"\n#include \"tool_filetime.h\"\n#include \"tool_getparam.h\"\n#include \"tool_helpers.h\"\n#include \"tool_findfile.h\"\n#include \"tool_libinfo.h\"\n#include \"tool_main.h\"\n#include \"tool_msgs.h\"\n#include \"tool_operate.h\"\n#include \"tool_operhlp.h\"\n#include \"tool_paramhlp.h\"\n#include \"tool_parsecfg.h\"\n#include \"tool_setopt.h\"\n#include \"tool_sleep.h\"\n#include \"tool_urlglob.h\"\n#include \"tool_util.h\"\n#include \"tool_writeout.h\"\n#include \"tool_xattr.h\"\n#include \"tool_vms.h\"\n#include \"tool_help.h\"\n#include \"tool_hugehelp.h\"\n#include \"tool_progress.h\"\n#include \"tool_ipfs.h\"\n#include \"dynbuf.h\"\n\n#include \"memdebug.h\" /* keep this as LAST include */\n\n#ifdef CURLDEBUG\n/* libcurl's debug builds provide an extra function */\nCURLcode curl_easy_perform_ev(CURL *easy);\n#endif\n\n#ifndef O_BINARY\n/* since O_BINARY as used in bitmasks, setting it to zero makes it usable in\n   source code but yet it doesn't ruin anything */\n#  define O_BINARY 0\n#endif\n\n#define CURL_CA_CERT_ERRORMSG                                               \\\n  \"More details here: https://curl.se/docs/sslcerts.html\\n\\n\"          \\\n  \"curl failed to verify the legitimacy of the server and therefore \"       \\\n  \"could not\\nestablish a secure connection to it. To learn more about \"    \\\n  \"this situation and\\nhow to fix it, please visit the web page mentioned \" \\\n  \"above.\\n\"\n\nstatic CURLcode single_transfer(struct GlobalConfig *global,\n                                struct OperationConfig *config,\n                                CURLSH *share,\n                                bool capath_from_env,\n                                bool *added);\nstatic CURLcode create_transfer(struct GlobalConfig *global,\n                                CURLSH *share,\n                                bool *added);\n\nstatic bool is_fatal_error(CURLcode code)\n{\n  switch(code) {\n  case CURLE_FAILED_INIT:\n  case CURLE_OUT_OF_MEMORY:\n  case CURLE_UNKNOWN_OPTION:\n  case CURLE_FUNCTION_NOT_FOUND:\n  case CURLE_BAD_FUNCTION_ARGUMENT:\n    /* critical error */\n    return TRUE;\n  default:\n    break;\n  }\n\n  /* no error or not critical */\n  return FALSE;\n}\n\n/*\n * Check if a given string is a PKCS#11 URI\n */\nstatic bool is_pkcs11_uri(const char *string)\n{\n  if(curl_strnequal(string, \"pkcs11:\", 7)) {\n    return TRUE;\n  }\n  else {\n    return FALSE;\n  }\n}\n\n#ifdef __VMS\n/*\n * get_vms_file_size does what it takes to get the real size of the file\n *\n * For fixed files, find out the size of the EOF block and adjust.\n *\n * For all others, have to read the entire file in, discarding the contents.\n * Most posted text files will be small, and binary files like zlib archives\n * and CD/DVD images should be either a STREAM_LF format or a fixed format.\n *\n */\nstatic curl_off_t vms_realfilesize(const char *name,\n                                   const struct_stat *stat_buf)\n{\n  char buffer[8192];\n  curl_off_t count;\n  int ret_stat;\n  FILE * file;\n\n  /* !checksrc! disable FOPENMODE 1 */\n  file = fopen(name, \"r\"); /* VMS */\n  if(!file) {\n    return 0;\n  }\n  count = 0;\n  ret_stat = 1;\n  while(ret_stat > 0) {\n    ret_stat = fread(buffer, 1, sizeof(buffer), file);\n    if(ret_stat)\n      count += ret_stat;\n  }\n  fclose(file);\n\n  return count;\n}\n\n/*\n *\n *  VmsSpecialSize checks to see if the stat st_size can be trusted and\n *  if not to call a routine to get the correct size.\n *\n */\nstatic curl_off_t VmsSpecialSize(const char *name,\n                                 const struct_stat *stat_buf)\n{\n  switch(stat_buf->st_fab_rfm) {\n  case FAB$C_VAR:\n  case FAB$C_VFC:\n    return vms_realfilesize(name, stat_buf);\n    break;\n  default:\n    return stat_buf->st_size;\n  }\n}\n#endif /* __VMS */\n\n#define BUFFER_SIZE (100*1024)\n\nstruct per_transfer *transfers; /* first node */\nstatic struct per_transfer *transfersl; /* last node */\nstatic curl_off_t all_pers;\n\n/* add_per_transfer creates a new 'per_transfer' node in the linked\n   list of transfers */\nstatic CURLcode add_per_transfer(struct per_transfer **per)\n{\n  struct per_transfer *p;\n  p = calloc(1, sizeof(struct per_transfer));\n  if(!p)\n    return CURLE_OUT_OF_MEMORY;\n  if(!transfers)\n    /* first entry */\n    transfersl = transfers = p;\n  else {\n    /* make the last node point to the new node */\n    transfersl->next = p;\n    /* make the new node point back to the formerly last node */\n    p->prev = transfersl;\n    /* move the last node pointer to the new entry */\n    transfersl = p;\n  }\n  *per = p;\n  all_xfers++; /* count total number of transfers added */\n  all_pers++;\n\n  return CURLE_OK;\n}\n\n/* Remove the specified transfer from the list (and free it), return the next\n   in line */\nstatic struct per_transfer *del_per_transfer(struct per_transfer *per)\n{\n  struct per_transfer *n;\n  struct per_transfer *p;\n  DEBUGASSERT(transfers);\n  DEBUGASSERT(transfersl);\n  DEBUGASSERT(per);\n\n  n = per->next;\n  p = per->prev;\n\n  if(p)\n    p->next = n;\n  else\n    transfers = n;\n\n  if(n)\n    n->prev = p;\n  else\n    transfersl = p;\n\n  free(per);\n  all_pers--;\n\n  return n;\n}\n\nstatic CURLcode pre_transfer(struct GlobalConfig *global,\n                             struct per_transfer *per)\n{\n  curl_off_t uploadfilesize = -1;\n  struct_stat fileinfo;\n  CURLcode result = CURLE_OK;\n\n  if(per->uploadfile && !stdin_upload(per->uploadfile)) {\n    /* VMS Note:\n     *\n     * Reading binary from files can be a problem...  Only FIXED, VAR\n     * etc WITHOUT implied CC will work. Others need a \\n appended to\n     * a line\n     *\n     * - Stat gives a size but this is UNRELIABLE in VMS. E.g.\n     * a fixed file with implied CC needs to have a byte added for every\n     * record processed, this can be derived from Filesize & recordsize\n     * for VARiable record files the records need to be counted!  for\n     * every record add 1 for linefeed and subtract 2 for the record\n     * header for VARIABLE header files only the bare record data needs\n     * to be considered with one appended if implied CC\n     */\n#ifdef __VMS\n    /* Calculate the real upload size for VMS */\n    per->infd = -1;\n    if(stat(per->uploadfile, &fileinfo) == 0) {\n      fileinfo.st_size = VmsSpecialSize(uploadfile, &fileinfo);\n      switch(fileinfo.st_fab_rfm) {\n      case FAB$C_VAR:\n      case FAB$C_VFC:\n      case FAB$C_STMCR:\n        per->infd = open(per->uploadfile, O_RDONLY | O_BINARY);\n        break;\n      default:\n        per->infd = open(per->uploadfile, O_RDONLY | O_BINARY,\n                        \"rfm=stmlf\", \"ctx=stm\");\n      }\n    }\n    if(per->infd == -1)\n#else\n      per->infd = open(per->uploadfile, O_RDONLY | O_BINARY);\n    if((per->infd == -1) || fstat(per->infd, &fileinfo))\n#endif\n    {\n      helpf(tool_stderr, \"Can't open '%s'\", per->uploadfile);\n      if(per->infd != -1) {\n        close(per->infd);\n        per->infd = STDIN_FILENO;\n      }\n      return CURLE_READ_ERROR;\n    }\n    per->infdopen = TRUE;\n\n    /* we ignore file size for char/block devices, sockets, etc. */\n    if(S_ISREG(fileinfo.st_mode))\n      uploadfilesize = fileinfo.st_size;\n\n#ifdef DEBUGBUILD\n    /* allow dedicated test cases to override */\n    {\n      char *ev = getenv(\"CURL_UPLOAD_SIZE\");\n      if(ev) {\n        int sz = atoi(ev);\n        uploadfilesize = (curl_off_t)sz;\n      }\n    }\n#endif\n\n    if(uploadfilesize != -1) {\n      struct OperationConfig *config = per->config; /* for the macro below */\n#ifdef CURL_DISABLE_LIBCURL_OPTION\n      (void)config;\n      (void)global;\n#endif\n      my_setopt(per->curl, CURLOPT_INFILESIZE_LARGE, uploadfilesize);\n    }\n  }\n  per->uploadfilesize = uploadfilesize;\n  per->start = tvnow();\n  return result;\n}\n\n/* When doing serial transfers, we use a single fixed error area */\nstatic char global_errorbuffer[CURL_ERROR_SIZE];\n\nvoid single_transfer_cleanup(struct OperationConfig *config)\n{\n  if(config) {\n    struct State *state = &config->state;\n    if(state->urls) {\n      /* Free list of remaining URLs */\n      glob_cleanup(state->urls);\n      state->urls = NULL;\n    }\n    Curl_safefree(state->outfiles);\n    Curl_safefree(state->uploadfile);\n    if(state->inglob) {\n      /* Free list of globbed upload files */\n      glob_cleanup(state->inglob);\n      state->inglob = NULL;\n    }\n  }\n}\n\n/*\n * Call this after a transfer has completed.\n */\nstatic CURLcode post_per_transfer(struct GlobalConfig *global,\n                                  struct per_transfer *per,\n                                  CURLcode result,\n                                  bool *retryp,\n                                  long *delay) /* milliseconds! */\n{\n  struct OutStruct *outs = &per->outs;\n  CURL *curl = per->curl;\n  struct OperationConfig *config = per->config;\n  int rc;\n\n  if(!curl || !config)\n    return result;\n\n  *retryp = FALSE;\n  *delay = 0; /* for no retry, keep it zero */\n\n  if(per->infdopen)\n    close(per->infd);\n\n#ifdef __VMS\n  if(is_vms_shell()) {\n    /* VMS DCL shell behavior */\n    if(global->silent && !global->showerror)\n      vms_show = VMSSTS_HIDE;\n  }\n  else\n#endif\n    if(!config->synthetic_error && result &&\n       (!global->silent || global->showerror)) {\n      const char *msg = per->errorbuffer;\n      fprintf(tool_stderr, \"curl: (%d) %s\\n\", result,\n              (msg && msg[0]) ? msg : curl_easy_strerror(result));\n      if(result == CURLE_PEER_FAILED_VERIFICATION)\n        fputs(CURL_CA_CERT_ERRORMSG, tool_stderr);\n    }\n    else if(config->failwithbody) {\n      /* if HTTP response >= 400, return error */\n      long code = 0;\n      curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &code);\n      if(code >= 400) {\n        if(!global->silent || global->showerror)\n          fprintf(tool_stderr,\n                  \"curl: (%d) The requested URL returned error: %ld\\n\",\n                  CURLE_HTTP_RETURNED_ERROR, code);\n        result = CURLE_HTTP_RETURNED_ERROR;\n      }\n    }\n  /* Set file extended attributes */\n  if(!result && config->xattr && outs->fopened && outs->stream) {\n    rc = fwrite_xattr(curl, per->this_url, fileno(outs->stream));\n    if(rc)\n      warnf(config->global, \"Error setting extended attributes on '%s': %s\",\n            outs->filename, strerror(errno));\n  }\n\n  if(!result && !outs->stream && !outs->bytes) {\n    /* we have received no data despite the transfer was successful\n       ==> force creation of an empty output file (if an output file\n       was specified) */\n    long cond_unmet = 0L;\n    /* do not create (or even overwrite) the file in case we get no\n       data because of unmet condition */\n    curl_easy_getinfo(curl, CURLINFO_CONDITION_UNMET, &cond_unmet);\n    if(!cond_unmet && !tool_create_output_file(outs, config))\n      result = CURLE_WRITE_ERROR;\n  }\n\n  if(!outs->s_isreg && outs->stream) {\n    /* Dump standard stream buffered data */\n    rc = fflush(outs->stream);\n    if(!result && rc) {\n      /* something went wrong in the writing process */\n      result = CURLE_WRITE_ERROR;\n      errorf(global, \"Failed writing body\");\n    }\n  }\n\n#ifdef _WIN32\n  /* Discard incomplete UTF-8 sequence buffered from body */\n  if(outs->utf8seq[0])\n    memset(outs->utf8seq, 0, sizeof(outs->utf8seq));\n#endif\n\n  /* if retry-max-time is non-zero, make sure we haven't exceeded the\n     time */\n  if(per->retry_numretries &&\n     (!config->retry_maxtime ||\n      (tvdiff(tvnow(), per->retrystart) <\n       config->retry_maxtime*1000L)) ) {\n    enum {\n      RETRY_NO,\n      RETRY_ALL_ERRORS,\n      RETRY_TIMEOUT,\n      RETRY_CONNREFUSED,\n      RETRY_HTTP,\n      RETRY_FTP,\n      RETRY_LAST /* not used */\n    } retry = RETRY_NO;\n    long response = 0;\n    if((CURLE_OPERATION_TIMEDOUT == result) ||\n       (CURLE_COULDNT_RESOLVE_HOST == result) ||\n       (CURLE_COULDNT_RESOLVE_PROXY == result) ||\n       (CURLE_FTP_ACCEPT_TIMEOUT == result))\n      /* retry timeout always */\n      retry = RETRY_TIMEOUT;\n    else if(config->retry_connrefused &&\n            (CURLE_COULDNT_CONNECT == result)) {\n      long oserrno = 0;\n      curl_easy_getinfo(curl, CURLINFO_OS_ERRNO, &oserrno);\n      if(ECONNREFUSED == oserrno)\n        retry = RETRY_CONNREFUSED;\n    }\n    else if((CURLE_OK == result) ||\n            ((config->failonerror || config->failwithbody) &&\n             (CURLE_HTTP_RETURNED_ERROR == result))) {\n      /* If it returned OK. _or_ failonerror was enabled and it\n         returned due to such an error, check for HTTP transient\n         errors to retry on. */\n      const char *scheme;\n      curl_easy_getinfo(curl, CURLINFO_SCHEME, &scheme);\n      scheme = proto_token(scheme);\n      if(scheme == proto_http || scheme == proto_https) {\n        /* This was HTTP(S) */\n        curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &response);\n\n        switch(response) {\n        case 408: /* Request Timeout */\n        case 429: /* Too Many Requests (RFC6585) */\n        case 500: /* Internal Server Error */\n        case 502: /* Bad Gateway */\n        case 503: /* Service Unavailable */\n        case 504: /* Gateway Timeout */\n          retry = RETRY_HTTP;\n          /*\n           * At this point, we have already written data to the output\n           * file (or terminal). If we write to a file, we must rewind\n           * or close/re-open the file so that the next attempt starts\n           * over from the beginning.\n           *\n           * TODO: similar action for the upload case. We might need\n           * to start over reading from a previous point if we have\n           * uploaded something when this was returned.\n           */\n          break;\n        }\n      }\n    } /* if CURLE_OK */\n    else if(result) {\n      const char *scheme;\n\n      curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &response);\n      curl_easy_getinfo(curl, CURLINFO_SCHEME, &scheme);\n      scheme = proto_token(scheme);\n\n      if((scheme == proto_ftp || scheme == proto_ftps) && response / 100 == 4)\n        /*\n         * This is typically when the FTP server only allows a certain\n         * amount of users and we are not one of them.  All 4xx codes\n         * are transient.\n         */\n        retry = RETRY_FTP;\n    }\n\n    if(result && !retry && config->retry_all_errors)\n      retry = RETRY_ALL_ERRORS;\n\n    if(retry) {\n      long sleeptime = 0;\n      curl_off_t retry_after = 0;\n      static const char * const m[]={\n        NULL,\n        \"(retrying all errors)\",\n        \": timeout\",\n        \": connection refused\",\n        \": HTTP error\",\n        \": FTP error\"\n      };\n\n      sleeptime = per->retry_sleep;\n      if(RETRY_HTTP == retry) {\n        curl_easy_getinfo(curl, CURLINFO_RETRY_AFTER, &retry_after);\n        if(retry_after) {\n          /* store in a 'long', make sure it doesn't overflow */\n          if(retry_after > LONG_MAX/1000)\n            sleeptime = LONG_MAX;\n          else if((retry_after * 1000) > sleeptime)\n            sleeptime = (long)retry_after * 1000; /* milliseconds */\n\n          /* if adding retry_after seconds to the process would exceed the\n             maximum time allowed for retrying, then exit the retries right\n             away */\n          if(config->retry_maxtime) {\n            curl_off_t seconds = tvdiff(tvnow(), per->retrystart)/1000;\n\n            if((CURL_OFF_T_MAX - retry_after < seconds) ||\n               (seconds + retry_after > config->retry_maxtime)) {\n              warnf(config->global, \"The Retry-After: time would \"\n                    \"make this command line exceed the maximum allowed time \"\n                    \"for retries.\");\n              goto noretry;\n            }\n          }\n        }\n      }\n      warnf(config->global, \"Problem %s. \"\n            \"Will retry in %ld seconds. \"\n            \"%ld retries left.\",\n            m[retry], sleeptime/1000L, per->retry_numretries);\n\n      per->retry_numretries--;\n      if(!config->retry_delay) {\n        per->retry_sleep *= 2;\n        if(per->retry_sleep > RETRY_SLEEP_MAX)\n          per->retry_sleep = RETRY_SLEEP_MAX;\n      }\n      if(outs->bytes && outs->filename && outs->stream) {\n        /* We have written data to an output file, we truncate file\n         */\n        notef(config->global,\n              \"Throwing away %\"  CURL_FORMAT_CURL_OFF_T \" bytes\",\n              outs->bytes);\n        fflush(outs->stream);\n        /* truncate file at the position where we started appending */\n#ifdef HAVE_FTRUNCATE\n        if(ftruncate(fileno(outs->stream), outs->init)) {\n          /* when truncate fails, we can't just append as then we'll\n             create something strange, bail out */\n          errorf(config->global, \"Failed to truncate file\");\n          return CURLE_WRITE_ERROR;\n        }\n        /* now seek to the end of the file, the position where we\n           just truncated the file in a large file-safe way */\n        rc = fseek(outs->stream, 0, SEEK_END);\n#else\n        /* ftruncate is not available, so just reposition the file\n           to the location we would have truncated it. This won't\n           work properly with large files on 32-bit systems, but\n           most of those will have ftruncate. */\n        rc = fseek(outs->stream, (long)outs->init, SEEK_SET);\n#endif\n        if(rc) {\n          errorf(config->global, \"Failed seeking to end of file\");\n          return CURLE_WRITE_ERROR;\n        }\n        outs->bytes = 0; /* clear for next round */\n      }\n      *retryp = TRUE;\n      *delay = sleeptime;\n      return CURLE_OK;\n    }\n  } /* if retry_numretries */\nnoretry:\n\n  if((global->progressmode == CURL_PROGRESS_BAR) &&\n     per->progressbar.calls)\n    /* if the custom progress bar has been displayed, we output a\n       newline here */\n    fputs(\"\\n\", per->progressbar.out);\n\n  /* Close the outs file */\n  if(outs->fopened && outs->stream) {\n    rc = fclose(outs->stream);\n    if(!result && rc) {\n      /* something went wrong in the writing process */\n      result = CURLE_WRITE_ERROR;\n      errorf(config->global, \"curl: (%d) Failed writing body\", result);\n    }\n    if(result && config->rm_partial) {\n      struct_stat st;\n      if(!stat(outs->filename, &st) &&\n         S_ISREG(st.st_mode)) {\n        if(!unlink(outs->filename))\n          notef(global, \"Removed output file: %s\", outs->filename);\n        else\n          warnf(global, \"Failed removing: %s\", outs->filename);\n      }\n      else\n        warnf(global, \"Skipping removal; not a regular file: %s\",\n              outs->filename);\n    }\n  }\n\n  /* File time can only be set _after_ the file has been closed */\n  if(!result && config->remote_time && outs->s_isreg && outs->filename) {\n    /* Ask libcurl if we got a remote file time */\n    curl_off_t filetime = -1;\n    curl_easy_getinfo(curl, CURLINFO_FILETIME_T, &filetime);\n    setfiletime(filetime, outs->filename, global);\n  }\n\n  /* Write the --write-out data before cleanup but after result is final */\n  if(config->writeout)\n    ourWriteOut(config, per, result);\n\n  /* Close function-local opened file descriptors */\n  if(per->heads.fopened && per->heads.stream)\n    fclose(per->heads.stream);\n\n  if(per->heads.alloc_filename)\n    Curl_safefree(per->heads.filename);\n\n  if(per->etag_save.fopened && per->etag_save.stream)\n    fclose(per->etag_save.stream);\n\n  if(per->etag_save.alloc_filename)\n    Curl_safefree(per->etag_save.filename);\n\n  curl_easy_cleanup(per->curl);\n  if(outs->alloc_filename)\n    free(outs->filename);\n  free(per->this_url);\n  free(per->outfile);\n  free(per->uploadfile);\n  if(global->parallel)\n    free(per->errorbuffer);\n\n  return result;\n}\n\n/*\n * Return the protocol token for the scheme used in the given URL\n */\nstatic CURLcode url_proto(char **url,\n                          struct OperationConfig *config,\n                          char **scheme)\n{\n  CURLcode result = CURLE_OK;\n  CURLU *uh = curl_url();\n  const char *proto = NULL;\n  *scheme = NULL;\n\n  if(uh) {\n    if(*url) {\n      char *schemep = NULL;\n\n      if(!curl_url_set(uh, CURLUPART_URL, *url,\n                       CURLU_GUESS_SCHEME | CURLU_NON_SUPPORT_SCHEME) &&\n         !curl_url_get(uh, CURLUPART_SCHEME, &schemep,\n                       CURLU_DEFAULT_SCHEME)) {\n        if(curl_strequal(schemep, proto_ipfs) ||\n           curl_strequal(schemep, proto_ipns)) {\n          result = ipfs_url_rewrite(uh, schemep, url, config);\n          /* short-circuit proto_token, we know it's ipfs or ipns */\n          if(curl_strequal(schemep, proto_ipfs))\n            proto = proto_ipfs;\n          else if(curl_strequal(schemep, proto_ipns))\n            proto = proto_ipns;\n          if(result)\n            config->synthetic_error = TRUE;\n        }\n        else\n          proto = proto_token(schemep);\n\n        curl_free(schemep);\n      }\n    }\n    curl_url_cleanup(uh);\n  }\n\n  *scheme = (char *) (proto? proto: \"???\");   /* Never match if not found. */\n  return result;\n}\n\n/* create the next (singular) transfer */\nstatic CURLcode single_transfer(struct GlobalConfig *global,\n                                struct OperationConfig *config,\n                                CURLSH *share,\n                                bool capath_from_env,\n                                bool *added)\n{\n  CURLcode result = CURLE_OK;\n  struct getout *urlnode;\n  bool orig_noprogress = global->noprogress;\n  bool orig_isatty = global->isatty;\n  struct State *state = &config->state;\n  char *httpgetfields = state->httpgetfields;\n\n  *added = FALSE; /* not yet */\n\n  if(config->postfields) {\n    if(config->use_httpget) {\n      if(!httpgetfields) {\n        /* Use the postfields data for an HTTP get */\n        httpgetfields = state->httpgetfields = config->postfields;\n        config->postfields = NULL;\n        if(SetHTTPrequest(config,\n                          (config->no_body?HTTPREQ_HEAD:HTTPREQ_GET),\n                          &config->httpreq)) {\n          result = CURLE_FAILED_INIT;\n        }\n      }\n    }\n    else {\n      if(SetHTTPrequest(config, HTTPREQ_SIMPLEPOST, &config->httpreq))\n        result = CURLE_FAILED_INIT;\n    }\n    if(result) {\n      single_transfer_cleanup(config);\n      return result;\n    }\n  }\n  if(!state->urlnode) {\n    /* first time caller, setup things */\n    state->urlnode = config->url_list;\n    state->infilenum = 1;\n  }\n\n  while(config->state.urlnode) {\n    static bool warn_more_options = FALSE;\n    char *infiles; /* might be a glob pattern */\n    struct URLGlob *inglob = state->inglob;\n    urlnode = config->state.urlnode;\n\n    /* urlnode->url is the full URL (it might be NULL) */\n\n    if(!urlnode->url) {\n      /* This node has no URL. Free node data without destroying the\n         node itself nor modifying next pointer and continue to next */\n      Curl_safefree(urlnode->outfile);\n      Curl_safefree(urlnode->infile);\n      urlnode->flags = 0;\n      config->state.urlnode = urlnode->next;\n      state->up = 0;\n      if(!warn_more_options) {\n        /* only show this once */\n        warnf(config->global, \"Got more output options than URLs\");\n        warn_more_options = TRUE;\n      }\n      continue; /* next URL please */\n    }\n\n    /* save outfile pattern before expansion */\n    if(urlnode->outfile && !state->outfiles) {\n      state->outfiles = strdup(urlnode->outfile);\n      if(!state->outfiles) {\n        errorf(global, \"out of memory\");\n        result = CURLE_OUT_OF_MEMORY;\n        break;\n      }\n    }\n\n    infiles = urlnode->infile;\n\n    if(!config->globoff && infiles && !inglob) {\n      /* Unless explicitly shut off */\n      result = glob_url(&inglob, infiles, &state->infilenum,\n                        (!global->silent || global->showerror)?\n                        tool_stderr:NULL);\n      if(result)\n        break;\n      config->state.inglob = inglob;\n    }\n\n    {\n      curl_off_t urlnum;\n\n      if(!state->up && !infiles)\n        Curl_nop_stmt;\n      else {\n        if(!state->uploadfile) {\n          if(inglob) {\n            result = glob_next_url(&state->uploadfile, inglob);\n            if(result == CURLE_OUT_OF_MEMORY)\n              errorf(global, \"out of memory\");\n          }\n          else if(!state->up) {\n            state->uploadfile = strdup(infiles);\n            if(!state->uploadfile) {\n              errorf(global, \"out of memory\");\n              result = CURLE_OUT_OF_MEMORY;\n            }\n          }\n        }\n        if(result)\n          break;\n      }\n\n      if(!state->urlnum) {\n        if(!config->globoff) {\n          /* Unless explicitly shut off, we expand '{...}' and '[...]'\n             expressions and return total number of URLs in pattern set */\n          result = glob_url(&state->urls, urlnode->url, &state->urlnum,\n                            (!global->silent || global->showerror)?\n                            tool_stderr:NULL);\n          if(result)\n            break;\n          urlnum = state->urlnum;\n        }\n        else\n          urlnum = 1; /* without globbing, this is a single URL */\n      }\n      else\n        urlnum = state->urlnum;\n\n      if(state->up < state->infilenum) {\n        struct per_transfer *per = NULL;\n        struct OutStruct *outs;\n        struct OutStruct *heads;\n        struct OutStruct *etag_save;\n        struct HdrCbData *hdrcbdata = NULL;\n        struct OutStruct etag_first;\n        char *use_proto;\n        CURL *curl;\n\n        /* --etag-save */\n        memset(&etag_first, 0, sizeof(etag_first));\n        etag_save = &etag_first;\n        etag_save->stream = stdout;\n\n        /* --etag-compare */\n        if(config->etag_compare_file) {\n          char *etag_from_file = NULL;\n          char *header = NULL;\n          ParameterError pe;\n\n          /* open file for reading: */\n          FILE *file = fopen(config->etag_compare_file, FOPEN_READTEXT);\n          if(!file && !config->etag_save_file) {\n            errorf(global,\n                   \"Failed to open %s\", config->etag_compare_file);\n            result = CURLE_READ_ERROR;\n            break;\n          }\n\n          if((PARAM_OK == file2string(&etag_from_file, file)) &&\n             etag_from_file) {\n            header = aprintf(\"If-None-Match: %s\", etag_from_file);\n            Curl_safefree(etag_from_file);\n          }\n          else\n            header = aprintf(\"If-None-Match: \\\"\\\"\");\n\n          if(!header) {\n            if(file)\n              fclose(file);\n            errorf(global,\n                   \"Failed to allocate memory for custom etag header\");\n            result = CURLE_OUT_OF_MEMORY;\n            break;\n          }\n\n          /* add Etag from file to list of custom headers */\n          pe = add2list(&config->headers, header);\n          Curl_safefree(header);\n\n          if(file)\n            fclose(file);\n          if(pe != PARAM_OK) {\n            result = CURLE_OUT_OF_MEMORY;\n            break;\n          }\n        }\n\n        if(config->etag_save_file) {\n          /* open file for output: */\n          if(strcmp(config->etag_save_file, \"-\")) {\n            FILE *newfile = fopen(config->etag_save_file, \"wb\");\n            if(!newfile) {\n              warnf(global, \"Failed creating file for saving etags: \\\"%s\\\". \"\n                    \"Skip this transfer\", config->etag_save_file);\n              Curl_safefree(state->outfiles);\n              glob_cleanup(state->urls);\n              return CURLE_OK;\n            }\n            else {\n              etag_save->filename = config->etag_save_file;\n              etag_save->s_isreg = TRUE;\n              etag_save->fopened = TRUE;\n              etag_save->stream = newfile;\n            }\n          }\n          else {\n            /* always use binary mode for protocol header output */\n            set_binmode(etag_save->stream);\n          }\n        }\n\n        curl = curl_easy_init();\n        if(curl)\n          result = add_per_transfer(&per);\n        else\n          result = CURLE_OUT_OF_MEMORY;\n        if(result) {\n          curl_easy_cleanup(curl);\n          if(etag_save->fopened)\n            fclose(etag_save->stream);\n          break;\n        }\n        per->etag_save = etag_first; /* copy the whole struct */\n        if(state->uploadfile) {\n          per->uploadfile = strdup(state->uploadfile);\n          if(!per->uploadfile) {\n            curl_easy_cleanup(curl);\n            result = CURLE_OUT_OF_MEMORY;\n            break;\n          }\n          if(SetHTTPrequest(config, HTTPREQ_PUT, &config->httpreq)) {\n            Curl_safefree(per->uploadfile);\n            curl_easy_cleanup(curl);\n            result = CURLE_FAILED_INIT;\n            break;\n          }\n        }\n        *added = TRUE;\n        per->config = config;\n        per->curl = curl;\n        per->urlnum = urlnode->num;\n\n        /* default headers output stream is stdout */\n        heads = &per->heads;\n        heads->stream = stdout;\n\n        /* Single header file for all URLs */\n        if(config->headerfile) {\n          /* open file for output: */\n          if(strcmp(config->headerfile, \"-\")) {\n            FILE *newfile;\n\n            /*\n             * Since every transfer has its own file handle for dumping\n             * the headers, we need to open it in append mode, since transfers\n             * might finish in any order.\n             * The first transfer just clears the file.\n             * TODO: Consider placing the file handle inside the\n             * OperationConfig, so that it does not need to be opened/closed\n             * for every transfer.\n             */\n            if(!per->prev || per->prev->config != config) {\n              newfile = fopen(config->headerfile, \"wb\");\n              if(newfile)\n                fclose(newfile);\n            }\n            newfile = fopen(config->headerfile, \"ab\");\n\n            if(!newfile) {\n              errorf(global, \"Failed to open %s\", config->headerfile);\n              result = CURLE_WRITE_ERROR;\n              break;\n            }\n            else {\n              heads->filename = config->headerfile;\n              heads->s_isreg = TRUE;\n              heads->fopened = TRUE;\n              heads->stream = newfile;\n            }\n          }\n          else {\n            /* always use binary mode for protocol header output */\n            set_binmode(heads->stream);\n          }\n        }\n\n        hdrcbdata = &per->hdrcbdata;\n\n        outs = &per->outs;\n\n        per->outfile = NULL;\n        per->infdopen = FALSE;\n        per->infd = STDIN_FILENO;\n\n        /* default output stream is stdout */\n        outs->stream = stdout;\n\n        if(state->urls) {\n          result = glob_next_url(&per->this_url, state->urls);\n          if(result)\n            break;\n        }\n        else if(!state->li) {\n          per->this_url = strdup(urlnode->url);\n          if(!per->this_url) {\n            result = CURLE_OUT_OF_MEMORY;\n            break;\n          }\n        }\n        else\n          per->this_url = NULL;\n        if(!per->this_url)\n          break;\n\n        if(state->outfiles) {\n          per->outfile = strdup(state->outfiles);\n          if(!per->outfile) {\n            result = CURLE_OUT_OF_MEMORY;\n            break;\n          }\n        }\n\n        if(((urlnode->flags&GETOUT_USEREMOTE) ||\n            (per->outfile && strcmp(\"-\", per->outfile)))) {\n\n          /*\n           * We have specified a file name to store the result in, or we have\n           * decided we want to use the remote file name.\n           */\n\n          if(!per->outfile) {\n            /* extract the file name from the URL */\n            result = get_url_file_name(&per->outfile, per->this_url);\n            if(result) {\n              errorf(global, \"Failed to extract a sensible file name\"\n                     \" from the URL to use for storage\");\n              break;\n            }\n            if(!*per->outfile && !config->content_disposition) {\n              errorf(global, \"Remote file name has no length\");\n              result = CURLE_WRITE_ERROR;\n              break;\n            }\n          }\n          else if(state->urls) {\n            /* fill '#1' ... '#9' terms from URL pattern */\n            char *storefile = per->outfile;\n            result = glob_match_url(&per->outfile, storefile, state->urls);\n            Curl_safefree(storefile);\n            if(result) {\n              /* bad globbing */\n              warnf(global, \"bad output glob\");\n              break;\n            }\n            if(!*per->outfile) {\n              warnf(global, \"output glob produces empty string\");\n              result = CURLE_WRITE_ERROR;\n              break;\n            }\n          }\n\n          if(config->output_dir && *config->output_dir) {\n            char *d = aprintf(\"%s/%s\", config->output_dir, per->outfile);\n            if(!d) {\n              result = CURLE_WRITE_ERROR;\n              break;\n            }\n            free(per->outfile);\n            per->outfile = d;\n          }\n          /* Create the directory hierarchy, if not pre-existent to a multiple\n             file output call */\n\n          if(config->create_dirs) {\n            result = create_dir_hierarchy(per->outfile, global);\n            /* create_dir_hierarchy shows error upon CURLE_WRITE_ERROR */\n            if(result)\n              break;\n          }\n\n          if((urlnode->flags & GETOUT_USEREMOTE)\n             && config->content_disposition) {\n            /* Our header callback MIGHT set the filename */\n            DEBUGASSERT(!outs->filename);\n          }\n\n          if(config->resume_from_current) {\n            /* We're told to continue from where we are now. Get the size\n               of the file as it is now and open it for append instead */\n            struct_stat fileinfo;\n            /* VMS -- Danger, the filesize is only valid for stream files */\n            if(0 == stat(per->outfile, &fileinfo))\n              /* set offset to current file size: */\n              config->resume_from = fileinfo.st_size;\n            else\n              /* let offset be 0 */\n              config->resume_from = 0;\n          }\n\n          if(config->resume_from) {\n#ifdef __VMS\n            /* open file for output, forcing VMS output format into stream\n               mode which is needed for stat() call above to always work. */\n            FILE *file = fopen(outfile, \"ab\",\n                               \"ctx=stm\", \"rfm=stmlf\", \"rat=cr\", \"mrs=0\");\n#else\n            /* open file for output: */\n            FILE *file = fopen(per->outfile, \"ab\");\n#endif\n            if(!file) {\n              errorf(global, \"Can't open '%s'\", per->outfile);\n              result = CURLE_WRITE_ERROR;\n              break;\n            }\n            outs->fopened = TRUE;\n            outs->stream = file;\n            outs->init = config->resume_from;\n          }\n          else {\n            outs->stream = NULL; /* open when needed */\n          }\n          outs->filename = per->outfile;\n          outs->s_isreg = TRUE;\n        }\n\n        if(per->uploadfile && !stdin_upload(per->uploadfile)) {\n          /*\n           * We have specified a file to upload and it isn't \"-\".\n           */\n          result = add_file_name_to_url(per->curl, &per->this_url,\n                                        per->uploadfile);\n          if(result)\n            break;\n        }\n        else if(per->uploadfile && stdin_upload(per->uploadfile)) {\n          /* count to see if there are more than one auth bit set\n             in the authtype field */\n          int authbits = 0;\n          int bitcheck = 0;\n          while(bitcheck < 32) {\n            if(config->authtype & (1UL << bitcheck++)) {\n              authbits++;\n              if(authbits > 1) {\n                /* more than one, we're done! */\n                break;\n              }\n            }\n          }\n\n          /*\n           * If the user has also selected --anyauth or --proxy-anyauth\n           * we should warn them.\n           */\n          if(config->proxyanyauth || (authbits>1)) {\n            warnf(global,\n                  \"Using --anyauth or --proxy-anyauth with upload from stdin\"\n                  \" involves a big risk of it not working. Use a temporary\"\n                  \" file or a fixed auth type instead\");\n          }\n\n          DEBUGASSERT(per->infdopen == FALSE);\n          DEBUGASSERT(per->infd == STDIN_FILENO);\n\n          set_binmode(stdin);\n          if(!strcmp(per->uploadfile, \".\")) {\n            if(curlx_nonblock((curl_socket_t)per->infd, TRUE) < 0)\n              warnf(global,\n                    \"fcntl failed on fd=%d: %s\", per->infd, strerror(errno));\n          }\n        }\n\n        if(per->uploadfile && config->resume_from_current)\n          config->resume_from = -1; /* -1 will then force get-it-yourself */\n\n        if(output_expected(per->this_url, per->uploadfile) && outs->stream &&\n           isatty(fileno(outs->stream)))\n          /* we send the output to a tty, therefore we switch off the progress\n             meter */\n          per->noprogress = global->noprogress = global->isatty = TRUE;\n        else {\n          /* progress meter is per download, so restore config\n             values */\n          per->noprogress = global->noprogress = orig_noprogress;\n          global->isatty = orig_isatty;\n        }\n\n        if(httpgetfields || config->query) {\n          char *q = httpgetfields ? httpgetfields : config->query;\n          CURLU *uh = curl_url();\n          if(uh) {\n            CURLUcode uerr;\n            uerr = curl_url_set(uh, CURLUPART_URL, per->this_url,\n                            CURLU_GUESS_SCHEME);\n            if(uerr) {\n              result = urlerr_cvt(uerr);\n              errorf(global, \"(%d) Could not parse the URL, \"\n                     \"failed to set query\", result);\n              config->synthetic_error = TRUE;\n            }\n            else {\n              char *updated = NULL;\n              uerr = curl_url_set(uh, CURLUPART_QUERY, q, CURLU_APPENDQUERY);\n              if(!uerr)\n                uerr = curl_url_get(uh, CURLUPART_URL, &updated,\n                                   CURLU_GUESS_SCHEME);\n              if(uerr)\n                result = urlerr_cvt(uerr);\n              else {\n                Curl_safefree(per->this_url); /* free previous URL */\n                per->this_url = updated; /* use our new URL instead! */\n              }\n            }\n            curl_url_cleanup(uh);\n            if(result)\n              break;\n          }\n        }\n\n        if((!per->outfile || !strcmp(per->outfile, \"-\")) &&\n           !config->use_ascii) {\n          /* We get the output to stdout and we have not got the ASCII/text\n             flag, then set stdout to be binary */\n          set_binmode(stdout);\n        }\n\n        /* explicitly passed to stdout means okaying binary gunk */\n        config->terminal_binary_ok =\n          (per->outfile && !strcmp(per->outfile, \"-\"));\n\n        /* Avoid having this setopt added to the --libcurl source output. */\n        result = curl_easy_setopt(curl, CURLOPT_SHARE, share);\n        if(result)\n          break;\n\n        /* result is only used when for ipfs and ipns, ignored otherwise */\n        result = url_proto(&per->this_url, config, &use_proto);\n        if(result && (use_proto == proto_ipfs || use_proto == proto_ipns))\n          break;\n\n#ifndef DEBUGBUILD\n        /* On most modern OSes, exiting works thoroughly,\n           we'll clean everything up via exit(), so don't bother with\n           slow cleanups. Crappy ones might need to skip this.\n           Note: avoid having this setopt added to the --libcurl source\n           output. */\n        result = curl_easy_setopt(curl, CURLOPT_QUICK_EXIT, 1L);\n        if(result)\n          break;\n#endif\n\n        if(!config->tcp_nodelay)\n          my_setopt(curl, CURLOPT_TCP_NODELAY, 0L);\n\n        if(config->tcp_fastopen)\n          my_setopt(curl, CURLOPT_TCP_FASTOPEN, 1L);\n\n        /* where to store */\n        my_setopt(curl, CURLOPT_WRITEDATA, per);\n        my_setopt(curl, CURLOPT_INTERLEAVEDATA, per);\n\n        /* what call to write */\n        my_setopt(curl, CURLOPT_WRITEFUNCTION, tool_write_cb);\n\n        /* Note that if CURLOPT_READFUNCTION is fread (the default), then\n         * lib/telnet.c will Curl_poll() on the input file descriptor\n         * rather than calling the READFUNCTION at regular intervals.\n         * The circumstances in which it is preferable to enable this\n         * behavior, by omitting to set the READFUNCTION & READDATA options,\n         * have not been determined.\n         */\n        my_setopt(curl, CURLOPT_READDATA, per);\n        /* what call to read */\n        my_setopt(curl, CURLOPT_READFUNCTION, tool_read_cb);\n\n        /* in 7.18.0, the CURLOPT_SEEKFUNCTION/DATA pair is taking over what\n           CURLOPT_IOCTLFUNCTION/DATA pair previously provided for seeking */\n        my_setopt(curl, CURLOPT_SEEKDATA, per);\n        my_setopt(curl, CURLOPT_SEEKFUNCTION, tool_seek_cb);\n\n        {\n#ifdef CURLDEBUG\n          char *env = getenv(\"CURL_BUFFERSIZE\");\n          if(env) {\n            long size = strtol(env, NULL, 10);\n            if(size)\n              my_setopt(curl, CURLOPT_BUFFERSIZE, size);\n          }\n          else\n#endif\n          if(config->recvpersecond &&\n             (config->recvpersecond < BUFFER_SIZE))\n            /* use a smaller sized buffer for better sleeps */\n            my_setopt(curl, CURLOPT_BUFFERSIZE, (long)config->recvpersecond);\n          else\n            my_setopt(curl, CURLOPT_BUFFERSIZE, (long)BUFFER_SIZE);\n        }\n\n        my_setopt_str(curl, CURLOPT_URL, per->this_url);\n        my_setopt(curl, CURLOPT_NOPROGRESS,\n                  global->noprogress || global->silent?1L:0L);\n        if(config->no_body)\n          my_setopt(curl, CURLOPT_NOBODY, 1L);\n\n        if(config->oauth_bearer)\n          my_setopt_str(curl, CURLOPT_XOAUTH2_BEARER, config->oauth_bearer);\n\n        my_setopt_str(curl, CURLOPT_PROXY, config->proxy);\n\n        if(config->proxy && result) {\n          errorf(global, \"proxy support is disabled in this libcurl\");\n          config->synthetic_error = TRUE;\n          result = CURLE_NOT_BUILT_IN;\n          break;\n        }\n\n        /* new in libcurl 7.5 */\n        if(config->proxy)\n          my_setopt_enum(curl, CURLOPT_PROXYTYPE, config->proxyver);\n\n        my_setopt_str(curl, CURLOPT_PROXYUSERPWD, config->proxyuserpwd);\n\n        /* new in libcurl 7.3 */\n        my_setopt(curl, CURLOPT_HTTPPROXYTUNNEL, config->proxytunnel?1L:0L);\n\n        /* new in libcurl 7.52.0 */\n        if(config->preproxy)\n          my_setopt_str(curl, CURLOPT_PRE_PROXY, config->preproxy);\n\n        /* new in libcurl 7.10.6 */\n        if(config->proxyanyauth)\n          my_setopt_bitmask(curl, CURLOPT_PROXYAUTH,\n                            (long)CURLAUTH_ANY);\n        else if(config->proxynegotiate)\n          my_setopt_bitmask(curl, CURLOPT_PROXYAUTH,\n                            (long)CURLAUTH_GSSNEGOTIATE);\n        else if(config->proxyntlm)\n          my_setopt_bitmask(curl, CURLOPT_PROXYAUTH,\n                            (long)CURLAUTH_NTLM);\n        else if(config->proxydigest)\n          my_setopt_bitmask(curl, CURLOPT_PROXYAUTH,\n                            (long)CURLAUTH_DIGEST);\n        else if(config->proxybasic)\n          my_setopt_bitmask(curl, CURLOPT_PROXYAUTH,\n                            (long)CURLAUTH_BASIC);\n\n        /* new in libcurl 7.19.4 */\n        my_setopt_str(curl, CURLOPT_NOPROXY, config->noproxy);\n\n        my_setopt(curl, CURLOPT_SUPPRESS_CONNECT_HEADERS,\n                  config->suppress_connect_headers?1L:0L);\n\n        my_setopt(curl, CURLOPT_FAILONERROR, config->failonerror?1L:0L);\n        my_setopt(curl, CURLOPT_REQUEST_TARGET, config->request_target);\n        my_setopt(curl, CURLOPT_UPLOAD, per->uploadfile?1L:0L);\n        my_setopt(curl, CURLOPT_DIRLISTONLY, config->dirlistonly?1L:0L);\n        my_setopt(curl, CURLOPT_APPEND, config->ftp_append?1L:0L);\n\n        if(config->netrc_opt)\n          my_setopt_enum(curl, CURLOPT_NETRC, (long)CURL_NETRC_OPTIONAL);\n        else if(config->netrc || config->netrc_file)\n          my_setopt_enum(curl, CURLOPT_NETRC, (long)CURL_NETRC_REQUIRED);\n        else\n          my_setopt_enum(curl, CURLOPT_NETRC, (long)CURL_NETRC_IGNORED);\n\n        if(config->netrc_file)\n          my_setopt_str(curl, CURLOPT_NETRC_FILE, config->netrc_file);\n\n        my_setopt(curl, CURLOPT_TRANSFERTEXT, config->use_ascii?1L:0L);\n        if(config->login_options)\n          my_setopt_str(curl, CURLOPT_LOGIN_OPTIONS, config->login_options);\n        my_setopt_str(curl, CURLOPT_USERPWD, config->userpwd);\n        my_setopt_str(curl, CURLOPT_RANGE, config->range);\n        if(!global->parallel) {\n          per->errorbuffer = global_errorbuffer;\n          my_setopt(curl, CURLOPT_ERRORBUFFER, global_errorbuffer);\n        }\n        my_setopt(curl, CURLOPT_TIMEOUT_MS, config->timeout_ms);\n\n        switch(config->httpreq) {\n        case HTTPREQ_SIMPLEPOST:\n          if(config->resume_from) {\n            errorf(global, \"cannot mix --continue-at with --data\");\n            result = CURLE_FAILED_INIT;\n          }\n          else {\n            my_setopt_str(curl, CURLOPT_POSTFIELDS,\n                          curlx_dyn_ptr(&config->postdata));\n            my_setopt(curl, CURLOPT_POSTFIELDSIZE_LARGE,\n                      (curl_off_t)curlx_dyn_len(&config->postdata));\n          }\n          break;\n        case HTTPREQ_MIMEPOST:\n          /* free previous remainders */\n          curl_mime_free(config->mimepost);\n          config->mimepost = NULL;\n          if(config->resume_from) {\n            errorf(global, \"cannot mix --continue-at with --form\");\n            result = CURLE_FAILED_INIT;\n          }\n          else {\n            result = tool2curlmime(curl, config->mimeroot, &config->mimepost);\n            if(!result)\n              my_setopt_mimepost(curl, CURLOPT_MIMEPOST, config->mimepost);\n          }\n          break;\n        default:\n          break;\n        }\n        if(result)\n          break;\n\n        /* new in libcurl 7.81.0 */\n        if(config->mime_options)\n          my_setopt(curl, CURLOPT_MIME_OPTIONS, config->mime_options);\n\n        /* new in libcurl 7.10.6 (default is Basic) */\n        if(config->authtype)\n          my_setopt_bitmask(curl, CURLOPT_HTTPAUTH, (long)config->authtype);\n\n        my_setopt_slist(curl, CURLOPT_HTTPHEADER, config->headers);\n\n        if(proto_http || proto_rtsp) {\n          my_setopt_str(curl, CURLOPT_REFERER, config->referer);\n          my_setopt_str(curl, CURLOPT_USERAGENT, config->useragent);\n        }\n\n        if(proto_http) {\n          long postRedir = 0;\n\n          my_setopt(curl, CURLOPT_FOLLOWLOCATION,\n                    config->followlocation?1L:0L);\n          my_setopt(curl, CURLOPT_UNRESTRICTED_AUTH,\n                    config->unrestricted_auth?1L:0L);\n          my_setopt_str(curl, CURLOPT_AWS_SIGV4, config->aws_sigv4);\n          my_setopt(curl, CURLOPT_AUTOREFERER, config->autoreferer?1L:0L);\n\n          /* new in libcurl 7.36.0 */\n          if(config->proxyheaders) {\n            my_setopt_slist(curl, CURLOPT_PROXYHEADER, config->proxyheaders);\n            my_setopt(curl, CURLOPT_HEADEROPT, (long)CURLHEADER_SEPARATE);\n          }\n\n          /* new in libcurl 7.5 */\n          my_setopt(curl, CURLOPT_MAXREDIRS, config->maxredirs);\n\n          if(config->httpversion)\n            my_setopt_enum(curl, CURLOPT_HTTP_VERSION, config->httpversion);\n          else if(feature_http2)\n            my_setopt_enum(curl, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_2TLS);\n\n          /* curl 7.19.1 (the 301 version existed in 7.18.2),\n             303 was added in 7.26.0 */\n          if(config->post301)\n            postRedir |= CURL_REDIR_POST_301;\n          if(config->post302)\n            postRedir |= CURL_REDIR_POST_302;\n          if(config->post303)\n            postRedir |= CURL_REDIR_POST_303;\n          my_setopt(curl, CURLOPT_POSTREDIR, postRedir);\n\n          /* new in libcurl 7.21.6 */\n          if(config->encoding)\n            my_setopt_str(curl, CURLOPT_ACCEPT_ENCODING, \"\");\n\n          /* new in libcurl 7.21.6 */\n          if(config->tr_encoding)\n            my_setopt(curl, CURLOPT_TRANSFER_ENCODING, 1L);\n          /* new in libcurl 7.64.0 */\n          my_setopt(curl, CURLOPT_HTTP09_ALLOWED,\n                    config->http09_allowed ? 1L : 0L);\n          if(result) {\n            errorf(global, \"HTTP/0.9 is not supported in this build\");\n            return result;\n          }\n\n        } /* (proto_http) */\n\n        if(proto_ftp)\n          my_setopt_str(curl, CURLOPT_FTPPORT, config->ftpport);\n        my_setopt(curl, CURLOPT_LOW_SPEED_LIMIT,\n                  config->low_speed_limit);\n        my_setopt(curl, CURLOPT_LOW_SPEED_TIME, config->low_speed_time);\n        my_setopt(curl, CURLOPT_MAX_SEND_SPEED_LARGE,\n                  config->sendpersecond);\n        my_setopt(curl, CURLOPT_MAX_RECV_SPEED_LARGE,\n                  config->recvpersecond);\n\n        if(config->use_resume)\n          my_setopt(curl, CURLOPT_RESUME_FROM_LARGE, config->resume_from);\n        else\n          my_setopt(curl, CURLOPT_RESUME_FROM_LARGE, CURL_OFF_T_C(0));\n\n        my_setopt_str(curl, CURLOPT_KEYPASSWD, config->key_passwd);\n        my_setopt_str(curl, CURLOPT_PROXY_KEYPASSWD, config->proxy_key_passwd);\n\n        if(use_proto == proto_scp || use_proto == proto_sftp) {\n          /* SSH and SSL private key uses same command-line option */\n          /* new in libcurl 7.16.1 */\n          my_setopt_str(curl, CURLOPT_SSH_PRIVATE_KEYFILE, config->key);\n          /* new in libcurl 7.16.1 */\n          my_setopt_str(curl, CURLOPT_SSH_PUBLIC_KEYFILE, config->pubkey);\n\n          /* new in libcurl 7.17.1: SSH host key md5 checking allows us\n             to fail if we are not talking to who we think we should */\n          my_setopt_str(curl, CURLOPT_SSH_HOST_PUBLIC_KEY_MD5,\n                        config->hostpubmd5);\n\n          /* new in libcurl 7.80.0: SSH host key sha256 checking allows us\n             to fail if we are not talking to who we think we should */\n          my_setopt_str(curl, CURLOPT_SSH_HOST_PUBLIC_KEY_SHA256,\n              config->hostpubsha256);\n\n          /* new in libcurl 7.56.0 */\n          if(config->ssh_compression)\n            my_setopt(curl, CURLOPT_SSH_COMPRESSION, 1L);\n        }\n\n        if(config->cacert)\n          my_setopt_str(curl, CURLOPT_CAINFO, config->cacert);\n        if(config->proxy_cacert)\n          my_setopt_str(curl, CURLOPT_PROXY_CAINFO, config->proxy_cacert);\n\n        if(config->capath) {\n          result = res_setopt_str(curl, CURLOPT_CAPATH, config->capath);\n          if(result == CURLE_NOT_BUILT_IN) {\n            warnf(global, \"ignoring %s, not supported by libcurl\",\n                  capath_from_env?\n                  \"SSL_CERT_DIR environment variable\":\"--capath\");\n          }\n          else if(result)\n            break;\n        }\n        /* For the time being if --proxy-capath is not set then we use the\n           --capath value for it, if any. See #1257 */\n        if(config->proxy_capath || config->capath) {\n          result = res_setopt_str(curl, CURLOPT_PROXY_CAPATH,\n                                  (config->proxy_capath ?\n                                   config->proxy_capath :\n                                   config->capath));\n          if((result == CURLE_NOT_BUILT_IN) ||\n             (result == CURLE_UNKNOWN_OPTION)) {\n            if(config->proxy_capath) {\n              warnf(global,\n                    \"ignoring --proxy-capath, not supported by libcurl\");\n            }\n          }\n          else if(result)\n            break;\n        }\n\n        if(config->crlfile)\n          my_setopt_str(curl, CURLOPT_CRLFILE, config->crlfile);\n        if(config->proxy_crlfile)\n          my_setopt_str(curl, CURLOPT_PROXY_CRLFILE, config->proxy_crlfile);\n        else if(config->crlfile) /* CURLOPT_PROXY_CRLFILE default is crlfile */\n          my_setopt_str(curl, CURLOPT_PROXY_CRLFILE, config->crlfile);\n\n        if(config->pinnedpubkey)\n          my_setopt_str(curl, CURLOPT_PINNEDPUBLICKEY, config->pinnedpubkey);\n\n        if(config->ssl_ec_curves)\n          my_setopt_str(curl, CURLOPT_SSL_EC_CURVES, config->ssl_ec_curves);\n\n        if(config->writeout)\n          my_setopt_str(curl, CURLOPT_CERTINFO, 1L);\n\n        if(feature_ssl) {\n          /* Check if config->cert is a PKCS#11 URI and set the\n           * config->cert_type if necessary */\n          if(config->cert) {\n            if(!config->cert_type) {\n              if(is_pkcs11_uri(config->cert)) {\n                config->cert_type = strdup(\"ENG\");\n              }\n            }\n          }\n\n          /* Check if config->key is a PKCS#11 URI and set the\n           * config->key_type if necessary */\n          if(config->key) {\n            if(!config->key_type) {\n              if(is_pkcs11_uri(config->key)) {\n                config->key_type = strdup(\"ENG\");\n              }\n            }\n          }\n\n          /* Check if config->proxy_cert is a PKCS#11 URI and set the\n           * config->proxy_type if necessary */\n          if(config->proxy_cert) {\n            if(!config->proxy_cert_type) {\n              if(is_pkcs11_uri(config->proxy_cert)) {\n                config->proxy_cert_type = strdup(\"ENG\");\n              }\n            }\n          }\n\n          /* Check if config->proxy_key is a PKCS#11 URI and set the\n           * config->proxy_key_type if necessary */\n          if(config->proxy_key) {\n            if(!config->proxy_key_type) {\n              if(is_pkcs11_uri(config->proxy_key)) {\n                config->proxy_key_type = strdup(\"ENG\");\n              }\n            }\n          }\n\n          /* In debug build of curl tool, using\n           *    --cert loadmem=<filename>:<password> --cert-type p12\n           *  must do the same thing as classic:\n           *    --cert <filename>:<password> --cert-type p12\n           *  but is designed to test blob */\n#if defined(CURLDEBUG) || defined(DEBUGBUILD)\n          if(config->cert && (strlen(config->cert) > 8) &&\n             (memcmp(config->cert, \"loadmem=\",8) == 0)) {\n            FILE *fInCert = fopen(config->cert + 8, \"rb\");\n            void *certdata = NULL;\n            long filesize = 0;\n            bool continue_reading = fInCert != NULL;\n            if(continue_reading)\n              continue_reading = fseek(fInCert, 0, SEEK_END) == 0;\n            if(continue_reading)\n              filesize = ftell(fInCert);\n            if(filesize < 0)\n              continue_reading = FALSE;\n            if(continue_reading)\n              continue_reading = fseek(fInCert, 0, SEEK_SET) == 0;\n            if(continue_reading)\n              certdata = malloc(((size_t)filesize) + 1);\n            if((!certdata) ||\n                ((int)fread(certdata, (size_t)filesize, 1, fInCert) != 1))\n              continue_reading = FALSE;\n            if(fInCert)\n              fclose(fInCert);\n            if((filesize > 0) && continue_reading) {\n              struct curl_blob structblob;\n              structblob.data = certdata;\n              structblob.len = (size_t)filesize;\n              structblob.flags = CURL_BLOB_COPY;\n              my_setopt_str(curl, CURLOPT_SSLCERT_BLOB, &structblob);\n              /* if test run well, we are sure we don't reuse\n               * original mem pointer */\n              memset(certdata, 0, (size_t)filesize);\n            }\n            free(certdata);\n          }\n          else\n#endif\n          my_setopt_str(curl, CURLOPT_SSLCERT, config->cert);\n          my_setopt_str(curl, CURLOPT_PROXY_SSLCERT, config->proxy_cert);\n          my_setopt_str(curl, CURLOPT_SSLCERTTYPE, config->cert_type);\n          my_setopt_str(curl, CURLOPT_PROXY_SSLCERTTYPE,\n                        config->proxy_cert_type);\n\n\n#if defined(CURLDEBUG) || defined(DEBUGBUILD)\n          if(config->key && (strlen(config->key) > 8) &&\n             (memcmp(config->key, \"loadmem=\",8) == 0)) {\n            FILE *fInCert = fopen(config->key + 8, \"rb\");\n            void *certdata = NULL;\n            long filesize = 0;\n            bool continue_reading = fInCert != NULL;\n            if(continue_reading)\n              continue_reading = fseek(fInCert, 0, SEEK_END) == 0;\n            if(continue_reading)\n              filesize = ftell(fInCert);\n            if(filesize < 0)\n              continue_reading = FALSE;\n            if(continue_reading)\n              continue_reading = fseek(fInCert, 0, SEEK_SET) == 0;\n            if(continue_reading)\n              certdata = malloc(((size_t)filesize) + 1);\n            if((!certdata) ||\n                ((int)fread(certdata, (size_t)filesize, 1, fInCert) != 1))\n              continue_reading = FALSE;\n            if(fInCert)\n              fclose(fInCert);\n            if((filesize > 0) && continue_reading) {\n              struct curl_blob structblob;\n              structblob.data = certdata;\n              structblob.len = (size_t)filesize;\n              structblob.flags = CURL_BLOB_COPY;\n              my_setopt_str(curl, CURLOPT_SSLKEY_BLOB, &structblob);\n              /* if test run well, we are sure we don't reuse\n               * original mem pointer */\n              memset(certdata, 0, (size_t)filesize);\n            }\n            free(certdata);\n          }\n          else\n#endif\n          my_setopt_str(curl, CURLOPT_SSLKEY, config->key);\n          my_setopt_str(curl, CURLOPT_PROXY_SSLKEY, config->proxy_key);\n          my_setopt_str(curl, CURLOPT_SSLKEYTYPE, config->key_type);\n          my_setopt_str(curl, CURLOPT_PROXY_SSLKEYTYPE,\n                        config->proxy_key_type);\n          if(config->insecure_ok) {\n            my_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0L);\n            my_setopt(curl, CURLOPT_SSL_VERIFYHOST, 0L);\n          }\n          else {\n            my_setopt(curl, CURLOPT_SSL_VERIFYPEER, 1L);\n            /* libcurl default is strict verifyhost -> 2L   */\n            /* my_setopt(curl, CURLOPT_SSL_VERIFYHOST, 2L); */\n          }\n\n          if(config->doh_insecure_ok) {\n            my_setopt(curl, CURLOPT_DOH_SSL_VERIFYPEER, 0L);\n            my_setopt(curl, CURLOPT_DOH_SSL_VERIFYHOST, 0L);\n          }\n\n          if(config->proxy_insecure_ok) {\n            my_setopt(curl, CURLOPT_PROXY_SSL_VERIFYPEER, 0L);\n            my_setopt(curl, CURLOPT_PROXY_SSL_VERIFYHOST, 0L);\n          }\n          else {\n            my_setopt(curl, CURLOPT_PROXY_SSL_VERIFYPEER, 1L);\n          }\n\n          if(config->verifystatus)\n            my_setopt(curl, CURLOPT_SSL_VERIFYSTATUS, 1L);\n\n          if(config->doh_verifystatus)\n            my_setopt(curl, CURLOPT_DOH_SSL_VERIFYSTATUS, 1L);\n\n          if(config->falsestart)\n            my_setopt(curl, CURLOPT_SSL_FALSESTART, 1L);\n\n          my_setopt_SSLVERSION(curl, CURLOPT_SSLVERSION,\n                               config->ssl_version | config->ssl_version_max);\n          if(config->proxy)\n            my_setopt_SSLVERSION(curl, CURLOPT_PROXY_SSLVERSION,\n                                 config->proxy_ssl_version);\n\n          {\n            long mask =\n              (config->ssl_allow_beast ?\n               CURLSSLOPT_ALLOW_BEAST : 0) |\n              (config->ssl_no_revoke ?\n               CURLSSLOPT_NO_REVOKE : 0) |\n              (config->ssl_revoke_best_effort ?\n               CURLSSLOPT_REVOKE_BEST_EFFORT : 0) |\n              (config->native_ca_store ?\n               CURLSSLOPT_NATIVE_CA : 0) |\n              (config->ssl_auto_client_cert ?\n               CURLSSLOPT_AUTO_CLIENT_CERT : 0);\n\n            if(mask)\n              my_setopt_bitmask(curl, CURLOPT_SSL_OPTIONS, mask);\n          }\n\n          {\n            long mask =\n              (config->proxy_ssl_allow_beast ?\n               CURLSSLOPT_ALLOW_BEAST : 0) |\n              (config->proxy_ssl_auto_client_cert ?\n               CURLSSLOPT_AUTO_CLIENT_CERT : 0) |\n              (config->proxy_native_ca_store ?\n               CURLSSLOPT_NATIVE_CA : 0);\n\n            if(mask)\n              my_setopt_bitmask(curl, CURLOPT_PROXY_SSL_OPTIONS, mask);\n          }\n        }\n\n        if(config->path_as_is)\n          my_setopt(curl, CURLOPT_PATH_AS_IS, 1L);\n\n        if((use_proto == proto_scp || use_proto == proto_sftp) &&\n           !config->insecure_ok) {\n          char *known = findfile(\".ssh/known_hosts\", FALSE);\n          if(known) {\n            /* new in curl 7.19.6 */\n            result = res_setopt_str(curl, CURLOPT_SSH_KNOWNHOSTS, known);\n            curl_free(known);\n            if(result == CURLE_UNKNOWN_OPTION)\n              /* libssh2 version older than 1.1.1 */\n              result = CURLE_OK;\n            if(result)\n              break;\n          }\n          else\n            warnf(global, \"Couldn't find a known_hosts file\");\n        }\n\n        if(config->no_body || config->remote_time) {\n          /* no body or use remote time */\n          my_setopt(curl, CURLOPT_FILETIME, 1L);\n        }\n\n        my_setopt(curl, CURLOPT_CRLF, config->crlf?1L:0L);\n        my_setopt_slist(curl, CURLOPT_QUOTE, config->quote);\n        my_setopt_slist(curl, CURLOPT_POSTQUOTE, config->postquote);\n        my_setopt_slist(curl, CURLOPT_PREQUOTE, config->prequote);\n\n        if(config->cookies) {\n          struct curlx_dynbuf cookies;\n          struct curl_slist *cl;\n\n          /* The maximum size needs to match MAX_NAME in cookie.h */\n#define MAX_COOKIE_LINE 8200\n          curlx_dyn_init(&cookies, MAX_COOKIE_LINE);\n          for(cl = config->cookies; cl; cl = cl->next) {\n            if(cl == config->cookies)\n              result = curlx_dyn_addf(&cookies, \"%s\", cl->data);\n            else\n              result = curlx_dyn_addf(&cookies, \";%s\", cl->data);\n\n            if(result) {\n              warnf(global,\n                    \"skipped provided cookie, the cookie header \"\n                    \"would go over %u bytes\", MAX_COOKIE_LINE);\n              break;\n            }\n          }\n\n          my_setopt_str(curl, CURLOPT_COOKIE, curlx_dyn_ptr(&cookies));\n          curlx_dyn_free(&cookies);\n        }\n\n        if(config->cookiefiles) {\n          struct curl_slist *cfl;\n\n          for(cfl = config->cookiefiles; cfl; cfl = cfl->next)\n            my_setopt_str(curl, CURLOPT_COOKIEFILE, cfl->data);\n        }\n\n        /* new in libcurl 7.9 */\n        if(config->cookiejar)\n          my_setopt_str(curl, CURLOPT_COOKIEJAR, config->cookiejar);\n\n        /* new in libcurl 7.9.7 */\n        my_setopt(curl, CURLOPT_COOKIESESSION, config->cookiesession?1L:0L);\n\n        my_setopt_enum(curl, CURLOPT_TIMECONDITION, (long)config->timecond);\n        my_setopt(curl, CURLOPT_TIMEVALUE_LARGE, config->condtime);\n        my_setopt_str(curl, CURLOPT_CUSTOMREQUEST, config->customrequest);\n        customrequest_helper(config, config->httpreq, config->customrequest);\n        my_setopt(curl, CURLOPT_STDERR, tool_stderr);\n\n        /* three new ones in libcurl 7.3: */\n        my_setopt_str(curl, CURLOPT_INTERFACE, config->iface);\n        my_setopt_str(curl, CURLOPT_KRBLEVEL, config->krblevel);\n        progressbarinit(&per->progressbar, config);\n\n        if((global->progressmode == CURL_PROGRESS_BAR) &&\n           !global->noprogress && !global->silent) {\n          /* we want the alternative style, then we have to implement it\n             ourselves! */\n          my_setopt(curl, CURLOPT_XFERINFOFUNCTION, tool_progress_cb);\n          my_setopt(curl, CURLOPT_XFERINFODATA, per);\n        }\n        else if(per->uploadfile && !strcmp(per->uploadfile, \".\")) {\n          /* when reading from stdin in non-blocking mode, we use the progress\n             function to unpause a busy read */\n          my_setopt(curl, CURLOPT_NOPROGRESS, 0L);\n          my_setopt(curl, CURLOPT_XFERINFOFUNCTION, tool_readbusy_cb);\n          my_setopt(curl, CURLOPT_XFERINFODATA, per);\n        }\n\n        /* new in libcurl 7.24.0: */\n        if(config->dns_servers)\n          my_setopt_str(curl, CURLOPT_DNS_SERVERS, config->dns_servers);\n\n        /* new in libcurl 7.33.0: */\n        if(config->dns_interface)\n          my_setopt_str(curl, CURLOPT_DNS_INTERFACE, config->dns_interface);\n        if(config->dns_ipv4_addr)\n          my_setopt_str(curl, CURLOPT_DNS_LOCAL_IP4, config->dns_ipv4_addr);\n        if(config->dns_ipv6_addr)\n          my_setopt_str(curl, CURLOPT_DNS_LOCAL_IP6, config->dns_ipv6_addr);\n\n        /* new in libcurl 7.6.2: */\n        my_setopt_slist(curl, CURLOPT_TELNETOPTIONS, config->telnet_options);\n\n        /* new in libcurl 7.7: */\n        my_setopt(curl, CURLOPT_CONNECTTIMEOUT_MS, config->connecttimeout_ms);\n\n        if(config->doh_url)\n          my_setopt_str(curl, CURLOPT_DOH_URL, config->doh_url);\n\n        if(config->cipher_list)\n          my_setopt_str(curl, CURLOPT_SSL_CIPHER_LIST, config->cipher_list);\n\n        if(config->proxy_cipher_list)\n          my_setopt_str(curl, CURLOPT_PROXY_SSL_CIPHER_LIST,\n                        config->proxy_cipher_list);\n\n        if(config->cipher13_list)\n          my_setopt_str(curl, CURLOPT_TLS13_CIPHERS, config->cipher13_list);\n\n        if(config->proxy_cipher13_list)\n          my_setopt_str(curl, CURLOPT_PROXY_TLS13_CIPHERS,\n                        config->proxy_cipher13_list);\n\n        /* new in libcurl 7.9.2: */\n        if(config->disable_epsv)\n          /* disable it */\n          my_setopt(curl, CURLOPT_FTP_USE_EPSV, 0L);\n\n        /* new in libcurl 7.10.5 */\n        if(config->disable_eprt)\n          /* disable it */\n          my_setopt(curl, CURLOPT_FTP_USE_EPRT, 0L);\n\n        if(global->tracetype != TRACE_NONE) {\n          my_setopt(curl, CURLOPT_DEBUGFUNCTION, tool_debug_cb);\n          my_setopt(curl, CURLOPT_DEBUGDATA, config);\n          my_setopt(curl, CURLOPT_VERBOSE, 1L);\n        }\n\n        /* new in curl 7.9.3 */\n        if(config->engine) {\n          result = res_setopt_str(curl, CURLOPT_SSLENGINE, config->engine);\n          if(result)\n            break;\n        }\n\n        /* new in curl 7.10.7, extended in 7.19.4. Modified to use\n           CREATE_DIR_RETRY in 7.49.0 */\n        my_setopt(curl, CURLOPT_FTP_CREATE_MISSING_DIRS,\n                  (long)(config->ftp_create_dirs?\n                         CURLFTP_CREATE_DIR_RETRY:\n                         CURLFTP_CREATE_DIR_NONE));\n\n        /* new in curl 7.10.8 */\n        if(config->max_filesize)\n          my_setopt(curl, CURLOPT_MAXFILESIZE_LARGE,\n                    config->max_filesize);\n\n        my_setopt(curl, CURLOPT_IPRESOLVE, config->ip_version);\n\n        /* new in curl 7.15.5 */\n        if(config->ftp_ssl_reqd)\n          my_setopt_enum(curl, CURLOPT_USE_SSL, (long)CURLUSESSL_ALL);\n\n        /* new in curl 7.11.0 */\n        else if(config->ftp_ssl)\n          my_setopt_enum(curl, CURLOPT_USE_SSL, (long)CURLUSESSL_TRY);\n\n        /* new in curl 7.16.0 */\n        else if(config->ftp_ssl_control)\n          my_setopt_enum(curl, CURLOPT_USE_SSL, (long)CURLUSESSL_CONTROL);\n\n        /* new in curl 7.16.1 */\n        if(config->ftp_ssl_ccc)\n          my_setopt_enum(curl, CURLOPT_FTP_SSL_CCC,\n                         (long)config->ftp_ssl_ccc_mode);\n\n        /* new in curl 7.19.4 */\n        if(config->socks5_gssapi_nec)\n          my_setopt_str(curl, CURLOPT_SOCKS5_GSSAPI_NEC, 1L);\n\n        /* new in curl 7.55.0 */\n        if(config->socks5_auth)\n          my_setopt_bitmask(curl, CURLOPT_SOCKS5_AUTH,\n                            (long)config->socks5_auth);\n\n        /* new in curl 7.43.0 */\n        if(config->proxy_service_name)\n          my_setopt_str(curl, CURLOPT_PROXY_SERVICE_NAME,\n                        config->proxy_service_name);\n\n        /* new in curl 7.43.0 */\n        if(config->service_name)\n          my_setopt_str(curl, CURLOPT_SERVICE_NAME,\n                        config->service_name);\n\n        /* curl 7.13.0 */\n        my_setopt_str(curl, CURLOPT_FTP_ACCOUNT, config->ftp_account);\n        my_setopt(curl, CURLOPT_IGNORE_CONTENT_LENGTH, config->ignorecl?1L:0L);\n\n        /* curl 7.14.2 */\n        my_setopt(curl, CURLOPT_FTP_SKIP_PASV_IP, config->ftp_skip_ip?1L:0L);\n\n        /* curl 7.15.1 */\n        if(proto_ftp)\n          my_setopt(curl, CURLOPT_FTP_FILEMETHOD,\n                    (long)config->ftp_filemethod);\n\n        /* curl 7.15.2 */\n        if(config->localport) {\n          my_setopt(curl, CURLOPT_LOCALPORT, config->localport);\n          my_setopt_str(curl, CURLOPT_LOCALPORTRANGE, config->localportrange);\n        }\n\n        /* curl 7.15.5 */\n        my_setopt_str(curl, CURLOPT_FTP_ALTERNATIVE_TO_USER,\n                      config->ftp_alternative_to_user);\n\n        /* curl 7.16.0 */\n        if(config->disable_sessionid)\n          /* disable it */\n          my_setopt(curl, CURLOPT_SSL_SESSIONID_CACHE, 0L);\n\n        /* curl 7.16.2 */\n        if(config->raw) {\n          my_setopt(curl, CURLOPT_HTTP_CONTENT_DECODING, 0L);\n          my_setopt(curl, CURLOPT_HTTP_TRANSFER_DECODING, 0L);\n        }\n\n        /* curl 7.17.1 */\n        if(!config->nokeepalive) {\n          my_setopt(curl, CURLOPT_TCP_KEEPALIVE, 1L);\n          if(config->alivetime) {\n            my_setopt(curl, CURLOPT_TCP_KEEPIDLE, config->alivetime);\n            my_setopt(curl, CURLOPT_TCP_KEEPINTVL, config->alivetime);\n          }\n        }\n        else\n          my_setopt(curl, CURLOPT_TCP_KEEPALIVE, 0L);\n\n        /* curl 7.20.0 */\n        if(config->tftp_blksize && proto_tftp)\n          my_setopt(curl, CURLOPT_TFTP_BLKSIZE, config->tftp_blksize);\n\n        if(config->mail_from)\n          my_setopt_str(curl, CURLOPT_MAIL_FROM, config->mail_from);\n\n        if(config->mail_rcpt)\n          my_setopt_slist(curl, CURLOPT_MAIL_RCPT, config->mail_rcpt);\n\n        /* curl 7.69.x */\n        my_setopt(curl, CURLOPT_MAIL_RCPT_ALLOWFAILS,\n                  config->mail_rcpt_allowfails ? 1L : 0L);\n\n        /* curl 7.20.x */\n        if(config->ftp_pret)\n          my_setopt(curl, CURLOPT_FTP_USE_PRET, 1L);\n\n        if(config->create_file_mode)\n          my_setopt(curl, CURLOPT_NEW_FILE_PERMS, config->create_file_mode);\n\n        if(config->proto_present)\n          my_setopt_str(curl, CURLOPT_PROTOCOLS_STR, config->proto_str);\n        if(config->proto_redir_present)\n          my_setopt_str(curl, CURLOPT_REDIR_PROTOCOLS_STR,\n                        config->proto_redir_str);\n\n        if(config->content_disposition\n           && (urlnode->flags & GETOUT_USEREMOTE))\n          hdrcbdata->honor_cd_filename = TRUE;\n        else\n          hdrcbdata->honor_cd_filename = FALSE;\n\n        hdrcbdata->outs = outs;\n        hdrcbdata->heads = heads;\n        hdrcbdata->etag_save = etag_save;\n        hdrcbdata->global = global;\n        hdrcbdata->config = config;\n\n        my_setopt(curl, CURLOPT_HEADERFUNCTION, tool_header_cb);\n        my_setopt(curl, CURLOPT_HEADERDATA, per);\n\n        if(config->resolve)\n          /* new in 7.21.3 */\n          my_setopt_slist(curl, CURLOPT_RESOLVE, config->resolve);\n\n        if(config->connect_to)\n          /* new in 7.49.0 */\n          my_setopt_slist(curl, CURLOPT_CONNECT_TO, config->connect_to);\n\n        /* new in 7.21.4 */\n        if(feature_tls_srp) {\n          if(config->tls_username)\n            my_setopt_str(curl, CURLOPT_TLSAUTH_USERNAME,\n                          config->tls_username);\n          if(config->tls_password)\n            my_setopt_str(curl, CURLOPT_TLSAUTH_PASSWORD,\n                          config->tls_password);\n          if(config->tls_authtype)\n            my_setopt_str(curl, CURLOPT_TLSAUTH_TYPE,\n                          config->tls_authtype);\n          if(config->proxy_tls_username)\n            my_setopt_str(curl, CURLOPT_PROXY_TLSAUTH_USERNAME,\n                          config->proxy_tls_username);\n          if(config->proxy_tls_password)\n            my_setopt_str(curl, CURLOPT_PROXY_TLSAUTH_PASSWORD,\n                          config->proxy_tls_password);\n          if(config->proxy_tls_authtype)\n            my_setopt_str(curl, CURLOPT_PROXY_TLSAUTH_TYPE,\n                          config->proxy_tls_authtype);\n        }\n\n        /* new in 7.22.0 */\n        if(config->gssapi_delegation)\n          my_setopt_str(curl, CURLOPT_GSSAPI_DELEGATION,\n                        config->gssapi_delegation);\n\n        if(config->mail_auth)\n          my_setopt_str(curl, CURLOPT_MAIL_AUTH, config->mail_auth);\n\n        /* new in 7.66.0 */\n        if(config->sasl_authzid)\n          my_setopt_str(curl, CURLOPT_SASL_AUTHZID, config->sasl_authzid);\n\n        /* new in 7.31.0 */\n        if(config->sasl_ir)\n          my_setopt(curl, CURLOPT_SASL_IR, 1L);\n\n        if(config->noalpn) {\n          my_setopt(curl, CURLOPT_SSL_ENABLE_ALPN, 0L);\n        }\n\n        /* new in 7.40.0, abstract support added in 7.53.0 */\n        if(config->unix_socket_path) {\n          if(config->abstract_unix_socket) {\n            my_setopt_str(curl, CURLOPT_ABSTRACT_UNIX_SOCKET,\n                          config->unix_socket_path);\n          }\n          else {\n            my_setopt_str(curl, CURLOPT_UNIX_SOCKET_PATH,\n                          config->unix_socket_path);\n          }\n        }\n\n        /* new in 7.45.0 */\n        if(config->proto_default)\n          my_setopt_str(curl, CURLOPT_DEFAULT_PROTOCOL, config->proto_default);\n\n        /* new in 7.47.0 */\n        if(config->expect100timeout_ms > 0)\n          my_setopt_str(curl, CURLOPT_EXPECT_100_TIMEOUT_MS,\n                        config->expect100timeout_ms);\n\n        /* new in 7.48.0 */\n        if(config->tftp_no_options && proto_tftp)\n          my_setopt(curl, CURLOPT_TFTP_NO_OPTIONS, 1L);\n\n        /* new in 7.59.0 */\n        if(config->happy_eyeballs_timeout_ms != CURL_HET_DEFAULT)\n          my_setopt(curl, CURLOPT_HAPPY_EYEBALLS_TIMEOUT_MS,\n                    config->happy_eyeballs_timeout_ms);\n\n        /* new in 7.60.0 */\n        if(config->haproxy_protocol)\n          my_setopt(curl, CURLOPT_HAPROXYPROTOCOL, 1L);\n\n        /* new in 8.2.0 */\n        if(config->haproxy_clientip)\n          my_setopt_str(curl, CURLOPT_HAPROXY_CLIENT_IP,\n              config->haproxy_clientip);\n\n        if(config->disallow_username_in_url)\n          my_setopt(curl, CURLOPT_DISALLOW_USERNAME_IN_URL, 1L);\n\n        if(config->altsvc)\n          my_setopt_str(curl, CURLOPT_ALTSVC, config->altsvc);\n\n        if(config->hsts)\n          my_setopt_str(curl, CURLOPT_HSTS, config->hsts);\n\n        /* initialize retry vars for loop below */\n        per->retry_sleep_default = (config->retry_delay) ?\n          config->retry_delay*1000L : RETRY_SLEEP_DEFAULT; /* ms */\n        per->retry_numretries = config->req_retry;\n        per->retry_sleep = per->retry_sleep_default; /* ms */\n        per->retrystart = tvnow();\n\n        state->li++;\n        /* Here's looping around each globbed URL */\n        if(state->li >= urlnum) {\n          state->li = 0;\n          state->urlnum = 0; /* forced reglob of URLs */\n          glob_cleanup(state->urls);\n          state->urls = NULL;\n          state->up++;\n          Curl_safefree(state->uploadfile); /* clear it to get the next */\n        }\n      }\n      else {\n        /* Free this URL node data without destroying the\n           node itself nor modifying next pointer. */\n        Curl_safefree(urlnode->outfile);\n        Curl_safefree(urlnode->infile);\n        urlnode->flags = 0;\n        glob_cleanup(state->urls);\n        state->urls = NULL;\n        state->urlnum = 0;\n\n        Curl_safefree(state->outfiles);\n        Curl_safefree(state->uploadfile);\n        if(state->inglob) {\n          /* Free list of globbed upload files */\n          glob_cleanup(state->inglob);\n          state->inglob = NULL;\n        }\n        config->state.urlnode = urlnode->next;\n        state->up = 0;\n        continue;\n      }\n    }\n    break;\n  }\n  Curl_safefree(state->outfiles);\n\n  if(!*added || result) {\n    *added = FALSE;\n    single_transfer_cleanup(config);\n  }\n  return result;\n}\n\nstatic long all_added; /* number of easy handles currently added */\n\n/*\n * add_parallel_transfers() sets 'morep' to TRUE if there are more transfers\n * to add even after this call returns. sets 'addedp' to TRUE if one or more\n * transfers were added.\n */\nstatic CURLcode add_parallel_transfers(struct GlobalConfig *global,\n                                       CURLM *multi,\n                                       CURLSH *share,\n                                       bool *morep,\n                                       bool *addedp)\n{\n  struct per_transfer *per;\n  CURLcode result = CURLE_OK;\n  CURLMcode mcode;\n  bool sleeping = FALSE;\n  char *errorbuf;\n  *addedp = FALSE;\n  *morep = FALSE;\n  if(all_pers < (global->parallel_max*2)) {\n    result = create_transfer(global, share, addedp);\n    if(result)\n      return result;\n  }\n  for(per = transfers; per && (all_added < global->parallel_max);\n      per = per->next) {\n    bool getadded = FALSE;\n    if(per->added)\n      /* already added */\n      continue;\n    if(per->startat && (time(NULL) < per->startat)) {\n      /* this is still delaying */\n      sleeping = TRUE;\n      continue;\n    }\n    per->added = TRUE;\n\n    result = pre_transfer(global, per);\n    if(result)\n      return result;\n\n    errorbuf = malloc(CURL_ERROR_SIZE);\n    if(!errorbuf)\n      return CURLE_OUT_OF_MEMORY;\n\n    /* parallel connect means that we don't set PIPEWAIT since pipewait\n       will make libcurl prefer multiplexing */\n    (void)curl_easy_setopt(per->curl, CURLOPT_PIPEWAIT,\n                           global->parallel_connect ? 0L : 1L);\n    (void)curl_easy_setopt(per->curl, CURLOPT_PRIVATE, per);\n    (void)curl_easy_setopt(per->curl, CURLOPT_XFERINFOFUNCTION, xferinfo_cb);\n    (void)curl_easy_setopt(per->curl, CURLOPT_XFERINFODATA, per);\n    (void)curl_easy_setopt(per->curl, CURLOPT_NOPROGRESS, 0L);\n\n    mcode = curl_multi_add_handle(multi, per->curl);\n    if(mcode) {\n      DEBUGASSERT(mcode == CURLM_OUT_OF_MEMORY);\n      result = CURLE_OUT_OF_MEMORY;\n    }\n\n    if(!result)\n      result = create_transfer(global, share, &getadded);\n    if(result) {\n      free(errorbuf);\n      return result;\n    }\n    errorbuf[0] = 0;\n    (void)curl_easy_setopt(per->curl, CURLOPT_ERRORBUFFER, errorbuf);\n    per->errorbuffer = errorbuf;\n    per->added = TRUE;\n    all_added++;\n    *addedp = TRUE;\n  }\n  *morep = (per || sleeping) ? TRUE : FALSE;\n  return CURLE_OK;\n}\n\nstatic CURLcode parallel_transfers(struct GlobalConfig *global,\n                                   CURLSH *share)\n{\n  CURLM *multi;\n  CURLMcode mcode = CURLM_OK;\n  CURLcode result = CURLE_OK;\n  int still_running = 1;\n  struct timeval start = tvnow();\n  bool more_transfers;\n  bool added_transfers;\n  /* wrapitup is set TRUE after a critical error occurs to end all transfers */\n  bool wrapitup = FALSE;\n  /* wrapitup_processed is set TRUE after the per transfer abort flag is set */\n  bool wrapitup_processed = FALSE;\n  time_t tick = time(NULL);\n\n  multi = curl_multi_init();\n  if(!multi)\n    return CURLE_OUT_OF_MEMORY;\n\n  result = add_parallel_transfers(global, multi, share,\n                                  &more_transfers, &added_transfers);\n  if(result) {\n    curl_multi_cleanup(multi);\n    return result;\n  }\n\n  while(!mcode && (still_running || more_transfers)) {\n    /* If stopping prematurely (eg due to a --fail-early condition) then signal\n       that any transfers in the multi should abort (via progress callback). */\n    if(wrapitup) {\n      if(!still_running)\n        break;\n      if(!wrapitup_processed) {\n        struct per_transfer *per;\n        for(per = transfers; per; per = per->next) {\n          if(per->added)\n            per->abort = TRUE;\n        }\n        wrapitup_processed = TRUE;\n      }\n    }\n\n    mcode = curl_multi_poll(multi, NULL, 0, 1000, NULL);\n    if(!mcode)\n      mcode = curl_multi_perform(multi, &still_running);\n\n    progress_meter(global, &start, FALSE);\n\n    if(!mcode) {\n      int rc;\n      CURLMsg *msg;\n      bool checkmore = FALSE;\n      do {\n        msg = curl_multi_info_read(multi, &rc);\n        if(msg) {\n          bool retry;\n          long delay;\n          struct per_transfer *ended;\n          CURL *easy = msg->easy_handle;\n          CURLcode tres = msg->data.result;\n          curl_easy_getinfo(easy, CURLINFO_PRIVATE, (void *)&ended);\n          curl_multi_remove_handle(multi, easy);\n\n          if(ended->abort && (tres == CURLE_ABORTED_BY_CALLBACK) &&\n             ended->errorbuffer) {\n            msnprintf(ended->errorbuffer, CURL_ERROR_SIZE,\n                      \"Transfer aborted due to critical error \"\n                      \"in another transfer\");\n          }\n          tres = post_per_transfer(global, ended, tres, &retry, &delay);\n          progress_finalize(ended); /* before it goes away */\n          all_added--; /* one fewer added */\n          checkmore = TRUE;\n          if(retry) {\n            ended->added = FALSE; /* add it again */\n            /* we delay retries in full integer seconds only */\n            ended->startat = delay ? time(NULL) + delay/1000 : 0;\n          }\n          else {\n            /* result receives this transfer's error unless the transfer was\n               marked for abort due to a critical error in another transfer */\n            if(tres && (!ended->abort || !result))\n              result = tres;\n            if(is_fatal_error(result) || (result && global->fail_early))\n              wrapitup = TRUE;\n            (void)del_per_transfer(ended);\n          }\n        }\n      } while(msg);\n      if(wrapitup) {\n        if(still_running)\n          continue;\n        else\n          break;\n      }\n      if(!checkmore) {\n        time_t tock = time(NULL);\n        if(tick != tock) {\n          checkmore = TRUE;\n          tick = tock;\n        }\n      }\n      if(checkmore) {\n        /* one or more transfers completed, add more! */\n        CURLcode tres = add_parallel_transfers(global, multi, share,\n                                               &more_transfers,\n                                               &added_transfers);\n        if(tres)\n          result = tres;\n        if(added_transfers)\n          /* we added new ones, make sure the loop doesn't exit yet */\n          still_running = 1;\n      }\n      if(is_fatal_error(result) || (result && global->fail_early))\n        wrapitup = TRUE;\n    }\n  }\n\n  (void)progress_meter(global, &start, TRUE);\n\n  /* Make sure to return some kind of error if there was a multi problem */\n  if(mcode) {\n    result = (mcode == CURLM_OUT_OF_MEMORY) ? CURLE_OUT_OF_MEMORY :\n      /* The other multi errors should never happen, so return\n         something suitably generic */\n      CURLE_BAD_FUNCTION_ARGUMENT;\n  }\n\n  curl_multi_cleanup(multi);\n\n  return result;\n}\n\nstatic CURLcode serial_transfers(struct GlobalConfig *global,\n                                 CURLSH *share)\n{\n  CURLcode returncode = CURLE_OK;\n  CURLcode result = CURLE_OK;\n  struct per_transfer *per;\n  bool added = FALSE;\n\n  result = create_transfer(global, share, &added);\n  if(result)\n    return result;\n  if(!added) {\n    errorf(global, \"no transfer performed\");\n    return CURLE_READ_ERROR;\n  }\n  for(per = transfers; per;) {\n    bool retry;\n    long delay_ms;\n    bool bailout = FALSE;\n    struct timeval start;\n    result = pre_transfer(global, per);\n    if(result)\n      break;\n\n    if(global->libcurl) {\n      result = easysrc_perform();\n      if(result)\n        break;\n    }\n    start = tvnow();\n#ifdef CURLDEBUG\n    if(global->test_event_based)\n      result = curl_easy_perform_ev(per->curl);\n    else\n#endif\n      result = curl_easy_perform(per->curl);\n\n    returncode = post_per_transfer(global, per, result, &retry, &delay_ms);\n    if(retry) {\n      tool_go_sleep(delay_ms);\n      continue;\n    }\n\n    /* Bail out upon critical errors or --fail-early */\n    if(is_fatal_error(returncode) || (returncode && global->fail_early))\n      bailout = TRUE;\n    else {\n      /* setup the next one just before we delete this */\n      result = create_transfer(global, share, &added);\n      if(result) {\n        returncode = result;\n        bailout = TRUE;\n      }\n    }\n\n    per = del_per_transfer(per);\n\n    if(bailout)\n      break;\n\n    if(per && global->ms_per_transfer) {\n      /* how long time did the most recent transfer take in number of\n         milliseconds */\n      long milli = tvdiff(tvnow(), start);\n      if(milli < global->ms_per_transfer) {\n        notef(global, \"Transfer took %ld ms, waits %ldms as set by --rate\",\n              milli, global->ms_per_transfer - milli);\n        /* The transfer took less time than wanted. Wait a little. */\n        tool_go_sleep(global->ms_per_transfer - milli);\n      }\n    }\n  }\n  if(returncode)\n    /* returncode errors have priority */\n    result = returncode;\n\n  if(result)\n    single_transfer_cleanup(global->current);\n\n  return result;\n}\n\n/* setup a transfer for the given config */\nstatic CURLcode transfer_per_config(struct GlobalConfig *global,\n                                    struct OperationConfig *config,\n                                    CURLSH *share,\n                                    bool *added)\n{\n  CURLcode result = CURLE_OK;\n  bool capath_from_env;\n  *added = FALSE;\n\n  /* Check we have a url */\n  if(!config->url_list || !config->url_list->url) {\n    helpf(tool_stderr, \"(%d) no URL specified\", CURLE_FAILED_INIT);\n    return CURLE_FAILED_INIT;\n  }\n\n  /* On WIN32 we can't set the path to curl-ca-bundle.crt\n   * at compile time. So we look here for the file in two ways:\n   * 1: look at the environment variable CURL_CA_BUNDLE for a path\n   * 2: if #1 isn't found, use the windows API function SearchPath()\n   *    to find it along the app's path (includes app's dir and CWD)\n   *\n   * We support the environment variable thing for non-Windows platforms\n   * too. Just for the sake of it.\n   */\n  capath_from_env = false;\n  if(!config->cacert &&\n     !config->capath &&\n     (!config->insecure_ok || (config->doh_url && !config->doh_insecure_ok))) {\n    CURL *curltls = curl_easy_init();\n    struct curl_tlssessioninfo *tls_backend_info = NULL;\n\n    /* With the addition of CAINFO support for Schannel, this search could find\n     * a certificate bundle that was previously ignored. To maintain backward\n     * compatibility, only perform this search if not using Schannel.\n     */\n    result = curl_easy_getinfo(curltls, CURLINFO_TLS_SSL_PTR,\n                               &tls_backend_info);\n    if(result) {\n      curl_easy_cleanup(curltls);\n      return result;\n    }\n\n    /* Set the CA cert locations specified in the environment. For Windows if\n     * no environment-specified filename is found then check for CA bundle\n     * default filename curl-ca-bundle.crt in the user's PATH.\n     *\n     * If Schannel is the selected SSL backend then these locations are\n     * ignored. We allow setting CA location for schannel only when explicitly\n     * specified by the user via CURLOPT_CAINFO / --cacert.\n     */\n    if(tls_backend_info->backend != CURLSSLBACKEND_SCHANNEL) {\n      char *env;\n      env = curlx_getenv(\"CURL_CA_BUNDLE\");\n      if(env) {\n        config->cacert = strdup(env);\n        if(!config->cacert) {\n          curl_free(env);\n          curl_easy_cleanup(curltls);\n          errorf(global, \"out of memory\");\n          return CURLE_OUT_OF_MEMORY;\n        }\n      }\n      else {\n        env = curlx_getenv(\"SSL_CERT_DIR\");\n        if(env) {\n          config->capath = strdup(env);\n          if(!config->capath) {\n            curl_free(env);\n            curl_easy_cleanup(curltls);\n            errorf(global, \"out of memory\");\n            return CURLE_OUT_OF_MEMORY;\n          }\n          curl_free(env);\n          capath_from_env = true;\n        }\n        env = curlx_getenv(\"SSL_CERT_FILE\");\n        if(env) {\n          config->cacert = strdup(env);\n          if(!config->cacert) {\n            curl_free(env);\n            if(capath_from_env)\n              free(config->capath);\n            curl_easy_cleanup(curltls);\n            errorf(global, \"out of memory\");\n            return CURLE_OUT_OF_MEMORY;\n          }\n        }\n      }\n\n      if(env)\n        curl_free(env);\n#ifdef _WIN32\n      else {\n        result = FindWin32CACert(config, tls_backend_info->backend,\n                                 TEXT(\"curl-ca-bundle.crt\"));\n      }\n#endif\n    }\n    curl_easy_cleanup(curltls);\n  }\n\n  if(!result)\n    result = single_transfer(global, config, share, capath_from_env, added);\n\n  return result;\n}\n\n/*\n * 'create_transfer' gets the details and sets up a new transfer if 'added'\n * returns TRUE.\n */\nstatic CURLcode create_transfer(struct GlobalConfig *global,\n                                CURLSH *share,\n                                bool *added)\n{\n  CURLcode result = CURLE_OK;\n  *added = FALSE;\n  while(global->current) {\n    result = transfer_per_config(global, global->current, share, added);\n    if(!result && !*added) {\n      /* when one set is drained, continue to next */\n      global->current = global->current->next;\n      continue;\n    }\n    break;\n  }\n  return result;\n}\n\nstatic CURLcode run_all_transfers(struct GlobalConfig *global,\n                                  CURLSH *share,\n                                  CURLcode result)\n{\n  /* Save the values of noprogress and isatty to restore them later on */\n  bool orig_noprogress = global->noprogress;\n  bool orig_isatty = global->isatty;\n  struct per_transfer *per;\n\n  /* Time to actually do the transfers */\n  if(!result) {\n    if(global->parallel)\n      result = parallel_transfers(global, share);\n    else\n      result = serial_transfers(global, share);\n  }\n\n  /* cleanup if there are any left */\n  for(per = transfers; per;) {\n    bool retry;\n    long delay;\n    CURLcode result2 = post_per_transfer(global, per, result, &retry, &delay);\n    if(!result)\n      /* don't overwrite the original error */\n      result = result2;\n\n    /* Free list of given URLs */\n    clean_getout(per->config);\n\n    per = del_per_transfer(per);\n  }\n\n  /* Reset the global config variables */\n  global->noprogress = orig_noprogress;\n  global->isatty = orig_isatty;\n\n\n  return result;\n}\n\nCURLcode operate(struct GlobalConfig *global, int argc, argv_item_t argv[])\n{\n  CURLcode result = CURLE_OK;\n  char *first_arg = argc > 1 ? curlx_convert_tchar_to_UTF8(argv[1]) : NULL;\n\n#ifdef HAVE_SETLOCALE\n  /* Override locale for number parsing (only) */\n  setlocale(LC_ALL, \"\");\n  setlocale(LC_NUMERIC, \"C\");\n#endif\n\n  /* Parse .curlrc if necessary */\n  if((argc == 1) ||\n     (first_arg && strncmp(first_arg, \"-q\", 2) &&\n      !curl_strequal(first_arg, \"--disable\"))) {\n    parseconfig(NULL, global); /* ignore possible failure */\n\n    /* If we had no arguments then make sure a url was specified in .curlrc */\n    if((argc < 2) && (!global->first->url_list)) {\n      helpf(tool_stderr, NULL);\n      result = CURLE_FAILED_INIT;\n    }\n  }\n\n  curlx_unicodefree(first_arg);\n\n  if(!result) {\n    /* Parse the command line arguments */\n    ParameterError res = parse_args(global, argc, argv);\n    if(res) {\n      result = CURLE_OK;\n\n      /* Check if we were asked for the help */\n      if(res == PARAM_HELP_REQUESTED)\n        tool_help(global->help_category);\n      /* Check if we were asked for the manual */\n      else if(res == PARAM_MANUAL_REQUESTED)\n        hugehelp();\n      /* Check if we were asked for the version information */\n      else if(res == PARAM_VERSION_INFO_REQUESTED)\n        tool_version_info();\n      /* Check if we were asked to list the SSL engines */\n      else if(res == PARAM_ENGINES_REQUESTED)\n        tool_list_engines();\n      else if(res == PARAM_LIBCURL_UNSUPPORTED_PROTOCOL)\n        result = CURLE_UNSUPPORTED_PROTOCOL;\n      else if(res == PARAM_READ_ERROR)\n        result = CURLE_READ_ERROR;\n      else\n        result = CURLE_FAILED_INIT;\n    }\n    else {\n      if(global->libcurl) {\n        /* Initialise the libcurl source output */\n        result = easysrc_init();\n      }\n\n      /* Perform the main operations */\n      if(!result) {\n        size_t count = 0;\n        struct OperationConfig *operation = global->first;\n        CURLSH *share = curl_share_init();\n        if(!share) {\n          if(global->libcurl) {\n            /* Cleanup the libcurl source output */\n            easysrc_cleanup();\n          }\n          result = CURLE_OUT_OF_MEMORY;\n        }\n\n        if(!result) {\n          curl_share_setopt(share, CURLSHOPT_SHARE, CURL_LOCK_DATA_COOKIE);\n          curl_share_setopt(share, CURLSHOPT_SHARE, CURL_LOCK_DATA_DNS);\n          curl_share_setopt(share, CURLSHOPT_SHARE,\n                            CURL_LOCK_DATA_SSL_SESSION);\n          curl_share_setopt(share, CURLSHOPT_SHARE, CURL_LOCK_DATA_CONNECT);\n          curl_share_setopt(share, CURLSHOPT_SHARE, CURL_LOCK_DATA_PSL);\n          curl_share_setopt(share, CURLSHOPT_SHARE, CURL_LOCK_DATA_HSTS);\n\n          /* Get the required arguments for each operation */\n          do {\n            result = get_args(operation, count++);\n\n            operation = operation->next;\n          } while(!result && operation);\n\n          /* Set the current operation pointer */\n          global->current = global->first;\n\n          /* now run! */\n          result = run_all_transfers(global, share, result);\n\n          curl_share_cleanup(share);\n          if(global->libcurl) {\n            /* Cleanup the libcurl source output */\n            easysrc_cleanup();\n\n            /* Dump the libcurl code if previously enabled */\n            dumpeasysrc(global);\n          }\n        }\n      }\n      else\n        errorf(global, \"out of memory\");\n    }\n  }\n\n  varcleanup(global);\n\n  return result;\n}\n` was unexpected","path":"/home/qqq/curl-8.7.0/src/tool_operate.c"},{"code":3,"level":"warn","type":"Syntax error","message":"Syntax error at line /home/qqq/curl-8.7.0/include/curl/curl.h:1:\n `#ifndef CURLINC_CURL_H\n#define CURLINC_CURL_H\n/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n * SPDX-License-Identifier: curl\n *\n ***************************************************************************/\n\n/*\n * If you have libcurl problems, all docs and details are found here:\n *   https://curl.se/libcurl/\n */\n\n#ifdef CURL_NO_OLDIES\n#define CURL_STRICTER\n#endif\n\n/* Compile-time deprecation macros. */\n#if defined(__GNUC__) &&                                                \\\n  ((__GNUC__ > 12) || ((__GNUC__ == 12) && (__GNUC_MINOR__ >= 1 ))) &&  \\\n  !defined(__INTEL_COMPILER) &&                                         \\\n  !defined(CURL_DISABLE_DEPRECATION) && !defined(BUILDING_LIBCURL)\n#define CURL_DEPRECATED(version, message)                       \\\n  __attribute__((deprecated(\"since \" # version \". \" message)))\n#define CURL_IGNORE_DEPRECATION(statements) \\\n      _Pragma(\"GCC diagnostic push\") \\\n      _Pragma(\"GCC diagnostic ignored \\\"-Wdeprecated-declarations\\\"\") \\\n      statements \\\n      _Pragma(\"GCC diagnostic pop\")\n#else\n#define CURL_DEPRECATED(version, message)\n#define CURL_IGNORE_DEPRECATION(statements)     statements\n#endif\n\n#include \"curlver.h\"         /* libcurl version defines   */\n#include \"system.h\"          /* determine things run-time */\n\n#include <stdio.h>\n#include <limits.h>\n\n#if defined(__FreeBSD__) || defined(__MidnightBSD__)\n/* Needed for __FreeBSD_version or __MidnightBSD_version symbol definition */\n#include <sys/param.h>\n#endif\n\n/* The include stuff here below is mainly for time_t! */\n#include <sys/types.h>\n#include <time.h>\n\n#if defined(_WIN32) && !defined(_WIN32_WCE) && !defined(__CYGWIN__)\n#if !(defined(_WINSOCKAPI_) || defined(_WINSOCK_H) || \\\n      defined(__LWIP_OPT_H__) || defined(LWIP_HDR_OPT_H))\n/* The check above prevents the winsock2 inclusion if winsock.h already was\n   included, since they can't co-exist without problems */\n#include <winsock2.h>\n#include <ws2tcpip.h>\n#endif\n#endif\n\n/* HP-UX systems version 9, 10 and 11 lack sys/select.h and so does oldish\n   libc5-based Linux systems. Only include it on systems that are known to\n   require it! */\n#if defined(_AIX) || defined(__NOVELL_LIBC__) || defined(__NetBSD__) || \\\n    defined(__minix) || defined(__INTEGRITY) || \\\n    defined(ANDROID) || defined(__ANDROID__) || defined(__OpenBSD__) || \\\n    defined(__CYGWIN__) || defined(AMIGA) || defined(__NuttX__) || \\\n   (defined(__FreeBSD_version) && (__FreeBSD_version < 800000)) || \\\n   (defined(__MidnightBSD_version) && (__MidnightBSD_version < 100000)) || \\\n    defined(__sun__) || defined(__serenity__) || defined(__vxworks__)\n#include <sys/select.h>\n#endif\n\n#if !defined(_WIN32) && !defined(_WIN32_WCE)\n#include <sys/socket.h>\n#endif\n\n#if !defined(_WIN32)\n#include <sys/time.h>\n#endif\n\n/* Compatibility for non-Clang compilers */\n#ifndef __has_declspec_attribute\n#  define __has_declspec_attribute(x) 0\n#endif\n\n#ifdef  __cplusplus\nextern \"C\" {\n#endif\n\n#if defined(BUILDING_LIBCURL) || defined(CURL_STRICTER)\ntypedef struct Curl_easy CURL;\ntypedef struct Curl_share CURLSH;\n#else\ntypedef void CURL;\ntypedef void CURLSH;\n#endif\n\n/*\n * libcurl external API function linkage decorations.\n */\n\n#ifdef CURL_STATICLIB\n#  define CURL_EXTERN\n#elif defined(_WIN32) || \\\n     (__has_declspec_attribute(dllexport) && \\\n      __has_declspec_attribute(dllimport))\n#  if defined(BUILDING_LIBCURL)\n#    define CURL_EXTERN  __declspec(dllexport)\n#  else\n#    define CURL_EXTERN  __declspec(dllimport)\n#  endif\n#elif defined(BUILDING_LIBCURL) && defined(CURL_HIDDEN_SYMBOLS)\n#  define CURL_EXTERN CURL_EXTERN_SYMBOL\n#else\n#  define CURL_EXTERN\n#endif\n\n#ifndef curl_socket_typedef\n/* socket typedef */\n#if defined(_WIN32) && !defined(__LWIP_OPT_H__) && !defined(LWIP_HDR_OPT_H)\ntypedef SOCKET curl_socket_t;\n#define CURL_SOCKET_BAD INVALID_SOCKET\n#else\ntypedef int curl_socket_t;\n#define CURL_SOCKET_BAD -1\n#endif\n#define curl_socket_typedef\n#endif /* curl_socket_typedef */\n\n/* enum for the different supported SSL backends */\ntypedef enum {\n  CURLSSLBACKEND_NONE = 0,\n  CURLSSLBACKEND_OPENSSL = 1,\n  CURLSSLBACKEND_GNUTLS = 2,\n  CURLSSLBACKEND_NSS                    CURL_DEPRECATED(8.3.0, \"\") = 3,\n  CURLSSLBACKEND_OBSOLETE4 = 4,  /* Was QSOSSL. */\n  CURLSSLBACKEND_GSKIT                  CURL_DEPRECATED(8.3.0, \"\") = 5,\n  CURLSSLBACKEND_POLARSSL               CURL_DEPRECATED(7.69.0, \"\") = 6,\n  CURLSSLBACKEND_WOLFSSL = 7,\n  CURLSSLBACKEND_SCHANNEL = 8,\n  CURLSSLBACKEND_SECURETRANSPORT = 9,\n  CURLSSLBACKEND_AXTLS                  CURL_DEPRECATED(7.61.0, \"\") = 10,\n  CURLSSLBACKEND_MBEDTLS = 11,\n  CURLSSLBACKEND_MESALINK               CURL_DEPRECATED(7.82.0, \"\") = 12,\n  CURLSSLBACKEND_BEARSSL = 13,\n  CURLSSLBACKEND_RUSTLS = 14\n} curl_sslbackend;\n\n/* aliases for library clones and renames */\n#define CURLSSLBACKEND_AWSLC CURLSSLBACKEND_OPENSSL\n#define CURLSSLBACKEND_BORINGSSL CURLSSLBACKEND_OPENSSL\n#define CURLSSLBACKEND_LIBRESSL CURLSSLBACKEND_OPENSSL\n\n/* deprecated names: */\n#define CURLSSLBACKEND_CYASSL CURLSSLBACKEND_WOLFSSL\n#define CURLSSLBACKEND_DARWINSSL CURLSSLBACKEND_SECURETRANSPORT\n\nstruct curl_httppost {\n  struct curl_httppost *next;       /* next entry in the list */\n  char *name;                       /* pointer to allocated name */\n  long namelength;                  /* length of name length */\n  char *contents;                   /* pointer to allocated data contents */\n  long contentslength;              /* length of contents field, see also\n                                       CURL_HTTPPOST_LARGE */\n  char *buffer;                     /* pointer to allocated buffer contents */\n  long bufferlength;                /* length of buffer field */\n  char *contenttype;                /* Content-Type */\n  struct curl_slist *contentheader; /* list of extra headers for this form */\n  struct curl_httppost *more;       /* if one field name has more than one\n                                       file, this link should link to following\n                                       files */\n  long flags;                       /* as defined below */\n\n/* specified content is a file name */\n#define CURL_HTTPPOST_FILENAME (1<<0)\n/* specified content is a file name */\n#define CURL_HTTPPOST_READFILE (1<<1)\n/* name is only stored pointer do not free in formfree */\n#define CURL_HTTPPOST_PTRNAME (1<<2)\n/* contents is only stored pointer do not free in formfree */\n#define CURL_HTTPPOST_PTRCONTENTS (1<<3)\n/* upload file from buffer */\n#define CURL_HTTPPOST_BUFFER (1<<4)\n/* upload file from pointer contents */\n#define CURL_HTTPPOST_PTRBUFFER (1<<5)\n/* upload file contents by using the regular read callback to get the data and\n   pass the given pointer as custom pointer */\n#define CURL_HTTPPOST_CALLBACK (1<<6)\n/* use size in 'contentlen', added in 7.46.0 */\n#define CURL_HTTPPOST_LARGE (1<<7)\n\n  char *showfilename;               /* The file name to show. If not set, the\n                                       actual file name will be used (if this\n                                       is a file part) */\n  void *userp;                      /* custom pointer used for\n                                       HTTPPOST_CALLBACK posts */\n  curl_off_t contentlen;            /* alternative length of contents\n                                       field. Used if CURL_HTTPPOST_LARGE is\n                                       set. Added in 7.46.0 */\n};\n\n\n/* This is a return code for the progress callback that, when returned, will\n   signal libcurl to continue executing the default progress function */\n#define CURL_PROGRESSFUNC_CONTINUE 0x10000001\n\n/* This is the CURLOPT_PROGRESSFUNCTION callback prototype. It is now\n   considered deprecated but was the only choice up until 7.31.0 */\ntypedef int (*curl_progress_callback)(void *clientp,\n                                      double dltotal,\n                                      double dlnow,\n                                      double ultotal,\n                                      double ulnow);\n\n/* This is the CURLOPT_XFERINFOFUNCTION callback prototype. It was introduced\n   in 7.32.0, avoids the use of floating point numbers and provides more\n   detailed information. */\ntypedef int (*curl_xferinfo_callback)(void *clientp,\n                                      curl_off_t dltotal,\n                                      curl_off_t dlnow,\n                                      curl_off_t ultotal,\n                                      curl_off_t ulnow);\n\n#ifndef CURL_MAX_READ_SIZE\n  /* The maximum receive buffer size configurable via CURLOPT_BUFFERSIZE. */\n#define CURL_MAX_READ_SIZE (10*1024*1024)\n#endif\n\n#ifndef CURL_MAX_WRITE_SIZE\n  /* Tests have proven that 20K is a very bad buffer size for uploads on\n     Windows, while 16K for some odd reason performed a lot better.\n     We do the ifndef check to allow this value to easier be changed at build\n     time for those who feel adventurous. The practical minimum is about\n     400 bytes since libcurl uses a buffer of this size as a scratch area\n     (unrelated to network send operations). */\n#define CURL_MAX_WRITE_SIZE 16384\n#endif\n\n#ifndef CURL_MAX_HTTP_HEADER\n/* The only reason to have a max limit for this is to avoid the risk of a bad\n   server feeding libcurl with a never-ending header that will cause reallocs\n   infinitely */\n#define CURL_MAX_HTTP_HEADER (100*1024)\n#endif\n\n/* This is a magic return code for the write callback that, when returned,\n   will signal libcurl to pause receiving on the current transfer. */\n#define CURL_WRITEFUNC_PAUSE 0x10000001\n\n/* This is a magic return code for the write callback that, when returned,\n   will signal an error from the callback. */\n#define CURL_WRITEFUNC_ERROR 0xFFFFFFFF\n\ntypedef size_t (*curl_write_callback)(char *buffer,\n                                      size_t size,\n                                      size_t nitems,\n                                      void *outstream);\n\n/* This callback will be called when a new resolver request is made */\ntypedef int (*curl_resolver_start_callback)(void *resolver_state,\n                                            void *reserved, void *userdata);\n\n/* enumeration of file types */\ntypedef enum {\n  CURLFILETYPE_FILE = 0,\n  CURLFILETYPE_DIRECTORY,\n  CURLFILETYPE_SYMLINK,\n  CURLFILETYPE_DEVICE_BLOCK,\n  CURLFILETYPE_DEVICE_CHAR,\n  CURLFILETYPE_NAMEDPIPE,\n  CURLFILETYPE_SOCKET,\n  CURLFILETYPE_DOOR, /* is possible only on Sun Solaris now */\n\n  CURLFILETYPE_UNKNOWN /* should never occur */\n} curlfiletype;\n\n#define CURLFINFOFLAG_KNOWN_FILENAME    (1<<0)\n#define CURLFINFOFLAG_KNOWN_FILETYPE    (1<<1)\n#define CURLFINFOFLAG_KNOWN_TIME        (1<<2)\n#define CURLFINFOFLAG_KNOWN_PERM        (1<<3)\n#define CURLFINFOFLAG_KNOWN_UID         (1<<4)\n#define CURLFINFOFLAG_KNOWN_GID         (1<<5)\n#define CURLFINFOFLAG_KNOWN_SIZE        (1<<6)\n#define CURLFINFOFLAG_KNOWN_HLINKCOUNT  (1<<7)\n\n/* Information about a single file, used when doing FTP wildcard matching */\nstruct curl_fileinfo {\n  char *filename;\n  curlfiletype filetype;\n  time_t time; /* always zero! */\n  unsigned int perm;\n  int uid;\n  int gid;\n  curl_off_t size;\n  long int hardlinks;\n\n  struct {\n    /* If some of these fields is not NULL, it is a pointer to b_data. */\n    char *time;\n    char *perm;\n    char *user;\n    char *group;\n    char *target; /* pointer to the target filename of a symlink */\n  } strings;\n\n  unsigned int flags;\n\n  /* These are libcurl private struct fields. Previously used by libcurl, so\n     they must never be interfered with. */\n  char *b_data;\n  size_t b_size;\n  size_t b_used;\n};\n\n/* return codes for CURLOPT_CHUNK_BGN_FUNCTION */\n#define CURL_CHUNK_BGN_FUNC_OK      0\n#define CURL_CHUNK_BGN_FUNC_FAIL    1 /* tell the lib to end the task */\n#define CURL_CHUNK_BGN_FUNC_SKIP    2 /* skip this chunk over */\n\n/* if splitting of data transfer is enabled, this callback is called before\n   download of an individual chunk started. Note that parameter \"remains\" works\n   only for FTP wildcard downloading (for now), otherwise is not used */\ntypedef long (*curl_chunk_bgn_callback)(const void *transfer_info,\n                                        void *ptr,\n                                        int remains);\n\n/* return codes for CURLOPT_CHUNK_END_FUNCTION */\n#define CURL_CHUNK_END_FUNC_OK      0\n#define CURL_CHUNK_END_FUNC_FAIL    1 /* tell the lib to end the task */\n\n/* If splitting of data transfer is enabled this callback is called after\n   download of an individual chunk finished.\n   Note! After this callback was set then it have to be called FOR ALL chunks.\n   Even if downloading of this chunk was skipped in CHUNK_BGN_FUNC.\n   This is the reason why we don't need \"transfer_info\" parameter in this\n   callback and we are not interested in \"remains\" parameter too. */\ntypedef long (*curl_chunk_end_callback)(void *ptr);\n\n/* return codes for FNMATCHFUNCTION */\n#define CURL_FNMATCHFUNC_MATCH    0 /* string corresponds to the pattern */\n#define CURL_FNMATCHFUNC_NOMATCH  1 /* pattern doesn't match the string */\n#define CURL_FNMATCHFUNC_FAIL     2 /* an error occurred */\n\n/* callback type for wildcard downloading pattern matching. If the\n   string matches the pattern, return CURL_FNMATCHFUNC_MATCH value, etc. */\ntypedef int (*curl_fnmatch_callback)(void *ptr,\n                                     const char *pattern,\n                                     const char *string);\n\n/* These are the return codes for the seek callbacks */\n#define CURL_SEEKFUNC_OK       0\n#define CURL_SEEKFUNC_FAIL     1 /* fail the entire transfer */\n#define CURL_SEEKFUNC_CANTSEEK 2 /* tell libcurl seeking can't be done, so\n                                    libcurl might try other means instead */\ntypedef int (*curl_seek_callback)(void *instream,\n                                  curl_off_t offset,\n                                  int origin); /* 'whence' */\n\n/* This is a return code for the read callback that, when returned, will\n   signal libcurl to immediately abort the current transfer. */\n#define CURL_READFUNC_ABORT 0x10000000\n/* This is a return code for the read callback that, when returned, will\n   signal libcurl to pause sending data on the current transfer. */\n#define CURL_READFUNC_PAUSE 0x10000001\n\n/* Return code for when the trailing headers' callback has terminated\n   without any errors */\n#define CURL_TRAILERFUNC_OK 0\n/* Return code for when was an error in the trailing header's list and we\n  want to abort the request */\n#define CURL_TRAILERFUNC_ABORT 1\n\ntypedef size_t (*curl_read_callback)(char *buffer,\n                                      size_t size,\n                                      size_t nitems,\n                                      void *instream);\n\ntypedef int (*curl_trailer_callback)(struct curl_slist **list,\n                                      void *userdata);\n\ntypedef enum {\n  CURLSOCKTYPE_IPCXN,  /* socket created for a specific IP connection */\n  CURLSOCKTYPE_ACCEPT, /* socket created by accept() call */\n  CURLSOCKTYPE_LAST    /* never use */\n} curlsocktype;\n\n/* The return code from the sockopt_callback can signal information back\n   to libcurl: */\n#define CURL_SOCKOPT_OK 0\n#define CURL_SOCKOPT_ERROR 1 /* causes libcurl to abort and return\n                                CURLE_ABORTED_BY_CALLBACK */\n#define CURL_SOCKOPT_ALREADY_CONNECTED 2\n\ntypedef int (*curl_sockopt_callback)(void *clientp,\n                                     curl_socket_t curlfd,\n                                     curlsocktype purpose);\n\nstruct curl_sockaddr {\n  int family;\n  int socktype;\n  int protocol;\n  unsigned int addrlen; /* addrlen was a socklen_t type before 7.18.0 but it\n                           turned really ugly and painful on the systems that\n                           lack this type */\n  struct sockaddr addr;\n};\n\ntypedef curl_socket_t\n(*curl_opensocket_callback)(void *clientp,\n                            curlsocktype purpose,\n                            struct curl_sockaddr *address);\n\ntypedef int\n(*curl_closesocket_callback)(void *clientp, curl_socket_t item);\n\ntypedef enum {\n  CURLIOE_OK,            /* I/O operation successful */\n  CURLIOE_UNKNOWNCMD,    /* command was unknown to callback */\n  CURLIOE_FAILRESTART,   /* failed to restart the read */\n  CURLIOE_LAST           /* never use */\n} curlioerr;\n\ntypedef enum {\n  CURLIOCMD_NOP,         /* no operation */\n  CURLIOCMD_RESTARTREAD, /* restart the read stream from start */\n  CURLIOCMD_LAST         /* never use */\n} curliocmd;\n\ntypedef curlioerr (*curl_ioctl_callback)(CURL *handle,\n                                         int cmd,\n                                         void *clientp);\n\n#ifndef CURL_DID_MEMORY_FUNC_TYPEDEFS\n/*\n * The following typedef's are signatures of malloc, free, realloc, strdup and\n * calloc respectively.  Function pointers of these types can be passed to the\n * curl_global_init_mem() function to set user defined memory management\n * callback routines.\n */\ntypedef void *(*curl_malloc_callback)(size_t size);\ntypedef void (*curl_free_callback)(void *ptr);\ntypedef void *(*curl_realloc_callback)(void *ptr, size_t size);\ntypedef char *(*curl_strdup_callback)(const char *str);\ntypedef void *(*curl_calloc_callback)(size_t nmemb, size_t size);\n\n#define CURL_DID_MEMORY_FUNC_TYPEDEFS\n#endif\n\n/* the kind of data that is passed to information_callback */\ntypedef enum {\n  CURLINFO_TEXT = 0,\n  CURLINFO_HEADER_IN,    /* 1 */\n  CURLINFO_HEADER_OUT,   /* 2 */\n  CURLINFO_DATA_IN,      /* 3 */\n  CURLINFO_DATA_OUT,     /* 4 */\n  CURLINFO_SSL_DATA_IN,  /* 5 */\n  CURLINFO_SSL_DATA_OUT, /* 6 */\n  CURLINFO_END\n} curl_infotype;\n\ntypedef int (*curl_debug_callback)\n       (CURL *handle,      /* the handle/transfer this concerns */\n        curl_infotype type, /* what kind of data */\n        char *data,        /* points to the data */\n        size_t size,       /* size of the data pointed to */\n        void *userptr);    /* whatever the user please */\n\n/* This is the CURLOPT_PREREQFUNCTION callback prototype. */\ntypedef int (*curl_prereq_callback)(void *clientp,\n                                    char *conn_primary_ip,\n                                    char *conn_local_ip,\n                                    int conn_primary_port,\n                                    int conn_local_port);\n\n/* Return code for when the pre-request callback has terminated without\n   any errors */\n#define CURL_PREREQFUNC_OK 0\n/* Return code for when the pre-request callback wants to abort the\n   request */\n#define CURL_PREREQFUNC_ABORT 1\n\n/* All possible error codes from all sorts of curl functions. Future versions\n   may return other values, stay prepared.\n\n   Always add new return codes last. Never *EVER* remove any. The return\n   codes must remain the same!\n */\n\ntypedef enum {\n  CURLE_OK = 0,\n  CURLE_UNSUPPORTED_PROTOCOL,    /* 1 */\n  CURLE_FAILED_INIT,             /* 2 */\n  CURLE_URL_MALFORMAT,           /* 3 */\n  CURLE_NOT_BUILT_IN,            /* 4 - [was obsoleted in August 2007 for\n                                    7.17.0, reused in April 2011 for 7.21.5] */\n  CURLE_COULDNT_RESOLVE_PROXY,   /* 5 */\n  CURLE_COULDNT_RESOLVE_HOST,    /* 6 */\n  CURLE_COULDNT_CONNECT,         /* 7 */\n  CURLE_WEIRD_SERVER_REPLY,      /* 8 */\n  CURLE_REMOTE_ACCESS_DENIED,    /* 9 a service was denied by the server\n                                    due to lack of access - when login fails\n                                    this is not returned. */\n  CURLE_FTP_ACCEPT_FAILED,       /* 10 - [was obsoleted in April 2006 for\n                                    7.15.4, reused in Dec 2011 for 7.24.0]*/\n  CURLE_FTP_WEIRD_PASS_REPLY,    /* 11 */\n  CURLE_FTP_ACCEPT_TIMEOUT,      /* 12 - timeout occurred accepting server\n                                    [was obsoleted in August 2007 for 7.17.0,\n                                    reused in Dec 2011 for 7.24.0]*/\n  CURLE_FTP_WEIRD_PASV_REPLY,    /* 13 */\n  CURLE_FTP_WEIRD_227_FORMAT,    /* 14 */\n  CURLE_FTP_CANT_GET_HOST,       /* 15 */\n  CURLE_HTTP2,                   /* 16 - A problem in the http2 framing layer.\n                                    [was obsoleted in August 2007 for 7.17.0,\n                                    reused in July 2014 for 7.38.0] */\n  CURLE_FTP_COULDNT_SET_TYPE,    /* 17 */\n  CURLE_PARTIAL_FILE,            /* 18 */\n  CURLE_FTP_COULDNT_RETR_FILE,   /* 19 */\n  CURLE_OBSOLETE20,              /* 20 - NOT USED */\n  CURLE_QUOTE_ERROR,             /* 21 - quote command failure */\n  CURLE_HTTP_RETURNED_ERROR,     /* 22 */\n  CURLE_WRITE_ERROR,             /* 23 */\n  CURLE_OBSOLETE24,              /* 24 - NOT USED */\n  CURLE_UPLOAD_FAILED,           /* 25 - failed upload \"command\" */\n  CURLE_READ_ERROR,              /* 26 - couldn't open/read from file */\n  CURLE_OUT_OF_MEMORY,           /* 27 */\n  CURLE_OPERATION_TIMEDOUT,      /* 28 - the timeout time was reached */\n  CURLE_OBSOLETE29,              /* 29 - NOT USED */\n  CURLE_FTP_PORT_FAILED,         /* 30 - FTP PORT operation failed */\n  CURLE_FTP_COULDNT_USE_REST,    /* 31 - the REST command failed */\n  CURLE_OBSOLETE32,              /* 32 - NOT USED */\n  CURLE_RANGE_ERROR,             /* 33 - RANGE \"command\" didn't work */\n  CURLE_HTTP_POST_ERROR,         /* 34 */\n  CURLE_SSL_CONNECT_ERROR,       /* 35 - wrong when connecting with SSL */\n  CURLE_BAD_DOWNLOAD_RESUME,     /* 36 - couldn't resume download */\n  CURLE_FILE_COULDNT_READ_FILE,  /* 37 */\n  CURLE_LDAP_CANNOT_BIND,        /* 38 */\n  CURLE_LDAP_SEARCH_FAILED,      /* 39 */\n  CURLE_OBSOLETE40,              /* 40 - NOT USED */\n  CURLE_FUNCTION_NOT_FOUND,      /* 41 - NOT USED starting with 7.53.0 */\n  CURLE_ABORTED_BY_CALLBACK,     /* 42 */\n  CURLE_BAD_FUNCTION_ARGUMENT,   /* 43 */\n  CURLE_OBSOLETE44,              /* 44 - NOT USED */\n  CURLE_INTERFACE_FAILED,        /* 45 - CURLOPT_INTERFACE failed */\n  CURLE_OBSOLETE46,              /* 46 - NOT USED */\n  CURLE_TOO_MANY_REDIRECTS,      /* 47 - catch endless re-direct loops */\n  CURLE_UNKNOWN_OPTION,          /* 48 - User specified an unknown option */\n  CURLE_SETOPT_OPTION_SYNTAX,    /* 49 - Malformed setopt option */\n  CURLE_OBSOLETE50,              /* 50 - NOT USED */\n  CURLE_OBSOLETE51,              /* 51 - NOT USED */\n  CURLE_GOT_NOTHING,             /* 52 - when this is a specific error */\n  CURLE_SSL_ENGINE_NOTFOUND,     /* 53 - SSL crypto engine not found */\n  CURLE_SSL_ENGINE_SETFAILED,    /* 54 - can not set SSL crypto engine as\n                                    default */\n  CURLE_SEND_ERROR,              /* 55 - failed sending network data */\n  CURLE_RECV_ERROR,              /* 56 - failure in receiving network data */\n  CURLE_OBSOLETE57,              /* 57 - NOT IN USE */\n  CURLE_SSL_CERTPROBLEM,         /* 58 - problem with the local certificate */\n  CURLE_SSL_CIPHER,              /* 59 - couldn't use specified cipher */\n  CURLE_PEER_FAILED_VERIFICATION, /* 60 - peer's certificate or fingerprint\n                                     wasn't verified fine */\n  CURLE_BAD_CONTENT_ENCODING,    /* 61 - Unrecognized/bad encoding */\n  CURLE_OBSOLETE62,              /* 62 - NOT IN USE since 7.82.0 */\n  CURLE_FILESIZE_EXCEEDED,       /* 63 - Maximum file size exceeded */\n  CURLE_USE_SSL_FAILED,          /* 64 - Requested FTP SSL level failed */\n  CURLE_SEND_FAIL_REWIND,        /* 65 - Sending the data requires a rewind\n                                    that failed */\n  CURLE_SSL_ENGINE_INITFAILED,   /* 66 - failed to initialise ENGINE */\n  CURLE_LOGIN_DENIED,            /* 67 - user, password or similar was not\n                                    accepted and we failed to login */\n  CURLE_TFTP_NOTFOUND,           /* 68 - file not found on server */\n  CURLE_TFTP_PERM,               /* 69 - permission problem on server */\n  CURLE_REMOTE_DISK_FULL,        /* 70 - out of disk space on server */\n  CURLE_TFTP_ILLEGAL,            /* 71 - Illegal TFTP operation */\n  CURLE_TFTP_UNKNOWNID,          /* 72 - Unknown transfer ID */\n  CURLE_REMOTE_FILE_EXISTS,      /* 73 - File already exists */\n  CURLE_TFTP_NOSUCHUSER,         /* 74 - No such user */\n  CURLE_OBSOLETE75,              /* 75 - NOT IN USE since 7.82.0 */\n  CURLE_OBSOLETE76,              /* 76 - NOT IN USE since 7.82.0 */\n  CURLE_SSL_CACERT_BADFILE,      /* 77 - could not load CACERT file, missing\n                                    or wrong format */\n  CURLE_REMOTE_FILE_NOT_FOUND,   /* 78 - remote file not found */\n  CURLE_SSH,                     /* 79 - error from the SSH layer, somewhat\n                                    generic so the error message will be of\n                                    interest when this has happened */\n\n  CURLE_SSL_SHUTDOWN_FAILED,     /* 80 - Failed to shut down the SSL\n                                    connection */\n  CURLE_AGAIN,                   /* 81 - socket is not ready for send/recv,\n                                    wait till it's ready and try again (Added\n                                    in 7.18.2) */\n  CURLE_SSL_CRL_BADFILE,         /* 82 - could not load CRL file, missing or\n                                    wrong format (Added in 7.19.0) */\n  CURLE_SSL_ISSUER_ERROR,        /* 83 - Issuer check failed.  (Added in\n                                    7.19.0) */\n  CURLE_FTP_PRET_FAILED,         /* 84 - a PRET command failed */\n  CURLE_RTSP_CSEQ_ERROR,         /* 85 - mismatch of RTSP CSeq numbers */\n  CURLE_RTSP_SESSION_ERROR,      /* 86 - mismatch of RTSP Session Ids */\n  CURLE_FTP_BAD_FILE_LIST,       /* 87 - unable to parse FTP file list */\n  CURLE_CHUNK_FAILED,            /* 88 - chunk callback reported error */\n  CURLE_NO_CONNECTION_AVAILABLE, /* 89 - No connection available, the\n                                    session will be queued */\n  CURLE_SSL_PINNEDPUBKEYNOTMATCH, /* 90 - specified pinned public key did not\n                                     match */\n  CURLE_SSL_INVALIDCERTSTATUS,   /* 91 - invalid certificate status */\n  CURLE_HTTP2_STREAM,            /* 92 - stream error in HTTP/2 framing layer\n                                    */\n  CURLE_RECURSIVE_API_CALL,      /* 93 - an api function was called from\n                                    inside a callback */\n  CURLE_AUTH_ERROR,              /* 94 - an authentication function returned an\n                                    error */\n  CURLE_HTTP3,                   /* 95 - An HTTP/3 layer problem */\n  CURLE_QUIC_CONNECT_ERROR,      /* 96 - QUIC connection error */\n  CURLE_PROXY,                   /* 97 - proxy handshake error */\n  CURLE_SSL_CLIENTCERT,          /* 98 - client-side certificate required */\n  CURLE_UNRECOVERABLE_POLL,      /* 99 - poll/select returned fatal error */\n  CURLE_TOO_LARGE,               /* 100 - a value/data met its maximum */\n  CURL_LAST /* never use! */\n} CURLcode;\n\n#ifndef CURL_NO_OLDIES /* define this to test if your app builds with all\n                          the obsolete stuff removed! */\n\n/* Previously obsolete error code reused in 7.38.0 */\n#define CURLE_OBSOLETE16 CURLE_HTTP2\n\n/* Previously obsolete error codes reused in 7.24.0 */\n#define CURLE_OBSOLETE10 CURLE_FTP_ACCEPT_FAILED\n#define CURLE_OBSOLETE12 CURLE_FTP_ACCEPT_TIMEOUT\n\n/*  compatibility with older names */\n#define CURLOPT_ENCODING CURLOPT_ACCEPT_ENCODING\n#define CURLE_FTP_WEIRD_SERVER_REPLY CURLE_WEIRD_SERVER_REPLY\n\n/* The following were added in 7.62.0 */\n#define CURLE_SSL_CACERT CURLE_PEER_FAILED_VERIFICATION\n\n/* The following were added in 7.21.5, April 2011 */\n#define CURLE_UNKNOWN_TELNET_OPTION CURLE_UNKNOWN_OPTION\n\n/* Added for 7.78.0 */\n#define CURLE_TELNET_OPTION_SYNTAX CURLE_SETOPT_OPTION_SYNTAX\n\n/* The following were added in 7.17.1 */\n/* These are scheduled to disappear by 2009 */\n#define CURLE_SSL_PEER_CERTIFICATE CURLE_PEER_FAILED_VERIFICATION\n\n/* The following were added in 7.17.0 */\n/* These are scheduled to disappear by 2009 */\n#define CURLE_OBSOLETE CURLE_OBSOLETE50 /* no one should be using this! */\n#define CURLE_BAD_PASSWORD_ENTERED CURLE_OBSOLETE46\n#define CURLE_BAD_CALLING_ORDER CURLE_OBSOLETE44\n#define CURLE_FTP_USER_PASSWORD_INCORRECT CURLE_OBSOLETE10\n#define CURLE_FTP_CANT_RECONNECT CURLE_OBSOLETE16\n#define CURLE_FTP_COULDNT_GET_SIZE CURLE_OBSOLETE32\n#define CURLE_FTP_COULDNT_SET_ASCII CURLE_OBSOLETE29\n#define CURLE_FTP_WEIRD_USER_REPLY CURLE_OBSOLETE12\n#define CURLE_FTP_WRITE_ERROR CURLE_OBSOLETE20\n#define CURLE_LIBRARY_NOT_FOUND CURLE_OBSOLETE40\n#define CURLE_MALFORMAT_USER CURLE_OBSOLETE24\n#define CURLE_SHARE_IN_USE CURLE_OBSOLETE57\n#define CURLE_URL_MALFORMAT_USER CURLE_NOT_BUILT_IN\n\n#define CURLE_FTP_ACCESS_DENIED CURLE_REMOTE_ACCESS_DENIED\n#define CURLE_FTP_COULDNT_SET_BINARY CURLE_FTP_COULDNT_SET_TYPE\n#define CURLE_FTP_QUOTE_ERROR CURLE_QUOTE_ERROR\n#define CURLE_TFTP_DISKFULL CURLE_REMOTE_DISK_FULL\n#define CURLE_TFTP_EXISTS CURLE_REMOTE_FILE_EXISTS\n#define CURLE_HTTP_RANGE_ERROR CURLE_RANGE_ERROR\n#define CURLE_FTP_SSL_FAILED CURLE_USE_SSL_FAILED\n\n/* The following were added earlier */\n\n#define CURLE_OPERATION_TIMEOUTED CURLE_OPERATION_TIMEDOUT\n#define CURLE_HTTP_NOT_FOUND CURLE_HTTP_RETURNED_ERROR\n#define CURLE_HTTP_PORT_FAILED CURLE_INTERFACE_FAILED\n#define CURLE_FTP_COULDNT_STOR_FILE CURLE_UPLOAD_FAILED\n#define CURLE_FTP_PARTIAL_FILE CURLE_PARTIAL_FILE\n#define CURLE_FTP_BAD_DOWNLOAD_RESUME CURLE_BAD_DOWNLOAD_RESUME\n#define CURLE_LDAP_INVALID_URL CURLE_OBSOLETE62\n#define CURLE_CONV_REQD CURLE_OBSOLETE76\n#define CURLE_CONV_FAILED CURLE_OBSOLETE75\n\n/* This was the error code 50 in 7.7.3 and a few earlier versions, this\n   is no longer used by libcurl but is instead #defined here only to not\n   make programs break */\n#define CURLE_ALREADY_COMPLETE 99999\n\n/* Provide defines for really old option names */\n#define CURLOPT_FILE CURLOPT_WRITEDATA /* name changed in 7.9.7 */\n#define CURLOPT_INFILE CURLOPT_READDATA /* name changed in 7.9.7 */\n#define CURLOPT_WRITEHEADER CURLOPT_HEADERDATA\n\n/* Since long deprecated options with no code in the lib that does anything\n   with them. */\n#define CURLOPT_WRITEINFO CURLOPT_OBSOLETE40\n#define CURLOPT_CLOSEPOLICY CURLOPT_OBSOLETE72\n\n#endif /* !CURL_NO_OLDIES */\n\n/*\n * Proxy error codes. Returned in CURLINFO_PROXY_ERROR if CURLE_PROXY was\n * return for the transfers.\n */\ntypedef enum {\n  CURLPX_OK,\n  CURLPX_BAD_ADDRESS_TYPE,\n  CURLPX_BAD_VERSION,\n  CURLPX_CLOSED,\n  CURLPX_GSSAPI,\n  CURLPX_GSSAPI_PERMSG,\n  CURLPX_GSSAPI_PROTECTION,\n  CURLPX_IDENTD,\n  CURLPX_IDENTD_DIFFER,\n  CURLPX_LONG_HOSTNAME,\n  CURLPX_LONG_PASSWD,\n  CURLPX_LONG_USER,\n  CURLPX_NO_AUTH,\n  CURLPX_RECV_ADDRESS,\n  CURLPX_RECV_AUTH,\n  CURLPX_RECV_CONNECT,\n  CURLPX_RECV_REQACK,\n  CURLPX_REPLY_ADDRESS_TYPE_NOT_SUPPORTED,\n  CURLPX_REPLY_COMMAND_NOT_SUPPORTED,\n  CURLPX_REPLY_CONNECTION_REFUSED,\n  CURLPX_REPLY_GENERAL_SERVER_FAILURE,\n  CURLPX_REPLY_HOST_UNREACHABLE,\n  CURLPX_REPLY_NETWORK_UNREACHABLE,\n  CURLPX_REPLY_NOT_ALLOWED,\n  CURLPX_REPLY_TTL_EXPIRED,\n  CURLPX_REPLY_UNASSIGNED,\n  CURLPX_REQUEST_FAILED,\n  CURLPX_RESOLVE_HOST,\n  CURLPX_SEND_AUTH,\n  CURLPX_SEND_CONNECT,\n  CURLPX_SEND_REQUEST,\n  CURLPX_UNKNOWN_FAIL,\n  CURLPX_UNKNOWN_MODE,\n  CURLPX_USER_REJECTED,\n  CURLPX_LAST /* never use */\n} CURLproxycode;\n\n/* This prototype applies to all conversion callbacks */\ntypedef CURLcode (*curl_conv_callback)(char *buffer, size_t length);\n\ntypedef CURLcode (*curl_ssl_ctx_callback)(CURL *curl,    /* easy handle */\n                                          void *ssl_ctx, /* actually an OpenSSL\n                                                            or WolfSSL SSL_CTX,\n                                                            or an mbedTLS\n                                                          mbedtls_ssl_config */\n                                          void *userptr);\n\ntypedef enum {\n  CURLPROXY_HTTP = 0,   /* added in 7.10, new in 7.19.4 default is to use\n                           CONNECT HTTP/1.1 */\n  CURLPROXY_HTTP_1_0 = 1,   /* added in 7.19.4, force to use CONNECT\n                               HTTP/1.0  */\n  CURLPROXY_HTTPS = 2,  /* HTTPS but stick to HTTP/1 added in 7.52.0 */\n  CURLPROXY_HTTPS2 = 3, /* HTTPS and attempt HTTP/2 added in 8.2.0 */\n  CURLPROXY_SOCKS4 = 4, /* support added in 7.15.2, enum existed already\n                           in 7.10 */\n  CURLPROXY_SOCKS5 = 5, /* added in 7.10 */\n  CURLPROXY_SOCKS4A = 6, /* added in 7.18.0 */\n  CURLPROXY_SOCKS5_HOSTNAME = 7 /* Use the SOCKS5 protocol but pass along the\n                                   host name rather than the IP address. added\n                                   in 7.18.0 */\n} curl_proxytype;  /* this enum was added in 7.10 */\n\n/*\n * Bitmasks for CURLOPT_HTTPAUTH and CURLOPT_PROXYAUTH options:\n *\n * CURLAUTH_NONE         - No HTTP authentication\n * CURLAUTH_BASIC        - HTTP Basic authentication (default)\n * CURLAUTH_DIGEST       - HTTP Digest authentication\n * CURLAUTH_NEGOTIATE    - HTTP Negotiate (SPNEGO) authentication\n * CURLAUTH_GSSNEGOTIATE - Alias for CURLAUTH_NEGOTIATE (deprecated)\n * CURLAUTH_NTLM         - HTTP NTLM authentication\n * CURLAUTH_DIGEST_IE    - HTTP Digest authentication with IE flavour\n * CURLAUTH_NTLM_WB      - HTTP NTLM authentication delegated to winbind helper\n * CURLAUTH_BEARER       - HTTP Bearer token authentication\n * CURLAUTH_ONLY         - Use together with a single other type to force no\n *                         authentication or just that single type\n * CURLAUTH_ANY          - All fine types set\n * CURLAUTH_ANYSAFE      - All fine types except Basic\n */\n\n#define CURLAUTH_NONE         ((unsigned long)0)\n#define CURLAUTH_BASIC        (((unsigned long)1)<<0)\n#define CURLAUTH_DIGEST       (((unsigned long)1)<<1)\n#define CURLAUTH_NEGOTIATE    (((unsigned long)1)<<2)\n/* Deprecated since the advent of CURLAUTH_NEGOTIATE */\n#define CURLAUTH_GSSNEGOTIATE CURLAUTH_NEGOTIATE\n/* Used for CURLOPT_SOCKS5_AUTH to stay terminologically correct */\n#define CURLAUTH_GSSAPI CURLAUTH_NEGOTIATE\n#define CURLAUTH_NTLM         (((unsigned long)1)<<3)\n#define CURLAUTH_DIGEST_IE    (((unsigned long)1)<<4)\n#define CURLAUTH_NTLM_WB      (((unsigned long)1)<<5)\n#define CURLAUTH_BEARER       (((unsigned long)1)<<6)\n#define CURLAUTH_AWS_SIGV4    (((unsigned long)1)<<7)\n#define CURLAUTH_ONLY         (((unsigned long)1)<<31)\n#define CURLAUTH_ANY          (~CURLAUTH_DIGEST_IE)\n#define CURLAUTH_ANYSAFE      (~(CURLAUTH_BASIC|CURLAUTH_DIGEST_IE))\n\n#define CURLSSH_AUTH_ANY       ~0     /* all types supported by the server */\n#define CURLSSH_AUTH_NONE      0      /* none allowed, silly but complete */\n#define CURLSSH_AUTH_PUBLICKEY (1<<0) /* public/private key files */\n#define CURLSSH_AUTH_PASSWORD  (1<<1) /* password */\n#define CURLSSH_AUTH_HOST      (1<<2) /* host key files */\n#define CURLSSH_AUTH_KEYBOARD  (1<<3) /* keyboard interactive */\n#define CURLSSH_AUTH_AGENT     (1<<4) /* agent (ssh-agent, pageant...) */\n#define CURLSSH_AUTH_GSSAPI    (1<<5) /* gssapi (kerberos, ...) */\n#define CURLSSH_AUTH_DEFAULT CURLSSH_AUTH_ANY\n\n#define CURLGSSAPI_DELEGATION_NONE        0      /* no delegation (default) */\n#define CURLGSSAPI_DELEGATION_POLICY_FLAG (1<<0) /* if permitted by policy */\n#define CURLGSSAPI_DELEGATION_FLAG        (1<<1) /* delegate always */\n\n#define CURL_ERROR_SIZE 256\n\nenum curl_khtype {\n  CURLKHTYPE_UNKNOWN,\n  CURLKHTYPE_RSA1,\n  CURLKHTYPE_RSA,\n  CURLKHTYPE_DSS,\n  CURLKHTYPE_ECDSA,\n  CURLKHTYPE_ED25519\n};\n\nstruct curl_khkey {\n  const char *key; /* points to a null-terminated string encoded with base64\n                      if len is zero, otherwise to the \"raw\" data */\n  size_t len;\n  enum curl_khtype keytype;\n};\n\n/* this is the set of return values expected from the curl_sshkeycallback\n   callback */\nenum curl_khstat {\n  CURLKHSTAT_FINE_ADD_TO_FILE,\n  CURLKHSTAT_FINE,\n  CURLKHSTAT_REJECT, /* reject the connection, return an error */\n  CURLKHSTAT_DEFER,  /* do not accept it, but we can't answer right now.\n                        Causes a CURLE_PEER_FAILED_VERIFICATION error but the\n                        connection will be left intact etc */\n  CURLKHSTAT_FINE_REPLACE, /* accept and replace the wrong key */\n  CURLKHSTAT_LAST    /* not for use, only a marker for last-in-list */\n};\n\n/* this is the set of status codes pass in to the callback */\nenum curl_khmatch {\n  CURLKHMATCH_OK,       /* match */\n  CURLKHMATCH_MISMATCH, /* host found, key mismatch! */\n  CURLKHMATCH_MISSING,  /* no matching host/key found */\n  CURLKHMATCH_LAST      /* not for use, only a marker for last-in-list */\n};\n\ntypedef int\n  (*curl_sshkeycallback) (CURL *easy,     /* easy handle */\n                          const struct curl_khkey *knownkey, /* known */\n                          const struct curl_khkey *foundkey, /* found */\n                          enum curl_khmatch, /* libcurl's view on the keys */\n                          void *clientp); /* custom pointer passed with */\n                                          /* CURLOPT_SSH_KEYDATA */\n\ntypedef int\n  (*curl_sshhostkeycallback) (void *clientp,/* custom pointer passed */\n                                            /* with CURLOPT_SSH_HOSTKEYDATA */\n                          int keytype, /* CURLKHTYPE */\n                          const char *key, /* hostkey to check */\n                          size_t keylen); /* length of the key */\n                          /* return CURLE_OK to accept */\n                          /* or something else to refuse */\n\n\n/* parameter for the CURLOPT_USE_SSL option */\ntypedef enum {\n  CURLUSESSL_NONE,    /* do not attempt to use SSL */\n  CURLUSESSL_TRY,     /* try using SSL, proceed anyway otherwise */\n  CURLUSESSL_CONTROL, /* SSL for the control connection or fail */\n  CURLUSESSL_ALL,     /* SSL for all communication or fail */\n  CURLUSESSL_LAST     /* not an option, never use */\n} curl_usessl;\n\n/* Definition of bits for the CURLOPT_SSL_OPTIONS argument: */\n\n/* - ALLOW_BEAST tells libcurl to allow the BEAST SSL vulnerability in the\n   name of improving interoperability with older servers. Some SSL libraries\n   have introduced work-arounds for this flaw but those work-arounds sometimes\n   make the SSL communication fail. To regain functionality with those broken\n   servers, a user can this way allow the vulnerability back. */\n#define CURLSSLOPT_ALLOW_BEAST (1<<0)\n\n/* - NO_REVOKE tells libcurl to disable certificate revocation checks for those\n   SSL backends where such behavior is present. */\n#define CURLSSLOPT_NO_REVOKE (1<<1)\n\n/* - NO_PARTIALCHAIN tells libcurl to *NOT* accept a partial certificate chain\n   if possible. The OpenSSL backend has this ability. */\n#define CURLSSLOPT_NO_PARTIALCHAIN (1<<2)\n\n/* - REVOKE_BEST_EFFORT tells libcurl to ignore certificate revocation offline\n   checks and ignore missing revocation list for those SSL backends where such\n   behavior is present. */\n#define CURLSSLOPT_REVOKE_BEST_EFFORT (1<<3)\n\n/* - CURLSSLOPT_NATIVE_CA tells libcurl to use standard certificate store of\n   operating system. Currently implemented under MS-Windows. */\n#define CURLSSLOPT_NATIVE_CA (1<<4)\n\n/* - CURLSSLOPT_AUTO_CLIENT_CERT tells libcurl to automatically locate and use\n   a client certificate for authentication. (Schannel) */\n#define CURLSSLOPT_AUTO_CLIENT_CERT (1<<5)\n\n/* The default connection attempt delay in milliseconds for happy eyeballs.\n   CURLOPT_HAPPY_EYEBALLS_TIMEOUT_MS.3 and happy-eyeballs-timeout-ms.d document\n   this value, keep them in sync. */\n#define CURL_HET_DEFAULT 200L\n\n/* The default connection upkeep interval in milliseconds. */\n#define CURL_UPKEEP_INTERVAL_DEFAULT 60000L\n\n#ifndef CURL_NO_OLDIES /* define this to test if your app builds with all\n                          the obsolete stuff removed! */\n\n/* Backwards compatibility with older names */\n/* These are scheduled to disappear by 2009 */\n\n#define CURLFTPSSL_NONE CURLUSESSL_NONE\n#define CURLFTPSSL_TRY CURLUSESSL_TRY\n#define CURLFTPSSL_CONTROL CURLUSESSL_CONTROL\n#define CURLFTPSSL_ALL CURLUSESSL_ALL\n#define CURLFTPSSL_LAST CURLUSESSL_LAST\n#define curl_ftpssl curl_usessl\n#endif /* !CURL_NO_OLDIES */\n\n/* parameter for the CURLOPT_FTP_SSL_CCC option */\ntypedef enum {\n  CURLFTPSSL_CCC_NONE,    /* do not send CCC */\n  CURLFTPSSL_CCC_PASSIVE, /* Let the server initiate the shutdown */\n  CURLFTPSSL_CCC_ACTIVE,  /* Initiate the shutdown */\n  CURLFTPSSL_CCC_LAST     /* not an option, never use */\n} curl_ftpccc;\n\n/* parameter for the CURLOPT_FTPSSLAUTH option */\ntypedef enum {\n  CURLFTPAUTH_DEFAULT, /* let libcurl decide */\n  CURLFTPAUTH_SSL,     /* use \"AUTH SSL\" */\n  CURLFTPAUTH_TLS,     /* use \"AUTH TLS\" */\n  CURLFTPAUTH_LAST /* not an option, never use */\n} curl_ftpauth;\n\n/* parameter for the CURLOPT_FTP_CREATE_MISSING_DIRS option */\ntypedef enum {\n  CURLFTP_CREATE_DIR_NONE,  /* do NOT create missing dirs! */\n  CURLFTP_CREATE_DIR,       /* (FTP/SFTP) if CWD fails, try MKD and then CWD\n                               again if MKD succeeded, for SFTP this does\n                               similar magic */\n  CURLFTP_CREATE_DIR_RETRY, /* (FTP only) if CWD fails, try MKD and then CWD\n                               again even if MKD failed! */\n  CURLFTP_CREATE_DIR_LAST   /* not an option, never use */\n} curl_ftpcreatedir;\n\n/* parameter for the CURLOPT_FTP_FILEMETHOD option */\ntypedef enum {\n  CURLFTPMETHOD_DEFAULT,   /* let libcurl pick */\n  CURLFTPMETHOD_MULTICWD,  /* single CWD operation for each path part */\n  CURLFTPMETHOD_NOCWD,     /* no CWD at all */\n  CURLFTPMETHOD_SINGLECWD, /* one CWD to full dir, then work on file */\n  CURLFTPMETHOD_LAST       /* not an option, never use */\n} curl_ftpmethod;\n\n/* bitmask defines for CURLOPT_HEADEROPT */\n#define CURLHEADER_UNIFIED  0\n#define CURLHEADER_SEPARATE (1<<0)\n\n/* CURLALTSVC_* are bits for the CURLOPT_ALTSVC_CTRL option */\n#define CURLALTSVC_READONLYFILE (1<<2)\n#define CURLALTSVC_H1           (1<<3)\n#define CURLALTSVC_H2           (1<<4)\n#define CURLALTSVC_H3           (1<<5)\n\n\nstruct curl_hstsentry {\n  char *name;\n  size_t namelen;\n  unsigned int includeSubDomains:1;\n  char expire[18]; /* YYYYMMDD HH:MM:SS [null-terminated] */\n};\n\nstruct curl_index {\n  size_t index; /* the provided entry's \"index\" or count */\n  size_t total; /* total number of entries to save */\n};\n\ntypedef enum {\n  CURLSTS_OK,\n  CURLSTS_DONE,\n  CURLSTS_FAIL\n} CURLSTScode;\n\ntypedef CURLSTScode (*curl_hstsread_callback)(CURL *easy,\n                                              struct curl_hstsentry *e,\n                                              void *userp);\ntypedef CURLSTScode (*curl_hstswrite_callback)(CURL *easy,\n                                               struct curl_hstsentry *e,\n                                               struct curl_index *i,\n                                               void *userp);\n\n/* CURLHSTS_* are bits for the CURLOPT_HSTS option */\n#define CURLHSTS_ENABLE       (long)(1<<0)\n#define CURLHSTS_READONLYFILE (long)(1<<1)\n\n/* The CURLPROTO_ defines below are for the **deprecated** CURLOPT_*PROTOCOLS\n   options. Do not use. */\n#define CURLPROTO_HTTP   (1<<0)\n#define CURLPROTO_HTTPS  (1<<1)\n#define CURLPROTO_FTP    (1<<2)\n#define CURLPROTO_FTPS   (1<<3)\n#define CURLPROTO_SCP    (1<<4)\n#define CURLPROTO_SFTP   (1<<5)\n#define CURLPROTO_TELNET (1<<6)\n#define CURLPROTO_LDAP   (1<<7)\n#define CURLPROTO_LDAPS  (1<<8)\n#define CURLPROTO_DICT   (1<<9)\n#define CURLPROTO_FILE   (1<<10)\n#define CURLPROTO_TFTP   (1<<11)\n#define CURLPROTO_IMAP   (1<<12)\n#define CURLPROTO_IMAPS  (1<<13)\n#define CURLPROTO_POP3   (1<<14)\n#define CURLPROTO_POP3S  (1<<15)\n#define CURLPROTO_SMTP   (1<<16)\n#define CURLPROTO_SMTPS  (1<<17)\n#define CURLPROTO_RTSP   (1<<18)\n#define CURLPROTO_RTMP   (1<<19)\n#define CURLPROTO_RTMPT  (1<<20)\n#define CURLPROTO_RTMPE  (1<<21)\n#define CURLPROTO_RTMPTE (1<<22)\n#define CURLPROTO_RTMPS  (1<<23)\n#define CURLPROTO_RTMPTS (1<<24)\n#define CURLPROTO_GOPHER (1<<25)\n#define CURLPROTO_SMB    (1<<26)\n#define CURLPROTO_SMBS   (1<<27)\n#define CURLPROTO_MQTT   (1<<28)\n#define CURLPROTO_GOPHERS (1<<29)\n#define CURLPROTO_ALL    (~0) /* enable everything */\n\n/* long may be 32 or 64 bits, but we should never depend on anything else\n   but 32 */\n#define CURLOPTTYPE_LONG          0\n#define CURLOPTTYPE_OBJECTPOINT   10000\n#define CURLOPTTYPE_FUNCTIONPOINT 20000\n#define CURLOPTTYPE_OFF_T         30000\n#define CURLOPTTYPE_BLOB          40000\n\n/* *STRINGPOINT is an alias for OBJECTPOINT to allow tools to extract the\n   string options from the header file */\n\n\n#define CURLOPT(na,t,nu) na = t + nu\n#define CURLOPTDEPRECATED(na,t,nu,v,m) na CURL_DEPRECATED(v,m) = t + nu\n\n/* CURLOPT aliases that make no run-time difference */\n\n/* 'char *' argument to a string with a trailing zero */\n#define CURLOPTTYPE_STRINGPOINT CURLOPTTYPE_OBJECTPOINT\n\n/* 'struct curl_slist *' argument */\n#define CURLOPTTYPE_SLISTPOINT  CURLOPTTYPE_OBJECTPOINT\n\n/* 'void *' argument passed untouched to callback */\n#define CURLOPTTYPE_CBPOINT     CURLOPTTYPE_OBJECTPOINT\n\n/* 'long' argument with a set of values/bitmask */\n#define CURLOPTTYPE_VALUES      CURLOPTTYPE_LONG\n\n/*\n * All CURLOPT_* values.\n */\n\ntypedef enum {\n  /* This is the FILE * or void * the regular output should be written to. */\n  CURLOPT(CURLOPT_WRITEDATA, CURLOPTTYPE_CBPOINT, 1),\n\n  /* The full URL to get/put */\n  CURLOPT(CURLOPT_URL, CURLOPTTYPE_STRINGPOINT, 2),\n\n  /* Port number to connect to, if other than default. */\n  CURLOPT(CURLOPT_PORT, CURLOPTTYPE_LONG, 3),\n\n  /* Name of proxy to use. */\n  CURLOPT(CURLOPT_PROXY, CURLOPTTYPE_STRINGPOINT, 4),\n\n  /* \"user:password;options\" to use when fetching. */\n  CURLOPT(CURLOPT_USERPWD, CURLOPTTYPE_STRINGPOINT, 5),\n\n  /* \"user:password\" to use with proxy. */\n  CURLOPT(CURLOPT_PROXYUSERPWD, CURLOPTTYPE_STRINGPOINT, 6),\n\n  /* Range to get, specified as an ASCII string. */\n  CURLOPT(CURLOPT_RANGE, CURLOPTTYPE_STRINGPOINT, 7),\n\n  /* not used */\n\n  /* Specified file stream to upload from (use as input): */\n  CURLOPT(CURLOPT_READDATA, CURLOPTTYPE_CBPOINT, 9),\n\n  /* Buffer to receive error messages in, must be at least CURL_ERROR_SIZE\n   * bytes big. */\n  CURLOPT(CURLOPT_ERRORBUFFER, CURLOPTTYPE_OBJECTPOINT, 10),\n\n  /* Function that will be called to store the output (instead of fwrite). The\n   * parameters will use fwrite() syntax, make sure to follow them. */\n  CURLOPT(CURLOPT_WRITEFUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 11),\n\n  /* Function that will be called to read the input (instead of fread). The\n   * parameters will use fread() syntax, make sure to follow them. */\n  CURLOPT(CURLOPT_READFUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 12),\n\n  /* Time-out the read operation after this amount of seconds */\n  CURLOPT(CURLOPT_TIMEOUT, CURLOPTTYPE_LONG, 13),\n\n  /* If CURLOPT_READDATA is used, this can be used to inform libcurl about\n   * how large the file being sent really is. That allows better error\n   * checking and better verifies that the upload was successful. -1 means\n   * unknown size.\n   *\n   * For large file support, there is also a _LARGE version of the key\n   * which takes an off_t type, allowing platforms with larger off_t\n   * sizes to handle larger files.  See below for INFILESIZE_LARGE.\n   */\n  CURLOPT(CURLOPT_INFILESIZE, CURLOPTTYPE_LONG, 14),\n\n  /* POST static input fields. */\n  CURLOPT(CURLOPT_POSTFIELDS, CURLOPTTYPE_OBJECTPOINT, 15),\n\n  /* Set the referrer page (needed by some CGIs) */\n  CURLOPT(CURLOPT_REFERER, CURLOPTTYPE_STRINGPOINT, 16),\n\n  /* Set the FTP PORT string (interface name, named or numerical IP address)\n     Use i.e '-' to use default address. */\n  CURLOPT(CURLOPT_FTPPORT, CURLOPTTYPE_STRINGPOINT, 17),\n\n  /* Set the User-Agent string (examined by some CGIs) */\n  CURLOPT(CURLOPT_USERAGENT, CURLOPTTYPE_STRINGPOINT, 18),\n\n  /* If the download receives less than \"low speed limit\" bytes/second\n   * during \"low speed time\" seconds, the operations is aborted.\n   * You could i.e if you have a pretty high speed connection, abort if\n   * it is less than 2000 bytes/sec during 20 seconds.\n   */\n\n  /* Set the \"low speed limit\" */\n  CURLOPT(CURLOPT_LOW_SPEED_LIMIT, CURLOPTTYPE_LONG, 19),\n\n  /* Set the \"low speed time\" */\n  CURLOPT(CURLOPT_LOW_SPEED_TIME, CURLOPTTYPE_LONG, 20),\n\n  /* Set the continuation offset.\n   *\n   * Note there is also a _LARGE version of this key which uses\n   * off_t types, allowing for large file offsets on platforms which\n   * use larger-than-32-bit off_t's.  Look below for RESUME_FROM_LARGE.\n   */\n  CURLOPT(CURLOPT_RESUME_FROM, CURLOPTTYPE_LONG, 21),\n\n  /* Set cookie in request: */\n  CURLOPT(CURLOPT_COOKIE, CURLOPTTYPE_STRINGPOINT, 22),\n\n  /* This points to a linked list of headers, struct curl_slist kind. This\n     list is also used for RTSP (in spite of its name) */\n  CURLOPT(CURLOPT_HTTPHEADER, CURLOPTTYPE_SLISTPOINT, 23),\n\n  /* This points to a linked list of post entries, struct curl_httppost */\n  CURLOPTDEPRECATED(CURLOPT_HTTPPOST, CURLOPTTYPE_OBJECTPOINT, 24,\n                    7.56.0, \"Use CURLOPT_MIMEPOST\"),\n\n  /* name of the file keeping your private SSL-certificate */\n  CURLOPT(CURLOPT_SSLCERT, CURLOPTTYPE_STRINGPOINT, 25),\n\n  /* password for the SSL or SSH private key */\n  CURLOPT(CURLOPT_KEYPASSWD, CURLOPTTYPE_STRINGPOINT, 26),\n\n  /* send TYPE parameter? */\n  CURLOPT(CURLOPT_CRLF, CURLOPTTYPE_LONG, 27),\n\n  /* send linked-list of QUOTE commands */\n  CURLOPT(CURLOPT_QUOTE, CURLOPTTYPE_SLISTPOINT, 28),\n\n  /* send FILE * or void * to store headers to, if you use a callback it\n     is simply passed to the callback unmodified */\n  CURLOPT(CURLOPT_HEADERDATA, CURLOPTTYPE_CBPOINT, 29),\n\n  /* point to a file to read the initial cookies from, also enables\n     \"cookie awareness\" */\n  CURLOPT(CURLOPT_COOKIEFILE, CURLOPTTYPE_STRINGPOINT, 31),\n\n  /* What version to specifically try to use.\n     See CURL_SSLVERSION defines below. */\n  CURLOPT(CURLOPT_SSLVERSION, CURLOPTTYPE_VALUES, 32),\n\n  /* What kind of HTTP time condition to use, see defines */\n  CURLOPT(CURLOPT_TIMECONDITION, CURLOPTTYPE_VALUES, 33),\n\n  /* Time to use with the above condition. Specified in number of seconds\n     since 1 Jan 1970 */\n  CURLOPT(CURLOPT_TIMEVALUE, CURLOPTTYPE_LONG, 34),\n\n  /* 35 = OBSOLETE */\n\n  /* Custom request, for customizing the get command like\n     HTTP: DELETE, TRACE and others\n     FTP: to use a different list command\n     */\n  CURLOPT(CURLOPT_CUSTOMREQUEST, CURLOPTTYPE_STRINGPOINT, 36),\n\n  /* FILE handle to use instead of stderr */\n  CURLOPT(CURLOPT_STDERR, CURLOPTTYPE_OBJECTPOINT, 37),\n\n  /* 38 is not used */\n\n  /* send linked-list of post-transfer QUOTE commands */\n  CURLOPT(CURLOPT_POSTQUOTE, CURLOPTTYPE_SLISTPOINT, 39),\n\n   /* OBSOLETE, do not use! */\n  CURLOPT(CURLOPT_OBSOLETE40, CURLOPTTYPE_OBJECTPOINT, 40),\n\n  /* talk a lot */\n  CURLOPT(CURLOPT_VERBOSE, CURLOPTTYPE_LONG, 41),\n\n  /* throw the header out too */\n  CURLOPT(CURLOPT_HEADER, CURLOPTTYPE_LONG, 42),\n\n  /* shut off the progress meter */\n  CURLOPT(CURLOPT_NOPROGRESS, CURLOPTTYPE_LONG, 43),\n\n  /* use HEAD to get http document */\n  CURLOPT(CURLOPT_NOBODY, CURLOPTTYPE_LONG, 44),\n\n  /* no output on http error codes >= 400 */\n  CURLOPT(CURLOPT_FAILONERROR, CURLOPTTYPE_LONG, 45),\n\n  /* this is an upload */\n  CURLOPT(CURLOPT_UPLOAD, CURLOPTTYPE_LONG, 46),\n\n  /* HTTP POST method */\n  CURLOPT(CURLOPT_POST, CURLOPTTYPE_LONG, 47),\n\n  /* bare names when listing directories */\n  CURLOPT(CURLOPT_DIRLISTONLY, CURLOPTTYPE_LONG, 48),\n\n  /* Append instead of overwrite on upload! */\n  CURLOPT(CURLOPT_APPEND, CURLOPTTYPE_LONG, 50),\n\n  /* Specify whether to read the user+password from the .netrc or the URL.\n   * This must be one of the CURL_NETRC_* enums below. */\n  CURLOPT(CURLOPT_NETRC, CURLOPTTYPE_VALUES, 51),\n\n  /* use Location: Luke! */\n  CURLOPT(CURLOPT_FOLLOWLOCATION, CURLOPTTYPE_LONG, 52),\n\n   /* transfer data in text/ASCII format */\n  CURLOPT(CURLOPT_TRANSFERTEXT, CURLOPTTYPE_LONG, 53),\n\n  /* HTTP PUT */\n  CURLOPTDEPRECATED(CURLOPT_PUT, CURLOPTTYPE_LONG, 54,\n                    7.12.1, \"Use CURLOPT_UPLOAD\"),\n\n  /* 55 = OBSOLETE */\n\n  /* DEPRECATED\n   * Function that will be called instead of the internal progress display\n   * function. This function should be defined as the curl_progress_callback\n   * prototype defines. */\n  CURLOPTDEPRECATED(CURLOPT_PROGRESSFUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 56,\n                    7.32.0, \"Use CURLOPT_XFERINFOFUNCTION\"),\n\n  /* Data passed to the CURLOPT_PROGRESSFUNCTION and CURLOPT_XFERINFOFUNCTION\n     callbacks */\n  CURLOPT(CURLOPT_XFERINFODATA, CURLOPTTYPE_CBPOINT, 57),\n#define CURLOPT_PROGRESSDATA CURLOPT_XFERINFODATA\n\n  /* We want the referrer field set automatically when following locations */\n  CURLOPT(CURLOPT_AUTOREFERER, CURLOPTTYPE_LONG, 58),\n\n  /* Port of the proxy, can be set in the proxy string as well with:\n     \"[host]:[port]\" */\n  CURLOPT(CURLOPT_PROXYPORT, CURLOPTTYPE_LONG, 59),\n\n  /* size of the POST input data, if strlen() is not good to use */\n  CURLOPT(CURLOPT_POSTFIELDSIZE, CURLOPTTYPE_LONG, 60),\n\n  /* tunnel non-http operations through an HTTP proxy */\n  CURLOPT(CURLOPT_HTTPPROXYTUNNEL, CURLOPTTYPE_LONG, 61),\n\n  /* Set the interface string to use as outgoing network interface */\n  CURLOPT(CURLOPT_INTERFACE, CURLOPTTYPE_STRINGPOINT, 62),\n\n  /* Set the krb4/5 security level, this also enables krb4/5 awareness.  This\n   * is a string, 'clear', 'safe', 'confidential' or 'private'.  If the string\n   * is set but doesn't match one of these, 'private' will be used.  */\n  CURLOPT(CURLOPT_KRBLEVEL, CURLOPTTYPE_STRINGPOINT, 63),\n\n  /* Set if we should verify the peer in ssl handshake, set 1 to verify. */\n  CURLOPT(CURLOPT_SSL_VERIFYPEER, CURLOPTTYPE_LONG, 64),\n\n  /* The CApath or CAfile used to validate the peer certificate\n     this option is used only if SSL_VERIFYPEER is true */\n  CURLOPT(CURLOPT_CAINFO, CURLOPTTYPE_STRINGPOINT, 65),\n\n  /* 66 = OBSOLETE */\n  /* 67 = OBSOLETE */\n\n  /* Maximum number of http redirects to follow */\n  CURLOPT(CURLOPT_MAXREDIRS, CURLOPTTYPE_LONG, 68),\n\n  /* Pass a long set to 1 to get the date of the requested document (if\n     possible)! Pass a zero to shut it off. */\n  CURLOPT(CURLOPT_FILETIME, CURLOPTTYPE_LONG, 69),\n\n  /* This points to a linked list of telnet options */\n  CURLOPT(CURLOPT_TELNETOPTIONS, CURLOPTTYPE_SLISTPOINT, 70),\n\n  /* Max amount of cached alive connections */\n  CURLOPT(CURLOPT_MAXCONNECTS, CURLOPTTYPE_LONG, 71),\n\n  /* OBSOLETE, do not use! */\n  CURLOPT(CURLOPT_OBSOLETE72, CURLOPTTYPE_LONG, 72),\n\n  /* 73 = OBSOLETE */\n\n  /* Set to explicitly use a new connection for the upcoming transfer.\n     Do not use this unless you're absolutely sure of this, as it makes the\n     operation slower and is less friendly for the network. */\n  CURLOPT(CURLOPT_FRESH_CONNECT, CURLOPTTYPE_LONG, 74),\n\n  /* Set to explicitly forbid the upcoming transfer's connection to be reused\n     when done. Do not use this unless you're absolutely sure of this, as it\n     makes the operation slower and is less friendly for the network. */\n  CURLOPT(CURLOPT_FORBID_REUSE, CURLOPTTYPE_LONG, 75),\n\n  /* Set to a file name that contains random data for libcurl to use to\n     seed the random engine when doing SSL connects. */\n  CURLOPTDEPRECATED(CURLOPT_RANDOM_FILE, CURLOPTTYPE_STRINGPOINT, 76,\n                    7.84.0, \"Serves no purpose anymore\"),\n\n  /* Set to the Entropy Gathering Daemon socket pathname */\n  CURLOPTDEPRECATED(CURLOPT_EGDSOCKET, CURLOPTTYPE_STRINGPOINT, 77,\n                    7.84.0, \"Serves no purpose anymore\"),\n\n  /* Time-out connect operations after this amount of seconds, if connects are\n     OK within this time, then fine... This only aborts the connect phase. */\n  CURLOPT(CURLOPT_CONNECTTIMEOUT, CURLOPTTYPE_LONG, 78),\n\n  /* Function that will be called to store headers (instead of fwrite). The\n   * parameters will use fwrite() syntax, make sure to follow them. */\n  CURLOPT(CURLOPT_HEADERFUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 79),\n\n  /* Set this to force the HTTP request to get back to GET. Only really usable\n     if POST, PUT or a custom request have been used first.\n   */\n  CURLOPT(CURLOPT_HTTPGET, CURLOPTTYPE_LONG, 80),\n\n  /* Set if we should verify the Common name from the peer certificate in ssl\n   * handshake, set 1 to check existence, 2 to ensure that it matches the\n   * provided hostname. */\n  CURLOPT(CURLOPT_SSL_VERIFYHOST, CURLOPTTYPE_LONG, 81),\n\n  /* Specify which file name to write all known cookies in after completed\n     operation. Set file name to \"-\" (dash) to make it go to stdout. */\n  CURLOPT(CURLOPT_COOKIEJAR, CURLOPTTYPE_STRINGPOINT, 82),\n\n  /* Specify which SSL ciphers to use */\n  CURLOPT(CURLOPT_SSL_CIPHER_LIST, CURLOPTTYPE_STRINGPOINT, 83),\n\n  /* Specify which HTTP version to use! This must be set to one of the\n     CURL_HTTP_VERSION* enums set below. */\n  CURLOPT(CURLOPT_HTTP_VERSION, CURLOPTTYPE_VALUES, 84),\n\n  /* Specifically switch on or off the FTP engine's use of the EPSV command. By\n     default, that one will always be attempted before the more traditional\n     PASV command. */\n  CURLOPT(CURLOPT_FTP_USE_EPSV, CURLOPTTYPE_LONG, 85),\n\n  /* type of the file keeping your SSL-certificate (\"DER\", \"PEM\", \"ENG\") */\n  CURLOPT(CURLOPT_SSLCERTTYPE, CURLOPTTYPE_STRINGPOINT, 86),\n\n  /* name of the file keeping your private SSL-key */\n  CURLOPT(CURLOPT_SSLKEY, CURLOPTTYPE_STRINGPOINT, 87),\n\n  /* type of the file keeping your private SSL-key (\"DER\", \"PEM\", \"ENG\") */\n  CURLOPT(CURLOPT_SSLKEYTYPE, CURLOPTTYPE_STRINGPOINT, 88),\n\n  /* crypto engine for the SSL-sub system */\n  CURLOPT(CURLOPT_SSLENGINE, CURLOPTTYPE_STRINGPOINT, 89),\n\n  /* set the crypto engine for the SSL-sub system as default\n     the param has no meaning...\n   */\n  CURLOPT(CURLOPT_SSLENGINE_DEFAULT, CURLOPTTYPE_LONG, 90),\n\n  /* Non-zero value means to use the global dns cache */\n  /* DEPRECATED, do not use! */\n  CURLOPTDEPRECATED(CURLOPT_DNS_USE_GLOBAL_CACHE, CURLOPTTYPE_LONG, 91,\n                    7.11.1, \"Use CURLOPT_SHARE\"),\n\n  /* DNS cache timeout */\n  CURLOPT(CURLOPT_DNS_CACHE_TIMEOUT, CURLOPTTYPE_LONG, 92),\n\n  /* send linked-list of pre-transfer QUOTE commands */\n  CURLOPT(CURLOPT_PREQUOTE, CURLOPTTYPE_SLISTPOINT, 93),\n\n  /* set the debug function */\n  CURLOPT(CURLOPT_DEBUGFUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 94),\n\n  /* set the data for the debug function */\n  CURLOPT(CURLOPT_DEBUGDATA, CURLOPTTYPE_CBPOINT, 95),\n\n  /* mark this as start of a cookie session */\n  CURLOPT(CURLOPT_COOKIESESSION, CURLOPTTYPE_LONG, 96),\n\n  /* The CApath directory used to validate the peer certificate\n     this option is used only if SSL_VERIFYPEER is true */\n  CURLOPT(CURLOPT_CAPATH, CURLOPTTYPE_STRINGPOINT, 97),\n\n  /* Instruct libcurl to use a smaller receive buffer */\n  CURLOPT(CURLOPT_BUFFERSIZE, CURLOPTTYPE_LONG, 98),\n\n  /* Instruct libcurl to not use any signal/alarm handlers, even when using\n     timeouts. This option is useful for multi-threaded applications.\n     See libcurl-the-guide for more background information. */\n  CURLOPT(CURLOPT_NOSIGNAL, CURLOPTTYPE_LONG, 99),\n\n  /* Provide a CURLShare for mutexing non-ts data */\n  CURLOPT(CURLOPT_SHARE, CURLOPTTYPE_OBJECTPOINT, 100),\n\n  /* indicates type of proxy. accepted values are CURLPROXY_HTTP (default),\n     CURLPROXY_HTTPS, CURLPROXY_SOCKS4, CURLPROXY_SOCKS4A and\n     CURLPROXY_SOCKS5. */\n  CURLOPT(CURLOPT_PROXYTYPE, CURLOPTTYPE_VALUES, 101),\n\n  /* Set the Accept-Encoding string. Use this to tell a server you would like\n     the response to be compressed. Before 7.21.6, this was known as\n     CURLOPT_ENCODING */\n  CURLOPT(CURLOPT_ACCEPT_ENCODING, CURLOPTTYPE_STRINGPOINT, 102),\n\n  /* Set pointer to private data */\n  CURLOPT(CURLOPT_PRIVATE, CURLOPTTYPE_OBJECTPOINT, 103),\n\n  /* Set aliases for HTTP 200 in the HTTP Response header */\n  CURLOPT(CURLOPT_HTTP200ALIASES, CURLOPTTYPE_SLISTPOINT, 104),\n\n  /* Continue to send authentication (user+password) when following locations,\n     even when hostname changed. This can potentially send off the name\n     and password to whatever host the server decides. */\n  CURLOPT(CURLOPT_UNRESTRICTED_AUTH, CURLOPTTYPE_LONG, 105),\n\n  /* Specifically switch on or off the FTP engine's use of the EPRT command (\n     it also disables the LPRT attempt). By default, those ones will always be\n     attempted before the good old traditional PORT command. */\n  CURLOPT(CURLOPT_FTP_USE_EPRT, CURLOPTTYPE_LONG, 106),\n\n  /* Set this to a bitmask value to enable the particular authentications\n     methods you like. Use this in combination with CURLOPT_USERPWD.\n     Note that setting multiple bits may cause extra network round-trips. */\n  CURLOPT(CURLOPT_HTTPAUTH, CURLOPTTYPE_VALUES, 107),\n\n  /* Set the ssl context callback function, currently only for OpenSSL or\n     WolfSSL ssl_ctx, or mbedTLS mbedtls_ssl_config in the second argument.\n     The function must match the curl_ssl_ctx_callback prototype. */\n  CURLOPT(CURLOPT_SSL_CTX_FUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 108),\n\n  /* Set the userdata for the ssl context callback function's third\n     argument */\n  CURLOPT(CURLOPT_SSL_CTX_DATA, CURLOPTTYPE_CBPOINT, 109),\n\n  /* FTP Option that causes missing dirs to be created on the remote server.\n     In 7.19.4 we introduced the convenience enums for this option using the\n     CURLFTP_CREATE_DIR prefix.\n  */\n  CURLOPT(CURLOPT_FTP_CREATE_MISSING_DIRS, CURLOPTTYPE_LONG, 110),\n\n  /* Set this to a bitmask value to enable the particular authentications\n     methods you like. Use this in combination with CURLOPT_PROXYUSERPWD.\n     Note that setting multiple bits may cause extra network round-trips. */\n  CURLOPT(CURLOPT_PROXYAUTH, CURLOPTTYPE_VALUES, 111),\n\n  /* Option that changes the timeout, in seconds, associated with getting a\n     response.  This is different from transfer timeout time and essentially\n     places a demand on the server to acknowledge commands in a timely\n     manner. For FTP, SMTP, IMAP and POP3. */\n  CURLOPT(CURLOPT_SERVER_RESPONSE_TIMEOUT, CURLOPTTYPE_LONG, 112),\n\n  /* Set this option to one of the CURL_IPRESOLVE_* defines (see below) to\n     tell libcurl to use those IP versions only. This only has effect on\n     systems with support for more than one, i.e IPv4 _and_ IPv6. */\n  CURLOPT(CURLOPT_IPRESOLVE, CURLOPTTYPE_VALUES, 113),\n\n  /* Set this option to limit the size of a file that will be downloaded from\n     an HTTP or FTP server.\n\n     Note there is also _LARGE version which adds large file support for\n     platforms which have larger off_t sizes.  See MAXFILESIZE_LARGE below. */\n  CURLOPT(CURLOPT_MAXFILESIZE, CURLOPTTYPE_LONG, 114),\n\n  /* See the comment for INFILESIZE above, but in short, specifies\n   * the size of the file being uploaded.  -1 means unknown.\n   */\n  CURLOPT(CURLOPT_INFILESIZE_LARGE, CURLOPTTYPE_OFF_T, 115),\n\n  /* Sets the continuation offset.  There is also a CURLOPTTYPE_LONG version\n   * of this; look above for RESUME_FROM.\n   */\n  CURLOPT(CURLOPT_RESUME_FROM_LARGE, CURLOPTTYPE_OFF_T, 116),\n\n  /* Sets the maximum size of data that will be downloaded from\n   * an HTTP or FTP server.  See MAXFILESIZE above for the LONG version.\n   */\n  CURLOPT(CURLOPT_MAXFILESIZE_LARGE, CURLOPTTYPE_OFF_T, 117),\n\n  /* Set this option to the file name of your .netrc file you want libcurl\n     to parse (using the CURLOPT_NETRC option). If not set, libcurl will do\n     a poor attempt to find the user's home directory and check for a .netrc\n     file in there. */\n  CURLOPT(CURLOPT_NETRC_FILE, CURLOPTTYPE_STRINGPOINT, 118),\n\n  /* Enable SSL/TLS for FTP, pick one of:\n     CURLUSESSL_TRY     - try using SSL, proceed anyway otherwise\n     CURLUSESSL_CONTROL - SSL for the control connection or fail\n     CURLUSESSL_ALL     - SSL for all communication or fail\n  */\n  CURLOPT(CURLOPT_USE_SSL, CURLOPTTYPE_VALUES, 119),\n\n  /* The _LARGE version of the standard POSTFIELDSIZE option */\n  CURLOPT(CURLOPT_POSTFIELDSIZE_LARGE, CURLOPTTYPE_OFF_T, 120),\n\n  /* Enable/disable the TCP Nagle algorithm */\n  CURLOPT(CURLOPT_TCP_NODELAY, CURLOPTTYPE_LONG, 121),\n\n  /* 122 OBSOLETE, used in 7.12.3. Gone in 7.13.0 */\n  /* 123 OBSOLETE. Gone in 7.16.0 */\n  /* 124 OBSOLETE, used in 7.12.3. Gone in 7.13.0 */\n  /* 125 OBSOLETE, used in 7.12.3. Gone in 7.13.0 */\n  /* 126 OBSOLETE, used in 7.12.3. Gone in 7.13.0 */\n  /* 127 OBSOLETE. Gone in 7.16.0 */\n  /* 128 OBSOLETE. Gone in 7.16.0 */\n\n  /* When FTP over SSL/TLS is selected (with CURLOPT_USE_SSL), this option\n     can be used to change libcurl's default action which is to first try\n     \"AUTH SSL\" and then \"AUTH TLS\" in this order, and proceed when a OK\n     response has been received.\n\n     Available parameters are:\n     CURLFTPAUTH_DEFAULT - let libcurl decide\n     CURLFTPAUTH_SSL     - try \"AUTH SSL\" first, then TLS\n     CURLFTPAUTH_TLS     - try \"AUTH TLS\" first, then SSL\n  */\n  CURLOPT(CURLOPT_FTPSSLAUTH, CURLOPTTYPE_VALUES, 129),\n\n  CURLOPTDEPRECATED(CURLOPT_IOCTLFUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 130,\n                    7.18.0, \"Use CURLOPT_SEEKFUNCTION\"),\n  CURLOPTDEPRECATED(CURLOPT_IOCTLDATA, CURLOPTTYPE_CBPOINT, 131,\n                    7.18.0, \"Use CURLOPT_SEEKDATA\"),\n\n  /* 132 OBSOLETE. Gone in 7.16.0 */\n  /* 133 OBSOLETE. Gone in 7.16.0 */\n\n  /* null-terminated string for pass on to the FTP server when asked for\n     \"account\" info */\n  CURLOPT(CURLOPT_FTP_ACCOUNT, CURLOPTTYPE_STRINGPOINT, 134),\n\n  /* feed cookie into cookie engine */\n  CURLOPT(CURLOPT_COOKIELIST, CURLOPTTYPE_STRINGPOINT, 135),\n\n  /* ignore Content-Length */\n  CURLOPT(CURLOPT_IGNORE_CONTENT_LENGTH, CURLOPTTYPE_LONG, 136),\n\n  /* Set to non-zero to skip the IP address received in a 227 PASV FTP server\n     response. Typically used for FTP-SSL purposes but is not restricted to\n     that. libcurl will then instead use the same IP address it used for the\n     control connection. */\n  CURLOPT(CURLOPT_FTP_SKIP_PASV_IP, CURLOPTTYPE_LONG, 137),\n\n  /* Select \"file method\" to use when doing FTP, see the curl_ftpmethod\n     above. */\n  CURLOPT(CURLOPT_FTP_FILEMETHOD, CURLOPTTYPE_VALUES, 138),\n\n  /* Local port number to bind the socket to */\n  CURLOPT(CURLOPT_LOCALPORT, CURLOPTTYPE_LONG, 139),\n\n  /* Number of ports to try, including the first one set with LOCALPORT.\n     Thus, setting it to 1 will make no additional attempts but the first.\n  */\n  CURLOPT(CURLOPT_LOCALPORTRANGE, CURLOPTTYPE_LONG, 140),\n\n  /* no transfer, set up connection and let application use the socket by\n     extracting it with CURLINFO_LASTSOCKET */\n  CURLOPT(CURLOPT_CONNECT_ONLY, CURLOPTTYPE_LONG, 141),\n\n  /* Function that will be called to convert from the\n     network encoding (instead of using the iconv calls in libcurl) */\n  CURLOPTDEPRECATED(CURLOPT_CONV_FROM_NETWORK_FUNCTION,\n                    CURLOPTTYPE_FUNCTIONPOINT, 142,\n                    7.82.0, \"Serves no purpose anymore\"),\n\n  /* Function that will be called to convert to the\n     network encoding (instead of using the iconv calls in libcurl) */\n  CURLOPTDEPRECATED(CURLOPT_CONV_TO_NETWORK_FUNCTION,\n                    CURLOPTTYPE_FUNCTIONPOINT, 143,\n                    7.82.0, \"Serves no purpose anymore\"),\n\n  /* Function that will be called to convert from UTF8\n     (instead of using the iconv calls in libcurl)\n     Note that this is used only for SSL certificate processing */\n  CURLOPTDEPRECATED(CURLOPT_CONV_FROM_UTF8_FUNCTION,\n                    CURLOPTTYPE_FUNCTIONPOINT, 144,\n                    7.82.0, \"Serves no purpose anymore\"),\n\n  /* if the connection proceeds too quickly then need to slow it down */\n  /* limit-rate: maximum number of bytes per second to send or receive */\n  CURLOPT(CURLOPT_MAX_SEND_SPEED_LARGE, CURLOPTTYPE_OFF_T, 145),\n  CURLOPT(CURLOPT_MAX_RECV_SPEED_LARGE, CURLOPTTYPE_OFF_T, 146),\n\n  /* Pointer to command string to send if USER/PASS fails. */\n  CURLOPT(CURLOPT_FTP_ALTERNATIVE_TO_USER, CURLOPTTYPE_STRINGPOINT, 147),\n\n  /* callback function for setting socket options */\n  CURLOPT(CURLOPT_SOCKOPTFUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 148),\n  CURLOPT(CURLOPT_SOCKOPTDATA, CURLOPTTYPE_CBPOINT, 149),\n\n  /* set to 0 to disable session ID reuse for this transfer, default is\n     enabled (== 1) */\n  CURLOPT(CURLOPT_SSL_SESSIONID_CACHE, CURLOPTTYPE_LONG, 150),\n\n  /* allowed SSH authentication methods */\n  CURLOPT(CURLOPT_SSH_AUTH_TYPES, CURLOPTTYPE_VALUES, 151),\n\n  /* Used by scp/sftp to do public/private key authentication */\n  CURLOPT(CURLOPT_SSH_PUBLIC_KEYFILE, CURLOPTTYPE_STRINGPOINT, 152),\n  CURLOPT(CURLOPT_SSH_PRIVATE_KEYFILE, CURLOPTTYPE_STRINGPOINT, 153),\n\n  /* Send CCC (Clear Command Channel) after authentication */\n  CURLOPT(CURLOPT_FTP_SSL_CCC, CURLOPTTYPE_LONG, 154),\n\n  /* Same as TIMEOUT and CONNECTTIMEOUT, but with ms resolution */\n  CURLOPT(CURLOPT_TIMEOUT_MS, CURLOPTTYPE_LONG, 155),\n  CURLOPT(CURLOPT_CONNECTTIMEOUT_MS, CURLOPTTYPE_LONG, 156),\n\n  /* set to zero to disable the libcurl's decoding and thus pass the raw body\n     data to the application even when it is encoded/compressed */\n  CURLOPT(CURLOPT_HTTP_TRANSFER_DECODING, CURLOPTTYPE_LONG, 157),\n  CURLOPT(CURLOPT_HTTP_CONTENT_DECODING, CURLOPTTYPE_LONG, 158),\n\n  /* Permission used when creating new files and directories on the remote\n     server for protocols that support it, SFTP/SCP/FILE */\n  CURLOPT(CURLOPT_NEW_FILE_PERMS, CURLOPTTYPE_LONG, 159),\n  CURLOPT(CURLOPT_NEW_DIRECTORY_PERMS, CURLOPTTYPE_LONG, 160),\n\n  /* Set the behavior of POST when redirecting. Values must be set to one\n     of CURL_REDIR* defines below. This used to be called CURLOPT_POST301 */\n  CURLOPT(CURLOPT_POSTREDIR, CURLOPTTYPE_VALUES, 161),\n\n  /* used by scp/sftp to verify the host's public key */\n  CURLOPT(CURLOPT_SSH_HOST_PUBLIC_KEY_MD5, CURLOPTTYPE_STRINGPOINT, 162),\n\n  /* Callback function for opening socket (instead of socket(2)). Optionally,\n     callback is able change the address or refuse to connect returning\n     CURL_SOCKET_BAD.  The callback should have type\n     curl_opensocket_callback */\n  CURLOPT(CURLOPT_OPENSOCKETFUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 163),\n  CURLOPT(CURLOPT_OPENSOCKETDATA, CURLOPTTYPE_CBPOINT, 164),\n\n  /* POST volatile input fields. */\n  CURLOPT(CURLOPT_COPYPOSTFIELDS, CURLOPTTYPE_OBJECTPOINT, 165),\n\n  /* set transfer mode (;type=<a|i>) when doing FTP via an HTTP proxy */\n  CURLOPT(CURLOPT_PROXY_TRANSFER_MODE, CURLOPTTYPE_LONG, 166),\n\n  /* Callback function for seeking in the input stream */\n  CURLOPT(CURLOPT_SEEKFUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 167),\n  CURLOPT(CURLOPT_SEEKDATA, CURLOPTTYPE_CBPOINT, 168),\n\n  /* CRL file */\n  CURLOPT(CURLOPT_CRLFILE, CURLOPTTYPE_STRINGPOINT, 169),\n\n  /* Issuer certificate */\n  CURLOPT(CURLOPT_ISSUERCERT, CURLOPTTYPE_STRINGPOINT, 170),\n\n  /* (IPv6) Address scope */\n  CURLOPT(CURLOPT_ADDRESS_SCOPE, CURLOPTTYPE_LONG, 171),\n\n  /* Collect certificate chain info and allow it to get retrievable with\n     CURLINFO_CERTINFO after the transfer is complete. */\n  CURLOPT(CURLOPT_CERTINFO, CURLOPTTYPE_LONG, 172),\n\n  /* \"name\" and \"pwd\" to use when fetching. */\n  CURLOPT(CURLOPT_USERNAME, CURLOPTTYPE_STRINGPOINT, 173),\n  CURLOPT(CURLOPT_PASSWORD, CURLOPTTYPE_STRINGPOINT, 174),\n\n    /* \"name\" and \"pwd\" to use with Proxy when fetching. */\n  CURLOPT(CURLOPT_PROXYUSERNAME, CURLOPTTYPE_STRINGPOINT, 175),\n  CURLOPT(CURLOPT_PROXYPASSWORD, CURLOPTTYPE_STRINGPOINT, 176),\n\n  /* Comma separated list of hostnames defining no-proxy zones. These should\n     match both hostnames directly, and hostnames within a domain. For\n     example, local.com will match local.com and www.local.com, but NOT\n     notlocal.com or www.notlocal.com. For compatibility with other\n     implementations of this, .local.com will be considered to be the same as\n     local.com. A single * is the only valid wildcard, and effectively\n     disables the use of proxy. */\n  CURLOPT(CURLOPT_NOPROXY, CURLOPTTYPE_STRINGPOINT, 177),\n\n  /* block size for TFTP transfers */\n  CURLOPT(CURLOPT_TFTP_BLKSIZE, CURLOPTTYPE_LONG, 178),\n\n  /* Socks Service */\n  /* DEPRECATED, do not use! */\n  CURLOPTDEPRECATED(CURLOPT_SOCKS5_GSSAPI_SERVICE,\n                    CURLOPTTYPE_STRINGPOINT, 179,\n                    7.49.0, \"Use CURLOPT_PROXY_SERVICE_NAME\"),\n\n  /* Socks Service */\n  CURLOPT(CURLOPT_SOCKS5_GSSAPI_NEC, CURLOPTTYPE_LONG, 180),\n\n  /* set the bitmask for the protocols that are allowed to be used for the\n     transfer, which thus helps the app which takes URLs from users or other\n     external inputs and want to restrict what protocol(s) to deal\n     with. Defaults to CURLPROTO_ALL. */\n  CURLOPTDEPRECATED(CURLOPT_PROTOCOLS, CURLOPTTYPE_LONG, 181,\n                    7.85.0, \"Use CURLOPT_PROTOCOLS_STR\"),\n\n  /* set the bitmask for the protocols that libcurl is allowed to follow to,\n     as a subset of the CURLOPT_PROTOCOLS ones. That means the protocol needs\n     to be set in both bitmasks to be allowed to get redirected to. */\n  CURLOPTDEPRECATED(CURLOPT_REDIR_PROTOCOLS, CURLOPTTYPE_LONG, 182,\n                    7.85.0, \"Use CURLOPT_REDIR_PROTOCOLS_STR\"),\n\n  /* set the SSH knownhost file name to use */\n  CURLOPT(CURLOPT_SSH_KNOWNHOSTS, CURLOPTTYPE_STRINGPOINT, 183),\n\n  /* set the SSH host key callback, must point to a curl_sshkeycallback\n     function */\n  CURLOPT(CURLOPT_SSH_KEYFUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 184),\n\n  /* set the SSH host key callback custom pointer */\n  CURLOPT(CURLOPT_SSH_KEYDATA, CURLOPTTYPE_CBPOINT, 185),\n\n  /* set the SMTP mail originator */\n  CURLOPT(CURLOPT_MAIL_FROM, CURLOPTTYPE_STRINGPOINT, 186),\n\n  /* set the list of SMTP mail receiver(s) */\n  CURLOPT(CURLOPT_MAIL_RCPT, CURLOPTTYPE_SLISTPOINT, 187),\n\n  /* FTP: send PRET before PASV */\n  CURLOPT(CURLOPT_FTP_USE_PRET, CURLOPTTYPE_LONG, 188),\n\n  /* RTSP request method (OPTIONS, SETUP, PLAY, etc...) */\n  CURLOPT(CURLOPT_RTSP_REQUEST, CURLOPTTYPE_VALUES, 189),\n\n  /* The RTSP session identifier */\n  CURLOPT(CURLOPT_RTSP_SESSION_ID, CURLOPTTYPE_STRINGPOINT, 190),\n\n  /* The RTSP stream URI */\n  CURLOPT(CURLOPT_RTSP_STREAM_URI, CURLOPTTYPE_STRINGPOINT, 191),\n\n  /* The Transport: header to use in RTSP requests */\n  CURLOPT(CURLOPT_RTSP_TRANSPORT, CURLOPTTYPE_STRINGPOINT, 192),\n\n  /* Manually initialize the client RTSP CSeq for this handle */\n  CURLOPT(CURLOPT_RTSP_CLIENT_CSEQ, CURLOPTTYPE_LONG, 193),\n\n  /* Manually initialize the server RTSP CSeq for this handle */\n  CURLOPT(CURLOPT_RTSP_SERVER_CSEQ, CURLOPTTYPE_LONG, 194),\n\n  /* The stream to pass to INTERLEAVEFUNCTION. */\n  CURLOPT(CURLOPT_INTERLEAVEDATA, CURLOPTTYPE_CBPOINT, 195),\n\n  /* Let the application define a custom write method for RTP data */\n  CURLOPT(CURLOPT_INTERLEAVEFUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 196),\n\n  /* Turn on wildcard matching */\n  CURLOPT(CURLOPT_WILDCARDMATCH, CURLOPTTYPE_LONG, 197),\n\n  /* Directory matching callback called before downloading of an\n     individual file (chunk) started */\n  CURLOPT(CURLOPT_CHUNK_BGN_FUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 198),\n\n  /* Directory matching callback called after the file (chunk)\n     was downloaded, or skipped */\n  CURLOPT(CURLOPT_CHUNK_END_FUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 199),\n\n  /* Change match (fnmatch-like) callback for wildcard matching */\n  CURLOPT(CURLOPT_FNMATCH_FUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 200),\n\n  /* Let the application define custom chunk data pointer */\n  CURLOPT(CURLOPT_CHUNK_DATA, CURLOPTTYPE_CBPOINT, 201),\n\n  /* FNMATCH_FUNCTION user pointer */\n  CURLOPT(CURLOPT_FNMATCH_DATA, CURLOPTTYPE_CBPOINT, 202),\n\n  /* send linked-list of name:port:address sets */\n  CURLOPT(CURLOPT_RESOLVE, CURLOPTTYPE_SLISTPOINT, 203),\n\n  /* Set a username for authenticated TLS */\n  CURLOPT(CURLOPT_TLSAUTH_USERNAME, CURLOPTTYPE_STRINGPOINT, 204),\n\n  /* Set a password for authenticated TLS */\n  CURLOPT(CURLOPT_TLSAUTH_PASSWORD, CURLOPTTYPE_STRINGPOINT, 205),\n\n  /* Set authentication type for authenticated TLS */\n  CURLOPT(CURLOPT_TLSAUTH_TYPE, CURLOPTTYPE_STRINGPOINT, 206),\n\n  /* Set to 1 to enable the \"TE:\" header in HTTP requests to ask for\n     compressed transfer-encoded responses. Set to 0 to disable the use of TE:\n     in outgoing requests. The current default is 0, but it might change in a\n     future libcurl release.\n\n     libcurl will ask for the compressed methods it knows of, and if that\n     isn't any, it will not ask for transfer-encoding at all even if this\n     option is set to 1.\n\n  */\n  CURLOPT(CURLOPT_TRANSFER_ENCODING, CURLOPTTYPE_LONG, 207),\n\n  /* Callback function for closing socket (instead of close(2)). The callback\n     should have type curl_closesocket_callback */\n  CURLOPT(CURLOPT_CLOSESOCKETFUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 208),\n  CURLOPT(CURLOPT_CLOSESOCKETDATA, CURLOPTTYPE_CBPOINT, 209),\n\n  /* allow GSSAPI credential delegation */\n  CURLOPT(CURLOPT_GSSAPI_DELEGATION, CURLOPTTYPE_VALUES, 210),\n\n  /* Set the name servers to use for DNS resolution.\n   * Only supported by the c-ares DNS backend */\n  CURLOPT(CURLOPT_DNS_SERVERS, CURLOPTTYPE_STRINGPOINT, 211),\n\n  /* Time-out accept operations (currently for FTP only) after this amount\n     of milliseconds. */\n  CURLOPT(CURLOPT_ACCEPTTIMEOUT_MS, CURLOPTTYPE_LONG, 212),\n\n  /* Set TCP keepalive */\n  CURLOPT(CURLOPT_TCP_KEEPALIVE, CURLOPTTYPE_LONG, 213),\n\n  /* non-universal keepalive knobs (Linux, AIX, HP-UX, more) */\n  CURLOPT(CURLOPT_TCP_KEEPIDLE, CURLOPTTYPE_LONG, 214),\n  CURLOPT(CURLOPT_TCP_KEEPINTVL, CURLOPTTYPE_LONG, 215),\n\n  /* Enable/disable specific SSL features with a bitmask, see CURLSSLOPT_* */\n  CURLOPT(CURLOPT_SSL_OPTIONS, CURLOPTTYPE_VALUES, 216),\n\n  /* Set the SMTP auth originator */\n  CURLOPT(CURLOPT_MAIL_AUTH, CURLOPTTYPE_STRINGPOINT, 217),\n\n  /* Enable/disable SASL initial response */\n  CURLOPT(CURLOPT_SASL_IR, CURLOPTTYPE_LONG, 218),\n\n  /* Function that will be called instead of the internal progress display\n   * function. This function should be defined as the curl_xferinfo_callback\n   * prototype defines. (Deprecates CURLOPT_PROGRESSFUNCTION) */\n  CURLOPT(CURLOPT_XFERINFOFUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 219),\n\n  /* The XOAUTH2 bearer token */\n  CURLOPT(CURLOPT_XOAUTH2_BEARER, CURLOPTTYPE_STRINGPOINT, 220),\n\n  /* Set the interface string to use as outgoing network\n   * interface for DNS requests.\n   * Only supported by the c-ares DNS backend */\n  CURLOPT(CURLOPT_DNS_INTERFACE, CURLOPTTYPE_STRINGPOINT, 221),\n\n  /* Set the local IPv4 address to use for outgoing DNS requests.\n   * Only supported by the c-ares DNS backend */\n  CURLOPT(CURLOPT_DNS_LOCAL_IP4, CURLOPTTYPE_STRINGPOINT, 222),\n\n  /* Set the local IPv6 address to use for outgoing DNS requests.\n   * Only supported by the c-ares DNS backend */\n  CURLOPT(CURLOPT_DNS_LOCAL_IP6, CURLOPTTYPE_STRINGPOINT, 223),\n\n  /* Set authentication options directly */\n  CURLOPT(CURLOPT_LOGIN_OPTIONS, CURLOPTTYPE_STRINGPOINT, 224),\n\n  /* Enable/disable TLS NPN extension (http2 over ssl might fail without) */\n  CURLOPTDEPRECATED(CURLOPT_SSL_ENABLE_NPN, CURLOPTTYPE_LONG, 225,\n                    7.86.0, \"Has no function\"),\n\n  /* Enable/disable TLS ALPN extension (http2 over ssl might fail without) */\n  CURLOPT(CURLOPT_SSL_ENABLE_ALPN, CURLOPTTYPE_LONG, 226),\n\n  /* Time to wait for a response to an HTTP request containing an\n   * Expect: 100-continue header before sending the data anyway. */\n  CURLOPT(CURLOPT_EXPECT_100_TIMEOUT_MS, CURLOPTTYPE_LONG, 227),\n\n  /* This points to a linked list of headers used for proxy requests only,\n     struct curl_slist kind */\n  CURLOPT(CURLOPT_PROXYHEADER, CURLOPTTYPE_SLISTPOINT, 228),\n\n  /* Pass in a bitmask of \"header options\" */\n  CURLOPT(CURLOPT_HEADEROPT, CURLOPTTYPE_VALUES, 229),\n\n  /* The public key in DER form used to validate the peer public key\n     this option is used only if SSL_VERIFYPEER is true */\n  CURLOPT(CURLOPT_PINNEDPUBLICKEY, CURLOPTTYPE_STRINGPOINT, 230),\n\n  /* Path to Unix domain socket */\n  CURLOPT(CURLOPT_UNIX_SOCKET_PATH, CURLOPTTYPE_STRINGPOINT, 231),\n\n  /* Set if we should verify the certificate status. */\n  CURLOPT(CURLOPT_SSL_VERIFYSTATUS, CURLOPTTYPE_LONG, 232),\n\n  /* Set if we should enable TLS false start. */\n  CURLOPT(CURLOPT_SSL_FALSESTART, CURLOPTTYPE_LONG, 233),\n\n  /* Do not squash dot-dot sequences */\n  CURLOPT(CURLOPT_PATH_AS_IS, CURLOPTTYPE_LONG, 234),\n\n  /* Proxy Service Name */\n  CURLOPT(CURLOPT_PROXY_SERVICE_NAME, CURLOPTTYPE_STRINGPOINT, 235),\n\n  /* Service Name */\n  CURLOPT(CURLOPT_SERVICE_NAME, CURLOPTTYPE_STRINGPOINT, 236),\n\n  /* Wait/don't wait for pipe/mutex to clarify */\n  CURLOPT(CURLOPT_PIPEWAIT, CURLOPTTYPE_LONG, 237),\n\n  /* Set the protocol used when curl is given a URL without a protocol */\n  CURLOPT(CURLOPT_DEFAULT_PROTOCOL, CURLOPTTYPE_STRINGPOINT, 238),\n\n  /* Set stream weight, 1 - 256 (default is 16) */\n  CURLOPT(CURLOPT_STREAM_WEIGHT, CURLOPTTYPE_LONG, 239),\n\n  /* Set stream dependency on another CURL handle */\n  CURLOPT(CURLOPT_STREAM_DEPENDS, CURLOPTTYPE_OBJECTPOINT, 240),\n\n  /* Set E-xclusive stream dependency on another CURL handle */\n  CURLOPT(CURLOPT_STREAM_DEPENDS_E, CURLOPTTYPE_OBJECTPOINT, 241),\n\n  /* Do not send any tftp option requests to the server */\n  CURLOPT(CURLOPT_TFTP_NO_OPTIONS, CURLOPTTYPE_LONG, 242),\n\n  /* Linked-list of host:port:connect-to-host:connect-to-port,\n     overrides the URL's host:port (only for the network layer) */\n  CURLOPT(CURLOPT_CONNECT_TO, CURLOPTTYPE_SLISTPOINT, 243),\n\n  /* Set TCP Fast Open */\n  CURLOPT(CURLOPT_TCP_FASTOPEN, CURLOPTTYPE_LONG, 244),\n\n  /* Continue to send data if the server responds early with an\n   * HTTP status code >= 300 */\n  CURLOPT(CURLOPT_KEEP_SENDING_ON_ERROR, CURLOPTTYPE_LONG, 245),\n\n  /* The CApath or CAfile used to validate the proxy certificate\n     this option is used only if PROXY_SSL_VERIFYPEER is true */\n  CURLOPT(CURLOPT_PROXY_CAINFO, CURLOPTTYPE_STRINGPOINT, 246),\n\n  /* The CApath directory used to validate the proxy certificate\n     this option is used only if PROXY_SSL_VERIFYPEER is true */\n  CURLOPT(CURLOPT_PROXY_CAPATH, CURLOPTTYPE_STRINGPOINT, 247),\n\n  /* Set if we should verify the proxy in ssl handshake,\n     set 1 to verify. */\n  CURLOPT(CURLOPT_PROXY_SSL_VERIFYPEER, CURLOPTTYPE_LONG, 248),\n\n  /* Set if we should verify the Common name from the proxy certificate in ssl\n   * handshake, set 1 to check existence, 2 to ensure that it matches\n   * the provided hostname. */\n  CURLOPT(CURLOPT_PROXY_SSL_VERIFYHOST, CURLOPTTYPE_LONG, 249),\n\n  /* What version to specifically try to use for proxy.\n     See CURL_SSLVERSION defines below. */\n  CURLOPT(CURLOPT_PROXY_SSLVERSION, CURLOPTTYPE_VALUES, 250),\n\n  /* Set a username for authenticated TLS for proxy */\n  CURLOPT(CURLOPT_PROXY_TLSAUTH_USERNAME, CURLOPTTYPE_STRINGPOINT, 251),\n\n  /* Set a password for authenticated TLS for proxy */\n  CURLOPT(CURLOPT_PROXY_TLSAUTH_PASSWORD, CURLOPTTYPE_STRINGPOINT, 252),\n\n  /* Set authentication type for authenticated TLS for proxy */\n  CURLOPT(CURLOPT_PROXY_TLSAUTH_TYPE, CURLOPTTYPE_STRINGPOINT, 253),\n\n  /* name of the file keeping your private SSL-certificate for proxy */\n  CURLOPT(CURLOPT_PROXY_SSLCERT, CURLOPTTYPE_STRINGPOINT, 254),\n\n  /* type of the file keeping your SSL-certificate (\"DER\", \"PEM\", \"ENG\") for\n     proxy */\n  CURLOPT(CURLOPT_PROXY_SSLCERTTYPE, CURLOPTTYPE_STRINGPOINT, 255),\n\n  /* name of the file keeping your private SSL-key for proxy */\n  CURLOPT(CURLOPT_PROXY_SSLKEY, CURLOPTTYPE_STRINGPOINT, 256),\n\n  /* type of the file keeping your private SSL-key (\"DER\", \"PEM\", \"ENG\") for\n     proxy */\n  CURLOPT(CURLOPT_PROXY_SSLKEYTYPE, CURLOPTTYPE_STRINGPOINT, 257),\n\n  /* password for the SSL private key for proxy */\n  CURLOPT(CURLOPT_PROXY_KEYPASSWD, CURLOPTTYPE_STRINGPOINT, 258),\n\n  /* Specify which SSL ciphers to use for proxy */\n  CURLOPT(CURLOPT_PROXY_SSL_CIPHER_LIST, CURLOPTTYPE_STRINGPOINT, 259),\n\n  /* CRL file for proxy */\n  CURLOPT(CURLOPT_PROXY_CRLFILE, CURLOPTTYPE_STRINGPOINT, 260),\n\n  /* Enable/disable specific SSL features with a bitmask for proxy, see\n     CURLSSLOPT_* */\n  CURLOPT(CURLOPT_PROXY_SSL_OPTIONS, CURLOPTTYPE_LONG, 261),\n\n  /* Name of pre proxy to use. */\n  CURLOPT(CURLOPT_PRE_PROXY, CURLOPTTYPE_STRINGPOINT, 262),\n\n  /* The public key in DER form used to validate the proxy public key\n     this option is used only if PROXY_SSL_VERIFYPEER is true */\n  CURLOPT(CURLOPT_PROXY_PINNEDPUBLICKEY, CURLOPTTYPE_STRINGPOINT, 263),\n\n  /* Path to an abstract Unix domain socket */\n  CURLOPT(CURLOPT_ABSTRACT_UNIX_SOCKET, CURLOPTTYPE_STRINGPOINT, 264),\n\n  /* Suppress proxy CONNECT response headers from user callbacks */\n  CURLOPT(CURLOPT_SUPPRESS_CONNECT_HEADERS, CURLOPTTYPE_LONG, 265),\n\n  /* The request target, instead of extracted from the URL */\n  CURLOPT(CURLOPT_REQUEST_TARGET, CURLOPTTYPE_STRINGPOINT, 266),\n\n  /* bitmask of allowed auth methods for connections to SOCKS5 proxies */\n  CURLOPT(CURLOPT_SOCKS5_AUTH, CURLOPTTYPE_LONG, 267),\n\n  /* Enable/disable SSH compression */\n  CURLOPT(CURLOPT_SSH_COMPRESSION, CURLOPTTYPE_LONG, 268),\n\n  /* Post MIME data. */\n  CURLOPT(CURLOPT_MIMEPOST, CURLOPTTYPE_OBJECTPOINT, 269),\n\n  /* Time to use with the CURLOPT_TIMECONDITION. Specified in number of\n     seconds since 1 Jan 1970. */\n  CURLOPT(CURLOPT_TIMEVALUE_LARGE, CURLOPTTYPE_OFF_T, 270),\n\n  /* Head start in milliseconds to give happy eyeballs. */\n  CURLOPT(CURLOPT_HAPPY_EYEBALLS_TIMEOUT_MS, CURLOPTTYPE_LONG, 271),\n\n  /* Function that will be called before a resolver request is made */\n  CURLOPT(CURLOPT_RESOLVER_START_FUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 272),\n\n  /* User data to pass to the resolver start callback. */\n  CURLOPT(CURLOPT_RESOLVER_START_DATA, CURLOPTTYPE_CBPOINT, 273),\n\n  /* send HAProxy PROXY protocol header? */\n  CURLOPT(CURLOPT_HAPROXYPROTOCOL, CURLOPTTYPE_LONG, 274),\n\n  /* shuffle addresses before use when DNS returns multiple */\n  CURLOPT(CURLOPT_DNS_SHUFFLE_ADDRESSES, CURLOPTTYPE_LONG, 275),\n\n  /* Specify which TLS 1.3 ciphers suites to use */\n  CURLOPT(CURLOPT_TLS13_CIPHERS, CURLOPTTYPE_STRINGPOINT, 276),\n  CURLOPT(CURLOPT_PROXY_TLS13_CIPHERS, CURLOPTTYPE_STRINGPOINT, 277),\n\n  /* Disallow specifying username/login in URL. */\n  CURLOPT(CURLOPT_DISALLOW_USERNAME_IN_URL, CURLOPTTYPE_LONG, 278),\n\n  /* DNS-over-HTTPS URL */\n  CURLOPT(CURLOPT_DOH_URL, CURLOPTTYPE_STRINGPOINT, 279),\n\n  /* Preferred buffer size to use for uploads */\n  CURLOPT(CURLOPT_UPLOAD_BUFFERSIZE, CURLOPTTYPE_LONG, 280),\n\n  /* Time in ms between connection upkeep calls for long-lived connections. */\n  CURLOPT(CURLOPT_UPKEEP_INTERVAL_MS, CURLOPTTYPE_LONG, 281),\n\n  /* Specify URL using CURL URL API. */\n  CURLOPT(CURLOPT_CURLU, CURLOPTTYPE_OBJECTPOINT, 282),\n\n  /* add trailing data just after no more data is available */\n  CURLOPT(CURLOPT_TRAILERFUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 283),\n\n  /* pointer to be passed to HTTP_TRAILER_FUNCTION */\n  CURLOPT(CURLOPT_TRAILERDATA, CURLOPTTYPE_CBPOINT, 284),\n\n  /* set this to 1L to allow HTTP/0.9 responses or 0L to disallow */\n  CURLOPT(CURLOPT_HTTP09_ALLOWED, CURLOPTTYPE_LONG, 285),\n\n  /* alt-svc control bitmask */\n  CURLOPT(CURLOPT_ALTSVC_CTRL, CURLOPTTYPE_LONG, 286),\n\n  /* alt-svc cache file name to possibly read from/write to */\n  CURLOPT(CURLOPT_ALTSVC, CURLOPTTYPE_STRINGPOINT, 287),\n\n  /* maximum age (idle time) of a connection to consider it for reuse\n   * (in seconds) */\n  CURLOPT(CURLOPT_MAXAGE_CONN, CURLOPTTYPE_LONG, 288),\n\n  /* SASL authorization identity */\n  CURLOPT(CURLOPT_SASL_AUTHZID, CURLOPTTYPE_STRINGPOINT, 289),\n\n  /* allow RCPT TO command to fail for some recipients */\n  CURLOPT(CURLOPT_MAIL_RCPT_ALLOWFAILS, CURLOPTTYPE_LONG, 290),\n\n  /* the private SSL-certificate as a \"blob\" */\n  CURLOPT(CURLOPT_SSLCERT_BLOB, CURLOPTTYPE_BLOB, 291),\n  CURLOPT(CURLOPT_SSLKEY_BLOB, CURLOPTTYPE_BLOB, 292),\n  CURLOPT(CURLOPT_PROXY_SSLCERT_BLOB, CURLOPTTYPE_BLOB, 293),\n  CURLOPT(CURLOPT_PROXY_SSLKEY_BLOB, CURLOPTTYPE_BLOB, 294),\n  CURLOPT(CURLOPT_ISSUERCERT_BLOB, CURLOPTTYPE_BLOB, 295),\n\n  /* Issuer certificate for proxy */\n  CURLOPT(CURLOPT_PROXY_ISSUERCERT, CURLOPTTYPE_STRINGPOINT, 296),\n  CURLOPT(CURLOPT_PROXY_ISSUERCERT_BLOB, CURLOPTTYPE_BLOB, 297),\n\n  /* the EC curves requested by the TLS client (RFC 8422, 5.1);\n   * OpenSSL support via 'set_groups'/'set_curves':\n   * https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set1_groups.html\n   */\n  CURLOPT(CURLOPT_SSL_EC_CURVES, CURLOPTTYPE_STRINGPOINT, 298),\n\n  /* HSTS bitmask */\n  CURLOPT(CURLOPT_HSTS_CTRL, CURLOPTTYPE_LONG, 299),\n  /* HSTS file name */\n  CURLOPT(CURLOPT_HSTS, CURLOPTTYPE_STRINGPOINT, 300),\n\n  /* HSTS read callback */\n  CURLOPT(CURLOPT_HSTSREADFUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 301),\n  CURLOPT(CURLOPT_HSTSREADDATA, CURLOPTTYPE_CBPOINT, 302),\n\n  /* HSTS write callback */\n  CURLOPT(CURLOPT_HSTSWRITEFUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 303),\n  CURLOPT(CURLOPT_HSTSWRITEDATA, CURLOPTTYPE_CBPOINT, 304),\n\n  /* Parameters for V4 signature */\n  CURLOPT(CURLOPT_AWS_SIGV4, CURLOPTTYPE_STRINGPOINT, 305),\n\n  /* Same as CURLOPT_SSL_VERIFYPEER but for DoH (DNS-over-HTTPS) servers. */\n  CURLOPT(CURLOPT_DOH_SSL_VERIFYPEER, CURLOPTTYPE_LONG, 306),\n\n  /* Same as CURLOPT_SSL_VERIFYHOST but for DoH (DNS-over-HTTPS) servers. */\n  CURLOPT(CURLOPT_DOH_SSL_VERIFYHOST, CURLOPTTYPE_LONG, 307),\n\n  /* Same as CURLOPT_SSL_VERIFYSTATUS but for DoH (DNS-over-HTTPS) servers. */\n  CURLOPT(CURLOPT_DOH_SSL_VERIFYSTATUS, CURLOPTTYPE_LONG, 308),\n\n  /* The CA certificates as \"blob\" used to validate the peer certificate\n     this option is used only if SSL_VERIFYPEER is true */\n  CURLOPT(CURLOPT_CAINFO_BLOB, CURLOPTTYPE_BLOB, 309),\n\n  /* The CA certificates as \"blob\" used to validate the proxy certificate\n     this option is used only if PROXY_SSL_VERIFYPEER is true */\n  CURLOPT(CURLOPT_PROXY_CAINFO_BLOB, CURLOPTTYPE_BLOB, 310),\n\n  /* used by scp/sftp to verify the host's public key */\n  CURLOPT(CURLOPT_SSH_HOST_PUBLIC_KEY_SHA256, CURLOPTTYPE_STRINGPOINT, 311),\n\n  /* Function that will be called immediately before the initial request\n     is made on a connection (after any protocol negotiation step).  */\n  CURLOPT(CURLOPT_PREREQFUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 312),\n\n  /* Data passed to the CURLOPT_PREREQFUNCTION callback */\n  CURLOPT(CURLOPT_PREREQDATA, CURLOPTTYPE_CBPOINT, 313),\n\n  /* maximum age (since creation) of a connection to consider it for reuse\n   * (in seconds) */\n  CURLOPT(CURLOPT_MAXLIFETIME_CONN, CURLOPTTYPE_LONG, 314),\n\n  /* Set MIME option flags. */\n  CURLOPT(CURLOPT_MIME_OPTIONS, CURLOPTTYPE_LONG, 315),\n\n  /* set the SSH host key callback, must point to a curl_sshkeycallback\n     function */\n  CURLOPT(CURLOPT_SSH_HOSTKEYFUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 316),\n\n  /* set the SSH host key callback custom pointer */\n  CURLOPT(CURLOPT_SSH_HOSTKEYDATA, CURLOPTTYPE_CBPOINT, 317),\n\n  /* specify which protocols that are allowed to be used for the transfer,\n     which thus helps the app which takes URLs from users or other external\n     inputs and want to restrict what protocol(s) to deal with. Defaults to\n     all built-in protocols. */\n  CURLOPT(CURLOPT_PROTOCOLS_STR, CURLOPTTYPE_STRINGPOINT, 318),\n\n  /* specify which protocols that libcurl is allowed to follow directs to */\n  CURLOPT(CURLOPT_REDIR_PROTOCOLS_STR, CURLOPTTYPE_STRINGPOINT, 319),\n\n  /* websockets options */\n  CURLOPT(CURLOPT_WS_OPTIONS, CURLOPTTYPE_LONG, 320),\n\n  /* CA cache timeout */\n  CURLOPT(CURLOPT_CA_CACHE_TIMEOUT, CURLOPTTYPE_LONG, 321),\n\n  /* Can leak things, gonna exit() soon */\n  CURLOPT(CURLOPT_QUICK_EXIT, CURLOPTTYPE_LONG, 322),\n\n  /* set a specific client IP for HAProxy PROXY protocol header? */\n  CURLOPT(CURLOPT_HAPROXY_CLIENT_IP, CURLOPTTYPE_STRINGPOINT, 323),\n\n  /* millisecond version */\n  CURLOPT(CURLOPT_SERVER_RESPONSE_TIMEOUT_MS, CURLOPTTYPE_LONG, 324),\n\n  CURLOPT_LASTENTRY /* the last unused */\n} CURLoption;\n\n#ifndef CURL_NO_OLDIES /* define this to test if your app builds with all\n                          the obsolete stuff removed! */\n\n/* Backwards compatibility with older names */\n/* These are scheduled to disappear by 2011 */\n\n/* This was added in version 7.19.1 */\n#define CURLOPT_POST301 CURLOPT_POSTREDIR\n\n/* These are scheduled to disappear by 2009 */\n\n/* The following were added in 7.17.0 */\n#define CURLOPT_SSLKEYPASSWD CURLOPT_KEYPASSWD\n#define CURLOPT_FTPAPPEND CURLOPT_APPEND\n#define CURLOPT_FTPLISTONLY CURLOPT_DIRLISTONLY\n#define CURLOPT_FTP_SSL CURLOPT_USE_SSL\n\n/* The following were added earlier */\n\n#define CURLOPT_SSLCERTPASSWD CURLOPT_KEYPASSWD\n#define CURLOPT_KRB4LEVEL CURLOPT_KRBLEVEL\n\n/* */\n#define CURLOPT_FTP_RESPONSE_TIMEOUT CURLOPT_SERVER_RESPONSE_TIMEOUT\n\n/* Added in 8.2.0 */\n#define CURLOPT_MAIL_RCPT_ALLLOWFAILS CURLOPT_MAIL_RCPT_ALLOWFAILS\n\n#else\n/* This is set if CURL_NO_OLDIES is defined at compile-time */\n#undef CURLOPT_DNS_USE_GLOBAL_CACHE /* soon obsolete */\n#endif\n\n\n  /* Below here follows defines for the CURLOPT_IPRESOLVE option. If a host\n     name resolves addresses using more than one IP protocol version, this\n     option might be handy to force libcurl to use a specific IP version. */\n#define CURL_IPRESOLVE_WHATEVER 0 /* default, uses addresses to all IP\n                                     versions that your system allows */\n#define CURL_IPRESOLVE_V4       1 /* uses only IPv4 addresses/connections */\n#define CURL_IPRESOLVE_V6       2 /* uses only IPv6 addresses/connections */\n\n  /* Convenient \"aliases\" */\n#define CURLOPT_RTSPHEADER CURLOPT_HTTPHEADER\n\n  /* These enums are for use with the CURLOPT_HTTP_VERSION option. */\nenum {\n  CURL_HTTP_VERSION_NONE, /* setting this means we don't care, and that we'd\n                             like the library to choose the best possible\n                             for us! */\n  CURL_HTTP_VERSION_1_0,  /* please use HTTP 1.0 in the request */\n  CURL_HTTP_VERSION_1_1,  /* please use HTTP 1.1 in the request */\n  CURL_HTTP_VERSION_2_0,  /* please use HTTP 2 in the request */\n  CURL_HTTP_VERSION_2TLS, /* use version 2 for HTTPS, version 1.1 for HTTP */\n  CURL_HTTP_VERSION_2_PRIOR_KNOWLEDGE,  /* please use HTTP 2 without HTTP/1.1\n                                           Upgrade */\n  CURL_HTTP_VERSION_3 = 30, /* Use HTTP/3, fallback to HTTP/2 or HTTP/1 if\n                               needed. For HTTPS only. For HTTP, this option\n                               makes libcurl return error. */\n  CURL_HTTP_VERSION_3ONLY = 31, /* Use HTTP/3 without fallback. For HTTPS\n                                   only. For HTTP, this makes libcurl\n                                   return error. */\n\n  CURL_HTTP_VERSION_LAST /* *ILLEGAL* http version */\n};\n\n/* Convenience definition simple because the name of the version is HTTP/2 and\n   not 2.0. The 2_0 version of the enum name was set while the version was\n   still planned to be 2.0 and we stick to it for compatibility. */\n#define CURL_HTTP_VERSION_2 CURL_HTTP_VERSION_2_0\n\n/*\n * Public API enums for RTSP requests\n */\nenum {\n    CURL_RTSPREQ_NONE, /* first in list */\n    CURL_RTSPREQ_OPTIONS,\n    CURL_RTSPREQ_DESCRIBE,\n    CURL_RTSPREQ_ANNOUNCE,\n    CURL_RTSPREQ_SETUP,\n    CURL_RTSPREQ_PLAY,\n    CURL_RTSPREQ_PAUSE,\n    CURL_RTSPREQ_TEARDOWN,\n    CURL_RTSPREQ_GET_PARAMETER,\n    CURL_RTSPREQ_SET_PARAMETER,\n    CURL_RTSPREQ_RECORD,\n    CURL_RTSPREQ_RECEIVE,\n    CURL_RTSPREQ_LAST /* last in list */\n};\n\n  /* These enums are for use with the CURLOPT_NETRC option. */\nenum CURL_NETRC_OPTION {\n  CURL_NETRC_IGNORED,     /* The .netrc will never be read.\n                           * This is the default. */\n  CURL_NETRC_OPTIONAL,    /* A user:password in the URL will be preferred\n                           * to one in the .netrc. */\n  CURL_NETRC_REQUIRED,    /* A user:password in the URL will be ignored.\n                           * Unless one is set programmatically, the .netrc\n                           * will be queried. */\n  CURL_NETRC_LAST\n};\n\nenum {\n  CURL_SSLVERSION_DEFAULT,\n  CURL_SSLVERSION_TLSv1, /* TLS 1.x */\n  CURL_SSLVERSION_SSLv2,\n  CURL_SSLVERSION_SSLv3,\n  CURL_SSLVERSION_TLSv1_0,\n  CURL_SSLVERSION_TLSv1_1,\n  CURL_SSLVERSION_TLSv1_2,\n  CURL_SSLVERSION_TLSv1_3,\n\n  CURL_SSLVERSION_LAST /* never use, keep last */\n};\n\nenum {\n  CURL_SSLVERSION_MAX_NONE =     0,\n  CURL_SSLVERSION_MAX_DEFAULT =  (CURL_SSLVERSION_TLSv1   << 16),\n  CURL_SSLVERSION_MAX_TLSv1_0 =  (CURL_SSLVERSION_TLSv1_0 << 16),\n  CURL_SSLVERSION_MAX_TLSv1_1 =  (CURL_SSLVERSION_TLSv1_1 << 16),\n  CURL_SSLVERSION_MAX_TLSv1_2 =  (CURL_SSLVERSION_TLSv1_2 << 16),\n  CURL_SSLVERSION_MAX_TLSv1_3 =  (CURL_SSLVERSION_TLSv1_3 << 16),\n\n  /* never use, keep last */\n  CURL_SSLVERSION_MAX_LAST =     (CURL_SSLVERSION_LAST    << 16)\n};\n\nenum CURL_TLSAUTH {\n  CURL_TLSAUTH_NONE,\n  CURL_TLSAUTH_SRP,\n  CURL_TLSAUTH_LAST /* never use, keep last */\n};\n\n/* symbols to use with CURLOPT_POSTREDIR.\n   CURL_REDIR_POST_301, CURL_REDIR_POST_302 and CURL_REDIR_POST_303\n   can be bitwise ORed so that CURL_REDIR_POST_301 | CURL_REDIR_POST_302\n   | CURL_REDIR_POST_303 == CURL_REDIR_POST_ALL */\n\n#define CURL_REDIR_GET_ALL  0\n#define CURL_REDIR_POST_301 1\n#define CURL_REDIR_POST_302 2\n#define CURL_REDIR_POST_303 4\n#define CURL_REDIR_POST_ALL \\\n    (CURL_REDIR_POST_301|CURL_REDIR_POST_302|CURL_REDIR_POST_303)\n\ntypedef enum {\n  CURL_TIMECOND_NONE,\n\n  CURL_TIMECOND_IFMODSINCE,\n  CURL_TIMECOND_IFUNMODSINCE,\n  CURL_TIMECOND_LASTMOD,\n\n  CURL_TIMECOND_LAST\n} curl_TimeCond;\n\n/* Special size_t value signaling a null-terminated string. */\n#define CURL_ZERO_TERMINATED ((size_t) -1)\n\n/* curl_strequal() and curl_strnequal() are subject for removal in a future\n   release */\nCURL_EXTERN int curl_strequal(const char *s1, const char *s2);\nCURL_EXTERN int curl_strnequal(const char *s1, const char *s2, size_t n);\n\n/* Mime/form handling support. */\ntypedef struct curl_mime      curl_mime;      /* Mime context. */\ntypedef struct curl_mimepart  curl_mimepart;  /* Mime part context. */\n\n/* CURLMIMEOPT_ defines are for the CURLOPT_MIME_OPTIONS option. */\n#define CURLMIMEOPT_FORMESCAPE  (1<<0) /* Use backslash-escaping for forms. */\n\n/*\n * NAME curl_mime_init()\n *\n * DESCRIPTION\n *\n * Create a mime context and return its handle. The easy parameter is the\n * target handle.\n */\nCURL_EXTERN curl_mime *curl_mime_init(CURL *easy);\n\n/*\n * NAME curl_mime_free()\n *\n * DESCRIPTION\n *\n * release a mime handle and its substructures.\n */\nCURL_EXTERN void curl_mime_free(curl_mime *mime);\n\n/*\n * NAME curl_mime_addpart()\n *\n * DESCRIPTION\n *\n * Append a new empty part to the given mime context and return a handle to\n * the created part.\n */\nCURL_EXTERN curl_mimepart *curl_mime_addpart(curl_mime *mime);\n\n/*\n * NAME curl_mime_name()\n *\n * DESCRIPTION\n *\n * Set mime/form part name.\n */\nCURL_EXTERN CURLcode curl_mime_name(curl_mimepart *part, const char *name);\n\n/*\n * NAME curl_mime_filename()\n *\n * DESCRIPTION\n *\n * Set mime part remote file name.\n */\nCURL_EXTERN CURLcode curl_mime_filename(curl_mimepart *part,\n                                        const char *filename);\n\n/*\n * NAME curl_mime_type()\n *\n * DESCRIPTION\n *\n * Set mime part type.\n */\nCURL_EXTERN CURLcode curl_mime_type(curl_mimepart *part, const char *mimetype);\n\n/*\n * NAME curl_mime_encoder()\n *\n * DESCRIPTION\n *\n * Set mime data transfer encoder.\n */\nCURL_EXTERN CURLcode curl_mime_encoder(curl_mimepart *part,\n                                       const char *encoding);\n\n/*\n * NAME curl_mime_data()\n *\n * DESCRIPTION\n *\n * Set mime part data source from memory data,\n */\nCURL_EXTERN CURLcode curl_mime_data(curl_mimepart *part,\n                                    const char *data, size_t datasize);\n\n/*\n * NAME curl_mime_filedata()\n *\n * DESCRIPTION\n *\n * Set mime part data source from named file.\n */\nCURL_EXTERN CURLcode curl_mime_filedata(curl_mimepart *part,\n                                        const char *filename);\n\n/*\n * NAME curl_mime_data_cb()\n *\n * DESCRIPTION\n *\n * Set mime part data source from callback function.\n */\nCURL_EXTERN CURLcode curl_mime_data_cb(curl_mimepart *part,\n                                       curl_off_t datasize,\n                                       curl_read_callback readfunc,\n                                       curl_seek_callback seekfunc,\n                                       curl_free_callback freefunc,\n                                       void *arg);\n\n/*\n * NAME curl_mime_subparts()\n *\n * DESCRIPTION\n *\n * Set mime part data source from subparts.\n */\nCURL_EXTERN CURLcode curl_mime_subparts(curl_mimepart *part,\n                                        curl_mime *subparts);\n/*\n * NAME curl_mime_headers()\n *\n * DESCRIPTION\n *\n * Set mime part headers.\n */\nCURL_EXTERN CURLcode curl_mime_headers(curl_mimepart *part,\n                                       struct curl_slist *headers,\n                                       int take_ownership);\n\ntypedef enum {\n  /********* the first one is unused ************/\n  CURLFORM_NOTHING         CURL_DEPRECATED(7.56.0, \"\"),\n  CURLFORM_COPYNAME        CURL_DEPRECATED(7.56.0, \"Use curl_mime_name()\"),\n  CURLFORM_PTRNAME         CURL_DEPRECATED(7.56.0, \"Use curl_mime_name()\"),\n  CURLFORM_NAMELENGTH      CURL_DEPRECATED(7.56.0, \"\"),\n  CURLFORM_COPYCONTENTS    CURL_DEPRECATED(7.56.0, \"Use curl_mime_data()\"),\n  CURLFORM_PTRCONTENTS     CURL_DEPRECATED(7.56.0, \"Use curl_mime_data()\"),\n  CURLFORM_CONTENTSLENGTH  CURL_DEPRECATED(7.56.0, \"Use curl_mime_data()\"),\n  CURLFORM_FILECONTENT     CURL_DEPRECATED(7.56.0, \"Use curl_mime_data_cb()\"),\n  CURLFORM_ARRAY           CURL_DEPRECATED(7.56.0, \"\"),\n  CURLFORM_OBSOLETE,\n  CURLFORM_FILE            CURL_DEPRECATED(7.56.0, \"Use curl_mime_filedata()\"),\n\n  CURLFORM_BUFFER          CURL_DEPRECATED(7.56.0, \"Use curl_mime_filename()\"),\n  CURLFORM_BUFFERPTR       CURL_DEPRECATED(7.56.0, \"Use curl_mime_data()\"),\n  CURLFORM_BUFFERLENGTH    CURL_DEPRECATED(7.56.0, \"Use curl_mime_data()\"),\n\n  CURLFORM_CONTENTTYPE     CURL_DEPRECATED(7.56.0, \"Use curl_mime_type()\"),\n  CURLFORM_CONTENTHEADER   CURL_DEPRECATED(7.56.0, \"Use curl_mime_headers()\"),\n  CURLFORM_FILENAME        CURL_DEPRECATED(7.56.0, \"Use curl_mime_filename()\"),\n  CURLFORM_END,\n  CURLFORM_OBSOLETE2,\n\n  CURLFORM_STREAM          CURL_DEPRECATED(7.56.0, \"Use curl_mime_data_cb()\"),\n  CURLFORM_CONTENTLEN  /* added in 7.46.0, provide a curl_off_t length */\n                           CURL_DEPRECATED(7.56.0, \"Use curl_mime_data()\"),\n\n  CURLFORM_LASTENTRY /* the last unused */\n} CURLformoption;\n\n/* structure to be used as parameter for CURLFORM_ARRAY */\nstruct curl_forms {\n  CURLformoption option;\n  const char     *value;\n};\n\n/* use this for multipart formpost building */\n/* Returns code for curl_formadd()\n *\n * Returns:\n * CURL_FORMADD_OK             on success\n * CURL_FORMADD_MEMORY         if the FormInfo allocation fails\n * CURL_FORMADD_OPTION_TWICE   if one option is given twice for one Form\n * CURL_FORMADD_NULL           if a null pointer was given for a char\n * CURL_FORMADD_MEMORY         if the allocation of a FormInfo struct failed\n * CURL_FORMADD_UNKNOWN_OPTION if an unknown option was used\n * CURL_FORMADD_INCOMPLETE     if the some FormInfo is not complete (or error)\n * CURL_FORMADD_MEMORY         if a curl_httppost struct cannot be allocated\n * CURL_FORMADD_MEMORY         if some allocation for string copying failed.\n * CURL_FORMADD_ILLEGAL_ARRAY  if an illegal option is used in an array\n *\n ***************************************************************************/\ntypedef enum {\n  CURL_FORMADD_OK             CURL_DEPRECATED(7.56.0, \"\"), /* 1st, no error */\n\n  CURL_FORMADD_MEMORY         CURL_DEPRECATED(7.56.0, \"\"),\n  CURL_FORMADD_OPTION_TWICE   CURL_DEPRECATED(7.56.0, \"\"),\n  CURL_FORMADD_NULL           CURL_DEPRECATED(7.56.0, \"\"),\n  CURL_FORMADD_UNKNOWN_OPTION CURL_DEPRECATED(7.56.0, \"\"),\n  CURL_FORMADD_INCOMPLETE     CURL_DEPRECATED(7.56.0, \"\"),\n  CURL_FORMADD_ILLEGAL_ARRAY  CURL_DEPRECATED(7.56.0, \"\"),\n  /* libcurl was built with form api disabled */\n  CURL_FORMADD_DISABLED       CURL_DEPRECATED(7.56.0, \"\"),\n\n  CURL_FORMADD_LAST /* last */\n} CURLFORMcode;\n\n/*\n * NAME curl_formadd()\n *\n * DESCRIPTION\n *\n * Pretty advanced function for building multi-part formposts. Each invoke\n * adds one part that together construct a full post. Then use\n * CURLOPT_HTTPPOST to send it off to libcurl.\n */\nCURL_EXTERN CURLFORMcode CURL_DEPRECATED(7.56.0, \"Use curl_mime_init()\")\ncurl_formadd(struct curl_httppost **httppost,\n             struct curl_httppost **last_post,\n             ...);\n\n/*\n * callback function for curl_formget()\n * The void *arg pointer will be the one passed as second argument to\n *   curl_formget().\n * The character buffer passed to it must not be freed.\n * Should return the buffer length passed to it as the argument \"len\" on\n *   success.\n */\ntypedef size_t (*curl_formget_callback)(void *arg, const char *buf,\n                                        size_t len);\n\n/*\n * NAME curl_formget()\n *\n * DESCRIPTION\n *\n * Serialize a curl_httppost struct built with curl_formadd().\n * Accepts a void pointer as second argument which will be passed to\n * the curl_formget_callback function.\n * Returns 0 on success.\n */\nCURL_EXTERN int CURL_DEPRECATED(7.56.0, \"\")\ncurl_formget(struct curl_httppost *form, void *arg,\n             curl_formget_callback append);\n/*\n * NAME curl_formfree()\n *\n * DESCRIPTION\n *\n * Free a multipart formpost previously built with curl_formadd().\n */\nCURL_EXTERN void CURL_DEPRECATED(7.56.0, \"Use curl_mime_free()\")\ncurl_formfree(struct curl_httppost *form);\n\n/*\n * NAME curl_getenv()\n *\n * DESCRIPTION\n *\n * Returns a malloc()'ed string that MUST be curl_free()ed after usage is\n * complete. DEPRECATED - see lib/README.curlx\n */\nCURL_EXTERN char *curl_getenv(const char *variable);\n\n/*\n * NAME curl_version()\n *\n * DESCRIPTION\n *\n * Returns a static ascii string of the libcurl version.\n */\nCURL_EXTERN char *curl_version(void);\n\n/*\n * NAME curl_easy_escape()\n *\n * DESCRIPTION\n *\n * Escapes URL strings (converts all letters consider illegal in URLs to their\n * %XX versions). This function returns a new allocated string or NULL if an\n * error occurred.\n */\nCURL_EXTERN char *curl_easy_escape(CURL *handle,\n                                   const char *string,\n                                   int length);\n\n/* the previous version: */\nCURL_EXTERN char *curl_escape(const char *string,\n                              int length);\n\n\n/*\n * NAME curl_easy_unescape()\n *\n * DESCRIPTION\n *\n * Unescapes URL encoding in strings (converts all %XX codes to their 8bit\n * versions). This function returns a new allocated string or NULL if an error\n * occurred.\n * Conversion Note: On non-ASCII platforms the ASCII %XX codes are\n * converted into the host encoding.\n */\nCURL_EXTERN char *curl_easy_unescape(CURL *handle,\n                                     const char *string,\n                                     int length,\n                                     int *outlength);\n\n/* the previous version */\nCURL_EXTERN char *curl_unescape(const char *string,\n                                int length);\n\n/*\n * NAME curl_free()\n *\n * DESCRIPTION\n *\n * Provided for de-allocation in the same translation unit that did the\n * allocation. Added in libcurl 7.10\n */\nCURL_EXTERN void curl_free(void *p);\n\n/*\n * NAME curl_global_init()\n *\n * DESCRIPTION\n *\n * curl_global_init() should be invoked exactly once for each application that\n * uses libcurl and before any call of other libcurl functions.\n\n * This function is thread-safe if CURL_VERSION_THREADSAFE is set in the\n * curl_version_info_data.features flag (fetch by curl_version_info()).\n\n */\nCURL_EXTERN CURLcode curl_global_init(long flags);\n\n/*\n * NAME curl_global_init_mem()\n *\n * DESCRIPTION\n *\n * curl_global_init() or curl_global_init_mem() should be invoked exactly once\n * for each application that uses libcurl.  This function can be used to\n * initialize libcurl and set user defined memory management callback\n * functions.  Users can implement memory management routines to check for\n * memory leaks, check for mis-use of the curl library etc.  User registered\n * callback routines will be invoked by this library instead of the system\n * memory management routines like malloc, free etc.\n */\nCURL_EXTERN CURLcode curl_global_init_mem(long flags,\n                                          curl_malloc_callback m,\n                                          curl_free_callback f,\n                                          curl_realloc_callback r,\n                                          curl_strdup_callback s,\n                                          curl_calloc_callback c);\n\n/*\n * NAME curl_global_cleanup()\n *\n * DESCRIPTION\n *\n * curl_global_cleanup() should be invoked exactly once for each application\n * that uses libcurl\n */\nCURL_EXTERN void curl_global_cleanup(void);\n\n/*\n * NAME curl_global_trace()\n *\n * DESCRIPTION\n *\n * curl_global_trace() can be invoked at application start to\n * configure which components in curl should participate in tracing.\n\n * This function is thread-safe if CURL_VERSION_THREADSAFE is set in the\n * curl_version_info_data.features flag (fetch by curl_version_info()).\n\n */\nCURL_EXTERN CURLcode curl_global_trace(const char *config);\n\n/* linked-list structure for the CURLOPT_QUOTE option (and other) */\nstruct curl_slist {\n  char *data;\n  struct curl_slist *next;\n};\n\n/*\n * NAME curl_global_sslset()\n *\n * DESCRIPTION\n *\n * When built with multiple SSL backends, curl_global_sslset() allows to\n * choose one. This function can only be called once, and it must be called\n * *before* curl_global_init().\n *\n * The backend can be identified by the id (e.g. CURLSSLBACKEND_OPENSSL). The\n * backend can also be specified via the name parameter (passing -1 as id).\n * If both id and name are specified, the name will be ignored. If neither id\n * nor name are specified, the function will fail with\n * CURLSSLSET_UNKNOWN_BACKEND and set the \"avail\" pointer to the\n * NULL-terminated list of available backends.\n *\n * Upon success, the function returns CURLSSLSET_OK.\n *\n * If the specified SSL backend is not available, the function returns\n * CURLSSLSET_UNKNOWN_BACKEND and sets the \"avail\" pointer to a NULL-terminated\n * list of available SSL backends.\n *\n * The SSL backend can be set only once. If it has already been set, a\n * subsequent attempt to change it will result in a CURLSSLSET_TOO_LATE.\n */\n\nstruct curl_ssl_backend {\n  curl_sslbackend id;\n  const char *name;\n};\ntypedef struct curl_ssl_backend curl_ssl_backend;\n\ntypedef enum {\n  CURLSSLSET_OK = 0,\n  CURLSSLSET_UNKNOWN_BACKEND,\n  CURLSSLSET_TOO_LATE,\n  CURLSSLSET_NO_BACKENDS /* libcurl was built without any SSL support */\n} CURLsslset;\n\nCURL_EXTERN CURLsslset curl_global_sslset(curl_sslbackend id, const char *name,\n                                          const curl_ssl_backend ***avail);\n\n/*\n * NAME curl_slist_append()\n *\n * DESCRIPTION\n *\n * Appends a string to a linked list. If no list exists, it will be created\n * first. Returns the new list, after appending.\n */\nCURL_EXTERN struct curl_slist *curl_slist_append(struct curl_slist *list,\n                                                 const char *data);\n\n/*\n * NAME curl_slist_free_all()\n *\n * DESCRIPTION\n *\n * free a previously built curl_slist.\n */\nCURL_EXTERN void curl_slist_free_all(struct curl_slist *list);\n\n/*\n * NAME curl_getdate()\n *\n * DESCRIPTION\n *\n * Returns the time, in seconds since 1 Jan 1970 of the time string given in\n * the first argument. The time argument in the second parameter is unused\n * and should be set to NULL.\n */\nCURL_EXTERN time_t curl_getdate(const char *p, const time_t *unused);\n\n/* info about the certificate chain, for SSL backends that support it. Asked\n   for with CURLOPT_CERTINFO / CURLINFO_CERTINFO */\nstruct curl_certinfo {\n  int num_of_certs;             /* number of certificates with information */\n  struct curl_slist **certinfo; /* for each index in this array, there's a\n                                   linked list with textual information for a\n                                   certificate in the format \"name:content\".\n                                   eg \"Subject:foo\", \"Issuer:bar\", etc. */\n};\n\n/* Information about the SSL library used and the respective internal SSL\n   handle, which can be used to obtain further information regarding the\n   connection. Asked for with CURLINFO_TLS_SSL_PTR or CURLINFO_TLS_SESSION. */\nstruct curl_tlssessioninfo {\n  curl_sslbackend backend;\n  void *internals;\n};\n\n#define CURLINFO_STRING   0x100000\n#define CURLINFO_LONG     0x200000\n#define CURLINFO_DOUBLE   0x300000\n#define CURLINFO_SLIST    0x400000\n#define CURLINFO_PTR      0x400000 /* same as SLIST */\n#define CURLINFO_SOCKET   0x500000\n#define CURLINFO_OFF_T    0x600000\n#define CURLINFO_MASK     0x0fffff\n#define CURLINFO_TYPEMASK 0xf00000\n\ntypedef enum {\n  CURLINFO_NONE, /* first, never use this */\n  CURLINFO_EFFECTIVE_URL    = CURLINFO_STRING + 1,\n  CURLINFO_RESPONSE_CODE    = CURLINFO_LONG   + 2,\n  CURLINFO_TOTAL_TIME       = CURLINFO_DOUBLE + 3,\n  CURLINFO_NAMELOOKUP_TIME  = CURLINFO_DOUBLE + 4,\n  CURLINFO_CONNECT_TIME     = CURLINFO_DOUBLE + 5,\n  CURLINFO_PRETRANSFER_TIME = CURLINFO_DOUBLE + 6,\n  CURLINFO_SIZE_UPLOAD CURL_DEPRECATED(7.55.0, \"Use CURLINFO_SIZE_UPLOAD_T\")\n                            = CURLINFO_DOUBLE + 7,\n  CURLINFO_SIZE_UPLOAD_T    = CURLINFO_OFF_T  + 7,\n  CURLINFO_SIZE_DOWNLOAD\n                       CURL_DEPRECATED(7.55.0, \"Use CURLINFO_SIZE_DOWNLOAD_T\")\n                            = CURLINFO_DOUBLE + 8,\n  CURLINFO_SIZE_DOWNLOAD_T  = CURLINFO_OFF_T  + 8,\n  CURLINFO_SPEED_DOWNLOAD\n                       CURL_DEPRECATED(7.55.0, \"Use CURLINFO_SPEED_DOWNLOAD_T\")\n                            = CURLINFO_DOUBLE + 9,\n  CURLINFO_SPEED_DOWNLOAD_T = CURLINFO_OFF_T  + 9,\n  CURLINFO_SPEED_UPLOAD\n                       CURL_DEPRECATED(7.55.0, \"Use CURLINFO_SPEED_UPLOAD_T\")\n                            = CURLINFO_DOUBLE + 10,\n  CURLINFO_SPEED_UPLOAD_T   = CURLINFO_OFF_T  + 10,\n  CURLINFO_HEADER_SIZE      = CURLINFO_LONG   + 11,\n  CURLINFO_REQUEST_SIZE     = CURLINFO_LONG   + 12,\n  CURLINFO_SSL_VERIFYRESULT = CURLINFO_LONG   + 13,\n  CURLINFO_FILETIME         = CURLINFO_LONG   + 14,\n  CURLINFO_FILETIME_T       = CURLINFO_OFF_T  + 14,\n  CURLINFO_CONTENT_LENGTH_DOWNLOAD\n                       CURL_DEPRECATED(7.55.0,\n                                      \"Use CURLINFO_CONTENT_LENGTH_DOWNLOAD_T\")\n                            = CURLINFO_DOUBLE + 15,\n  CURLINFO_CONTENT_LENGTH_DOWNLOAD_T = CURLINFO_OFF_T  + 15,\n  CURLINFO_CONTENT_LENGTH_UPLOAD\n                       CURL_DEPRECATED(7.55.0,\n                                       \"Use CURLINFO_CONTENT_LENGTH_UPLOAD_T\")\n                            = CURLINFO_DOUBLE + 16,\n  CURLINFO_CONTENT_LENGTH_UPLOAD_T   = CURLINFO_OFF_T  + 16,\n  CURLINFO_STARTTRANSFER_TIME = CURLINFO_DOUBLE + 17,\n  CURLINFO_CONTENT_TYPE     = CURLINFO_STRING + 18,\n  CURLINFO_REDIRECT_TIME    = CURLINFO_DOUBLE + 19,\n  CURLINFO_REDIRECT_COUNT   = CURLINFO_LONG   + 20,\n  CURLINFO_PRIVATE          = CURLINFO_STRING + 21,\n  CURLINFO_HTTP_CONNECTCODE = CURLINFO_LONG   + 22,\n  CURLINFO_HTTPAUTH_AVAIL   = CURLINFO_LONG   + 23,\n  CURLINFO_PROXYAUTH_AVAIL  = CURLINFO_LONG   + 24,\n  CURLINFO_OS_ERRNO         = CURLINFO_LONG   + 25,\n  CURLINFO_NUM_CONNECTS     = CURLINFO_LONG   + 26,\n  CURLINFO_SSL_ENGINES      = CURLINFO_SLIST  + 27,\n  CURLINFO_COOKIELIST       = CURLINFO_SLIST  + 28,\n  CURLINFO_LASTSOCKET  CURL_DEPRECATED(7.45.0, \"Use CURLINFO_ACTIVESOCKET\")\n                            = CURLINFO_LONG   + 29,\n  CURLINFO_FTP_ENTRY_PATH   = CURLINFO_STRING + 30,\n  CURLINFO_REDIRECT_URL     = CURLINFO_STRING + 31,\n  CURLINFO_PRIMARY_IP       = CURLINFO_STRING + 32,\n  CURLINFO_APPCONNECT_TIME  = CURLINFO_DOUBLE + 33,\n  CURLINFO_CERTINFO         = CURLINFO_PTR    + 34,\n  CURLINFO_CONDITION_UNMET  = CURLINFO_LONG   + 35,\n  CURLINFO_RTSP_SESSION_ID  = CURLINFO_STRING + 36,\n  CURLINFO_RTSP_CLIENT_CSEQ = CURLINFO_LONG   + 37,\n  CURLINFO_RTSP_SERVER_CSEQ = CURLINFO_LONG   + 38,\n  CURLINFO_RTSP_CSEQ_RECV   = CURLINFO_LONG   + 39,\n  CURLINFO_PRIMARY_PORT     = CURLINFO_LONG   + 40,\n  CURLINFO_LOCAL_IP         = CURLINFO_STRING + 41,\n  CURLINFO_LOCAL_PORT       = CURLINFO_LONG   + 42,\n  CURLINFO_TLS_SESSION CURL_DEPRECATED(7.48.0, \"Use CURLINFO_TLS_SSL_PTR\")\n                            = CURLINFO_PTR    + 43,\n  CURLINFO_ACTIVESOCKET     = CURLINFO_SOCKET + 44,\n  CURLINFO_TLS_SSL_PTR      = CURLINFO_PTR    + 45,\n  CURLINFO_HTTP_VERSION     = CURLINFO_LONG   + 46,\n  CURLINFO_PROXY_SSL_VERIFYRESULT = CURLINFO_LONG + 47,\n  CURLINFO_PROTOCOL    CURL_DEPRECATED(7.85.0, \"Use CURLINFO_SCHEME\")\n                            = CURLINFO_LONG   + 48,\n  CURLINFO_SCHEME           = CURLINFO_STRING + 49,\n  CURLINFO_TOTAL_TIME_T     = CURLINFO_OFF_T + 50,\n  CURLINFO_NAMELOOKUP_TIME_T = CURLINFO_OFF_T + 51,\n  CURLINFO_CONNECT_TIME_T   = CURLINFO_OFF_T + 52,\n  CURLINFO_PRETRANSFER_TIME_T = CURLINFO_OFF_T + 53,\n  CURLINFO_STARTTRANSFER_TIME_T = CURLINFO_OFF_T + 54,\n  CURLINFO_REDIRECT_TIME_T  = CURLINFO_OFF_T + 55,\n  CURLINFO_APPCONNECT_TIME_T = CURLINFO_OFF_T + 56,\n  CURLINFO_RETRY_AFTER      = CURLINFO_OFF_T + 57,\n  CURLINFO_EFFECTIVE_METHOD = CURLINFO_STRING + 58,\n  CURLINFO_PROXY_ERROR      = CURLINFO_LONG + 59,\n  CURLINFO_REFERER          = CURLINFO_STRING + 60,\n  CURLINFO_CAINFO           = CURLINFO_STRING + 61,\n  CURLINFO_CAPATH           = CURLINFO_STRING + 62,\n  CURLINFO_XFER_ID          = CURLINFO_OFF_T + 63,\n  CURLINFO_CONN_ID          = CURLINFO_OFF_T + 64,\n  CURLINFO_QUEUE_TIME_T     = CURLINFO_OFF_T + 65,\n  CURLINFO_USED_PROXY       = CURLINFO_LONG + 66,\n  CURLINFO_LASTONE          = 66\n} CURLINFO;\n\n/* CURLINFO_RESPONSE_CODE is the new name for the option previously known as\n   CURLINFO_HTTP_CODE */\n#define CURLINFO_HTTP_CODE CURLINFO_RESPONSE_CODE\n\ntypedef enum {\n  CURLCLOSEPOLICY_NONE, /* first, never use this */\n\n  CURLCLOSEPOLICY_OLDEST,\n  CURLCLOSEPOLICY_LEAST_RECENTLY_USED,\n  CURLCLOSEPOLICY_LEAST_TRAFFIC,\n  CURLCLOSEPOLICY_SLOWEST,\n  CURLCLOSEPOLICY_CALLBACK,\n\n  CURLCLOSEPOLICY_LAST /* last, never use this */\n} curl_closepolicy;\n\n#define CURL_GLOBAL_SSL (1<<0) /* no purpose since 7.57.0 */\n#define CURL_GLOBAL_WIN32 (1<<1)\n#define CURL_GLOBAL_ALL (CURL_GLOBAL_SSL|CURL_GLOBAL_WIN32)\n#define CURL_GLOBAL_NOTHING 0\n#define CURL_GLOBAL_DEFAULT CURL_GLOBAL_ALL\n#define CURL_GLOBAL_ACK_EINTR (1<<2)\n\n\n/*****************************************************************************\n * Setup defines, protos etc for the sharing stuff.\n */\n\n/* Different data locks for a single share */\ntypedef enum {\n  CURL_LOCK_DATA_NONE = 0,\n  /*  CURL_LOCK_DATA_SHARE is used internally to say that\n   *  the locking is just made to change the internal state of the share\n   *  itself.\n   */\n  CURL_LOCK_DATA_SHARE,\n  CURL_LOCK_DATA_COOKIE,\n  CURL_LOCK_DATA_DNS,\n  CURL_LOCK_DATA_SSL_SESSION,\n  CURL_LOCK_DATA_CONNECT,\n  CURL_LOCK_DATA_PSL,\n  CURL_LOCK_DATA_HSTS,\n  CURL_LOCK_DATA_LAST\n} curl_lock_data;\n\n/* Different lock access types */\ntypedef enum {\n  CURL_LOCK_ACCESS_NONE = 0,   /* unspecified action */\n  CURL_LOCK_ACCESS_SHARED = 1, /* for read perhaps */\n  CURL_LOCK_ACCESS_SINGLE = 2, /* for write perhaps */\n  CURL_LOCK_ACCESS_LAST        /* never use */\n} curl_lock_access;\n\ntypedef void (*curl_lock_function)(CURL *handle,\n                                   curl_lock_data data,\n                                   curl_lock_access locktype,\n                                   void *userptr);\ntypedef void (*curl_unlock_function)(CURL *handle,\n                                     curl_lock_data data,\n                                     void *userptr);\n\n\ntypedef enum {\n  CURLSHE_OK,  /* all is fine */\n  CURLSHE_BAD_OPTION, /* 1 */\n  CURLSHE_IN_USE,     /* 2 */\n  CURLSHE_INVALID,    /* 3 */\n  CURLSHE_NOMEM,      /* 4 out of memory */\n  CURLSHE_NOT_BUILT_IN, /* 5 feature not present in lib */\n  CURLSHE_LAST        /* never use */\n} CURLSHcode;\n\ntypedef enum {\n  CURLSHOPT_NONE,  /* don't use */\n  CURLSHOPT_SHARE,   /* specify a data type to share */\n  CURLSHOPT_UNSHARE, /* specify which data type to stop sharing */\n  CURLSHOPT_LOCKFUNC,   /* pass in a 'curl_lock_function' pointer */\n  CURLSHOPT_UNLOCKFUNC, /* pass in a 'curl_unlock_function' pointer */\n  CURLSHOPT_USERDATA,   /* pass in a user data pointer used in the lock/unlock\n                           callback functions */\n  CURLSHOPT_LAST  /* never use */\n} CURLSHoption;\n\nCURL_EXTERN CURLSH *curl_share_init(void);\nCURL_EXTERN CURLSHcode curl_share_setopt(CURLSH *share, CURLSHoption option,\n                                         ...);\nCURL_EXTERN CURLSHcode curl_share_cleanup(CURLSH *share);\n\n/****************************************************************************\n * Structures for querying information about the curl library at runtime.\n */\n\ntypedef enum {\n  CURLVERSION_FIRST,\n  CURLVERSION_SECOND,\n  CURLVERSION_THIRD,\n  CURLVERSION_FOURTH,\n  CURLVERSION_FIFTH,\n  CURLVERSION_SIXTH,\n  CURLVERSION_SEVENTH,\n  CURLVERSION_EIGHTH,\n  CURLVERSION_NINTH,\n  CURLVERSION_TENTH,\n  CURLVERSION_ELEVENTH,\n  CURLVERSION_LAST /* never actually use this */\n} CURLversion;\n\n/* The 'CURLVERSION_NOW' is the symbolic name meant to be used by\n   basically all programs ever that want to get version information. It is\n   meant to be a built-in version number for what kind of struct the caller\n   expects. If the struct ever changes, we redefine the NOW to another enum\n   from above. */\n#define CURLVERSION_NOW CURLVERSION_ELEVENTH\n\nstruct curl_version_info_data {\n  CURLversion age;          /* age of the returned struct */\n  const char *version;      /* LIBCURL_VERSION */\n  unsigned int version_num; /* LIBCURL_VERSION_NUM */\n  const char *host;         /* OS/host/cpu/machine when configured */\n  int features;             /* bitmask, see defines below */\n  const char *ssl_version;  /* human readable string */\n  long ssl_version_num;     /* not used anymore, always 0 */\n  const char *libz_version; /* human readable string */\n  /* protocols is terminated by an entry with a NULL protoname */\n  const char * const *protocols;\n\n  /* The fields below this were added in CURLVERSION_SECOND */\n  const char *ares;\n  int ares_num;\n\n  /* This field was added in CURLVERSION_THIRD */\n  const char *libidn;\n\n  /* These field were added in CURLVERSION_FOURTH */\n\n  /* Same as '_libiconv_version' if built with HAVE_ICONV */\n  int iconv_ver_num;\n\n  const char *libssh_version; /* human readable string */\n\n  /* These fields were added in CURLVERSION_FIFTH */\n  unsigned int brotli_ver_num; /* Numeric Brotli version\n                                  (MAJOR << 24) | (MINOR << 12) | PATCH */\n  const char *brotli_version; /* human readable string. */\n\n  /* These fields were added in CURLVERSION_SIXTH */\n  unsigned int nghttp2_ver_num; /* Numeric nghttp2 version\n                                   (MAJOR << 16) | (MINOR << 8) | PATCH */\n  const char *nghttp2_version; /* human readable string. */\n  const char *quic_version;    /* human readable quic (+ HTTP/3) library +\n                                  version or NULL */\n\n  /* These fields were added in CURLVERSION_SEVENTH */\n  const char *cainfo;          /* the built-in default CURLOPT_CAINFO, might\n                                  be NULL */\n  const char *capath;          /* the built-in default CURLOPT_CAPATH, might\n                                  be NULL */\n\n  /* These fields were added in CURLVERSION_EIGHTH */\n  unsigned int zstd_ver_num; /* Numeric Zstd version\n                                  (MAJOR << 24) | (MINOR << 12) | PATCH */\n  const char *zstd_version; /* human readable string. */\n\n  /* These fields were added in CURLVERSION_NINTH */\n  const char *hyper_version; /* human readable string. */\n\n  /* These fields were added in CURLVERSION_TENTH */\n  const char *gsasl_version; /* human readable string. */\n\n  /* These fields were added in CURLVERSION_ELEVENTH */\n  /* feature_names is terminated by an entry with a NULL feature name */\n  const char * const *feature_names;\n};\ntypedef struct curl_version_info_data curl_version_info_data;\n\n#define CURL_VERSION_IPV6         (1<<0)  /* IPv6-enabled */\n#define CURL_VERSION_KERBEROS4    (1<<1)  /* Kerberos V4 auth is supported\n                                             (deprecated) */\n#define CURL_VERSION_SSL          (1<<2)  /* SSL options are present */\n#define CURL_VERSION_LIBZ         (1<<3)  /* libz features are present */\n#define CURL_VERSION_NTLM         (1<<4)  /* NTLM auth is supported */\n#define CURL_VERSION_GSSNEGOTIATE (1<<5)  /* Negotiate auth is supported\n                                             (deprecated) */\n#define CURL_VERSION_DEBUG        (1<<6)  /* Built with debug capabilities */\n#define CURL_VERSION_ASYNCHDNS    (1<<7)  /* Asynchronous DNS resolves */\n#define CURL_VERSION_SPNEGO       (1<<8)  /* SPNEGO auth is supported */\n#define CURL_VERSION_LARGEFILE    (1<<9)  /* Supports files larger than 2GB */\n#define CURL_VERSION_IDN          (1<<10) /* Internationized Domain Names are\n                                             supported */\n#define CURL_VERSION_SSPI         (1<<11) /* Built against Windows SSPI */\n#define CURL_VERSION_CONV         (1<<12) /* Character conversions supported */\n#define CURL_VERSION_CURLDEBUG    (1<<13) /* Debug memory tracking supported */\n#define CURL_VERSION_TLSAUTH_SRP  (1<<14) /* TLS-SRP auth is supported */\n#define CURL_VERSION_NTLM_WB      (1<<15) /* NTLM delegation to winbind helper\n                                             is supported */\n#define CURL_VERSION_HTTP2        (1<<16) /* HTTP2 support built-in */\n#define CURL_VERSION_GSSAPI       (1<<17) /* Built against a GSS-API library */\n#define CURL_VERSION_KERBEROS5    (1<<18) /* Kerberos V5 auth is supported */\n#define CURL_VERSION_UNIX_SOCKETS (1<<19) /* Unix domain sockets support */\n#define CURL_VERSION_PSL          (1<<20) /* Mozilla's Public Suffix List, used\n                                             for cookie domain verification */\n#define CURL_VERSION_HTTPS_PROXY  (1<<21) /* HTTPS-proxy support built-in */\n#define CURL_VERSION_MULTI_SSL    (1<<22) /* Multiple SSL backends available */\n#define CURL_VERSION_BROTLI       (1<<23) /* Brotli features are present. */\n#define CURL_VERSION_ALTSVC       (1<<24) /* Alt-Svc handling built-in */\n#define CURL_VERSION_HTTP3        (1<<25) /* HTTP3 support built-in */\n#define CURL_VERSION_ZSTD         (1<<26) /* zstd features are present */\n#define CURL_VERSION_UNICODE      (1<<27) /* Unicode support on Windows */\n#define CURL_VERSION_HSTS         (1<<28) /* HSTS is supported */\n#define CURL_VERSION_GSASL        (1<<29) /* libgsasl is supported */\n#define CURL_VERSION_THREADSAFE   (1<<30) /* libcurl API is thread-safe */\n\n /*\n * NAME curl_version_info()\n *\n * DESCRIPTION\n *\n * This function returns a pointer to a static copy of the version info\n * struct. See above.\n */\nCURL_EXTERN curl_version_info_data *curl_version_info(CURLversion);\n\n/*\n * NAME curl_easy_strerror()\n *\n * DESCRIPTION\n *\n * The curl_easy_strerror function may be used to turn a CURLcode value\n * into the equivalent human readable error string.  This is useful\n * for printing meaningful error messages.\n */\nCURL_EXTERN const char *curl_easy_strerror(CURLcode);\n\n/*\n * NAME curl_share_strerror()\n *\n * DESCRIPTION\n *\n * The curl_share_strerror function may be used to turn a CURLSHcode value\n * into the equivalent human readable error string.  This is useful\n * for printing meaningful error messages.\n */\nCURL_EXTERN const char *curl_share_strerror(CURLSHcode);\n\n/*\n * NAME curl_easy_pause()\n *\n * DESCRIPTION\n *\n * The curl_easy_pause function pauses or unpauses transfers. Select the new\n * state by setting the bitmask, use the convenience defines below.\n *\n */\nCURL_EXTERN CURLcode curl_easy_pause(CURL *handle, int bitmask);\n\n#define CURLPAUSE_RECV      (1<<0)\n#define CURLPAUSE_RECV_CONT (0)\n\n#define CURLPAUSE_SEND      (1<<2)\n#define CURLPAUSE_SEND_CONT (0)\n\n#define CURLPAUSE_ALL       (CURLPAUSE_RECV|CURLPAUSE_SEND)\n#define CURLPAUSE_CONT      (CURLPAUSE_RECV_CONT|CURLPAUSE_SEND_CONT)\n\n#ifdef  __cplusplus\n} /* end of extern \"C\" */\n#endif\n\n/* unfortunately, the easy.h and multi.h include files need options and info\n  stuff before they can be included! */\n#include \"easy.h\" /* nothing in curl is fun without the easy stuff */\n#include \"multi.h\"\n#include \"urlapi.h\"\n#include \"options.h\"\n#include \"header.h\"\n#include \"websockets.h\"\n#include \"mprintf.h\"\n\n/* the typechecker doesn't work in C++ (yet) */\n#if defined(__GNUC__) && defined(__GNUC_MINOR__) && \\\n    ((__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && \\\n    !defined(__cplusplus) && !defined(CURL_DISABLE_TYPECHECK)\n#include \"typecheck-gcc.h\"\n#else\n#if defined(__STDC__) && (__STDC__ >= 1)\n/* This preprocessor magic that replaces a call with the exact same call is\n   only done to make sure application authors pass exactly three arguments\n   to these functions. */\n#define curl_easy_setopt(handle,opt,param) curl_easy_setopt(handle,opt,param)\n#define curl_easy_getinfo(handle,info,arg) curl_easy_getinfo(handle,info,arg)\n#define curl_share_setopt(share,opt,param) curl_share_setopt(share,opt,param)\n#define curl_multi_setopt(handle,opt,param) curl_multi_setopt(handle,opt,param)\n#endif /* __STDC__ >= 1 */\n#endif /* gcc >= 4.3 && !__cplusplus && !CURL_DISABLE_TYPECHECK */\n\n#endif /* CURLINC_CURL_H */\n` was unexpected","path":"/home/qqq/curl-8.7.0/include/curl/curl.h"},{"code":3,"level":"warn","type":["PartialParsing",[{"path":"/home/qqq/curl-8.7.0/src/tool_util.c","start":{"line":87,"col":3,"offset":0},"end":{"line":88,"col":11,"offset":15}},{"path":"/home/qqq/curl-8.7.0/src/tool_util.c","start":{"line":93,"col":3,"offset":0},"end":{"line":93,"col":4,"offset":1}}]],"message":"Syntax error at line /home/qqq/curl-8.7.0/src/tool_util.c:87:\n `else\n    (void)` was unexpected","path":"/home/qqq/curl-8.7.0/src/tool_util.c","spans":[{"file":"/home/qqq/curl-8.7.0/src/tool_util.c","start":{"line":87,"col":3,"offset":0},"end":{"line":88,"col":11,"offset":15}},{"file":"/home/qqq/curl-8.7.0/src/tool_util.c","start":{"line":93,"col":3,"offset":0},"end":{"line":93,"col":4,"offset":1}}]},{"code":3,"level":"warn","type":"Syntax error","message":"Syntax error at line /home/qqq/curl-8.7.0/lib/timeval.c:1:\n `/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n * SPDX-License-Identifier: curl\n *\n ***************************************************************************/\n\n#include \"timeval.h\"\n\n#if defined(_WIN32)\n\n#include <curl/curl.h>\n#include \"system_win32.h\"\n\n/* In case of bug fix this function has a counterpart in tool_util.c */\nstruct curltime Curl_now(void)\n{\n  struct curltime now;\n  if(Curl_isVistaOrGreater) { /* QPC timer might have issues pre-Vista */\n    LARGE_INTEGER count;\n    QueryPerformanceCounter(&count);\n    now.tv_sec = (time_t)(count.QuadPart / Curl_freq.QuadPart);\n    now.tv_usec = (int)((count.QuadPart % Curl_freq.QuadPart) * 1000000 /\n                        Curl_freq.QuadPart);\n  }\n  else {\n    /* Disable /analyze warning that GetTickCount64 is preferred  */\n#if defined(_MSC_VER)\n#pragma warning(push)\n#pragma warning(disable:28159)\n#endif\n    DWORD milliseconds = GetTickCount();\n#if defined(_MSC_VER)\n#pragma warning(pop)\n#endif\n\n    now.tv_sec = milliseconds / 1000;\n    now.tv_usec = (milliseconds % 1000) * 1000;\n  }\n  return now;\n}\n\n#elif defined(HAVE_CLOCK_GETTIME_MONOTONIC) ||  \\\n  defined(HAVE_CLOCK_GETTIME_MONOTONIC_RAW)\n\nstruct curltime Curl_now(void)\n{\n  /*\n  ** clock_gettime() is granted to be increased monotonically when the\n  ** monotonic clock is queried. Time starting point is unspecified, it\n  ** could be the system start-up time, the Epoch, or something else,\n  ** in any case the time starting point does not change once that the\n  ** system has started up.\n  */\n#ifdef HAVE_GETTIMEOFDAY\n  struct timeval now;\n#endif\n  struct curltime cnow;\n  struct timespec tsnow;\n\n  /*\n  ** clock_gettime() may be defined by Apple's SDK as weak symbol thus\n  ** code compiles but fails during run-time if clock_gettime() is\n  ** called on unsupported OS version.\n  */\n#if defined(__APPLE__) && defined(HAVE_BUILTIN_AVAILABLE) && \\\n        (HAVE_BUILTIN_AVAILABLE == 1)\n  bool have_clock_gettime = FALSE;\n  if(__builtin_available(macOS 10.12, iOS 10, tvOS 10, watchOS 3, *))\n    have_clock_gettime = TRUE;\n#endif\n\n#ifdef HAVE_CLOCK_GETTIME_MONOTONIC_RAW\n  if(\n#if defined(__APPLE__) && defined(HAVE_BUILTIN_AVAILABLE) &&    \\\n        (HAVE_BUILTIN_AVAILABLE == 1)\n    have_clock_gettime &&\n#endif\n    (0 == clock_gettime(CLOCK_MONOTONIC_RAW, &tsnow))) {\n    cnow.tv_sec = tsnow.tv_sec;\n    cnow.tv_usec = (unsigned int)(tsnow.tv_nsec / 1000);\n  }\n  else\n#endif\n\n  if(\n#if defined(__APPLE__) && defined(HAVE_BUILTIN_AVAILABLE) && \\\n        (HAVE_BUILTIN_AVAILABLE == 1)\n    have_clock_gettime &&\n#endif\n    (0 == clock_gettime(CLOCK_MONOTONIC, &tsnow))) {\n    cnow.tv_sec = tsnow.tv_sec;\n    cnow.tv_usec = (unsigned int)(tsnow.tv_nsec / 1000);\n  }\n  /*\n  ** Even when the configure process has truly detected monotonic clock\n  ** availability, it might happen that it is not actually available at\n  ** run-time. When this occurs simply fallback to other time source.\n  */\n#ifdef HAVE_GETTIMEOFDAY\n  else {\n    (void)gettimeofday(&now, NULL);\n    cnow.tv_sec = now.tv_sec;\n    cnow.tv_usec = (unsigned int)now.tv_usec;\n  }\n#else\n  else {\n    cnow.tv_sec = time(NULL);\n    cnow.tv_usec = 0;\n  }\n#endif\n  return cnow;\n}\n\n#elif defined(HAVE_MACH_ABSOLUTE_TIME)\n\n#include <stdint.h>\n#include <mach/mach_time.h>\n\nstruct curltime Curl_now(void)\n{\n  /*\n  ** Monotonic timer on Mac OS is provided by mach_absolute_time(), which\n  ** returns time in Mach \"absolute time units,\" which are platform-dependent.\n  ** To convert to nanoseconds, one must use conversion factors specified by\n  ** mach_timebase_info().\n  */\n  static mach_timebase_info_data_t timebase;\n  struct curltime cnow;\n  uint64_t usecs;\n\n  if(0 == timebase.denom)\n    (void) mach_timebase_info(&timebase);\n\n  usecs = mach_absolute_time();\n  usecs *= timebase.numer;\n  usecs /= timebase.denom;\n  usecs /= 1000;\n\n  cnow.tv_sec = usecs / 1000000;\n  cnow.tv_usec = (int)(usecs % 1000000);\n\n  return cnow;\n}\n\n#elif defined(HAVE_GETTIMEOFDAY)\n\nstruct curltime Curl_now(void)\n{\n  /*\n  ** gettimeofday() is not granted to be increased monotonically, due to\n  ** clock drifting and external source time synchronization it can jump\n  ** forward or backward in time.\n  */\n  struct timeval now;\n  struct curltime ret;\n  (void)gettimeofday(&now, NULL);\n  ret.tv_sec = now.tv_sec;\n  ret.tv_usec = (int)now.tv_usec;\n  return ret;\n}\n\n#else\n\nstruct curltime Curl_now(void)\n{\n  /*\n  ** time() returns the value of time in seconds since the Epoch.\n  */\n  struct curltime now;\n  now.tv_sec = time(NULL);\n  now.tv_usec = 0;\n  return now;\n}\n\n#endif\n\n/*\n * Returns: time difference in number of milliseconds. For too large diffs it\n * returns max value.\n *\n * @unittest: 1323\n */\ntimediff_t Curl_timediff(struct curltime newer, struct curltime older)\n{\n  timediff_t diff = (timediff_t)newer.tv_sec-older.tv_sec;\n  if(diff >= (TIMEDIFF_T_MAX/1000))\n    return TIMEDIFF_T_MAX;\n  else if(diff <= (TIMEDIFF_T_MIN/1000))\n    return TIMEDIFF_T_MIN;\n  return diff * 1000 + (newer.tv_usec-older.tv_usec)/1000;\n}\n\n/*\n * Returns: time difference in number of milliseconds, rounded up.\n * For too large diffs it returns max value.\n */\ntimediff_t Curl_timediff_ceil(struct curltime newer, struct curltime older)\n{\n  timediff_t diff = (timediff_t)newer.tv_sec-older.tv_sec;\n  if(diff >= (TIMEDIFF_T_MAX/1000))\n    return TIMEDIFF_T_MAX;\n  else if(diff <= (TIMEDIFF_T_MIN/1000))\n    return TIMEDIFF_T_MIN;\n  return diff * 1000 + (newer.tv_usec - older.tv_usec + 999)/1000;\n}\n\n/*\n * Returns: time difference in number of microseconds. For too large diffs it\n * returns max value.\n */\ntimediff_t Curl_timediff_us(struct curltime newer, struct curltime older)\n{\n  timediff_t diff = (timediff_t)newer.tv_sec-older.tv_sec;\n  if(diff >= (TIMEDIFF_T_MAX/1000000))\n    return TIMEDIFF_T_MAX;\n  else if(diff <= (TIMEDIFF_T_MIN/1000000))\n    return TIMEDIFF_T_MIN;\n  return diff * 1000000 + newer.tv_usec-older.tv_usec;\n}\n` was unexpected","path":"/home/qqq/curl-8.7.0/lib/timeval.c"},{"code":3,"level":"warn","type":["PartialParsing",[{"path":"/home/qqq/curl-8.7.0/src/tool_cb_hdr.c","start":{"line":230,"col":5,"offset":0},"end":{"line":230,"col":36,"offset":31}},{"path":"/home/qqq/curl-8.7.0/src/tool_cb_hdr.c","start":{"line":232,"col":8,"offset":0},"end":{"line":234,"col":41,"offset":69}},{"path":"/home/qqq/curl-8.7.0/src/tool_cb_hdr.c","start":{"line":428,"col":28,"offset":0},"end":{"line":428,"col":32,"offset":4}}]],"message":"Syntax error at line /home/qqq/curl-8.7.0/src/tool_cb_hdr.c:230:\n `if(hdrcbdata->global->isatty &&` was unexpected","path":"/home/qqq/curl-8.7.0/src/tool_cb_hdr.c","spans":[{"file":"/home/qqq/curl-8.7.0/src/tool_cb_hdr.c","start":{"line":230,"col":5,"offset":0},"end":{"line":230,"col":36,"offset":31}},{"file":"/home/qqq/curl-8.7.0/src/tool_cb_hdr.c","start":{"line":232,"col":8,"offset":0},"end":{"line":234,"col":41,"offset":69}},{"file":"/home/qqq/curl-8.7.0/src/tool_cb_hdr.c","start":{"line":428,"col":28,"offset":0},"end":{"line":428,"col":32,"offset":4}}]},{"code":3,"level":"warn","type":["PartialParsing",[{"path":"/home/qqq/curl-8.7.0/lib/setup-vms.h","start":{"line":46,"col":7,"offset":0},"end":{"line":46,"col":11,"offset":4}},{"path":"/home/qqq/curl-8.7.0/lib/setup-vms.h","start":{"line":96,"col":19,"offset":0},"end":{"line":96,"col":39,"offset":20}},{"path":"/home/qqq/curl-8.7.0/lib/setup-vms.h","start":{"line":123,"col":12,"offset":0},"end":{"line":123,"col":16,"offset":4}}]],"message":"Syntax error at line /home/qqq/curl-8.7.0/lib/setup-vms.h:46:\n `decc` was unexpected","path":"/home/qqq/curl-8.7.0/lib/setup-vms.h","spans":[{"file":"/home/qqq/curl-8.7.0/lib/setup-vms.h","start":{"line":46,"col":7,"offset":0},"end":{"line":46,"col":11,"offset":4}},{"file":"/home/qqq/curl-8.7.0/lib/setup-vms.h","start":{"line":96,"col":19,"offset":0},"end":{"line":96,"col":39,"offset":20}},{"file":"/home/qqq/curl-8.7.0/lib/setup-vms.h","start":{"line":123,"col":12,"offset":0},"end":{"line":123,"col":16,"offset":4}}]},{"code":3,"level":"warn","type":["PartialParsing",[{"path":"/home/qqq/curl-8.7.0/lib/md5.c","start":{"line":441,"col":5,"offset":0},"end":{"line":441,"col":6,"offset":1}}]],"message":"Syntax error at line /home/qqq/curl-8.7.0/lib/md5.c:441:\n `a` was unexpected","path":"/home/qqq/curl-8.7.0/lib/md5.c","spans":[{"file":"/home/qqq/curl-8.7.0/lib/md5.c","start":{"line":441,"col":5,"offset":0},"end":{"line":441,"col":6,"offset":1}}]},{"code":3,"level":"warn","type":"Syntax error","message":"Syntax error at line /home/qqq/curl-8.7.0/lib/asyn-thread.c:1:\n `/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n * SPDX-License-Identifier: curl\n *\n ***************************************************************************/\n\n#include \"curl_setup.h\"\n#include \"socketpair.h\"\n\n/***********************************************************************\n * Only for threaded name resolves builds\n **********************************************************************/\n#ifdef CURLRES_THREADED\n\n#ifdef HAVE_NETINET_IN_H\n#include <netinet/in.h>\n#endif\n#ifdef HAVE_NETDB_H\n#include <netdb.h>\n#endif\n#ifdef HAVE_ARPA_INET_H\n#include <arpa/inet.h>\n#endif\n#ifdef __VMS\n#include <in.h>\n#include <inet.h>\n#endif\n\n#if defined(USE_THREADS_POSIX) && defined(HAVE_PTHREAD_H)\n#  include <pthread.h>\n#endif\n\n#ifdef HAVE_GETADDRINFO\n#  define RESOLVER_ENOMEM  EAI_MEMORY\n#else\n#  define RESOLVER_ENOMEM  ENOMEM\n#endif\n\n#include \"system_win32.h\"\n#include \"urldata.h\"\n#include \"sendf.h\"\n#include \"hostip.h\"\n#include \"hash.h\"\n#include \"share.h\"\n#include \"url.h\"\n#include \"multiif.h\"\n#include \"inet_ntop.h\"\n#include \"curl_threads.h\"\n#include \"connect.h\"\n/* The last 3 #include files should be in this order */\n#include \"curl_printf.h\"\n#include \"curl_memory.h\"\n#include \"memdebug.h\"\n\nstruct resdata {\n  struct curltime start;\n};\n\n/*\n * Curl_resolver_global_init()\n * Called from curl_global_init() to initialize global resolver environment.\n * Does nothing here.\n */\nint Curl_resolver_global_init(void)\n{\n  return CURLE_OK;\n}\n\n/*\n * Curl_resolver_global_cleanup()\n * Called from curl_global_cleanup() to destroy global resolver environment.\n * Does nothing here.\n */\nvoid Curl_resolver_global_cleanup(void)\n{\n}\n\n/*\n * Curl_resolver_init()\n * Called from curl_easy_init() -> Curl_open() to initialize resolver\n * URL-state specific environment ('resolver' member of the UrlState\n * structure).\n */\nCURLcode Curl_resolver_init(struct Curl_easy *easy, void **resolver)\n{\n  (void)easy;\n  *resolver = calloc(1, sizeof(struct resdata));\n  if(!*resolver)\n    return CURLE_OUT_OF_MEMORY;\n  return CURLE_OK;\n}\n\n/*\n * Curl_resolver_cleanup()\n * Called from curl_easy_cleanup() -> Curl_close() to cleanup resolver\n * URL-state specific environment ('resolver' member of the UrlState\n * structure).\n */\nvoid Curl_resolver_cleanup(void *resolver)\n{\n  free(resolver);\n}\n\n/*\n * Curl_resolver_duphandle()\n * Called from curl_easy_duphandle() to duplicate resolver URL state-specific\n * environment ('resolver' member of the UrlState structure).\n */\nCURLcode Curl_resolver_duphandle(struct Curl_easy *easy, void **to, void *from)\n{\n  (void)from;\n  return Curl_resolver_init(easy, to);\n}\n\nstatic void destroy_async_data(struct Curl_async *);\n\n/*\n * Cancel all possibly still on-going resolves for this connection.\n */\nvoid Curl_resolver_cancel(struct Curl_easy *data)\n{\n  destroy_async_data(&data->state.async);\n}\n\n/* This function is used to init a threaded resolve */\nstatic bool init_resolve_thread(struct Curl_easy *data,\n                                const char *hostname, int port,\n                                const struct addrinfo *hints);\n\n#ifdef _WIN32\n/* Thread sync data used by GetAddrInfoExW for win8+ */\nstruct thread_sync_data_w8\n{\n  OVERLAPPED overlapped;\n  ADDRINFOEXW_ *res;\n  HANDLE cancel_ev;\n  ADDRINFOEXW_ hints;\n};\n#endif\n\n/* Data for synchronization between resolver thread and its parent */\nstruct thread_sync_data {\n#ifdef _WIN32\n  struct thread_sync_data_w8 w8;\n#endif\n  curl_mutex_t *mtx;\n  int done;\n  int port;\n  char *hostname;        /* hostname to resolve, Curl_async.hostname\n                            duplicate */\n#ifndef CURL_DISABLE_SOCKETPAIR\n  struct Curl_easy *data;\n  curl_socket_t sock_pair[2]; /* socket pair */\n#endif\n  int sock_error;\n  struct Curl_addrinfo *res;\n#ifdef HAVE_GETADDRINFO\n  struct addrinfo hints;\n#endif\n  struct thread_data *td; /* for thread-self cleanup */\n};\n\nstruct thread_data {\n#ifdef _WIN32\n  HANDLE complete_ev;\n#endif\n  curl_thread_t thread_hnd;\n  unsigned int poll_interval;\n  timediff_t interval_end;\n  struct thread_sync_data tsd;\n};\n\nstatic struct thread_sync_data *conn_thread_sync_data(struct Curl_easy *data)\n{\n  return &(data->state.async.tdata->tsd);\n}\n\n/* Destroy resolver thread synchronization data */\nstatic\nvoid destroy_thread_sync_data(struct thread_sync_data *tsd)\n{\n  if(tsd->mtx) {\n    Curl_mutex_destroy(tsd->mtx);\n    free(tsd->mtx);\n  }\n\n  free(tsd->hostname);\n\n  if(tsd->res)\n    Curl_freeaddrinfo(tsd->res);\n\n#ifndef CURL_DISABLE_SOCKETPAIR\n  /*\n   * close one end of the socket pair (may be done in resolver thread);\n   * the other end (for reading) is always closed in the parent thread.\n   */\n  if(tsd->sock_pair[1] != CURL_SOCKET_BAD) {\n    wakeup_close(tsd->sock_pair[1]);\n  }\n#endif\n  memset(tsd, 0, sizeof(*tsd));\n}\n\n/* Initialize resolver thread synchronization data */\nstatic\nint init_thread_sync_data(struct thread_data *td,\n                           const char *hostname,\n                           int port,\n                           const struct addrinfo *hints)\n{\n  struct thread_sync_data *tsd = &td->tsd;\n\n  memset(tsd, 0, sizeof(*tsd));\n\n  tsd->td = td;\n  tsd->port = port;\n  /* Treat the request as done until the thread actually starts so any early\n   * cleanup gets done properly.\n   */\n  tsd->done = 1;\n#ifdef HAVE_GETADDRINFO\n  DEBUGASSERT(hints);\n  tsd->hints = *hints;\n#else\n  (void) hints;\n#endif\n\n  tsd->mtx = malloc(sizeof(curl_mutex_t));\n  if(!tsd->mtx)\n    goto err_exit;\n\n  Curl_mutex_init(tsd->mtx);\n\n#ifndef CURL_DISABLE_SOCKETPAIR\n  /* create socket pair or pipe */\n  if(wakeup_create(&tsd->sock_pair[0]) < 0) {\n    tsd->sock_pair[0] = CURL_SOCKET_BAD;\n    tsd->sock_pair[1] = CURL_SOCKET_BAD;\n    goto err_exit;\n  }\n#endif\n  tsd->sock_error = CURL_ASYNC_SUCCESS;\n\n  /* Copying hostname string because original can be destroyed by parent\n   * thread during gethostbyname execution.\n   */\n  tsd->hostname = strdup(hostname);\n  if(!tsd->hostname)\n    goto err_exit;\n\n  return 1;\n\nerr_exit:\n#ifndef CURL_DISABLE_SOCKETPAIR\n  if(tsd->sock_pair[0] != CURL_SOCKET_BAD) {\n    wakeup_close(tsd->sock_pair[0]);\n    tsd->sock_pair[0] = CURL_SOCKET_BAD;\n  }\n#endif\n  destroy_thread_sync_data(tsd);\n  return 0;\n}\n\nstatic CURLcode getaddrinfo_complete(struct Curl_easy *data)\n{\n  struct thread_sync_data *tsd = conn_thread_sync_data(data);\n  CURLcode result;\n\n  result = Curl_addrinfo_callback(data, tsd->sock_error, tsd->res);\n  /* The tsd->res structure has been copied to async.dns and perhaps the DNS\n     cache.  Set our copy to NULL so destroy_thread_sync_data doesn't free it.\n  */\n  tsd->res = NULL;\n\n  return result;\n}\n\n#ifdef _WIN32\nstatic VOID WINAPI\nquery_complete(DWORD err, DWORD bytes, LPWSAOVERLAPPED overlapped)\n{\n  size_t ss_size;\n  const ADDRINFOEXW_ *ai;\n  struct Curl_addrinfo *ca;\n  struct Curl_addrinfo *cafirst = NULL;\n  struct Curl_addrinfo *calast = NULL;\n#ifdef __clang__\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wcast-align\"\n#endif\n  struct thread_sync_data *tsd =\n    CONTAINING_RECORD(overlapped, struct thread_sync_data, w8.overlapped);\n#ifdef __clang__\n#pragma clang diagnostic pop\n#endif\n  struct thread_data *td = tsd->td;\n  const ADDRINFOEXW_ *res = tsd->w8.res;\n  int error = (int)err;\n  (void)bytes;\n\n  if(error == ERROR_SUCCESS) {\n    /* traverse the addrinfo list */\n\n    for(ai = res; ai != NULL; ai = ai->ai_next) {\n      size_t namelen = ai->ai_canonname ? wcslen(ai->ai_canonname) + 1 : 0;\n      /* ignore elements with unsupported address family, */\n      /* settle family-specific sockaddr structure size.  */\n      if(ai->ai_family == AF_INET)\n        ss_size = sizeof(struct sockaddr_in);\n#ifdef ENABLE_IPV6\n      else if(ai->ai_family == AF_INET6)\n        ss_size = sizeof(struct sockaddr_in6);\n#endif\n      else\n        continue;\n\n      /* ignore elements without required address info */\n      if(!ai->ai_addr || !(ai->ai_addrlen > 0))\n        continue;\n\n      /* ignore elements with bogus address size */\n      if((size_t)ai->ai_addrlen < ss_size)\n        continue;\n\n      ca = malloc(sizeof(struct Curl_addrinfo) + ss_size + namelen);\n      if(!ca) {\n        error = EAI_MEMORY;\n        break;\n      }\n\n      /* copy each structure member individually, member ordering, */\n      /* size, or padding might be different for each platform.    */\n      ca->ai_flags     = ai->ai_flags;\n      ca->ai_family    = ai->ai_family;\n      ca->ai_socktype  = ai->ai_socktype;\n      ca->ai_protocol  = ai->ai_protocol;\n      ca->ai_addrlen   = (curl_socklen_t)ss_size;\n      ca->ai_addr      = NULL;\n      ca->ai_canonname = NULL;\n      ca->ai_next      = NULL;\n\n      ca->ai_addr = (void *)((char *)ca + sizeof(struct Curl_addrinfo));\n      memcpy(ca->ai_addr, ai->ai_addr, ss_size);\n\n      if(namelen) {\n        size_t i;\n        ca->ai_canonname = (void *)((char *)ca->ai_addr + ss_size);\n        for(i = 0; i < namelen; ++i) /* convert wide string to ascii */\n          ca->ai_canonname[i] = (char)ai->ai_canonname[i];\n        ca->ai_canonname[namelen] = '\\0';\n      }\n\n      /* if the return list is empty, this becomes the first element */\n      if(!cafirst)\n        cafirst = ca;\n\n      /* add this element last in the return list */\n      if(calast)\n        calast->ai_next = ca;\n      calast = ca;\n    }\n\n    /* if we failed, also destroy the Curl_addrinfo list */\n    if(error) {\n      Curl_freeaddrinfo(cafirst);\n      cafirst = NULL;\n    }\n    else if(!cafirst) {\n#ifdef EAI_NONAME\n      /* rfc3493 conformant */\n      error = EAI_NONAME;\n#else\n      /* rfc3493 obsoleted */\n      error = EAI_NODATA;\n#endif\n#ifdef USE_WINSOCK\n      SET_SOCKERRNO(error);\n#endif\n    }\n    tsd->res = cafirst;\n  }\n\n  if(tsd->w8.res) {\n    Curl_FreeAddrInfoExW(tsd->w8.res);\n    tsd->w8.res = NULL;\n  }\n\n  if(error) {\n    tsd->sock_error = SOCKERRNO?SOCKERRNO:error;\n    if(tsd->sock_error == 0)\n      tsd->sock_error = RESOLVER_ENOMEM;\n  }\n  else {\n    Curl_addrinfo_set_port(tsd->res, tsd->port);\n  }\n\n  Curl_mutex_acquire(tsd->mtx);\n  if(tsd->done) {\n    /* too late, gotta clean up the mess */\n    Curl_mutex_release(tsd->mtx);\n    destroy_thread_sync_data(tsd);\n    free(td);\n  }\n  else {\n#ifndef CURL_DISABLE_SOCKETPAIR\n    char buf[1];\n    if(tsd->sock_pair[1] != CURL_SOCKET_BAD) {\n      /* DNS has been resolved, signal client task */\n      buf[0] = 1;\n      if(swrite(tsd->sock_pair[1],  buf, sizeof(buf)) < 0) {\n        /* update sock_erro to errno */\n        tsd->sock_error = SOCKERRNO;\n      }\n    }\n#endif\n    tsd->done = 1;\n    Curl_mutex_release(tsd->mtx);\n    if(td->complete_ev)\n      SetEvent(td->complete_ev); /* Notify caller that the query completed */\n  }\n}\n#endif\n\n#ifdef HAVE_GETADDRINFO\n\n/*\n * getaddrinfo_thread() resolves a name and then exits.\n *\n * For builds without ARES, but with ENABLE_IPV6, create a resolver thread\n * and wait on it.\n */\nstatic unsigned int CURL_STDCALL getaddrinfo_thread(void *arg)\n{\n  struct thread_sync_data *tsd = (struct thread_sync_data *)arg;\n  struct thread_data *td = tsd->td;\n  char service[12];\n  int rc;\n#ifndef CURL_DISABLE_SOCKETPAIR\n  char buf[1];\n#endif\n\n  msnprintf(service, sizeof(service), \"%d\", tsd->port);\n\n  rc = Curl_getaddrinfo_ex(tsd->hostname, service, &tsd->hints, &tsd->res);\n\n  if(rc) {\n    tsd->sock_error = SOCKERRNO?SOCKERRNO:rc;\n    if(tsd->sock_error == 0)\n      tsd->sock_error = RESOLVER_ENOMEM;\n  }\n  else {\n    Curl_addrinfo_set_port(tsd->res, tsd->port);\n  }\n\n  Curl_mutex_acquire(tsd->mtx);\n  if(tsd->done) {\n    /* too late, gotta clean up the mess */\n    Curl_mutex_release(tsd->mtx);\n    destroy_thread_sync_data(tsd);\n    free(td);\n  }\n  else {\n#ifndef CURL_DISABLE_SOCKETPAIR\n    if(tsd->sock_pair[1] != CURL_SOCKET_BAD) {\n      /* DNS has been resolved, signal client task */\n      buf[0] = 1;\n      if(wakeup_write(tsd->sock_pair[1],  buf, sizeof(buf)) < 0) {\n        /* update sock_erro to errno */\n        tsd->sock_error = SOCKERRNO;\n      }\n    }\n#endif\n    tsd->done = 1;\n    Curl_mutex_release(tsd->mtx);\n  }\n\n  return 0;\n}\n\n#else /* HAVE_GETADDRINFO */\n\n/*\n * gethostbyname_thread() resolves a name and then exits.\n */\nstatic unsigned int CURL_STDCALL gethostbyname_thread(void *arg)\n{\n  struct thread_sync_data *tsd = (struct thread_sync_data *)arg;\n  struct thread_data *td = tsd->td;\n\n  tsd->res = Curl_ipv4_resolve_r(tsd->hostname, tsd->port);\n\n  if(!tsd->res) {\n    tsd->sock_error = SOCKERRNO;\n    if(tsd->sock_error == 0)\n      tsd->sock_error = RESOLVER_ENOMEM;\n  }\n\n  Curl_mutex_acquire(tsd->mtx);\n  if(tsd->done) {\n    /* too late, gotta clean up the mess */\n    Curl_mutex_release(tsd->mtx);\n    destroy_thread_sync_data(tsd);\n    free(td);\n  }\n  else {\n    tsd->done = 1;\n    Curl_mutex_release(tsd->mtx);\n  }\n\n  return 0;\n}\n\n#endif /* HAVE_GETADDRINFO */\n\n/*\n * destroy_async_data() cleans up async resolver data and thread handle.\n */\nstatic void destroy_async_data(struct Curl_async *async)\n{\n  if(async->tdata) {\n    struct thread_data *td = async->tdata;\n    int done;\n#ifndef CURL_DISABLE_SOCKETPAIR\n    curl_socket_t sock_rd = td->tsd.sock_pair[0];\n    struct Curl_easy *data = td->tsd.data;\n#endif\n\n    /*\n     * if the thread is still blocking in the resolve syscall, detach it and\n     * let the thread do the cleanup...\n     */\n    Curl_mutex_acquire(td->tsd.mtx);\n    done = td->tsd.done;\n    td->tsd.done = 1;\n    Curl_mutex_release(td->tsd.mtx);\n\n    if(!done) {\n#ifdef _WIN32\n      if(td->complete_ev)\n        CloseHandle(td->complete_ev);\n      else\n#endif\n      Curl_thread_destroy(td->thread_hnd);\n    }\n    else {\n#ifdef _WIN32\n      if(td->complete_ev) {\n        Curl_GetAddrInfoExCancel(&td->tsd.w8.cancel_ev);\n        WaitForSingleObject(td->complete_ev, INFINITE);\n        CloseHandle(td->complete_ev);\n      }\n#endif\n      if(td->thread_hnd != curl_thread_t_null)\n        Curl_thread_join(&td->thread_hnd);\n\n      destroy_thread_sync_data(&td->tsd);\n\n      free(async->tdata);\n    }\n#ifndef CURL_DISABLE_SOCKETPAIR\n    /*\n     * ensure CURLMOPT_SOCKETFUNCTION fires CURL_POLL_REMOVE\n     * before the FD is invalidated to avoid EBADF on EPOLL_CTL_DEL\n     */\n    Curl_multi_closed(data, sock_rd);\n    wakeup_close(sock_rd);\n#endif\n  }\n  async->tdata = NULL;\n\n  free(async->hostname);\n  async->hostname = NULL;\n}\n\n/*\n * init_resolve_thread() starts a new thread that performs the actual\n * resolve. This function returns before the resolve is done.\n *\n * Returns FALSE in case of failure, otherwise TRUE.\n */\nstatic bool init_resolve_thread(struct Curl_easy *data,\n                                const char *hostname, int port,\n                                const struct addrinfo *hints)\n{\n  struct thread_data *td = calloc(1, sizeof(struct thread_data));\n  int err = ENOMEM;\n  struct Curl_async *asp = &data->state.async;\n\n  data->state.async.tdata = td;\n  if(!td)\n    goto errno_exit;\n\n  asp->port = port;\n  asp->done = FALSE;\n  asp->status = 0;\n  asp->dns = NULL;\n  td->thread_hnd = curl_thread_t_null;\n#ifdef _WIN32\n  td->complete_ev = NULL;\n#endif\n\n  if(!init_thread_sync_data(td, hostname, port, hints)) {\n    asp->tdata = NULL;\n    free(td);\n    goto errno_exit;\n  }\n\n  free(asp->hostname);\n  asp->hostname = strdup(hostname);\n  if(!asp->hostname)\n    goto err_exit;\n\n  /* The thread will set this to 1 when complete. */\n  td->tsd.done = 0;\n\n#ifdef _WIN32\n  if(Curl_isWindows8OrGreater && Curl_FreeAddrInfoExW &&\n     Curl_GetAddrInfoExCancel && Curl_GetAddrInfoExW) {\n#define MAX_NAME_LEN 256 /* max domain name is 253 chars */\n#define MAX_PORT_LEN 8\n    WCHAR namebuf[MAX_NAME_LEN];\n    WCHAR portbuf[MAX_PORT_LEN];\n    /* calculate required length */\n    int w_len = MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, hostname,\n                                    -1, NULL, 0);\n    if((w_len > 0) && (w_len < MAX_NAME_LEN)) {\n      /* do utf8 conversion */\n      w_len = MultiByteToWideChar(CP_UTF8, 0, hostname, -1, namebuf, w_len);\n      if((w_len > 0) && (w_len < MAX_NAME_LEN)) {\n        swprintf(portbuf, MAX_PORT_LEN, L\"%d\", port);\n        td->tsd.w8.hints.ai_family = hints->ai_family;\n        td->tsd.w8.hints.ai_socktype = hints->ai_socktype;\n        td->complete_ev = CreateEvent(NULL, TRUE, FALSE, NULL);\n        if(!td->complete_ev) {\n          /* failed to start, mark it as done here for proper cleanup. */\n          td->tsd.done = 1;\n          goto err_exit;\n        }\n        err = Curl_GetAddrInfoExW(namebuf, portbuf, NS_DNS,\n                                  NULL, &td->tsd.w8.hints, &td->tsd.w8.res,\n                                  NULL, &td->tsd.w8.overlapped,\n                                  &query_complete, &td->tsd.w8.cancel_ev);\n        if(err != WSA_IO_PENDING)\n          query_complete(err, 0, &td->tsd.w8.overlapped);\n        return TRUE;\n      }\n    }\n  }\n#endif\n\n#ifdef HAVE_GETADDRINFO\n  td->thread_hnd = Curl_thread_create(getaddrinfo_thread, &td->tsd);\n#else\n  td->thread_hnd = Curl_thread_create(gethostbyname_thread, &td->tsd);\n#endif\n\n  if(!td->thread_hnd) {\n    /* The thread never started, so mark it as done here for proper cleanup. */\n    td->tsd.done = 1;\n    err = errno;\n    goto err_exit;\n  }\n\n  return TRUE;\n\nerr_exit:\n  destroy_async_data(asp);\n\nerrno_exit:\n  errno = err;\n  return FALSE;\n}\n\n/*\n * 'entry' may be NULL and then no data is returned\n */\nstatic CURLcode thread_wait_resolv(struct Curl_easy *data,\n                                   struct Curl_dns_entry **entry,\n                                   bool report)\n{\n  struct thread_data *td;\n  CURLcode result = CURLE_OK;\n\n  DEBUGASSERT(data);\n  td = data->state.async.tdata;\n  DEBUGASSERT(td);\n#ifdef _WIN32\n  DEBUGASSERT(td->complete_ev || td->thread_hnd != curl_thread_t_null);\n#else\n  DEBUGASSERT(td->thread_hnd != curl_thread_t_null);\n#endif\n\n  /* wait for the thread to resolve the name */\n#ifdef _WIN32\n  if(td->complete_ev) {\n    WaitForSingleObject(td->complete_ev, INFINITE);\n    CloseHandle(td->complete_ev);\n    if(entry)\n      result = getaddrinfo_complete(data);\n  }\n  else\n#endif\n  if(Curl_thread_join(&td->thread_hnd)) {\n    if(entry)\n      result = getaddrinfo_complete(data);\n  }\n  else\n    DEBUGASSERT(0);\n\n  data->state.async.done = TRUE;\n\n  if(entry)\n    *entry = data->state.async.dns;\n\n  if(!data->state.async.dns && report)\n    /* a name was not resolved, report error */\n    result = Curl_resolver_error(data);\n\n  destroy_async_data(&data->state.async);\n\n  if(!data->state.async.dns && report)\n    connclose(data->conn, \"asynch resolve failed\");\n\n  return result;\n}\n\n\n/*\n * Until we gain a way to signal the resolver threads to stop early, we must\n * simply wait for them and ignore their results.\n */\nvoid Curl_resolver_kill(struct Curl_easy *data)\n{\n  struct thread_data *td = data->state.async.tdata;\n\n  /* If we're still resolving, we must wait for the threads to fully clean up,\n     unfortunately.  Otherwise, we can simply cancel to clean up any resolver\n     data. */\n  if(td && td->thread_hnd != curl_thread_t_null\n     && (data->set.quick_exit != 1L))\n    (void)thread_wait_resolv(data, NULL, FALSE);\n  else\n    Curl_resolver_cancel(data);\n}\n\n/*\n * Curl_resolver_wait_resolv()\n *\n * Waits for a resolve to finish. This function should be avoided since using\n * this risk getting the multi interface to \"hang\".\n *\n * If 'entry' is non-NULL, make it point to the resolved dns entry\n *\n * Returns CURLE_COULDNT_RESOLVE_HOST if the host was not resolved,\n * CURLE_OPERATION_TIMEDOUT if a time-out occurred, or other errors.\n *\n * This is the version for resolves-in-a-thread.\n */\nCURLcode Curl_resolver_wait_resolv(struct Curl_easy *data,\n                                   struct Curl_dns_entry **entry)\n{\n  return thread_wait_resolv(data, entry, TRUE);\n}\n\n/*\n * Curl_resolver_is_resolved() is called repeatedly to check if a previous\n * name resolve request has completed. It should also make sure to time-out if\n * the operation seems to take too long.\n */\nCURLcode Curl_resolver_is_resolved(struct Curl_easy *data,\n                                   struct Curl_dns_entry **entry)\n{\n  struct thread_data *td = data->state.async.tdata;\n  int done = 0;\n\n  DEBUGASSERT(entry);\n  *entry = NULL;\n\n  if(!td) {\n    DEBUGASSERT(td);\n    return CURLE_COULDNT_RESOLVE_HOST;\n  }\n\n  Curl_mutex_acquire(td->tsd.mtx);\n  done = td->tsd.done;\n  Curl_mutex_release(td->tsd.mtx);\n\n  if(done) {\n    getaddrinfo_complete(data);\n\n    if(!data->state.async.dns) {\n      CURLcode result = Curl_resolver_error(data);\n      destroy_async_data(&data->state.async);\n      return result;\n    }\n    destroy_async_data(&data->state.async);\n    *entry = data->state.async.dns;\n  }\n  else {\n    /* poll for name lookup done with exponential backoff up to 250ms */\n    /* should be fine even if this converts to 32 bit */\n    timediff_t elapsed = Curl_timediff(Curl_now(),\n                                       data->progress.t_startsingle);\n    if(elapsed < 0)\n      elapsed = 0;\n\n    if(td->poll_interval == 0)\n      /* Start at 1ms poll interval */\n      td->poll_interval = 1;\n    else if(elapsed >= td->interval_end)\n      /* Back-off exponentially if last interval expired  */\n      td->poll_interval *= 2;\n\n    if(td->poll_interval > 250)\n      td->poll_interval = 250;\n\n    td->interval_end = elapsed + td->poll_interval;\n    Curl_expire(data, td->poll_interval, EXPIRE_ASYNC_NAME);\n  }\n\n  return CURLE_OK;\n}\n\nint Curl_resolver_getsock(struct Curl_easy *data, curl_socket_t *socks)\n{\n  int ret_val = 0;\n  timediff_t milli;\n  timediff_t ms;\n  struct resdata *reslv = (struct resdata *)data->state.async.resolver;\n#ifndef CURL_DISABLE_SOCKETPAIR\n  struct thread_data *td = data->state.async.tdata;\n#else\n  (void)socks;\n#endif\n\n#ifndef CURL_DISABLE_SOCKETPAIR\n  if(td) {\n    /* return read fd to client for polling the DNS resolution status */\n    socks[0] = td->tsd.sock_pair[0];\n    td->tsd.data = data;\n    ret_val = GETSOCK_READSOCK(0);\n  }\n  else {\n#endif\n    ms = Curl_timediff(Curl_now(), reslv->start);\n    if(ms < 3)\n      milli = 0;\n    else if(ms <= 50)\n      milli = ms/3;\n    else if(ms <= 250)\n      milli = 50;\n    else\n      milli = 200;\n    Curl_expire(data, milli, EXPIRE_ASYNC_NAME);\n#ifndef CURL_DISABLE_SOCKETPAIR\n  }\n#endif\n\n\n  return ret_val;\n}\n\n#ifndef HAVE_GETADDRINFO\n/*\n * Curl_getaddrinfo() - for platforms without getaddrinfo\n */\nstruct Curl_addrinfo *Curl_resolver_getaddrinfo(struct Curl_easy *data,\n                                                const char *hostname,\n                                                int port,\n                                                int *waitp)\n{\n  struct resdata *reslv = (struct resdata *)data->state.async.resolver;\n\n  *waitp = 0; /* default to synchronous response */\n\n  reslv->start = Curl_now();\n\n  /* fire up a new resolver thread! */\n  if(init_resolve_thread(data, hostname, port, NULL)) {\n    *waitp = 1; /* expect asynchronous response */\n    return NULL;\n  }\n\n  failf(data, \"getaddrinfo() thread failed\");\n\n  return NULL;\n}\n\n#else /* !HAVE_GETADDRINFO */\n\n/*\n * Curl_resolver_getaddrinfo() - for getaddrinfo\n */\nstruct Curl_addrinfo *Curl_resolver_getaddrinfo(struct Curl_easy *data,\n                                                const char *hostname,\n                                                int port,\n                                                int *waitp)\n{\n  struct addrinfo hints;\n  int pf = PF_INET;\n  struct resdata *reslv = (struct resdata *)data->state.async.resolver;\n\n  *waitp = 0; /* default to synchronous response */\n\n#ifdef CURLRES_IPV6\n  if((data->conn->ip_version != CURL_IPRESOLVE_V4) && Curl_ipv6works(data)) {\n    /* The stack seems to be IPv6-enabled */\n    if(data->conn->ip_version == CURL_IPRESOLVE_V6)\n      pf = PF_INET6;\n    else\n      pf = PF_UNSPEC;\n  }\n#endif /* CURLRES_IPV6 */\n\n  memset(&hints, 0, sizeof(hints));\n  hints.ai_family = pf;\n  hints.ai_socktype = (data->conn->transport == TRNSPRT_TCP)?\n    SOCK_STREAM : SOCK_DGRAM;\n\n  reslv->start = Curl_now();\n  /* fire up a new resolver thread! */\n  if(init_resolve_thread(data, hostname, port, &hints)) {\n    *waitp = 1; /* expect asynchronous response */\n    return NULL;\n  }\n\n  failf(data, \"getaddrinfo() thread failed to start\");\n  return NULL;\n\n}\n\n#endif /* !HAVE_GETADDRINFO */\n\nCURLcode Curl_set_dns_servers(struct Curl_easy *data,\n                              char *servers)\n{\n  (void)data;\n  (void)servers;\n  return CURLE_NOT_BUILT_IN;\n\n}\n\nCURLcode Curl_set_dns_interface(struct Curl_easy *data,\n                                const char *interf)\n{\n  (void)data;\n  (void)interf;\n  return CURLE_NOT_BUILT_IN;\n}\n\nCURLcode Curl_set_dns_local_ip4(struct Curl_easy *data,\n                                const char *local_ip4)\n{\n  (void)data;\n  (void)local_ip4;\n  return CURLE_NOT_BUILT_IN;\n}\n\nCURLcode Curl_set_dns_local_ip6(struct Curl_easy *data,\n                                const char *local_ip6)\n{\n  (void)data;\n  (void)local_ip6;\n  return CURLE_NOT_BUILT_IN;\n}\n\n#endif /* CURLRES_THREADED */\n` was unexpected","path":"/home/qqq/curl-8.7.0/lib/asyn-thread.c"},{"code":3,"level":"warn","type":["PartialParsing",[{"path":"/home/qqq/curl-8.7.0/lib/easy.c","start":{"line":484,"col":43,"offset":0},"end":{"line":484,"col":63,"offset":20}},{"path":"/home/qqq/curl-8.7.0/lib/easy.c","start":{"line":491,"col":43,"offset":0},"end":{"line":491,"col":63,"offset":20}},{"path":"/home/qqq/curl-8.7.0/lib/easy.c","start":{"line":516,"col":43,"offset":0},"end":{"line":516,"col":63,"offset":20}},{"path":"/home/qqq/curl-8.7.0/lib/easy.c","start":{"line":828,"col":22,"offset":0},"end":{"line":828,"col":30,"offset":8}}]],"message":"Syntax error at line /home/qqq/curl-8.7.0/lib/easy.c:484:\n `CURL_FORMAT_SOCKET_T` was unexpected","path":"/home/qqq/curl-8.7.0/lib/easy.c","spans":[{"file":"/home/qqq/curl-8.7.0/lib/easy.c","start":{"line":484,"col":43,"offset":0},"end":{"line":484,"col":63,"offset":20}},{"file":"/home/qqq/curl-8.7.0/lib/easy.c","start":{"line":491,"col":43,"offset":0},"end":{"line":491,"col":63,"offset":20}},{"file":"/home/qqq/curl-8.7.0/lib/easy.c","start":{"line":516,"col":43,"offset":0},"end":{"line":516,"col":63,"offset":20}},{"file":"/home/qqq/curl-8.7.0/lib/easy.c","start":{"line":828,"col":22,"offset":0},"end":{"line":828,"col":30,"offset":8}}]},{"code":3,"level":"warn","type":"Syntax error","message":"Syntax error at line /home/qqq/curl-8.7.0/lib/hostip.c:1:\n `/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n * SPDX-License-Identifier: curl\n *\n ***************************************************************************/\n\n#include \"curl_setup.h\"\n\n#ifdef HAVE_NETINET_IN_H\n#include <netinet/in.h>\n#endif\n#ifdef HAVE_NETINET_IN6_H\n#include <netinet/in6.h>\n#endif\n#ifdef HAVE_NETDB_H\n#include <netdb.h>\n#endif\n#ifdef HAVE_ARPA_INET_H\n#include <arpa/inet.h>\n#endif\n#ifdef __VMS\n#include <in.h>\n#include <inet.h>\n#endif\n\n#include <setjmp.h>\n#include <signal.h>\n\n#include \"urldata.h\"\n#include \"sendf.h\"\n#include \"hostip.h\"\n#include \"hash.h\"\n#include \"rand.h\"\n#include \"share.h\"\n#include \"url.h\"\n#include \"inet_ntop.h\"\n#include \"inet_pton.h\"\n#include \"multiif.h\"\n#include \"doh.h\"\n#include \"warnless.h\"\n#include \"strcase.h\"\n#include \"easy_lock.h\"\n/* The last 3 #include files should be in this order */\n#include \"curl_printf.h\"\n#include \"curl_memory.h\"\n#include \"memdebug.h\"\n\n#if defined(CURLRES_SYNCH) &&                   \\\n  defined(HAVE_ALARM) &&                        \\\n  defined(SIGALRM) &&                           \\\n  defined(HAVE_SIGSETJMP) &&                    \\\n  defined(GLOBAL_INIT_IS_THREADSAFE)\n/* alarm-based timeouts can only be used with all the dependencies satisfied */\n#define USE_ALARM_TIMEOUT\n#endif\n\n#define MAX_HOSTCACHE_LEN (255 + 7) /* max FQDN + colon + port number + zero */\n\n#define MAX_DNS_CACHE_SIZE 29999\n\n/*\n * hostip.c explained\n * ==================\n *\n * The main COMPILE-TIME DEFINES to keep in mind when reading the host*.c\n * source file are these:\n *\n * CURLRES_IPV6 - this host has getaddrinfo() and family, and thus we use\n * that. The host may not be able to resolve IPv6, but we don't really have to\n * take that into account. Hosts that aren't IPv6-enabled have CURLRES_IPV4\n * defined.\n *\n * CURLRES_ARES - is defined if libcurl is built to use c-ares for\n * asynchronous name resolves. This can be Windows or *nix.\n *\n * CURLRES_THREADED - is defined if libcurl is built to run under (native)\n * Windows, and then the name resolve will be done in a new thread, and the\n * supported API will be the same as for ares-builds.\n *\n * If any of the two previous are defined, CURLRES_ASYNCH is defined too. If\n * libcurl is not built to use an asynchronous resolver, CURLRES_SYNCH is\n * defined.\n *\n * The host*.c sources files are split up like this:\n *\n * hostip.c   - method-independent resolver functions and utility functions\n * hostasyn.c - functions for asynchronous name resolves\n * hostsyn.c  - functions for synchronous name resolves\n * hostip4.c  - IPv4 specific functions\n * hostip6.c  - IPv6 specific functions\n *\n * The two asynchronous name resolver backends are implemented in:\n * asyn-ares.c   - functions for ares-using name resolves\n * asyn-thread.c - functions for threaded name resolves\n\n * The hostip.h is the united header file for all this. It defines the\n * CURLRES_* defines based on the config*.h and curl_setup.h defines.\n */\n\nstatic void freednsentry(void *freethis);\n\n#ifndef CURL_DISABLE_VERBOSE_STRINGS\nstatic void show_resolve_info(struct Curl_easy *data,\n                              struct Curl_dns_entry *dns);\n#else\n#define show_resolve_info(x,y) Curl_nop_stmt\n#endif\n\n/*\n * Curl_printable_address() stores a printable version of the 1st address\n * given in the 'ai' argument. The result will be stored in the buf that is\n * bufsize bytes big.\n *\n * If the conversion fails, the target buffer is empty.\n */\nvoid Curl_printable_address(const struct Curl_addrinfo *ai, char *buf,\n                            size_t bufsize)\n{\n  DEBUGASSERT(bufsize);\n  buf[0] = 0;\n\n  switch(ai->ai_family) {\n  case AF_INET: {\n    const struct sockaddr_in *sa4 = (const void *)ai->ai_addr;\n    const struct in_addr *ipaddr4 = &sa4->sin_addr;\n    (void)Curl_inet_ntop(ai->ai_family, (const void *)ipaddr4, buf, bufsize);\n    break;\n  }\n#ifdef ENABLE_IPV6\n  case AF_INET6: {\n    const struct sockaddr_in6 *sa6 = (const void *)ai->ai_addr;\n    const struct in6_addr *ipaddr6 = &sa6->sin6_addr;\n    (void)Curl_inet_ntop(ai->ai_family, (const void *)ipaddr6, buf, bufsize);\n    break;\n  }\n#endif\n  default:\n    break;\n  }\n}\n\n/*\n * Create a hostcache id string for the provided host + port, to be used by\n * the DNS caching. Without alloc. Return length of the id string.\n */\nstatic size_t\ncreate_hostcache_id(const char *name,\n                    size_t nlen, /* 0 or actual name length */\n                    int port, char *ptr, size_t buflen)\n{\n  size_t len = nlen ? nlen : strlen(name);\n  size_t olen = 0;\n  DEBUGASSERT(buflen >= MAX_HOSTCACHE_LEN);\n  if(len > (buflen - 7))\n    len = buflen - 7;\n  /* store and lower case the name */\n  while(len--) {\n    *ptr++ = Curl_raw_tolower(*name++);\n    olen++;\n  }\n  olen += msnprintf(ptr, 7, \":%u\", port);\n  return olen;\n}\n\nstruct hostcache_prune_data {\n  time_t now;\n  time_t oldest; /* oldest time in cache not pruned. */\n  int cache_timeout;\n};\n\n/*\n * This function is set as a callback to be called for every entry in the DNS\n * cache when we want to prune old unused entries.\n *\n * Returning non-zero means remove the entry, return 0 to keep it in the\n * cache.\n */\nstatic int\nhostcache_timestamp_remove(void *datap, void *hc)\n{\n  struct hostcache_prune_data *prune =\n    (struct hostcache_prune_data *) datap;\n  struct Curl_dns_entry *c = (struct Curl_dns_entry *) hc;\n\n  if(c->timestamp) {\n    /* age in seconds */\n    time_t age = prune->now - c->timestamp;\n    if(age >= prune->cache_timeout)\n      return TRUE;\n    if(age > prune->oldest)\n      prune->oldest = age;\n  }\n  return FALSE;\n}\n\n/*\n * Prune the DNS cache. This assumes that a lock has already been taken.\n * Returns the 'age' of the oldest still kept entry.\n */\nstatic time_t\nhostcache_prune(struct Curl_hash *hostcache, int cache_timeout,\n                time_t now)\n{\n  struct hostcache_prune_data user;\n\n  user.cache_timeout = cache_timeout;\n  user.now = now;\n  user.oldest = 0;\n\n  Curl_hash_clean_with_criterium(hostcache,\n                                 (void *) &user,\n                                 hostcache_timestamp_remove);\n\n  return user.oldest;\n}\n\n/*\n * Library-wide function for pruning the DNS cache. This function takes and\n * returns the appropriate locks.\n */\nvoid Curl_hostcache_prune(struct Curl_easy *data)\n{\n  time_t now;\n  /* the timeout may be set -1 (forever) */\n  int timeout = data->set.dns_cache_timeout;\n\n  if(!data->dns.hostcache)\n    /* NULL hostcache means we can't do it */\n    return;\n\n  if(data->share)\n    Curl_share_lock(data, CURL_LOCK_DATA_DNS, CURL_LOCK_ACCESS_SINGLE);\n\n  time(&now);\n\n  do {\n    /* Remove outdated and unused entries from the hostcache */\n    time_t oldest = hostcache_prune(data->dns.hostcache, timeout, now);\n\n    if(oldest < INT_MAX)\n      timeout = (int)oldest; /* we know it fits */\n    else\n      timeout = INT_MAX - 1;\n\n    /* if the cache size is still too big, use the oldest age as new\n       prune limit */\n  } while(timeout && (data->dns.hostcache->size > MAX_DNS_CACHE_SIZE));\n\n  if(data->share)\n    Curl_share_unlock(data, CURL_LOCK_DATA_DNS);\n}\n\n#ifdef USE_ALARM_TIMEOUT\n/* Beware this is a global and unique instance. This is used to store the\n   return address that we can jump back to from inside a signal handler. This\n   is not thread-safe stuff. */\nstatic sigjmp_buf curl_jmpenv;\nstatic curl_simple_lock curl_jmpenv_lock;\n#endif\n\n/* lookup address, returns entry if found and not stale */\nstatic struct Curl_dns_entry *fetch_addr(struct Curl_easy *data,\n                                         const char *hostname,\n                                         int port)\n{\n  struct Curl_dns_entry *dns = NULL;\n  char entry_id[MAX_HOSTCACHE_LEN];\n\n  /* Create an entry id, based upon the hostname and port */\n  size_t entry_len = create_hostcache_id(hostname, 0, port,\n                                         entry_id, sizeof(entry_id));\n\n  /* See if it's already in our dns cache */\n  dns = Curl_hash_pick(data->dns.hostcache, entry_id, entry_len + 1);\n\n  /* No entry found in cache, check if we might have a wildcard entry */\n  if(!dns && data->state.wildcard_resolve) {\n    entry_len = create_hostcache_id(\"*\", 1, port, entry_id, sizeof(entry_id));\n\n    /* See if it's already in our dns cache */\n    dns = Curl_hash_pick(data->dns.hostcache, entry_id, entry_len + 1);\n  }\n\n  if(dns && (data->set.dns_cache_timeout != -1)) {\n    /* See whether the returned entry is stale. Done before we release lock */\n    struct hostcache_prune_data user;\n\n    time(&user.now);\n    user.cache_timeout = data->set.dns_cache_timeout;\n    user.oldest = 0;\n\n    if(hostcache_timestamp_remove(&user, dns)) {\n      infof(data, \"Hostname in DNS cache was stale, zapped\");\n      dns = NULL; /* the memory deallocation is being handled by the hash */\n      Curl_hash_delete(data->dns.hostcache, entry_id, entry_len + 1);\n    }\n  }\n\n  /* See if the returned entry matches the required resolve mode */\n  if(dns && data->conn->ip_version != CURL_IPRESOLVE_WHATEVER) {\n    int pf = PF_INET;\n    bool found = false;\n    struct Curl_addrinfo *addr = dns->addr;\n\n#ifdef PF_INET6\n    if(data->conn->ip_version == CURL_IPRESOLVE_V6)\n      pf = PF_INET6;\n#endif\n\n    while(addr) {\n      if(addr->ai_family == pf) {\n        found = true;\n        break;\n      }\n      addr = addr->ai_next;\n    }\n\n    if(!found) {\n      infof(data, \"Hostname in DNS cache doesn't have needed family, zapped\");\n      dns = NULL; /* the memory deallocation is being handled by the hash */\n      Curl_hash_delete(data->dns.hostcache, entry_id, entry_len + 1);\n    }\n  }\n  return dns;\n}\n\n/*\n * Curl_fetch_addr() fetches a 'Curl_dns_entry' already in the DNS cache.\n *\n * Curl_resolv() checks initially and multi_runsingle() checks each time\n * it discovers the handle in the state WAITRESOLVE whether the hostname\n * has already been resolved and the address has already been stored in\n * the DNS cache. This short circuits waiting for a lot of pending\n * lookups for the same hostname requested by different handles.\n *\n * Returns the Curl_dns_entry entry pointer or NULL if not in the cache.\n *\n * The returned data *MUST* be \"unlocked\" with Curl_resolv_unlock() after\n * use, or we'll leak memory!\n */\nstruct Curl_dns_entry *\nCurl_fetch_addr(struct Curl_easy *data,\n                const char *hostname,\n                int port)\n{\n  struct Curl_dns_entry *dns = NULL;\n\n  if(data->share)\n    Curl_share_lock(data, CURL_LOCK_DATA_DNS, CURL_LOCK_ACCESS_SINGLE);\n\n  dns = fetch_addr(data, hostname, port);\n\n  if(dns)\n    dns->inuse++; /* we use it! */\n\n  if(data->share)\n    Curl_share_unlock(data, CURL_LOCK_DATA_DNS);\n\n  return dns;\n}\n\n#ifndef CURL_DISABLE_SHUFFLE_DNS\n/*\n * Return # of addresses in a Curl_addrinfo struct\n */\nstatic int num_addresses(const struct Curl_addrinfo *addr)\n{\n  int i = 0;\n  while(addr) {\n    addr = addr->ai_next;\n    i++;\n  }\n  return i;\n}\n\nUNITTEST CURLcode Curl_shuffle_addr(struct Curl_easy *data,\n                                    struct Curl_addrinfo **addr);\n/*\n * Curl_shuffle_addr() shuffles the order of addresses in a 'Curl_addrinfo'\n * struct by re-linking its linked list.\n *\n * The addr argument should be the address of a pointer to the head node of a\n * `Curl_addrinfo` list and it will be modified to point to the new head after\n * shuffling.\n *\n * Not declared static only to make it easy to use in a unit test!\n *\n * @unittest: 1608\n */\nUNITTEST CURLcode Curl_shuffle_addr(struct Curl_easy *data,\n                                    struct Curl_addrinfo **addr)\n{\n  CURLcode result = CURLE_OK;\n  const int num_addrs = num_addresses(*addr);\n\n  if(num_addrs > 1) {\n    struct Curl_addrinfo **nodes;\n    infof(data, \"Shuffling %i addresses\", num_addrs);\n\n    nodes = malloc(num_addrs*sizeof(*nodes));\n    if(nodes) {\n      int i;\n      unsigned int *rnd;\n      const size_t rnd_size = num_addrs * sizeof(*rnd);\n\n      /* build a plain array of Curl_addrinfo pointers */\n      nodes[0] = *addr;\n      for(i = 1; i < num_addrs; i++) {\n        nodes[i] = nodes[i-1]->ai_next;\n      }\n\n      rnd = malloc(rnd_size);\n      if(rnd) {\n        /* Fisher-Yates shuffle */\n        if(Curl_rand(data, (unsigned char *)rnd, rnd_size) == CURLE_OK) {\n          struct Curl_addrinfo *swap_tmp;\n          for(i = num_addrs - 1; i > 0; i--) {\n            swap_tmp = nodes[rnd[i] % (i + 1)];\n            nodes[rnd[i] % (i + 1)] = nodes[i];\n            nodes[i] = swap_tmp;\n          }\n\n          /* relink list in the new order */\n          for(i = 1; i < num_addrs; i++) {\n            nodes[i-1]->ai_next = nodes[i];\n          }\n\n          nodes[num_addrs-1]->ai_next = NULL;\n          *addr = nodes[0];\n        }\n        free(rnd);\n      }\n      else\n        result = CURLE_OUT_OF_MEMORY;\n      free(nodes);\n    }\n    else\n      result = CURLE_OUT_OF_MEMORY;\n  }\n  return result;\n}\n#endif\n\n/*\n * Curl_cache_addr() stores a 'Curl_addrinfo' struct in the DNS cache.\n *\n * When calling Curl_resolv() has resulted in a response with a returned\n * address, we call this function to store the information in the dns\n * cache etc\n *\n * Returns the Curl_dns_entry entry pointer or NULL if the storage failed.\n */\nstruct Curl_dns_entry *\nCurl_cache_addr(struct Curl_easy *data,\n                struct Curl_addrinfo *addr,\n                const char *hostname,\n                size_t hostlen, /* length or zero */\n                int port)\n{\n  char entry_id[MAX_HOSTCACHE_LEN];\n  size_t entry_len;\n  struct Curl_dns_entry *dns;\n  struct Curl_dns_entry *dns2;\n\n#ifndef CURL_DISABLE_SHUFFLE_DNS\n  /* shuffle addresses if requested */\n  if(data->set.dns_shuffle_addresses) {\n    CURLcode result = Curl_shuffle_addr(data, &addr);\n    if(result)\n      return NULL;\n  }\n#endif\n  if(!hostlen)\n    hostlen = strlen(hostname);\n\n  /* Create a new cache entry */\n  dns = calloc(1, sizeof(struct Curl_dns_entry) + hostlen);\n  if(!dns) {\n    return NULL;\n  }\n\n  /* Create an entry id, based upon the hostname and port */\n  entry_len = create_hostcache_id(hostname, hostlen, port,\n                                  entry_id, sizeof(entry_id));\n\n  dns->inuse = 1;   /* the cache has the first reference */\n  dns->addr = addr; /* this is the address(es) */\n  time(&dns->timestamp);\n  if(dns->timestamp == 0)\n    dns->timestamp = 1;   /* zero indicates permanent CURLOPT_RESOLVE entry */\n  dns->hostport = port;\n  if(hostlen)\n    memcpy(dns->hostname, hostname, hostlen);\n\n  /* Store the resolved data in our DNS cache. */\n  dns2 = Curl_hash_add(data->dns.hostcache, entry_id, entry_len + 1,\n                       (void *)dns);\n  if(!dns2) {\n    free(dns);\n    return NULL;\n  }\n\n  dns = dns2;\n  dns->inuse++;         /* mark entry as in-use */\n  return dns;\n}\n\n#ifdef ENABLE_IPV6\n/* return a static IPv6 ::1 for the name */\nstatic struct Curl_addrinfo *get_localhost6(int port, const char *name)\n{\n  struct Curl_addrinfo *ca;\n  const size_t ss_size = sizeof(struct sockaddr_in6);\n  const size_t hostlen = strlen(name);\n  struct sockaddr_in6 sa6;\n  unsigned char ipv6[16];\n  unsigned short port16 = (unsigned short)(port & 0xffff);\n  ca = calloc(1, sizeof(struct Curl_addrinfo) + ss_size + hostlen + 1);\n  if(!ca)\n    return NULL;\n\n  sa6.sin6_family = AF_INET6;\n  sa6.sin6_port = htons(port16);\n  sa6.sin6_flowinfo = 0;\n  sa6.sin6_scope_id = 0;\n  if(Curl_inet_pton(AF_INET6, \"::1\", ipv6) < 1)\n    return NULL;\n  memcpy(&sa6.sin6_addr, ipv6, sizeof(ipv6));\n\n  ca->ai_flags     = 0;\n  ca->ai_family    = AF_INET6;\n  ca->ai_socktype  = SOCK_STREAM;\n  ca->ai_protocol  = IPPROTO_TCP;\n  ca->ai_addrlen   = (curl_socklen_t)ss_size;\n  ca->ai_next      = NULL;\n  ca->ai_addr = (void *)((char *)ca + sizeof(struct Curl_addrinfo));\n  memcpy(ca->ai_addr, &sa6, ss_size);\n  ca->ai_canonname = (char *)ca->ai_addr + ss_size;\n  strcpy(ca->ai_canonname, name);\n  return ca;\n}\n#else\n#define get_localhost6(x,y) NULL\n#endif\n\n/* return a static IPv4 127.0.0.1 for the given name */\nstatic struct Curl_addrinfo *get_localhost(int port, const char *name)\n{\n  struct Curl_addrinfo *ca;\n  struct Curl_addrinfo *ca6;\n  const size_t ss_size = sizeof(struct sockaddr_in);\n  const size_t hostlen = strlen(name);\n  struct sockaddr_in sa;\n  unsigned int ipv4;\n  unsigned short port16 = (unsigned short)(port & 0xffff);\n\n  /* memset to clear the sa.sin_zero field */\n  memset(&sa, 0, sizeof(sa));\n  sa.sin_family = AF_INET;\n  sa.sin_port = htons(port16);\n  if(Curl_inet_pton(AF_INET, \"127.0.0.1\", (char *)&ipv4) < 1)\n    return NULL;\n  memcpy(&sa.sin_addr, &ipv4, sizeof(ipv4));\n\n  ca = calloc(1, sizeof(struct Curl_addrinfo) + ss_size + hostlen + 1);\n  if(!ca)\n    return NULL;\n  ca->ai_flags     = 0;\n  ca->ai_family    = AF_INET;\n  ca->ai_socktype  = SOCK_STREAM;\n  ca->ai_protocol  = IPPROTO_TCP;\n  ca->ai_addrlen   = (curl_socklen_t)ss_size;\n  ca->ai_addr = (void *)((char *)ca + sizeof(struct Curl_addrinfo));\n  memcpy(ca->ai_addr, &sa, ss_size);\n  ca->ai_canonname = (char *)ca->ai_addr + ss_size;\n  strcpy(ca->ai_canonname, name);\n\n  ca6 = get_localhost6(port, name);\n  if(!ca6)\n    return ca;\n  ca6->ai_next = ca;\n  return ca6;\n}\n\n#ifdef ENABLE_IPV6\n/*\n * Curl_ipv6works() returns TRUE if IPv6 seems to work.\n */\nbool Curl_ipv6works(struct Curl_easy *data)\n{\n  if(data) {\n    /* the nature of most system is that IPv6 status doesn't come and go\n       during a program's lifetime so we only probe the first time and then we\n       have the info kept for fast reuse */\n    DEBUGASSERT(data);\n    DEBUGASSERT(data->multi);\n    if(data->multi->ipv6_up == IPV6_UNKNOWN) {\n      bool works = Curl_ipv6works(NULL);\n      data->multi->ipv6_up = works ? IPV6_WORKS : IPV6_DEAD;\n    }\n    return data->multi->ipv6_up == IPV6_WORKS;\n  }\n  else {\n    int ipv6_works = -1;\n    /* probe to see if we have a working IPv6 stack */\n    curl_socket_t s = socket(PF_INET6, SOCK_DGRAM, 0);\n    if(s == CURL_SOCKET_BAD)\n      /* an IPv6 address was requested but we can't get/use one */\n      ipv6_works = 0;\n    else {\n      ipv6_works = 1;\n      sclose(s);\n    }\n    return (ipv6_works>0)?TRUE:FALSE;\n  }\n}\n#endif /* ENABLE_IPV6 */\n\n/*\n * Curl_host_is_ipnum() returns TRUE if the given string is a numerical IPv4\n * (or IPv6 if supported) address.\n */\nbool Curl_host_is_ipnum(const char *hostname)\n{\n  struct in_addr in;\n#ifdef ENABLE_IPV6\n  struct in6_addr in6;\n#endif\n  if(Curl_inet_pton(AF_INET, hostname, &in) > 0\n#ifdef ENABLE_IPV6\n     || Curl_inet_pton(AF_INET6, hostname, &in6) > 0\n#endif\n    )\n    return TRUE;\n  return FALSE;\n}\n\n\n/* return TRUE if 'part' is a case insensitive tail of 'full' */\nstatic bool tailmatch(const char *full, const char *part)\n{\n  size_t plen = strlen(part);\n  size_t flen = strlen(full);\n  if(plen > flen)\n    return FALSE;\n  return strncasecompare(part, &full[flen - plen], plen);\n}\n\n/*\n * Curl_resolv() is the main name resolve function within libcurl. It resolves\n * a name and returns a pointer to the entry in the 'entry' argument (if one\n * is provided). This function might return immediately if we're using asynch\n * resolves. See the return codes.\n *\n * The cache entry we return will get its 'inuse' counter increased when this\n * function is used. You MUST call Curl_resolv_unlock() later (when you're\n * done using this struct) to decrease the counter again.\n *\n * Return codes:\n *\n * CURLRESOLV_ERROR   (-1) = error, no pointer\n * CURLRESOLV_RESOLVED (0) = OK, pointer provided\n * CURLRESOLV_PENDING  (1) = waiting for response, no pointer\n */\n\nenum resolve_t Curl_resolv(struct Curl_easy *data,\n                           const char *hostname,\n                           int port,\n                           bool allowDOH,\n                           struct Curl_dns_entry **entry)\n{\n  struct Curl_dns_entry *dns = NULL;\n  CURLcode result;\n  enum resolve_t rc = CURLRESOLV_ERROR; /* default to failure */\n  struct connectdata *conn = data->conn;\n  /* We should intentionally error and not resolve .onion TLDs */\n  size_t hostname_len = strlen(hostname);\n  if(hostname_len >= 7 &&\n     (curl_strequal(&hostname[hostname_len - 6], \".onion\") ||\n      curl_strequal(&hostname[hostname_len - 7], \".onion.\"))) {\n    failf(data, \"Not resolving .onion address (RFC 7686)\");\n    return CURLRESOLV_ERROR;\n  }\n  *entry = NULL;\n#ifndef CURL_DISABLE_DOH\n  conn->bits.doh = FALSE; /* default is not */\n#else\n  (void)allowDOH;\n#endif\n\n  if(data->share)\n    Curl_share_lock(data, CURL_LOCK_DATA_DNS, CURL_LOCK_ACCESS_SINGLE);\n\n  dns = fetch_addr(data, hostname, port);\n\n  if(dns) {\n    infof(data, \"Hostname %s was found in DNS cache\", hostname);\n    dns->inuse++; /* we use it! */\n    rc = CURLRESOLV_RESOLVED;\n  }\n\n  if(data->share)\n    Curl_share_unlock(data, CURL_LOCK_DATA_DNS);\n\n  if(!dns) {\n    /* The entry was not in the cache. Resolve it to IP address */\n\n    struct Curl_addrinfo *addr = NULL;\n    int respwait = 0;\n#if !defined(CURL_DISABLE_DOH) || !defined(USE_RESOLVE_ON_IPS)\n    struct in_addr in;\n#endif\n#ifndef CURL_DISABLE_DOH\n#ifndef USE_RESOLVE_ON_IPS\n    const\n#endif\n      bool ipnum = FALSE;\n#endif\n\n    /* notify the resolver start callback */\n    if(data->set.resolver_start) {\n      int st;\n      Curl_set_in_callback(data, true);\n      st = data->set.resolver_start(\n#ifdef USE_CURL_ASYNC\n        data->state.async.resolver,\n#else\n        NULL,\n#endif\n        NULL,\n        data->set.resolver_start_client);\n      Curl_set_in_callback(data, false);\n      if(st)\n        return CURLRESOLV_ERROR;\n    }\n\n#ifndef USE_RESOLVE_ON_IPS\n    /* First check if this is an IPv4 address string */\n    if(Curl_inet_pton(AF_INET, hostname, &in) > 0) {\n      /* This is a dotted IP address 123.123.123.123-style */\n      addr = Curl_ip2addr(AF_INET, &in, hostname, port);\n      if(!addr)\n        return CURLRESOLV_ERROR;\n    }\n#ifdef ENABLE_IPV6\n    else {\n      struct in6_addr in6;\n      /* check if this is an IPv6 address string */\n      if(Curl_inet_pton(AF_INET6, hostname, &in6) > 0) {\n        /* This is an IPv6 address literal */\n        addr = Curl_ip2addr(AF_INET6, &in6, hostname, port);\n        if(!addr)\n          return CURLRESOLV_ERROR;\n      }\n    }\n#endif /* ENABLE_IPV6 */\n\n#else /* if USE_RESOLVE_ON_IPS */\n#ifndef CURL_DISABLE_DOH\n    /* First check if this is an IPv4 address string */\n    if(Curl_inet_pton(AF_INET, hostname, &in) > 0)\n      /* This is a dotted IP address 123.123.123.123-style */\n      ipnum = TRUE;\n#ifdef ENABLE_IPV6\n    else {\n      struct in6_addr in6;\n      /* check if this is an IPv6 address string */\n      if(Curl_inet_pton(AF_INET6, hostname, &in6) > 0)\n        /* This is an IPv6 address literal */\n        ipnum = TRUE;\n    }\n#endif /* ENABLE_IPV6 */\n#endif /* CURL_DISABLE_DOH */\n\n#endif /* !USE_RESOLVE_ON_IPS */\n\n    if(!addr) {\n      if(conn->ip_version == CURL_IPRESOLVE_V6 && !Curl_ipv6works(data))\n        return CURLRESOLV_ERROR;\n\n      if(strcasecompare(hostname, \"localhost\") ||\n         tailmatch(hostname, \".localhost\"))\n        addr = get_localhost(port, hostname);\n#ifndef CURL_DISABLE_DOH\n      else if(allowDOH && data->set.doh && !ipnum)\n        addr = Curl_doh(data, hostname, port, &respwait);\n#endif\n      else {\n        /* Check what IP specifics the app has requested and if we can provide\n         * it. If not, bail out. */\n        if(!Curl_ipvalid(data, conn))\n          return CURLRESOLV_ERROR;\n        /* If Curl_getaddrinfo() returns NULL, 'respwait' might be set to a\n           non-zero value indicating that we need to wait for the response to\n           the resolve call */\n        addr = Curl_getaddrinfo(data, hostname, port, &respwait);\n      }\n    }\n    if(!addr) {\n      if(respwait) {\n        /* the response to our resolve call will come asynchronously at\n           a later time, good or bad */\n        /* First, check that we haven't received the info by now */\n        result = Curl_resolv_check(data, &dns);\n        if(result) /* error detected */\n          return CURLRESOLV_ERROR;\n        if(dns)\n          rc = CURLRESOLV_RESOLVED; /* pointer provided */\n        else\n          rc = CURLRESOLV_PENDING; /* no info yet */\n      }\n    }\n    else {\n      if(data->share)\n        Curl_share_lock(data, CURL_LOCK_DATA_DNS, CURL_LOCK_ACCESS_SINGLE);\n\n      /* we got a response, store it in the cache */\n      dns = Curl_cache_addr(data, addr, hostname, 0, port);\n\n      if(data->share)\n        Curl_share_unlock(data, CURL_LOCK_DATA_DNS);\n\n      if(!dns)\n        /* returned failure, bail out nicely */\n        Curl_freeaddrinfo(addr);\n      else {\n        rc = CURLRESOLV_RESOLVED;\n        show_resolve_info(data, dns);\n      }\n    }\n  }\n\n  *entry = dns;\n\n  return rc;\n}\n\n#ifdef USE_ALARM_TIMEOUT\n/*\n * This signal handler jumps back into the main libcurl code and continues\n * execution.  This effectively causes the remainder of the application to run\n * within a signal handler which is nonportable and could lead to problems.\n */\nCURL_NORETURN static\nvoid alarmfunc(int sig)\n{\n  (void)sig;\n  siglongjmp(curl_jmpenv, 1);\n}\n#endif /* USE_ALARM_TIMEOUT */\n\n/*\n * Curl_resolv_timeout() is the same as Curl_resolv() but specifies a\n * timeout.  This function might return immediately if we're using asynch\n * resolves. See the return codes.\n *\n * The cache entry we return will get its 'inuse' counter increased when this\n * function is used. You MUST call Curl_resolv_unlock() later (when you're\n * done using this struct) to decrease the counter again.\n *\n * If built with a synchronous resolver and use of signals is not\n * disabled by the application, then a nonzero timeout will cause a\n * timeout after the specified number of milliseconds. Otherwise, timeout\n * is ignored.\n *\n * Return codes:\n *\n * CURLRESOLV_TIMEDOUT(-2) = warning, time too short or previous alarm expired\n * CURLRESOLV_ERROR   (-1) = error, no pointer\n * CURLRESOLV_RESOLVED (0) = OK, pointer provided\n * CURLRESOLV_PENDING  (1) = waiting for response, no pointer\n */\n\nenum resolve_t Curl_resolv_timeout(struct Curl_easy *data,\n                                   const char *hostname,\n                                   int port,\n                                   struct Curl_dns_entry **entry,\n                                   timediff_t timeoutms)\n{\n#ifdef USE_ALARM_TIMEOUT\n#ifdef HAVE_SIGACTION\n  struct sigaction keep_sigact;   /* store the old struct here */\n  volatile bool keep_copysig = FALSE; /* whether old sigact has been saved */\n  struct sigaction sigact;\n#else\n#ifdef HAVE_SIGNAL\n  void (*keep_sigact)(int);       /* store the old handler here */\n#endif /* HAVE_SIGNAL */\n#endif /* HAVE_SIGACTION */\n  volatile long timeout;\n  volatile unsigned int prev_alarm = 0;\n#endif /* USE_ALARM_TIMEOUT */\n  enum resolve_t rc;\n\n  *entry = NULL;\n\n  if(timeoutms < 0)\n    /* got an already expired timeout */\n    return CURLRESOLV_TIMEDOUT;\n\n#ifdef USE_ALARM_TIMEOUT\n  if(data->set.no_signal)\n    /* Ignore the timeout when signals are disabled */\n    timeout = 0;\n  else\n    timeout = (timeoutms > LONG_MAX) ? LONG_MAX : (long)timeoutms;\n\n  if(!timeout)\n    /* USE_ALARM_TIMEOUT defined, but no timeout actually requested */\n    return Curl_resolv(data, hostname, port, TRUE, entry);\n\n  if(timeout < 1000) {\n    /* The alarm() function only provides integer second resolution, so if\n       we want to wait less than one second we must bail out already now. */\n    failf(data,\n        \"remaining timeout of %ld too small to resolve via SIGALRM method\",\n        timeout);\n    return CURLRESOLV_TIMEDOUT;\n  }\n  /* This allows us to time-out from the name resolver, as the timeout\n     will generate a signal and we will siglongjmp() from that here.\n     This technique has problems (see alarmfunc).\n     This should be the last thing we do before calling Curl_resolv(),\n     as otherwise we'd have to worry about variables that get modified\n     before we invoke Curl_resolv() (and thus use \"volatile\"). */\n  curl_simple_lock_lock(&curl_jmpenv_lock);\n\n  if(sigsetjmp(curl_jmpenv, 1)) {\n    /* this is coming from a siglongjmp() after an alarm signal */\n    failf(data, \"name lookup timed out\");\n    rc = CURLRESOLV_ERROR;\n    goto clean_up;\n  }\n  else {\n    /*************************************************************\n     * Set signal handler to catch SIGALRM\n     * Store the old value to be able to set it back later!\n     *************************************************************/\n#ifdef HAVE_SIGACTION\n    sigaction(SIGALRM, NULL, &sigact);\n    keep_sigact = sigact;\n    keep_copysig = TRUE; /* yes, we have a copy */\n    sigact.sa_handler = alarmfunc;\n#ifdef SA_RESTART\n    /* HPUX doesn't have SA_RESTART but defaults to that behavior! */\n    sigact.sa_flags &= ~SA_RESTART;\n#endif\n    /* now set the new struct */\n    sigaction(SIGALRM, &sigact, NULL);\n#else /* HAVE_SIGACTION */\n    /* no sigaction(), revert to the much lamer signal() */\n#ifdef HAVE_SIGNAL\n    keep_sigact = signal(SIGALRM, alarmfunc);\n#endif\n#endif /* HAVE_SIGACTION */\n\n    /* alarm() makes a signal get sent when the timeout fires off, and that\n       will abort system calls */\n    prev_alarm = alarm(curlx_sltoui(timeout/1000L));\n  }\n\n#else\n#ifndef CURLRES_ASYNCH\n  if(timeoutms)\n    infof(data, \"timeout on name lookup is not supported\");\n#else\n  (void)timeoutms; /* timeoutms not used with an async resolver */\n#endif\n#endif /* USE_ALARM_TIMEOUT */\n\n  /* Perform the actual name resolution. This might be interrupted by an\n   * alarm if it takes too long.\n   */\n  rc = Curl_resolv(data, hostname, port, TRUE, entry);\n\n#ifdef USE_ALARM_TIMEOUT\nclean_up:\n\n  if(!prev_alarm)\n    /* deactivate a possibly active alarm before uninstalling the handler */\n    alarm(0);\n\n#ifdef HAVE_SIGACTION\n  if(keep_copysig) {\n    /* we got a struct as it looked before, now put that one back nice\n       and clean */\n    sigaction(SIGALRM, &keep_sigact, NULL); /* put it back */\n  }\n#else\n#ifdef HAVE_SIGNAL\n  /* restore the previous SIGALRM handler */\n  signal(SIGALRM, keep_sigact);\n#endif\n#endif /* HAVE_SIGACTION */\n\n  curl_simple_lock_unlock(&curl_jmpenv_lock);\n\n  /* switch back the alarm() to either zero or to what it was before minus\n     the time we spent until now! */\n  if(prev_alarm) {\n    /* there was an alarm() set before us, now put it back */\n    timediff_t elapsed_secs = Curl_timediff(Curl_now(),\n                                            data->conn->created) / 1000;\n\n    /* the alarm period is counted in even number of seconds */\n    unsigned long alarm_set = (unsigned long)(prev_alarm - elapsed_secs);\n\n    if(!alarm_set ||\n       ((alarm_set >= 0x80000000) && (prev_alarm < 0x80000000)) ) {\n      /* if the alarm time-left reached zero or turned \"negative\" (counted\n         with unsigned values), we should fire off a SIGALRM here, but we\n         won't, and zero would be to switch it off so we never set it to\n         less than 1! */\n      alarm(1);\n      rc = CURLRESOLV_TIMEDOUT;\n      failf(data, \"Previous alarm fired off\");\n    }\n    else\n      alarm((unsigned int)alarm_set);\n  }\n#endif /* USE_ALARM_TIMEOUT */\n\n  return rc;\n}\n\n/*\n * Curl_resolv_unlock() unlocks the given cached DNS entry. When this has been\n * made, the struct may be destroyed due to pruning. It is important that only\n * one unlock is made for each Curl_resolv() call.\n *\n * May be called with 'data' == NULL for global cache.\n */\nvoid Curl_resolv_unlock(struct Curl_easy *data, struct Curl_dns_entry *dns)\n{\n  if(data && data->share)\n    Curl_share_lock(data, CURL_LOCK_DATA_DNS, CURL_LOCK_ACCESS_SINGLE);\n\n  freednsentry(dns);\n\n  if(data && data->share)\n    Curl_share_unlock(data, CURL_LOCK_DATA_DNS);\n}\n\n/*\n * File-internal: release cache dns entry reference, free if inuse drops to 0\n */\nstatic void freednsentry(void *freethis)\n{\n  struct Curl_dns_entry *dns = (struct Curl_dns_entry *) freethis;\n  DEBUGASSERT(dns && (dns->inuse>0));\n\n  dns->inuse--;\n  if(dns->inuse == 0) {\n    Curl_freeaddrinfo(dns->addr);\n    free(dns);\n  }\n}\n\n/*\n * Curl_init_dnscache() inits a new DNS cache.\n */\nvoid Curl_init_dnscache(struct Curl_hash *hash, int size)\n{\n  Curl_hash_init(hash, size, Curl_hash_str, Curl_str_key_compare,\n                 freednsentry);\n}\n\n/*\n * Curl_hostcache_clean()\n *\n * This _can_ be called with 'data' == NULL but then of course no locking\n * can be done!\n */\n\nvoid Curl_hostcache_clean(struct Curl_easy *data,\n                          struct Curl_hash *hash)\n{\n  if(data && data->share)\n    Curl_share_lock(data, CURL_LOCK_DATA_DNS, CURL_LOCK_ACCESS_SINGLE);\n\n  Curl_hash_clean(hash);\n\n  if(data && data->share)\n    Curl_share_unlock(data, CURL_LOCK_DATA_DNS);\n}\n\n\nCURLcode Curl_loadhostpairs(struct Curl_easy *data)\n{\n  struct curl_slist *hostp;\n  char *host_end;\n\n  /* Default is no wildcard found */\n  data->state.wildcard_resolve = false;\n\n  for(hostp = data->state.resolve; hostp; hostp = hostp->next) {\n    char entry_id[MAX_HOSTCACHE_LEN];\n    if(!hostp->data)\n      continue;\n    if(hostp->data[0] == '-') {\n      unsigned long num = 0;\n      size_t entry_len;\n      size_t hlen = 0;\n      host_end = strchr(&hostp->data[1], ':');\n\n      if(host_end) {\n        hlen = host_end - &hostp->data[1];\n        num = strtoul(++host_end, NULL, 10);\n        if(!hlen || (num > 0xffff))\n          host_end = NULL;\n      }\n      if(!host_end) {\n        infof(data, \"Bad syntax CURLOPT_RESOLVE removal entry '%s'\",\n              hostp->data);\n        continue;\n      }\n      /* Create an entry id, based upon the hostname and port */\n      entry_len = create_hostcache_id(&hostp->data[1], hlen, (int)num,\n                                      entry_id, sizeof(entry_id));\n      if(data->share)\n        Curl_share_lock(data, CURL_LOCK_DATA_DNS, CURL_LOCK_ACCESS_SINGLE);\n\n      /* delete entry, ignore if it didn't exist */\n      Curl_hash_delete(data->dns.hostcache, entry_id, entry_len + 1);\n\n      if(data->share)\n        Curl_share_unlock(data, CURL_LOCK_DATA_DNS);\n    }\n    else {\n      struct Curl_dns_entry *dns;\n      struct Curl_addrinfo *head = NULL, *tail = NULL;\n      size_t entry_len;\n      char address[64];\n#if !defined(CURL_DISABLE_VERBOSE_STRINGS)\n      char *addresses = NULL;\n#endif\n      char *addr_begin;\n      char *addr_end;\n      char *port_ptr;\n      int port = 0;\n      char *end_ptr;\n      bool permanent = TRUE;\n      unsigned long tmp_port;\n      bool error = true;\n      char *host_begin = hostp->data;\n      size_t hlen = 0;\n\n      if(host_begin[0] == '+') {\n        host_begin++;\n        permanent = FALSE;\n      }\n      host_end = strchr(host_begin, ':');\n      if(!host_end)\n        goto err;\n      hlen = host_end - host_begin;\n\n      port_ptr = host_end + 1;\n      tmp_port = strtoul(port_ptr, &end_ptr, 10);\n      if(tmp_port > USHRT_MAX || end_ptr == port_ptr || *end_ptr != ':')\n        goto err;\n\n      port = (int)tmp_port;\n#if !defined(CURL_DISABLE_VERBOSE_STRINGS)\n      addresses = end_ptr + 1;\n#endif\n\n      while(*end_ptr) {\n        size_t alen;\n        struct Curl_addrinfo *ai;\n\n        addr_begin = end_ptr + 1;\n        addr_end = strchr(addr_begin, ',');\n        if(!addr_end)\n          addr_end = addr_begin + strlen(addr_begin);\n        end_ptr = addr_end;\n\n        /* allow IP(v6) address within [brackets] */\n        if(*addr_begin == '[') {\n          if(addr_end == addr_begin || *(addr_end - 1) != ']')\n            goto err;\n          ++addr_begin;\n          --addr_end;\n        }\n\n        alen = addr_end - addr_begin;\n        if(!alen)\n          continue;\n\n        if(alen >= sizeof(address))\n          goto err;\n\n        memcpy(address, addr_begin, alen);\n        address[alen] = '\\0';\n\n#ifndef ENABLE_IPV6\n        if(strchr(address, ':')) {\n          infof(data, \"Ignoring resolve address '%s', missing IPv6 support.\",\n                address);\n          continue;\n        }\n#endif\n\n        ai = Curl_str2addr(address, port);\n        if(!ai) {\n          infof(data, \"Resolve address '%s' found illegal\", address);\n          goto err;\n        }\n\n        if(tail) {\n          tail->ai_next = ai;\n          tail = tail->ai_next;\n        }\n        else {\n          head = tail = ai;\n        }\n      }\n\n      if(!head)\n        goto err;\n\n      error = false;\nerr:\n      if(error) {\n        failf(data, \"Couldn't parse CURLOPT_RESOLVE entry '%s'\",\n              hostp->data);\n        Curl_freeaddrinfo(head);\n        return CURLE_SETOPT_OPTION_SYNTAX;\n      }\n\n      /* Create an entry id, based upon the hostname and port */\n      entry_len = create_hostcache_id(host_begin, hlen, port,\n                                      entry_id, sizeof(entry_id));\n\n      if(data->share)\n        Curl_share_lock(data, CURL_LOCK_DATA_DNS, CURL_LOCK_ACCESS_SINGLE);\n\n      /* See if it's already in our dns cache */\n      dns = Curl_hash_pick(data->dns.hostcache, entry_id, entry_len + 1);\n\n      if(dns) {\n        infof(data, \"RESOLVE %.*s:%d - old addresses discarded\",\n              (int)hlen, host_begin, port);\n        /* delete old entry, there are two reasons for this\n         1. old entry may have different addresses.\n         2. even if entry with correct addresses is already in the cache,\n            but if it is close to expire, then by the time next http\n            request is made, it can get expired and pruned because old\n            entry is not necessarily marked as permanent.\n         3. when adding a non-permanent entry, we want it to remove and\n            replace an existing permanent entry.\n         4. when adding a non-permanent entry, we want it to get a \"fresh\"\n            timeout that starts _now_. */\n\n        Curl_hash_delete(data->dns.hostcache, entry_id, entry_len + 1);\n      }\n\n      /* put this new host in the cache */\n      dns = Curl_cache_addr(data, head, host_begin, hlen, port);\n      if(dns) {\n        if(permanent)\n          dns->timestamp = 0; /* mark as permanent */\n        /* release the returned reference; the cache itself will keep the\n         * entry alive: */\n        dns->inuse--;\n      }\n\n      if(data->share)\n        Curl_share_unlock(data, CURL_LOCK_DATA_DNS);\n\n      if(!dns) {\n        Curl_freeaddrinfo(head);\n        return CURLE_OUT_OF_MEMORY;\n      }\n#ifndef CURL_DISABLE_VERBOSE_STRINGS\n      infof(data, \"Added %.*s:%d:%s to DNS cache%s\",\n            (int)hlen, host_begin, port, addresses,\n            permanent ? \"\" : \" (non-permanent)\");\n#endif\n\n      /* Wildcard hostname */\n      if((hlen == 1) && (host_begin[0] == '*')) {\n        infof(data, \"RESOLVE *:%d using wildcard\", port);\n        data->state.wildcard_resolve = true;\n      }\n    }\n  }\n  data->state.resolve = NULL; /* dealt with now */\n\n  return CURLE_OK;\n}\n\n#ifndef CURL_DISABLE_VERBOSE_STRINGS\nstatic void show_resolve_info(struct Curl_easy *data,\n                              struct Curl_dns_entry *dns)\n{\n  struct Curl_addrinfo *a;\n  CURLcode result = CURLE_OK;\n#ifdef CURLRES_IPV6\n  struct dynbuf out[2];\n#else\n  struct dynbuf out[1];\n#endif\n  DEBUGASSERT(data);\n  DEBUGASSERT(dns);\n\n  if(!data->set.verbose ||\n     /* ignore no name or numerical IP addresses */\n     !dns->hostname[0] || Curl_host_is_ipnum(dns->hostname))\n    return;\n\n  a = dns->addr;\n\n  infof(data, \"Host %s:%d was resolved.\",\n        (dns->hostname[0] ? dns->hostname : \"(none)\"), dns->hostport);\n\n  Curl_dyn_init(&out[0], 1024);\n#ifdef CURLRES_IPV6\n  Curl_dyn_init(&out[1], 1024);\n#endif\n\n  while(a) {\n    if(\n#ifdef CURLRES_IPV6\n       a->ai_family == PF_INET6 ||\n#endif\n       a->ai_family == PF_INET) {\n      char buf[MAX_IPADR_LEN];\n      struct dynbuf *d = &out[(a->ai_family != PF_INET)];\n      Curl_printable_address(a, buf, sizeof(buf));\n      if(Curl_dyn_len(d))\n        result = Curl_dyn_addn(d, \", \", 2);\n      if(!result)\n        result = Curl_dyn_add(d, buf);\n      if(result) {\n        infof(data, \"too many IP, can't show\");\n        goto fail;\n      }\n    }\n    a = a->ai_next;\n  }\n\n#ifdef CURLRES_IPV6\n  infof(data, \"IPv6: %s\",\n        (Curl_dyn_len(&out[1]) ? Curl_dyn_ptr(&out[1]) : \"(none)\"));\n#endif\n  infof(data, \"IPv4: %s\",\n        (Curl_dyn_len(&out[0]) ? Curl_dyn_ptr(&out[0]) : \"(none)\"));\n\nfail:\n  Curl_dyn_free(&out[0]);\n#ifdef CURLRES_IPV6\n  Curl_dyn_free(&out[1]);\n#endif\n}\n#endif\n\nCURLcode Curl_resolv_check(struct Curl_easy *data,\n                           struct Curl_dns_entry **dns)\n{\n  CURLcode result;\n#if defined(CURL_DISABLE_DOH) && !defined(CURLRES_ASYNCH)\n  (void)data;\n  (void)dns;\n#endif\n#ifndef CURL_DISABLE_DOH\n  if(data->conn->bits.doh) {\n    result = Curl_doh_is_resolved(data, dns);\n  }\n  else\n#endif\n  result = Curl_resolver_is_resolved(data, dns);\n  if(*dns)\n    show_resolve_info(data, *dns);\n  return result;\n}\n\nint Curl_resolv_getsock(struct Curl_easy *data,\n                        curl_socket_t *socks)\n{\n#ifdef CURLRES_ASYNCH\n#ifndef CURL_DISABLE_DOH\n  if(data->conn->bits.doh)\n    /* nothing to wait for during DoH resolve, those handles have their own\n       sockets */\n    return GETSOCK_BLANK;\n#endif\n  return Curl_resolver_getsock(data, socks);\n#else\n  (void)data;\n  (void)socks;\n  return GETSOCK_BLANK;\n#endif\n}\n\n/* Call this function after Curl_connect() has returned async=TRUE and\n   then a successful name resolve has been received.\n\n   Note: this function disconnects and frees the conn data in case of\n   resolve failure */\nCURLcode Curl_once_resolved(struct Curl_easy *data, bool *protocol_done)\n{\n  CURLcode result;\n  struct connectdata *conn = data->conn;\n\n#ifdef USE_CURL_ASYNC\n  if(data->state.async.dns) {\n    conn->dns_entry = data->state.async.dns;\n    data->state.async.dns = NULL;\n  }\n#endif\n\n  result = Curl_setup_conn(data, protocol_done);\n\n  if(result) {\n    Curl_detach_connection(data);\n    Curl_conncache_remove_conn(data, conn, TRUE);\n    Curl_disconnect(data, conn, TRUE);\n  }\n  return result;\n}\n\n/*\n * Curl_resolver_error() calls failf() with the appropriate message after a\n * resolve error\n */\n\n#ifdef USE_CURL_ASYNC\nCURLcode Curl_resolver_error(struct Curl_easy *data)\n{\n  const char *host_or_proxy;\n  CURLcode result;\n\n#ifndef CURL_DISABLE_PROXY\n  struct connectdata *conn = data->conn;\n  if(conn->bits.httpproxy) {\n    host_or_proxy = \"proxy\";\n    result = CURLE_COULDNT_RESOLVE_PROXY;\n  }\n  else\n#endif\n  {\n    host_or_proxy = \"host\";\n    result = CURLE_COULDNT_RESOLVE_HOST;\n  }\n\n  failf(data, \"Could not resolve %s: %s\", host_or_proxy,\n        data->state.async.hostname);\n\n  return result;\n}\n#endif /* USE_CURL_ASYNC */\n` was unexpected","path":"/home/qqq/curl-8.7.0/lib/hostip.c"},{"code":3,"level":"warn","type":["PartialParsing",[{"path":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":358,"col":27,"offset":0},"end":{"line":358,"col":31,"offset":4}},{"path":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":369,"col":29,"offset":0},"end":{"line":369,"col":33,"offset":4}},{"path":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":374,"col":29,"offset":0},"end":{"line":374,"col":33,"offset":4}},{"path":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":460,"col":1,"offset":0},"end":{"line":460,"col":2,"offset":1}},{"path":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":544,"col":27,"offset":0},"end":{"line":544,"col":37,"offset":10}},{"path":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":641,"col":27,"offset":0},"end":{"line":641,"col":31,"offset":4}},{"path":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":645,"col":27,"offset":0},"end":{"line":645,"col":31,"offset":4}},{"path":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":703,"col":27,"offset":0},"end":{"line":703,"col":31,"offset":4}},{"path":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":708,"col":25,"offset":0},"end":{"line":708,"col":29,"offset":4}},{"path":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":725,"col":27,"offset":0},"end":{"line":725,"col":31,"offset":4}},{"path":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":761,"col":27,"offset":0},"end":{"line":761,"col":31,"offset":4}},{"path":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":769,"col":27,"offset":0},"end":{"line":769,"col":31,"offset":4}},{"path":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":812,"col":25,"offset":0},"end":{"line":812,"col":29,"offset":4}},{"path":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":834,"col":25,"offset":0},"end":{"line":834,"col":29,"offset":4}},{"path":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":852,"col":27,"offset":0},"end":{"line":852,"col":31,"offset":4}},{"path":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":911,"col":27,"offset":0},"end":{"line":911,"col":31,"offset":4}},{"path":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":916,"col":25,"offset":0},"end":{"line":916,"col":29,"offset":4}},{"path":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":1157,"col":35,"offset":0},"end":{"line":1157,"col":39,"offset":4}},{"path":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":1166,"col":35,"offset":0},"end":{"line":1166,"col":39,"offset":4}},{"path":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":1227,"col":31,"offset":0},"end":{"line":1227,"col":35,"offset":4}},{"path":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":1266,"col":31,"offset":0},"end":{"line":1266,"col":35,"offset":4}},{"path":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":1279,"col":27,"offset":0},"end":{"line":1279,"col":31,"offset":4}},{"path":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":1401,"col":70,"offset":0},"end":{"line":1401,"col":76,"offset":6}},{"path":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":1430,"col":31,"offset":0},"end":{"line":1430,"col":41,"offset":10}},{"path":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":1440,"col":33,"offset":0},"end":{"line":1440,"col":43,"offset":10}},{"path":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":1447,"col":23,"offset":0},"end":{"line":1447,"col":33,"offset":10}},{"path":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":1473,"col":29,"offset":0},"end":{"line":1473,"col":33,"offset":4}},{"path":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":1479,"col":29,"offset":0},"end":{"line":1479,"col":33,"offset":4}},{"path":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":1771,"col":29,"offset":0},"end":{"line":1771,"col":44,"offset":15}},{"path":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":1775,"col":29,"offset":0},"end":{"line":1775,"col":44,"offset":15}},{"path":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":1785,"col":31,"offset":0},"end":{"line":1785,"col":37,"offset":6}},{"path":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":1788,"col":33,"offset":0},"end":{"line":1788,"col":39,"offset":6}},{"path":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":1859,"col":29,"offset":0},"end":{"line":1859,"col":33,"offset":4}},{"path":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":1865,"col":27,"offset":0},"end":{"line":1865,"col":31,"offset":4}},{"path":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":1873,"col":27,"offset":0},"end":{"line":1873,"col":31,"offset":4}},{"path":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":1894,"col":27,"offset":0},"end":{"line":1894,"col":31,"offset":4}},{"path":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":1903,"col":25,"offset":0},"end":{"line":1903,"col":29,"offset":4}},{"path":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":1919,"col":29,"offset":0},"end":{"line":1919,"col":35,"offset":6}},{"path":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":1925,"col":29,"offset":0},"end":{"line":1925,"col":35,"offset":6}},{"path":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":1964,"col":29,"offset":0},"end":{"line":1964,"col":33,"offset":4}},{"path":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":1982,"col":29,"offset":0},"end":{"line":1982,"col":33,"offset":4}},{"path":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":2012,"col":25,"offset":0},"end":{"line":2012,"col":29,"offset":4}}]],"message":"Syntax error at line /home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c:358:\n `\"[%\"` was unexpected","path":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","spans":[{"file":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":358,"col":27,"offset":0},"end":{"line":358,"col":31,"offset":4}},{"file":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":369,"col":29,"offset":0},"end":{"line":369,"col":33,"offset":4}},{"file":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":374,"col":29,"offset":0},"end":{"line":374,"col":33,"offset":4}},{"file":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":460,"col":1,"offset":0},"end":{"line":460,"col":2,"offset":1}},{"file":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":544,"col":27,"offset":0},"end":{"line":544,"col":37,"offset":10}},{"file":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":641,"col":27,"offset":0},"end":{"line":641,"col":31,"offset":4}},{"file":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":645,"col":27,"offset":0},"end":{"line":645,"col":31,"offset":4}},{"file":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":703,"col":27,"offset":0},"end":{"line":703,"col":31,"offset":4}},{"file":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":708,"col":25,"offset":0},"end":{"line":708,"col":29,"offset":4}},{"file":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":725,"col":27,"offset":0},"end":{"line":725,"col":31,"offset":4}},{"file":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":761,"col":27,"offset":0},"end":{"line":761,"col":31,"offset":4}},{"file":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":769,"col":27,"offset":0},"end":{"line":769,"col":31,"offset":4}},{"file":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":812,"col":25,"offset":0},"end":{"line":812,"col":29,"offset":4}},{"file":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":834,"col":25,"offset":0},"end":{"line":834,"col":29,"offset":4}},{"file":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":852,"col":27,"offset":0},"end":{"line":852,"col":31,"offset":4}},{"file":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":911,"col":27,"offset":0},"end":{"line":911,"col":31,"offset":4}},{"file":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":916,"col":25,"offset":0},"end":{"line":916,"col":29,"offset":4}},{"file":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":1157,"col":35,"offset":0},"end":{"line":1157,"col":39,"offset":4}},{"file":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":1166,"col":35,"offset":0},"end":{"line":1166,"col":39,"offset":4}},{"file":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":1227,"col":31,"offset":0},"end":{"line":1227,"col":35,"offset":4}},{"file":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":1266,"col":31,"offset":0},"end":{"line":1266,"col":35,"offset":4}},{"file":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":1279,"col":27,"offset":0},"end":{"line":1279,"col":31,"offset":4}},{"file":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":1401,"col":70,"offset":0},"end":{"line":1401,"col":76,"offset":6}},{"file":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":1430,"col":31,"offset":0},"end":{"line":1430,"col":41,"offset":10}},{"file":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":1440,"col":33,"offset":0},"end":{"line":1440,"col":43,"offset":10}},{"file":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":1447,"col":23,"offset":0},"end":{"line":1447,"col":33,"offset":10}},{"file":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":1473,"col":29,"offset":0},"end":{"line":1473,"col":33,"offset":4}},{"file":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":1479,"col":29,"offset":0},"end":{"line":1479,"col":33,"offset":4}},{"file":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":1771,"col":29,"offset":0},"end":{"line":1771,"col":44,"offset":15}},{"file":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":1775,"col":29,"offset":0},"end":{"line":1775,"col":44,"offset":15}},{"file":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":1785,"col":31,"offset":0},"end":{"line":1785,"col":37,"offset":6}},{"file":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":1788,"col":33,"offset":0},"end":{"line":1788,"col":39,"offset":6}},{"file":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":1859,"col":29,"offset":0},"end":{"line":1859,"col":33,"offset":4}},{"file":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":1865,"col":27,"offset":0},"end":{"line":1865,"col":31,"offset":4}},{"file":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":1873,"col":27,"offset":0},"end":{"line":1873,"col":31,"offset":4}},{"file":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":1894,"col":27,"offset":0},"end":{"line":1894,"col":31,"offset":4}},{"file":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":1903,"col":25,"offset":0},"end":{"line":1903,"col":29,"offset":4}},{"file":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":1919,"col":29,"offset":0},"end":{"line":1919,"col":35,"offset":6}},{"file":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":1925,"col":29,"offset":0},"end":{"line":1925,"col":35,"offset":6}},{"file":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":1964,"col":29,"offset":0},"end":{"line":1964,"col":33,"offset":4}},{"file":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":1982,"col":29,"offset":0},"end":{"line":1982,"col":33,"offset":4}},{"file":"/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","start":{"line":2012,"col":25,"offset":0},"end":{"line":2012,"col":29,"offset":4}}]},{"code":3,"level":"warn","type":"Syntax error","message":"Syntax error at line /home/qqq/curl-8.7.0/lib/ftp.c:1:\n `/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n * SPDX-License-Identifier: curl\n *\n ***************************************************************************/\n\n#include \"curl_setup.h\"\n\n#ifndef CURL_DISABLE_FTP\n\n#ifdef HAVE_NETINET_IN_H\n#include <netinet/in.h>\n#endif\n#ifdef HAVE_ARPA_INET_H\n#include <arpa/inet.h>\n#endif\n#ifdef HAVE_NETDB_H\n#include <netdb.h>\n#endif\n#ifdef __VMS\n#include <in.h>\n#include <inet.h>\n#endif\n\n#include <curl/curl.h>\n#include \"urldata.h\"\n#include \"sendf.h\"\n#include \"if2ip.h\"\n#include \"hostip.h\"\n#include \"progress.h\"\n#include \"transfer.h\"\n#include \"escape.h\"\n#include \"http.h\" /* for HTTP proxy tunnel stuff */\n#include \"ftp.h\"\n#include \"fileinfo.h\"\n#include \"ftplistparser.h\"\n#include \"curl_range.h\"\n#include \"curl_krb5.h\"\n#include \"strtoofft.h\"\n#include \"strcase.h\"\n#include \"vtls/vtls.h\"\n#include \"cfilters.h\"\n#include \"cf-socket.h\"\n#include \"connect.h\"\n#include \"strerror.h\"\n#include \"inet_ntop.h\"\n#include \"inet_pton.h\"\n#include \"select.h\"\n#include \"parsedate.h\" /* for the week day and month names */\n#include \"sockaddr.h\" /* required for Curl_sockaddr_storage */\n#include \"multiif.h\"\n#include \"url.h\"\n#include \"speedcheck.h\"\n#include \"warnless.h\"\n#include \"http_proxy.h\"\n#include \"socks.h\"\n#include \"strdup.h\"\n/* The last 3 #include files should be in this order */\n#include \"curl_printf.h\"\n#include \"curl_memory.h\"\n#include \"memdebug.h\"\n\n#ifndef NI_MAXHOST\n#define NI_MAXHOST 1025\n#endif\n#ifndef INET_ADDRSTRLEN\n#define INET_ADDRSTRLEN 16\n#endif\n\n/* macro to check for a three-digit ftp status code at the start of the\n   given string */\n#define STATUSCODE(line) (ISDIGIT(line[0]) && ISDIGIT(line[1]) &&       \\\n                          ISDIGIT(line[2]))\n\n/* macro to check for the last line in an FTP server response */\n#define LASTLINE(line) (STATUSCODE(line) && (' ' == line[3]))\n\n#ifdef CURL_DISABLE_VERBOSE_STRINGS\n#define ftp_pasv_verbose(a,b,c,d)  Curl_nop_stmt\n#endif\n\n/* Local API functions */\n#ifndef DEBUGBUILD\nstatic void _ftp_state(struct Curl_easy *data,\n                       ftpstate newstate);\n#define ftp_state(x,y) _ftp_state(x,y)\n#else\nstatic void _ftp_state(struct Curl_easy *data,\n                       ftpstate newstate,\n                       int lineno);\n#define ftp_state(x,y) _ftp_state(x,y,__LINE__)\n#endif\n\nstatic CURLcode ftp_sendquote(struct Curl_easy *data,\n                              struct connectdata *conn,\n                              struct curl_slist *quote);\nstatic CURLcode ftp_quit(struct Curl_easy *data, struct connectdata *conn);\nstatic CURLcode ftp_parse_url_path(struct Curl_easy *data);\nstatic CURLcode ftp_regular_transfer(struct Curl_easy *data, bool *done);\n#ifndef CURL_DISABLE_VERBOSE_STRINGS\nstatic void ftp_pasv_verbose(struct Curl_easy *data,\n                             struct Curl_addrinfo *ai,\n                             char *newhost, /* ascii version */\n                             int port);\n#endif\nstatic CURLcode ftp_state_prepare_transfer(struct Curl_easy *data);\nstatic CURLcode ftp_state_mdtm(struct Curl_easy *data);\nstatic CURLcode ftp_state_quote(struct Curl_easy *data,\n                                bool init, ftpstate instate);\nstatic CURLcode ftp_nb_type(struct Curl_easy *data,\n                            struct connectdata *conn,\n                            bool ascii, ftpstate newstate);\nstatic int ftp_need_type(struct connectdata *conn,\n                         bool ascii);\nstatic CURLcode ftp_do(struct Curl_easy *data, bool *done);\nstatic CURLcode ftp_done(struct Curl_easy *data,\n                         CURLcode, bool premature);\nstatic CURLcode ftp_connect(struct Curl_easy *data, bool *done);\nstatic CURLcode ftp_disconnect(struct Curl_easy *data,\n                               struct connectdata *conn, bool dead_connection);\nstatic CURLcode ftp_do_more(struct Curl_easy *data, int *completed);\nstatic CURLcode ftp_multi_statemach(struct Curl_easy *data, bool *done);\nstatic int ftp_getsock(struct Curl_easy *data, struct connectdata *conn,\n                       curl_socket_t *socks);\nstatic int ftp_domore_getsock(struct Curl_easy *data,\n                              struct connectdata *conn, curl_socket_t *socks);\nstatic CURLcode ftp_doing(struct Curl_easy *data,\n                          bool *dophase_done);\nstatic CURLcode ftp_setup_connection(struct Curl_easy *data,\n                                     struct connectdata *conn);\nstatic CURLcode init_wc_data(struct Curl_easy *data);\nstatic CURLcode wc_statemach(struct Curl_easy *data);\nstatic void wc_data_dtor(void *ptr);\nstatic CURLcode ftp_state_retr(struct Curl_easy *data, curl_off_t filesize);\nstatic CURLcode ftp_readresp(struct Curl_easy *data,\n                             int sockindex,\n                             struct pingpong *pp,\n                             int *ftpcode,\n                             size_t *size);\nstatic CURLcode ftp_dophase_done(struct Curl_easy *data,\n                                 bool connected);\n\n/*\n * FTP protocol handler.\n */\n\nconst struct Curl_handler Curl_handler_ftp = {\n  \"FTP\",                           /* scheme */\n  ftp_setup_connection,            /* setup_connection */\n  ftp_do,                          /* do_it */\n  ftp_done,                        /* done */\n  ftp_do_more,                     /* do_more */\n  ftp_connect,                     /* connect_it */\n  ftp_multi_statemach,             /* connecting */\n  ftp_doing,                       /* doing */\n  ftp_getsock,                     /* proto_getsock */\n  ftp_getsock,                     /* doing_getsock */\n  ftp_domore_getsock,              /* domore_getsock */\n  ZERO_NULL,                       /* perform_getsock */\n  ftp_disconnect,                  /* disconnect */\n  ZERO_NULL,                       /* write_resp */\n  ZERO_NULL,                       /* connection_check */\n  ZERO_NULL,                       /* attach connection */\n  PORT_FTP,                        /* defport */\n  CURLPROTO_FTP,                   /* protocol */\n  CURLPROTO_FTP,                   /* family */\n  PROTOPT_DUAL | PROTOPT_CLOSEACTION | PROTOPT_NEEDSPWD |\n  PROTOPT_NOURLQUERY | PROTOPT_PROXY_AS_HTTP |\n  PROTOPT_WILDCARD /* flags */\n};\n\n\n#ifdef USE_SSL\n/*\n * FTPS protocol handler.\n */\n\nconst struct Curl_handler Curl_handler_ftps = {\n  \"FTPS\",                          /* scheme */\n  ftp_setup_connection,            /* setup_connection */\n  ftp_do,                          /* do_it */\n  ftp_done,                        /* done */\n  ftp_do_more,                     /* do_more */\n  ftp_connect,                     /* connect_it */\n  ftp_multi_statemach,             /* connecting */\n  ftp_doing,                       /* doing */\n  ftp_getsock,                     /* proto_getsock */\n  ftp_getsock,                     /* doing_getsock */\n  ftp_domore_getsock,              /* domore_getsock */\n  ZERO_NULL,                       /* perform_getsock */\n  ftp_disconnect,                  /* disconnect */\n  ZERO_NULL,                       /* write_resp */\n  ZERO_NULL,                       /* connection_check */\n  ZERO_NULL,                       /* attach connection */\n  PORT_FTPS,                       /* defport */\n  CURLPROTO_FTPS,                  /* protocol */\n  CURLPROTO_FTP,                   /* family */\n  PROTOPT_SSL | PROTOPT_DUAL | PROTOPT_CLOSEACTION |\n  PROTOPT_NEEDSPWD | PROTOPT_NOURLQUERY | PROTOPT_WILDCARD /* flags */\n};\n#endif\n\nstatic void close_secondarysocket(struct Curl_easy *data,\n                                  struct connectdata *conn)\n{\n  Curl_conn_close(data, SECONDARYSOCKET);\n  Curl_conn_cf_discard_all(data, conn, SECONDARYSOCKET);\n}\n\n/*\n * NOTE: back in the old days, we added code in the FTP code that made NOBODY\n * requests on files respond with headers passed to the client/stdout that\n * looked like HTTP ones.\n *\n * This approach is not very elegant, it causes confusion and is error-prone.\n * It is subject for removal at the next (or at least a future) soname bump.\n * Until then you can test the effects of the removal by undefining the\n * following define named CURL_FTP_HTTPSTYLE_HEAD.\n */\n#define CURL_FTP_HTTPSTYLE_HEAD 1\n\nstatic void freedirs(struct ftp_conn *ftpc)\n{\n  if(ftpc->dirs) {\n    int i;\n    for(i = 0; i < ftpc->dirdepth; i++) {\n      free(ftpc->dirs[i]);\n      ftpc->dirs[i] = NULL;\n    }\n    free(ftpc->dirs);\n    ftpc->dirs = NULL;\n    ftpc->dirdepth = 0;\n  }\n  Curl_safefree(ftpc->file);\n\n  /* no longer of any use */\n  Curl_safefree(ftpc->newhost);\n}\n\n#ifdef CURL_DO_LINEEND_CONV\n/***********************************************************************\n *\n * Lineend Conversions\n * On ASCII transfers, e.g. directory listings, we might get lines\n * ending in '\\r\\n' and we prefer just '\\n'.\n * We might also get a lonely '\\r' which we convert into a '\\n'.\n */\nstruct ftp_cw_lc_ctx {\n  struct Curl_cwriter super;\n  bool newline_pending;\n};\n\nstatic CURLcode ftp_cw_lc_write(struct Curl_easy *data,\n                                struct Curl_cwriter *writer, int type,\n                                const char *buf, size_t blen)\n{\n  static const char nl = '\\n';\n  struct ftp_cw_lc_ctx *ctx = writer->ctx;\n\n  if(!(type & CLIENTWRITE_BODY) ||\n     data->conn->proto.ftpc.transfertype != 'A')\n    return Curl_cwriter_write(data, writer->next, type, buf, blen);\n\n  /* ASCII mode BODY data, convert lineends */\n  while(blen) {\n    /* do not pass EOS when writing parts */\n    int chunk_type = (type & ~CLIENTWRITE_EOS);\n    const char *cp;\n    size_t chunk_len;\n    CURLcode result;\n\n    if(ctx->newline_pending) {\n      if(buf[0] != '\\n') {\n        /* previous chunk ended in '\\r' and we do not see a '\\n' in this one,\n         * need to write a newline. */\n        result = Curl_cwriter_write(data, writer->next, chunk_type, &nl, 1);\n        if(result)\n          return result;\n      }\n      /* either we just wrote the newline or it is part of the next\n       * chunk of bytes we write. */\n      data->state.crlf_conversions++;\n      ctx->newline_pending = FALSE;\n    }\n\n    cp = memchr(buf, '\\r', blen);\n    if(!cp)\n      break;\n\n    /* write the bytes before the '\\r', excluding the '\\r' */\n    chunk_len = cp - buf;\n    if(chunk_len) {\n      result = Curl_cwriter_write(data, writer->next, chunk_type,\n                                  buf, chunk_len);\n      if(result)\n        return result;\n    }\n    /* skip the '\\r', we now have a newline pending */\n    buf = cp + 1;\n    blen = blen - chunk_len - 1;\n    ctx->newline_pending = TRUE;\n  }\n\n  /* Any remaining data does not contain a '\\r' */\n  if(blen) {\n    DEBUGASSERT(!ctx->newline_pending);\n    return Curl_cwriter_write(data, writer->next, type, buf, blen);\n  }\n  else if(type & CLIENTWRITE_EOS) {\n    /* EndOfStream, if we have a trailing cr, now is the time to write it */\n    if(ctx->newline_pending) {\n      ctx->newline_pending = FALSE;\n      data->state.crlf_conversions++;\n      return Curl_cwriter_write(data, writer->next, type, &nl, 1);\n    }\n    /* Always pass on the EOS type indicator */\n    return Curl_cwriter_write(data, writer->next, type, buf, 0);\n  }\n  return CURLE_OK;\n}\n\nstatic const struct Curl_cwtype ftp_cw_lc = {\n  \"ftp-lineconv\",\n  NULL,\n  Curl_cwriter_def_init,\n  ftp_cw_lc_write,\n  Curl_cwriter_def_close,\n  sizeof(struct ftp_cw_lc_ctx)\n};\n\n#endif /* CURL_DO_LINEEND_CONV */\n/***********************************************************************\n *\n * AcceptServerConnect()\n *\n * After connection request is received from the server this function is\n * called to accept the connection and close the listening socket\n *\n */\nstatic CURLcode AcceptServerConnect(struct Curl_easy *data)\n{\n  struct connectdata *conn = data->conn;\n  curl_socket_t sock = conn->sock[SECONDARYSOCKET];\n  curl_socket_t s = CURL_SOCKET_BAD;\n#ifdef ENABLE_IPV6\n  struct Curl_sockaddr_storage add;\n#else\n  struct sockaddr_in add;\n#endif\n  curl_socklen_t size = (curl_socklen_t) sizeof(add);\n  CURLcode result;\n\n  if(0 == getsockname(sock, (struct sockaddr *) &add, &size)) {\n    size = sizeof(add);\n\n    s = accept(sock, (struct sockaddr *) &add, &size);\n  }\n\n  if(CURL_SOCKET_BAD == s) {\n    failf(data, \"Error accept()ing server connect\");\n    return CURLE_FTP_PORT_FAILED;\n  }\n  infof(data, \"Connection accepted from server\");\n  /* when this happens within the DO state it is important that we mark us as\n     not needing DO_MORE anymore */\n  conn->bits.do_more = FALSE;\n\n  (void)curlx_nonblock(s, TRUE); /* enable non-blocking */\n  /* Replace any filter on SECONDARY with one listening on this socket */\n  result = Curl_conn_tcp_accepted_set(data, conn, SECONDARYSOCKET, &s);\n  if(result)\n    return result;\n\n  if(data->set.fsockopt) {\n    int error = 0;\n\n    /* activate callback for setting socket options */\n    Curl_set_in_callback(data, true);\n    error = data->set.fsockopt(data->set.sockopt_client,\n                               s,\n                               CURLSOCKTYPE_ACCEPT);\n    Curl_set_in_callback(data, false);\n\n    if(error) {\n      close_secondarysocket(data, conn);\n      return CURLE_ABORTED_BY_CALLBACK;\n    }\n  }\n\n  return CURLE_OK;\n\n}\n\n/*\n * ftp_timeleft_accept() returns the amount of milliseconds left allowed for\n * waiting server to connect. If the value is negative, the timeout time has\n * already elapsed.\n *\n * The start time is stored in progress.t_acceptdata - as set with\n * Curl_pgrsTime(..., TIMER_STARTACCEPT);\n *\n */\nstatic timediff_t ftp_timeleft_accept(struct Curl_easy *data)\n{\n  timediff_t timeout_ms = DEFAULT_ACCEPT_TIMEOUT;\n  timediff_t other;\n  struct curltime now;\n\n  if(data->set.accepttimeout > 0)\n    timeout_ms = data->set.accepttimeout;\n\n  now = Curl_now();\n\n  /* check if the generic timeout possibly is set shorter */\n  other = Curl_timeleft(data, &now, FALSE);\n  if(other && (other < timeout_ms))\n    /* note that this also works fine for when other happens to be negative\n       due to it already having elapsed */\n    timeout_ms = other;\n  else {\n    /* subtract elapsed time */\n    timeout_ms -= Curl_timediff(now, data->progress.t_acceptdata);\n    if(!timeout_ms)\n      /* avoid returning 0 as that means no timeout! */\n      return -1;\n  }\n\n  return timeout_ms;\n}\n\n\n/***********************************************************************\n *\n * ReceivedServerConnect()\n *\n * After allowing server to connect to us from data port, this function\n * checks both data connection for connection establishment and ctrl\n * connection for a negative response regarding a failure in connecting\n *\n */\nstatic CURLcode ReceivedServerConnect(struct Curl_easy *data, bool *received)\n{\n  struct connectdata *conn = data->conn;\n  curl_socket_t ctrl_sock = conn->sock[FIRSTSOCKET];\n  curl_socket_t data_sock = conn->sock[SECONDARYSOCKET];\n  struct ftp_conn *ftpc = &conn->proto.ftpc;\n  struct pingpong *pp = &ftpc->pp;\n  int socketstate = 0;\n  timediff_t timeout_ms;\n  ssize_t nread;\n  int ftpcode;\n  bool response = FALSE;\n\n  *received = FALSE;\n\n  timeout_ms = ftp_timeleft_accept(data);\n  infof(data, \"Checking for server connect\");\n  if(timeout_ms < 0) {\n    /* if a timeout was already reached, bail out */\n    failf(data, \"Accept timeout occurred while waiting server connect\");\n    return CURLE_FTP_ACCEPT_TIMEOUT;\n  }\n\n  /* First check whether there is a cached response from server */\n  if(Curl_dyn_len(&pp->recvbuf) && (*Curl_dyn_ptr(&pp->recvbuf) > '3')) {\n    /* Data connection could not be established, let's return */\n    infof(data, \"There is negative response in cache while serv connect\");\n    (void)Curl_GetFTPResponse(data, &nread, &ftpcode);\n    return CURLE_FTP_ACCEPT_FAILED;\n  }\n\n  if(pp->overflow)\n    /* there is pending control data still in the buffer to read */\n    response = TRUE;\n  else\n    socketstate = Curl_socket_check(ctrl_sock, data_sock, CURL_SOCKET_BAD, 0);\n\n  /* see if the connection request is already here */\n  switch(socketstate) {\n  case -1: /* error */\n    /* let's die here */\n    failf(data, \"Error while waiting for server connect\");\n    return CURLE_FTP_ACCEPT_FAILED;\n  case 0:  /* Server connect is not received yet */\n    break; /* loop */\n  default:\n    if(socketstate & CURL_CSELECT_IN2) {\n      infof(data, \"Ready to accept data connection from server\");\n      *received = TRUE;\n    }\n    else if(socketstate & CURL_CSELECT_IN)\n      response = TRUE;\n    break;\n  }\n  if(response) {\n    infof(data, \"Ctrl conn has data while waiting for data conn\");\n    if(pp->overflow > 3) {\n      char *r = Curl_dyn_ptr(&pp->recvbuf);\n\n      DEBUGASSERT((pp->overflow + pp->nfinal) <=\n                  Curl_dyn_len(&pp->recvbuf));\n      /* move over the most recently handled response line */\n      r += pp->nfinal;\n\n      if(LASTLINE(r)) {\n        int status = curlx_sltosi(strtol(r, NULL, 10));\n        if(status == 226) {\n          /* funny timing situation where we get the final message on the\n             control connection before traffic on the data connection has been\n             noticed. Leave the 226 in there and use this as a trigger to read\n             the data socket. */\n          infof(data, \"Got 226 before data activity\");\n          *received = TRUE;\n          return CURLE_OK;\n        }\n      }\n    }\n\n    (void)Curl_GetFTPResponse(data, &nread, &ftpcode);\n\n    infof(data, \"FTP code: %03d\", ftpcode);\n\n    if(ftpcode/100 > 3)\n      return CURLE_FTP_ACCEPT_FAILED;\n\n    return CURLE_WEIRD_SERVER_REPLY;\n  }\n\n  return CURLE_OK;\n}\n\n\n/***********************************************************************\n *\n * InitiateTransfer()\n *\n * After connection from server is accepted this function is called to\n * setup transfer parameters and initiate the data transfer.\n *\n */\nstatic CURLcode InitiateTransfer(struct Curl_easy *data)\n{\n  CURLcode result = CURLE_OK;\n  struct connectdata *conn = data->conn;\n  bool connected;\n\n  DEBUGF(infof(data, \"ftp InitiateTransfer()\"));\n  if(conn->bits.ftp_use_data_ssl && data->set.ftp_use_port &&\n     !Curl_conn_is_ssl(conn, SECONDARYSOCKET)) {\n    result = Curl_ssl_cfilter_add(data, conn, SECONDARYSOCKET);\n    if(result)\n      return result;\n  }\n  result = Curl_conn_connect(data, SECONDARYSOCKET, TRUE, &connected);\n  if(result || !connected)\n    return result;\n\n  if(conn->proto.ftpc.state_saved == FTP_STOR) {\n    /* When we know we're uploading a specified file, we can get the file\n       size prior to the actual upload. */\n    Curl_pgrsSetUploadSize(data, data->state.infilesize);\n\n    /* set the SO_SNDBUF for the secondary socket for those who need it */\n    Curl_sndbufset(conn->sock[SECONDARYSOCKET]);\n\n    Curl_xfer_setup(data, -1, -1, FALSE, SECONDARYSOCKET);\n  }\n  else {\n    /* FTP download: */\n    Curl_xfer_setup(data, SECONDARYSOCKET,\n                    conn->proto.ftpc.retr_size_saved, FALSE, -1);\n  }\n\n  conn->proto.ftpc.pp.pending_resp = TRUE; /* expect server response */\n  ftp_state(data, FTP_STOP);\n\n  return CURLE_OK;\n}\n\n/***********************************************************************\n *\n * AllowServerConnect()\n *\n * When we've issue the PORT command, we have told the server to connect to\n * us. This function checks whether data connection is established if so it is\n * accepted.\n *\n */\nstatic CURLcode AllowServerConnect(struct Curl_easy *data, bool *connected)\n{\n  timediff_t timeout_ms;\n  CURLcode result = CURLE_OK;\n\n  *connected = FALSE;\n  infof(data, \"Preparing for accepting server on data port\");\n\n  /* Save the time we start accepting server connect */\n  Curl_pgrsTime(data, TIMER_STARTACCEPT);\n\n  timeout_ms = ftp_timeleft_accept(data);\n  if(timeout_ms < 0) {\n    /* if a timeout was already reached, bail out */\n    failf(data, \"Accept timeout occurred while waiting server connect\");\n    result = CURLE_FTP_ACCEPT_TIMEOUT;\n    goto out;\n  }\n\n  /* see if the connection request is already here */\n  result = ReceivedServerConnect(data, connected);\n  if(result)\n    goto out;\n\n  if(*connected) {\n    result = AcceptServerConnect(data);\n    if(result)\n      goto out;\n\n    result = InitiateTransfer(data);\n    if(result)\n      goto out;\n  }\n  else {\n    /* Add timeout to multi handle and break out of the loop */\n    Curl_expire(data, data->set.accepttimeout ?\n                data->set.accepttimeout: DEFAULT_ACCEPT_TIMEOUT,\n                EXPIRE_FTP_ACCEPT);\n  }\n\nout:\n  DEBUGF(infof(data, \"ftp AllowServerConnect() -> %d\", result));\n  return result;\n}\n\nstatic bool ftp_endofresp(struct Curl_easy *data, struct connectdata *conn,\n                          char *line, size_t len, int *code)\n{\n  (void)data;\n  (void)conn;\n\n  if((len > 3) && LASTLINE(line)) {\n    *code = curlx_sltosi(strtol(line, NULL, 10));\n    return TRUE;\n  }\n\n  return FALSE;\n}\n\nstatic CURLcode ftp_readresp(struct Curl_easy *data,\n                             int sockindex,\n                             struct pingpong *pp,\n                             int *ftpcode, /* return the ftp-code if done */\n                             size_t *size) /* size of the response */\n{\n  int code;\n  CURLcode result = Curl_pp_readresp(data, sockindex, pp, &code, size);\n\n#ifdef HAVE_GSSAPI\n  {\n    struct connectdata *conn = data->conn;\n    char * const buf = Curl_dyn_ptr(&data->conn->proto.ftpc.pp.recvbuf);\n\n    /* handle the security-oriented responses 6xx ***/\n    switch(code) {\n    case 631:\n      code = Curl_sec_read_msg(data, conn, buf, PROT_SAFE);\n      break;\n    case 632:\n      code = Curl_sec_read_msg(data, conn, buf, PROT_PRIVATE);\n      break;\n    case 633:\n      code = Curl_sec_read_msg(data, conn, buf, PROT_CONFIDENTIAL);\n      break;\n    default:\n      /* normal ftp stuff we pass through! */\n      break;\n    }\n  }\n#endif\n\n  /* store the latest code for later retrieval */\n  data->info.httpcode = code;\n\n  if(ftpcode)\n    *ftpcode = code;\n\n  if(421 == code) {\n    /* 421 means \"Service not available, closing control connection.\" and FTP\n     * servers use it to signal that idle session timeout has been exceeded.\n     * If we ignored the response, it could end up hanging in some cases.\n     *\n     * This response code can come at any point so having it treated\n     * generically is a good idea.\n     */\n    infof(data, \"We got a 421 - timeout\");\n    ftp_state(data, FTP_STOP);\n    return CURLE_OPERATION_TIMEDOUT;\n  }\n\n  return result;\n}\n\n/* --- parse FTP server responses --- */\n\n/*\n * Curl_GetFTPResponse() is a BLOCKING function to read the full response\n * from a server after a command.\n *\n */\n\nCURLcode Curl_GetFTPResponse(struct Curl_easy *data,\n                             ssize_t *nreadp, /* return number of bytes read */\n                             int *ftpcode) /* return the ftp-code */\n{\n  /*\n   * We cannot read just one byte per read() and then go back to select() as\n   * the OpenSSL read() doesn't grok that properly.\n   *\n   * Alas, read as much as possible, split up into lines, use the ending\n   * line in a response or continue reading.  */\n\n  struct connectdata *conn = data->conn;\n  curl_socket_t sockfd = conn->sock[FIRSTSOCKET];\n  CURLcode result = CURLE_OK;\n  struct ftp_conn *ftpc = &conn->proto.ftpc;\n  struct pingpong *pp = &ftpc->pp;\n  size_t nread;\n  int cache_skip = 0;\n  int value_to_be_ignored = 0;\n\n  if(ftpcode)\n    *ftpcode = 0; /* 0 for errors */\n  else\n    /* make the pointer point to something for the rest of this function */\n    ftpcode = &value_to_be_ignored;\n\n  *nreadp = 0;\n\n  while(!*ftpcode && !result) {\n    /* check and reset timeout value every lap */\n    timediff_t timeout = Curl_pp_state_timeout(data, pp, FALSE);\n    timediff_t interval_ms;\n\n    if(timeout <= 0) {\n      failf(data, \"FTP response timeout\");\n      return CURLE_OPERATION_TIMEDOUT; /* already too little time */\n    }\n\n    interval_ms = 1000;  /* use 1 second timeout intervals */\n    if(timeout < interval_ms)\n      interval_ms = timeout;\n\n    /*\n     * Since this function is blocking, we need to wait here for input on the\n     * connection and only then we call the response reading function. We do\n     * timeout at least every second to make the timeout check run.\n     *\n     * A caution here is that the ftp_readresp() function has a cache that may\n     * contain pieces of a response from the previous invoke and we need to\n     * make sure we don't just wait for input while there is unhandled data in\n     * that cache. But also, if the cache is there, we call ftp_readresp() and\n     * the cache wasn't good enough to continue we must not just busy-loop\n     * around this function.\n     *\n     */\n\n    if(Curl_dyn_len(&pp->recvbuf) && (cache_skip < 2)) {\n      /*\n       * There's a cache left since before. We then skipping the wait for\n       * socket action, unless this is the same cache like the previous round\n       * as then the cache was deemed not enough to act on and we then need to\n       * wait for more data anyway.\n       */\n    }\n    else if(!Curl_conn_data_pending(data, FIRSTSOCKET)) {\n      switch(SOCKET_READABLE(sockfd, interval_ms)) {\n      case -1: /* select() error, stop reading */\n        failf(data, \"FTP response aborted due to select/poll error: %d\",\n              SOCKERRNO);\n        return CURLE_RECV_ERROR;\n\n      case 0: /* timeout */\n        if(Curl_pgrsUpdate(data))\n          return CURLE_ABORTED_BY_CALLBACK;\n        continue; /* just continue in our loop for the timeout duration */\n\n      default: /* for clarity */\n        break;\n      }\n    }\n    result = ftp_readresp(data, FIRSTSOCKET, pp, ftpcode, &nread);\n    if(result)\n      break;\n\n    if(!nread && Curl_dyn_len(&pp->recvbuf))\n      /* bump cache skip counter as on repeated skips we must wait for more\n         data */\n      cache_skip++;\n    else\n      /* when we got data or there is no cache left, we reset the cache skip\n         counter */\n      cache_skip = 0;\n\n    *nreadp += nread;\n\n  } /* while there's buffer left and loop is requested */\n\n  pp->pending_resp = FALSE;\n\n  return result;\n}\n\n#if defined(DEBUGBUILD) && !defined(CURL_DISABLE_VERBOSE_STRINGS)\n  /* for debug purposes */\nstatic const char * const ftp_state_names[]={\n  \"STOP\",\n  \"WAIT220\",\n  \"AUTH\",\n  \"USER\",\n  \"PASS\",\n  \"ACCT\",\n  \"PBSZ\",\n  \"PROT\",\n  \"CCC\",\n  \"PWD\",\n  \"SYST\",\n  \"NAMEFMT\",\n  \"QUOTE\",\n  \"RETR_PREQUOTE\",\n  \"STOR_PREQUOTE\",\n  \"POSTQUOTE\",\n  \"CWD\",\n  \"MKD\",\n  \"MDTM\",\n  \"TYPE\",\n  \"LIST_TYPE\",\n  \"RETR_TYPE\",\n  \"STOR_TYPE\",\n  \"SIZE\",\n  \"RETR_SIZE\",\n  \"STOR_SIZE\",\n  \"REST\",\n  \"RETR_REST\",\n  \"PORT\",\n  \"PRET\",\n  \"PASV\",\n  \"LIST\",\n  \"RETR\",\n  \"STOR\",\n  \"QUIT\"\n};\n#endif\n\n/* This is the ONLY way to change FTP state! */\nstatic void _ftp_state(struct Curl_easy *data,\n                       ftpstate newstate\n#ifdef DEBUGBUILD\n                       , int lineno\n#endif\n  )\n{\n  struct connectdata *conn = data->conn;\n  struct ftp_conn *ftpc = &conn->proto.ftpc;\n\n#if defined(DEBUGBUILD)\n\n#if defined(CURL_DISABLE_VERBOSE_STRINGS)\n  (void) lineno;\n#else\n  if(ftpc->state != newstate)\n    infof(data, \"FTP %p (line %d) state change from %s to %s\",\n          (void *)ftpc, lineno, ftp_state_names[ftpc->state],\n          ftp_state_names[newstate]);\n#endif\n#endif\n\n  ftpc->state = newstate;\n}\n\nstatic CURLcode ftp_state_user(struct Curl_easy *data,\n                               struct connectdata *conn)\n{\n  CURLcode result = Curl_pp_sendf(data,\n                                  &conn->proto.ftpc.pp, \"USER %s\",\n                                  conn->user?conn->user:\"\");\n  if(!result) {\n    struct ftp_conn *ftpc = &conn->proto.ftpc;\n    ftpc->ftp_trying_alternative = FALSE;\n    ftp_state(data, FTP_USER);\n  }\n  return result;\n}\n\nstatic CURLcode ftp_state_pwd(struct Curl_easy *data,\n                              struct connectdata *conn)\n{\n  CURLcode result = Curl_pp_sendf(data, &conn->proto.ftpc.pp, \"%s\", \"PWD\");\n  if(!result)\n    ftp_state(data, FTP_PWD);\n\n  return result;\n}\n\n/* For the FTP \"protocol connect\" and \"doing\" phases only */\nstatic int ftp_getsock(struct Curl_easy *data,\n                       struct connectdata *conn,\n                       curl_socket_t *socks)\n{\n  return Curl_pp_getsock(data, &conn->proto.ftpc.pp, socks);\n}\n\n/* For the FTP \"DO_MORE\" phase only */\nstatic int ftp_domore_getsock(struct Curl_easy *data,\n                              struct connectdata *conn, curl_socket_t *socks)\n{\n  struct ftp_conn *ftpc = &conn->proto.ftpc;\n  (void)data;\n\n  /* When in DO_MORE state, we could be either waiting for us to connect to a\n   * remote site, or we could wait for that site to connect to us. Or just\n   * handle ordinary commands.\n   */\n  DEBUGF(infof(data, \"ftp_domore_getsock()\"));\n\n  if(FTP_STOP == ftpc->state) {\n    /* if stopped and still in this state, then we're also waiting for a\n       connect on the secondary connection */\n    DEBUGASSERT(conn->sock[SECONDARYSOCKET] != CURL_SOCKET_BAD ||\n               (conn->cfilter[SECONDARYSOCKET] &&\n                !Curl_conn_is_connected(conn, SECONDARYSOCKET)));\n    socks[0] = conn->sock[FIRSTSOCKET];\n    /* An unconnected SECONDARY will add its socket by itself\n     * via its adjust_pollset() */\n    return GETSOCK_READSOCK(0);\n  }\n  return Curl_pp_getsock(data, &conn->proto.ftpc.pp, socks);\n}\n\n/* This is called after the FTP_QUOTE state is passed.\n\n   ftp_state_cwd() sends the range of CWD commands to the server to change to\n   the correct directory. It may also need to send MKD commands to create\n   missing ones, if that option is enabled.\n*/\nstatic CURLcode ftp_state_cwd(struct Curl_easy *data,\n                              struct connectdata *conn)\n{\n  CURLcode result = CURLE_OK;\n  struct ftp_conn *ftpc = &conn->proto.ftpc;\n\n  if(ftpc->cwddone)\n    /* already done and fine */\n    result = ftp_state_mdtm(data);\n  else {\n    /* FTPFILE_NOCWD with full path: expect ftpc->cwddone! */\n    DEBUGASSERT((data->set.ftp_filemethod != FTPFILE_NOCWD) ||\n                !(ftpc->dirdepth && ftpc->dirs[0][0] == '/'));\n\n    ftpc->count2 = 0; /* count2 counts failed CWDs */\n\n    if(conn->bits.reuse && ftpc->entrypath &&\n       /* no need to go to entrypath when we have an absolute path */\n       !(ftpc->dirdepth && ftpc->dirs[0][0] == '/')) {\n      /* This is a reused connection. Since we change directory to where the\n         transfer is taking place, we must first get back to the original dir\n         where we ended up after login: */\n      ftpc->cwdcount = 0; /* we count this as the first path, then we add one\n                             for all upcoming ones in the ftp->dirs[] array */\n      result = Curl_pp_sendf(data, &ftpc->pp, \"CWD %s\", ftpc->entrypath);\n      if(!result)\n        ftp_state(data, FTP_CWD);\n    }\n    else {\n      if(ftpc->dirdepth) {\n        ftpc->cwdcount = 1;\n        /* issue the first CWD, the rest is sent when the CWD responses are\n           received... */\n        result = Curl_pp_sendf(data, &ftpc->pp, \"CWD %s\",\n                               ftpc->dirs[ftpc->cwdcount -1]);\n        if(!result)\n          ftp_state(data, FTP_CWD);\n      }\n      else {\n        /* No CWD necessary */\n        result = ftp_state_mdtm(data);\n      }\n    }\n  }\n  return result;\n}\n\ntypedef enum {\n  EPRT,\n  PORT,\n  DONE\n} ftpport;\n\nstatic CURLcode ftp_state_use_port(struct Curl_easy *data,\n                                   ftpport fcmd) /* start with this */\n{\n  CURLcode result = CURLE_FTP_PORT_FAILED;\n  struct connectdata *conn = data->conn;\n  struct ftp_conn *ftpc = &conn->proto.ftpc;\n  curl_socket_t portsock = CURL_SOCKET_BAD;\n  char myhost[MAX_IPADR_LEN + 1] = \"\";\n\n  struct Curl_sockaddr_storage ss;\n  struct Curl_addrinfo *res, *ai;\n  curl_socklen_t sslen;\n  char hbuf[NI_MAXHOST];\n  struct sockaddr *sa = (struct sockaddr *)&ss;\n  struct sockaddr_in * const sa4 = (void *)sa;\n#ifdef ENABLE_IPV6\n  struct sockaddr_in6 * const sa6 = (void *)sa;\n#endif\n  static const char mode[][5] = { \"EPRT\", \"PORT\" };\n  enum resolve_t rc;\n  int error;\n  char *host = NULL;\n  char *string_ftpport = data->set.str[STRING_FTPPORT];\n  struct Curl_dns_entry *h = NULL;\n  unsigned short port_min = 0;\n  unsigned short port_max = 0;\n  unsigned short port;\n  bool possibly_non_local = TRUE;\n  char buffer[STRERROR_LEN];\n  char *addr = NULL;\n  size_t addrlen = 0;\n  char ipstr[50];\n\n  /* Step 1, figure out what is requested,\n   * accepted format :\n   * (ipv4|ipv6|domain|interface)?(:port(-range)?)?\n   */\n\n  if(data->set.str[STRING_FTPPORT] &&\n     (strlen(data->set.str[STRING_FTPPORT]) > 1)) {\n    char *ip_end = NULL;\n\n#ifdef ENABLE_IPV6\n    if(*string_ftpport == '[') {\n      /* [ipv6]:port(-range) */\n      char *ip_start = string_ftpport + 1;\n      ip_end = strchr(ip_start, ']');\n      if(ip_end) {\n        addrlen = ip_end - ip_start;\n        addr = ip_start;\n      }\n    }\n    else\n#endif\n      if(*string_ftpport == ':') {\n        /* :port */\n        ip_end = string_ftpport;\n      }\n      else {\n        ip_end = strchr(string_ftpport, ':');\n        addr = string_ftpport;\n        if(ip_end) {\n          /* either ipv6 or (ipv4|domain|interface):port(-range) */\n          addrlen = ip_end - string_ftpport;\n#ifdef ENABLE_IPV6\n          if(Curl_inet_pton(AF_INET6, string_ftpport, &sa6->sin6_addr) == 1) {\n            /* ipv6 */\n            port_min = port_max = 0;\n            ip_end = NULL; /* this got no port ! */\n          }\n#endif\n        }\n        else\n          /* ipv4|interface */\n          addrlen = strlen(string_ftpport);\n      }\n\n    /* parse the port */\n    if(ip_end) {\n      char *port_sep = NULL;\n      char *port_start = strchr(ip_end, ':');\n      if(port_start) {\n        port_min = curlx_ultous(strtoul(port_start + 1, NULL, 10));\n        port_sep = strchr(port_start, '-');\n        if(port_sep) {\n          port_max = curlx_ultous(strtoul(port_sep + 1, NULL, 10));\n        }\n        else\n          port_max = port_min;\n      }\n    }\n\n    /* correct errors like:\n     *  :1234-1230\n     *  :-4711,  in this case port_min is (unsigned)-1,\n     *           therefore port_min > port_max for all cases\n     *           but port_max = (unsigned)-1\n     */\n    if(port_min > port_max)\n      port_min = port_max = 0;\n\n    if(addrlen) {\n      DEBUGASSERT(addr);\n      if(addrlen >= sizeof(ipstr))\n        goto out;\n      memcpy(ipstr, addr, addrlen);\n      ipstr[addrlen] = 0;\n\n      /* attempt to get the address of the given interface name */\n      switch(Curl_if2ip(conn->remote_addr->family,\n#ifdef ENABLE_IPV6\n                        Curl_ipv6_scope(&conn->remote_addr->sa_addr),\n                        conn->scope_id,\n#endif\n                        ipstr, hbuf, sizeof(hbuf))) {\n        case IF2IP_NOT_FOUND:\n          /* not an interface, use the given string as host name instead */\n          host = ipstr;\n          break;\n        case IF2IP_AF_NOT_SUPPORTED:\n          goto out;\n        case IF2IP_FOUND:\n          host = hbuf; /* use the hbuf for host name */\n          break;\n      }\n    }\n    else\n      /* there was only a port(-range) given, default the host */\n      host = NULL;\n  } /* data->set.ftpport */\n\n  if(!host) {\n    const char *r;\n    /* not an interface and not a host name, get default by extracting\n       the IP from the control connection */\n    sslen = sizeof(ss);\n    if(getsockname(conn->sock[FIRSTSOCKET], sa, &sslen)) {\n      failf(data, \"getsockname() failed: %s\",\n            Curl_strerror(SOCKERRNO, buffer, sizeof(buffer)));\n      goto out;\n    }\n    switch(sa->sa_family) {\n#ifdef ENABLE_IPV6\n    case AF_INET6:\n      r = Curl_inet_ntop(sa->sa_family, &sa6->sin6_addr, hbuf, sizeof(hbuf));\n      break;\n#endif\n    default:\n      r = Curl_inet_ntop(sa->sa_family, &sa4->sin_addr, hbuf, sizeof(hbuf));\n      break;\n    }\n    if(!r) {\n      goto out;\n    }\n    host = hbuf; /* use this host name */\n    possibly_non_local = FALSE; /* we know it is local now */\n  }\n\n  /* resolv ip/host to ip */\n  rc = Curl_resolv(data, host, 0, FALSE, &h);\n  if(rc == CURLRESOLV_PENDING)\n    (void)Curl_resolver_wait_resolv(data, &h);\n  if(h) {\n    res = h->addr;\n    /* when we return from this function, we can forget about this entry\n       to we can unlock it now already */\n    Curl_resolv_unlock(data, h);\n  } /* (h) */\n  else\n    res = NULL; /* failure! */\n\n  if(!res) {\n    failf(data, \"failed to resolve the address provided to PORT: %s\", host);\n    goto out;\n  }\n\n  host = NULL;\n\n  /* step 2, create a socket for the requested address */\n  error = 0;\n  for(ai = res; ai; ai = ai->ai_next) {\n    if(Curl_socket_open(data, ai, NULL, conn->transport, &portsock)) {\n      error = SOCKERRNO;\n      continue;\n    }\n    break;\n  }\n  if(!ai) {\n    failf(data, \"socket failure: %s\",\n          Curl_strerror(error, buffer, sizeof(buffer)));\n    goto out;\n  }\n  DEBUGF(infof(data, \"ftp_state_use_port(), opened socket\"));\n\n  /* step 3, bind to a suitable local address */\n\n  memcpy(sa, ai->ai_addr, ai->ai_addrlen);\n  sslen = ai->ai_addrlen;\n\n  for(port = port_min; port <= port_max;) {\n    if(sa->sa_family == AF_INET)\n      sa4->sin_port = htons(port);\n#ifdef ENABLE_IPV6\n    else\n      sa6->sin6_port = htons(port);\n#endif\n    /* Try binding the given address. */\n    if(bind(portsock, sa, sslen) ) {\n      /* It failed. */\n      error = SOCKERRNO;\n      if(possibly_non_local && (error == EADDRNOTAVAIL)) {\n        /* The requested bind address is not local.  Use the address used for\n         * the control connection instead and restart the port loop\n         */\n        infof(data, \"bind(port=%hu) on non-local address failed: %s\", port,\n              Curl_strerror(error, buffer, sizeof(buffer)));\n\n        sslen = sizeof(ss);\n        if(getsockname(conn->sock[FIRSTSOCKET], sa, &sslen)) {\n          failf(data, \"getsockname() failed: %s\",\n                Curl_strerror(SOCKERRNO, buffer, sizeof(buffer)));\n          goto out;\n        }\n        port = port_min;\n        possibly_non_local = FALSE; /* don't try this again */\n        continue;\n      }\n      if(error != EADDRINUSE && error != EACCES) {\n        failf(data, \"bind(port=%hu) failed: %s\", port,\n              Curl_strerror(error, buffer, sizeof(buffer)));\n        goto out;\n      }\n    }\n    else\n      break;\n\n    port++;\n  }\n\n  /* maybe all ports were in use already */\n  if(port > port_max) {\n    failf(data, \"bind() failed, we ran out of ports\");\n    goto out;\n  }\n\n  /* get the name again after the bind() so that we can extract the\n     port number it uses now */\n  sslen = sizeof(ss);\n  if(getsockname(portsock, sa, &sslen)) {\n    failf(data, \"getsockname() failed: %s\",\n          Curl_strerror(SOCKERRNO, buffer, sizeof(buffer)));\n    goto out;\n  }\n  DEBUGF(infof(data, \"ftp_state_use_port(), socket bound to port %d\", port));\n\n  /* step 4, listen on the socket */\n\n  if(listen(portsock, 1)) {\n    failf(data, \"socket failure: %s\",\n          Curl_strerror(SOCKERRNO, buffer, sizeof(buffer)));\n    goto out;\n  }\n  DEBUGF(infof(data, \"ftp_state_use_port(), listening on %d\", port));\n\n  /* step 5, send the proper FTP command */\n\n  /* get a plain printable version of the numerical address to work with\n     below */\n  Curl_printable_address(ai, myhost, sizeof(myhost));\n\n#ifdef ENABLE_IPV6\n  if(!conn->bits.ftp_use_eprt && conn->bits.ipv6)\n    /* EPRT is disabled but we are connected to a IPv6 host, so we ignore the\n       request and enable EPRT again! */\n    conn->bits.ftp_use_eprt = TRUE;\n#endif\n\n  /* Replace any filter on SECONDARY with one listening on this socket */\n  result = Curl_conn_tcp_listen_set(data, conn, SECONDARYSOCKET, &portsock);\n  if(result)\n    goto out;\n  portsock = CURL_SOCKET_BAD; /* now held in filter */\n\n  for(; fcmd != DONE; fcmd++) {\n\n    if(!conn->bits.ftp_use_eprt && (EPRT == fcmd))\n      /* if disabled, goto next */\n      continue;\n\n    if((PORT == fcmd) && sa->sa_family != AF_INET)\n      /* PORT is IPv4 only */\n      continue;\n\n    switch(sa->sa_family) {\n    case AF_INET:\n      port = ntohs(sa4->sin_port);\n      break;\n#ifdef ENABLE_IPV6\n    case AF_INET6:\n      port = ntohs(sa6->sin6_port);\n      break;\n#endif\n    default:\n      continue; /* might as well skip this */\n    }\n\n    if(EPRT == fcmd) {\n      /*\n       * Two fine examples from RFC2428;\n       *\n       * EPRT |1|132.235.1.2|6275|\n       *\n       * EPRT |2|1080::8:800:200C:417A|5282|\n       */\n\n      result = Curl_pp_sendf(data, &ftpc->pp, \"%s |%d|%s|%hu|\", mode[fcmd],\n                             sa->sa_family == AF_INET?1:2,\n                             myhost, port);\n      if(result) {\n        failf(data, \"Failure sending EPRT command: %s\",\n              curl_easy_strerror(result));\n        goto out;\n      }\n      break;\n    }\n    if(PORT == fcmd) {\n      /* large enough for [IP address],[num],[num] */\n      char target[sizeof(myhost) + 20];\n      char *source = myhost;\n      char *dest = target;\n\n      /* translate x.x.x.x to x,x,x,x */\n      while(source && *source) {\n        if(*source == '.')\n          *dest = ',';\n        else\n          *dest = *source;\n        dest++;\n        source++;\n      }\n      *dest = 0;\n      msnprintf(dest, 20, \",%d,%d\", (int)(port>>8), (int)(port&0xff));\n\n      result = Curl_pp_sendf(data, &ftpc->pp, \"%s %s\", mode[fcmd], target);\n      if(result) {\n        failf(data, \"Failure sending PORT command: %s\",\n              curl_easy_strerror(result));\n        goto out;\n      }\n      break;\n    }\n  }\n\n  /* store which command was sent */\n  ftpc->count1 = fcmd;\n\n  ftp_state(data, FTP_PORT);\n\nout:\n  if(result) {\n    ftp_state(data, FTP_STOP);\n  }\n  if(portsock != CURL_SOCKET_BAD)\n    Curl_socket_close(data, conn, portsock);\n  return result;\n}\n\nstatic CURLcode ftp_state_use_pasv(struct Curl_easy *data,\n                                   struct connectdata *conn)\n{\n  struct ftp_conn *ftpc = &conn->proto.ftpc;\n  CURLcode result = CURLE_OK;\n  /*\n    Here's the executive summary on what to do:\n\n    PASV is RFC959, expect:\n    227 Entering Passive Mode (a1,a2,a3,a4,p1,p2)\n\n    LPSV is RFC1639, expect:\n    228 Entering Long Passive Mode (4,4,a1,a2,a3,a4,2,p1,p2)\n\n    EPSV is RFC2428, expect:\n    229 Entering Extended Passive Mode (|||port|)\n\n  */\n\n  static const char mode[][5] = { \"EPSV\", \"PASV\" };\n  int modeoff;\n\n#ifdef PF_INET6\n  if(!conn->bits.ftp_use_epsv && conn->bits.ipv6)\n    /* EPSV is disabled but we are connected to a IPv6 host, so we ignore the\n       request and enable EPSV again! */\n    conn->bits.ftp_use_epsv = TRUE;\n#endif\n\n  modeoff = conn->bits.ftp_use_epsv?0:1;\n\n  result = Curl_pp_sendf(data, &ftpc->pp, \"%s\", mode[modeoff]);\n  if(!result) {\n    ftpc->count1 = modeoff;\n    ftp_state(data, FTP_PASV);\n    infof(data, \"Connect data stream passively\");\n  }\n  return result;\n}\n\n/*\n * ftp_state_prepare_transfer() starts PORT, PASV or PRET etc.\n *\n * REST is the last command in the chain of commands when a \"head\"-like\n * request is made. Thus, if an actual transfer is to be made this is where we\n * take off for real.\n */\nstatic CURLcode ftp_state_prepare_transfer(struct Curl_easy *data)\n{\n  CURLcode result = CURLE_OK;\n  struct FTP *ftp = data->req.p.ftp;\n  struct connectdata *conn = data->conn;\n\n  if(ftp->transfer != PPTRANSFER_BODY) {\n    /* doesn't transfer any data */\n\n    /* still possibly do PRE QUOTE jobs */\n    ftp_state(data, FTP_RETR_PREQUOTE);\n    result = ftp_state_quote(data, TRUE, FTP_RETR_PREQUOTE);\n  }\n  else if(data->set.ftp_use_port) {\n    /* We have chosen to use the PORT (or similar) command */\n    result = ftp_state_use_port(data, EPRT);\n  }\n  else {\n    /* We have chosen (this is default) to use the PASV (or similar) command */\n    if(data->set.ftp_use_pret) {\n      /* The user has requested that we send a PRET command\n         to prepare the server for the upcoming PASV */\n      struct ftp_conn *ftpc = &conn->proto.ftpc;\n      if(!conn->proto.ftpc.file)\n        result = Curl_pp_sendf(data, &ftpc->pp, \"PRET %s\",\n                               data->set.str[STRING_CUSTOMREQUEST]?\n                               data->set.str[STRING_CUSTOMREQUEST]:\n                               (data->state.list_only?\"NLST\":\"LIST\"));\n      else if(data->state.upload)\n        result = Curl_pp_sendf(data, &ftpc->pp, \"PRET STOR %s\",\n                               conn->proto.ftpc.file);\n      else\n        result = Curl_pp_sendf(data, &ftpc->pp, \"PRET RETR %s\",\n                               conn->proto.ftpc.file);\n      if(!result)\n        ftp_state(data, FTP_PRET);\n    }\n    else\n      result = ftp_state_use_pasv(data, conn);\n  }\n  return result;\n}\n\nstatic CURLcode ftp_state_rest(struct Curl_easy *data,\n                               struct connectdata *conn)\n{\n  CURLcode result = CURLE_OK;\n  struct FTP *ftp = data->req.p.ftp;\n  struct ftp_conn *ftpc = &conn->proto.ftpc;\n\n  if((ftp->transfer != PPTRANSFER_BODY) && ftpc->file) {\n    /* if a \"head\"-like request is being made (on a file) */\n\n    /* Determine if server can respond to REST command and therefore\n       whether it supports range */\n    result = Curl_pp_sendf(data, &ftpc->pp, \"REST %d\", 0);\n    if(!result)\n      ftp_state(data, FTP_REST);\n  }\n  else\n    result = ftp_state_prepare_transfer(data);\n\n  return result;\n}\n\nstatic CURLcode ftp_state_size(struct Curl_easy *data,\n                               struct connectdata *conn)\n{\n  CURLcode result = CURLE_OK;\n  struct FTP *ftp = data->req.p.ftp;\n  struct ftp_conn *ftpc = &conn->proto.ftpc;\n\n  if((ftp->transfer == PPTRANSFER_INFO) && ftpc->file) {\n    /* if a \"head\"-like request is being made (on a file) */\n\n    /* we know ftpc->file is a valid pointer to a file name */\n    result = Curl_pp_sendf(data, &ftpc->pp, \"SIZE %s\", ftpc->file);\n    if(!result)\n      ftp_state(data, FTP_SIZE);\n  }\n  else\n    result = ftp_state_rest(data, conn);\n\n  return result;\n}\n\nstatic CURLcode ftp_state_list(struct Curl_easy *data)\n{\n  CURLcode result = CURLE_OK;\n  struct FTP *ftp = data->req.p.ftp;\n  struct connectdata *conn = data->conn;\n\n  /* If this output is to be machine-parsed, the NLST command might be better\n     to use, since the LIST command output is not specified or standard in any\n     way. It has turned out that the NLST list output is not the same on all\n     servers either... */\n\n  /*\n     if FTPFILE_NOCWD was specified, we should add the path\n     as argument for the LIST / NLST / or custom command.\n     Whether the server will support this, is uncertain.\n\n     The other ftp_filemethods will CWD into dir/dir/ first and\n     then just do LIST (in that case: nothing to do here)\n  */\n  char *lstArg = NULL;\n  char *cmd;\n\n  if((data->set.ftp_filemethod == FTPFILE_NOCWD) && ftp->path) {\n    /* url-decode before evaluation: e.g. paths starting/ending with %2f */\n    const char *slashPos = NULL;\n    char *rawPath = NULL;\n    result = Curl_urldecode(ftp->path, 0, &rawPath, NULL, REJECT_CTRL);\n    if(result)\n      return result;\n\n    slashPos = strrchr(rawPath, '/');\n    if(slashPos) {\n      /* chop off the file part if format is dir/file otherwise remove\n         the trailing slash for dir/dir/ except for absolute path / */\n      size_t n = slashPos - rawPath;\n      if(n == 0)\n        ++n;\n\n      lstArg = rawPath;\n      lstArg[n] = '\\0';\n    }\n    else\n      free(rawPath);\n  }\n\n  cmd = aprintf(\"%s%s%s\",\n                data->set.str[STRING_CUSTOMREQUEST]?\n                data->set.str[STRING_CUSTOMREQUEST]:\n                (data->state.list_only?\"NLST\":\"LIST\"),\n                lstArg? \" \": \"\",\n                lstArg? lstArg: \"\");\n  free(lstArg);\n\n  if(!cmd)\n    return CURLE_OUT_OF_MEMORY;\n\n  result = Curl_pp_sendf(data, &conn->proto.ftpc.pp, \"%s\", cmd);\n  free(cmd);\n\n  if(!result)\n    ftp_state(data, FTP_LIST);\n\n  return result;\n}\n\nstatic CURLcode ftp_state_retr_prequote(struct Curl_easy *data)\n{\n  /* We've sent the TYPE, now we must send the list of prequote strings */\n  return ftp_state_quote(data, TRUE, FTP_RETR_PREQUOTE);\n}\n\nstatic CURLcode ftp_state_stor_prequote(struct Curl_easy *data)\n{\n  /* We've sent the TYPE, now we must send the list of prequote strings */\n  return ftp_state_quote(data, TRUE, FTP_STOR_PREQUOTE);\n}\n\nstatic CURLcode ftp_state_type(struct Curl_easy *data)\n{\n  CURLcode result = CURLE_OK;\n  struct FTP *ftp = data->req.p.ftp;\n  struct connectdata *conn = data->conn;\n  struct ftp_conn *ftpc = &conn->proto.ftpc;\n\n  /* If we have selected NOBODY and HEADER, it means that we only want file\n     information. Which in FTP can't be much more than the file size and\n     date. */\n  if(data->req.no_body && ftpc->file &&\n     ftp_need_type(conn, data->state.prefer_ascii)) {\n    /* The SIZE command is _not_ RFC 959 specified, and therefore many servers\n       may not support it! It is however the only way we have to get a file's\n       size! */\n\n    ftp->transfer = PPTRANSFER_INFO;\n    /* this means no actual transfer will be made */\n\n    /* Some servers return different sizes for different modes, and thus we\n       must set the proper type before we check the size */\n    result = ftp_nb_type(data, conn, data->state.prefer_ascii, FTP_TYPE);\n    if(result)\n      return result;\n  }\n  else\n    result = ftp_state_size(data, conn);\n\n  return result;\n}\n\n/* This is called after the CWD commands have been done in the beginning of\n   the DO phase */\nstatic CURLcode ftp_state_mdtm(struct Curl_easy *data)\n{\n  CURLcode result = CURLE_OK;\n  struct connectdata *conn = data->conn;\n  struct ftp_conn *ftpc = &conn->proto.ftpc;\n\n  /* Requested time of file or time-depended transfer? */\n  if((data->set.get_filetime || data->set.timecondition) && ftpc->file) {\n\n    /* we have requested to get the modified-time of the file, this is a white\n       spot as the MDTM is not mentioned in RFC959 */\n    result = Curl_pp_sendf(data, &ftpc->pp, \"MDTM %s\", ftpc->file);\n\n    if(!result)\n      ftp_state(data, FTP_MDTM);\n  }\n  else\n    result = ftp_state_type(data);\n\n  return result;\n}\n\n\n/* This is called after the TYPE and possible quote commands have been sent */\nstatic CURLcode ftp_state_ul_setup(struct Curl_easy *data,\n                                   bool sizechecked)\n{\n  CURLcode result = CURLE_OK;\n  struct connectdata *conn = data->conn;\n  struct FTP *ftp = data->req.p.ftp;\n  struct ftp_conn *ftpc = &conn->proto.ftpc;\n  bool append = data->set.remote_append;\n\n  if((data->state.resume_from && !sizechecked) ||\n     ((data->state.resume_from > 0) && sizechecked)) {\n    /* we're about to continue the uploading of a file */\n    /* 1. get already existing file's size. We use the SIZE command for this\n       which may not exist in the server!  The SIZE command is not in\n       RFC959. */\n\n    /* 2. This used to set REST. But since we can do append, we\n       don't another ftp command. We just skip the source file\n       offset and then we APPEND the rest on the file instead */\n\n    /* 3. pass file-size number of bytes in the source file */\n    /* 4. lower the infilesize counter */\n    /* => transfer as usual */\n    int seekerr = CURL_SEEKFUNC_OK;\n\n    if(data->state.resume_from < 0) {\n      /* Got no given size to start from, figure it out */\n      result = Curl_pp_sendf(data, &ftpc->pp, \"SIZE %s\", ftpc->file);\n      if(!result)\n        ftp_state(data, FTP_STOR_SIZE);\n      return result;\n    }\n\n    /* enable append */\n    append = TRUE;\n\n    /* Let's read off the proper amount of bytes from the input. */\n    if(data->set.seek_func) {\n      Curl_set_in_callback(data, true);\n      seekerr = data->set.seek_func(data->set.seek_client,\n                                    data->state.resume_from, SEEK_SET);\n      Curl_set_in_callback(data, false);\n    }\n\n    if(seekerr != CURL_SEEKFUNC_OK) {\n      curl_off_t passed = 0;\n      if(seekerr != CURL_SEEKFUNC_CANTSEEK) {\n        failf(data, \"Could not seek stream\");\n        return CURLE_FTP_COULDNT_USE_REST;\n      }\n      /* seekerr == CURL_SEEKFUNC_CANTSEEK (can't seek to offset) */\n      do {\n        char scratch[4*1024];\n        size_t readthisamountnow =\n          (data->state.resume_from - passed > (curl_off_t)sizeof(scratch)) ?\n          sizeof(scratch) :\n          curlx_sotouz(data->state.resume_from - passed);\n\n        size_t actuallyread =\n          data->state.fread_func(scratch, 1, readthisamountnow,\n                                 data->state.in);\n\n        passed += actuallyread;\n        if((actuallyread == 0) || (actuallyread > readthisamountnow)) {\n          /* this checks for greater-than only to make sure that the\n             CURL_READFUNC_ABORT return code still aborts */\n          failf(data, \"Failed to read data\");\n          return CURLE_FTP_COULDNT_USE_REST;\n        }\n      } while(passed < data->state.resume_from);\n    }\n    /* now, decrease the size of the read */\n    if(data->state.infilesize>0) {\n      data->state.infilesize -= data->state.resume_from;\n\n      if(data->state.infilesize <= 0) {\n        infof(data, \"File already completely uploaded\");\n\n        /* no data to transfer */\n        Curl_xfer_setup(data, -1, -1, FALSE, -1);\n\n        /* Set ->transfer so that we won't get any error in\n         * ftp_done() because we didn't transfer anything! */\n        ftp->transfer = PPTRANSFER_NONE;\n\n        ftp_state(data, FTP_STOP);\n        return CURLE_OK;\n      }\n    }\n    /* we've passed, proceed as normal */\n  } /* resume_from */\n\n  result = Curl_pp_sendf(data, &ftpc->pp, append?\"APPE %s\":\"STOR %s\",\n                         ftpc->file);\n  if(!result)\n    ftp_state(data, FTP_STOR);\n\n  return result;\n}\n\nstatic CURLcode ftp_state_quote(struct Curl_easy *data,\n                                bool init,\n                                ftpstate instate)\n{\n  CURLcode result = CURLE_OK;\n  struct FTP *ftp = data->req.p.ftp;\n  struct connectdata *conn = data->conn;\n  struct ftp_conn *ftpc = &conn->proto.ftpc;\n  bool quote = FALSE;\n  struct curl_slist *item;\n\n  switch(instate) {\n  case FTP_QUOTE:\n  default:\n    item = data->set.quote;\n    break;\n  case FTP_RETR_PREQUOTE:\n  case FTP_STOR_PREQUOTE:\n    item = data->set.prequote;\n    break;\n  case FTP_POSTQUOTE:\n    item = data->set.postquote;\n    break;\n  }\n\n  /*\n   * This state uses:\n   * 'count1' to iterate over the commands to send\n   * 'count2' to store whether to allow commands to fail\n   */\n\n  if(init)\n    ftpc->count1 = 0;\n  else\n    ftpc->count1++;\n\n  if(item) {\n    int i = 0;\n\n    /* Skip count1 items in the linked list */\n    while((i< ftpc->count1) && item) {\n      item = item->next;\n      i++;\n    }\n    if(item) {\n      char *cmd = item->data;\n      if(cmd[0] == '*') {\n        cmd++;\n        ftpc->count2 = 1; /* the sent command is allowed to fail */\n      }\n      else\n        ftpc->count2 = 0; /* failure means cancel operation */\n\n      result = Curl_pp_sendf(data, &ftpc->pp, \"%s\", cmd);\n      if(result)\n        return result;\n      ftp_state(data, instate);\n      quote = TRUE;\n    }\n  }\n\n  if(!quote) {\n    /* No more quote to send, continue to ... */\n    switch(instate) {\n    case FTP_QUOTE:\n    default:\n      result = ftp_state_cwd(data, conn);\n      break;\n    case FTP_RETR_PREQUOTE:\n      if(ftp->transfer != PPTRANSFER_BODY)\n        ftp_state(data, FTP_STOP);\n      else {\n        if(ftpc->known_filesize != -1) {\n          Curl_pgrsSetDownloadSize(data, ftpc->known_filesize);\n          result = ftp_state_retr(data, ftpc->known_filesize);\n        }\n        else {\n          if(data->set.ignorecl || data->state.prefer_ascii) {\n            /* 'ignorecl' is used to support download of growing files.  It\n               prevents the state machine from requesting the file size from\n               the server.  With an unknown file size the download continues\n               until the server terminates it, otherwise the client stops if\n               the received byte count exceeds the reported file size.  Set\n               option CURLOPT_IGNORE_CONTENT_LENGTH to 1 to enable this\n               behavior.\n\n               In addition: asking for the size for 'TYPE A' transfers is not\n               constructive since servers don't report the converted size. So\n               skip it.\n            */\n            result = Curl_pp_sendf(data, &ftpc->pp, \"RETR %s\", ftpc->file);\n            if(!result)\n              ftp_state(data, FTP_RETR);\n          }\n          else {\n            result = Curl_pp_sendf(data, &ftpc->pp, \"SIZE %s\", ftpc->file);\n            if(!result)\n              ftp_state(data, FTP_RETR_SIZE);\n          }\n        }\n      }\n      break;\n    case FTP_STOR_PREQUOTE:\n      result = ftp_state_ul_setup(data, FALSE);\n      break;\n    case FTP_POSTQUOTE:\n      break;\n    }\n  }\n\n  return result;\n}\n\n/* called from ftp_state_pasv_resp to switch to PASV in case of EPSV\n   problems */\nstatic CURLcode ftp_epsv_disable(struct Curl_easy *data,\n                                 struct connectdata *conn)\n{\n  CURLcode result = CURLE_OK;\n\n  if(conn->bits.ipv6\n#ifndef CURL_DISABLE_PROXY\n     && !(conn->bits.tunnel_proxy || conn->bits.socksproxy)\n#endif\n    ) {\n    /* We can't disable EPSV when doing IPv6, so this is instead a fail */\n    failf(data, \"Failed EPSV attempt, exiting\");\n    return CURLE_WEIRD_SERVER_REPLY;\n  }\n\n  infof(data, \"Failed EPSV attempt. Disabling EPSV\");\n  /* disable it for next transfer */\n  conn->bits.ftp_use_epsv = FALSE;\n  Curl_conn_close(data, SECONDARYSOCKET);\n  Curl_conn_cf_discard_all(data, conn, SECONDARYSOCKET);\n  data->state.errorbuf = FALSE; /* allow error message to get\n                                         rewritten */\n  result = Curl_pp_sendf(data, &conn->proto.ftpc.pp, \"%s\", \"PASV\");\n  if(!result) {\n    conn->proto.ftpc.count1++;\n    /* remain in/go to the FTP_PASV state */\n    ftp_state(data, FTP_PASV);\n  }\n  return result;\n}\n\n\nstatic char *control_address(struct connectdata *conn)\n{\n  /* Returns the control connection IP address.\n     If a proxy tunnel is used, returns the original host name instead, because\n     the effective control connection address is the proxy address,\n     not the ftp host. */\n#ifndef CURL_DISABLE_PROXY\n  if(conn->bits.tunnel_proxy || conn->bits.socksproxy)\n    return conn->host.name;\n#endif\n  return conn->primary.remote_ip;\n}\n\nstatic bool match_pasv_6nums(const char *p,\n                             unsigned int *array) /* 6 numbers */\n{\n  int i;\n  for(i = 0; i < 6; i++) {\n    unsigned long num;\n    char *endp;\n    if(i) {\n      if(*p != ',')\n        return FALSE;\n      p++;\n    }\n    if(!ISDIGIT(*p))\n      return FALSE;\n    num = strtoul(p, &endp, 10);\n    if(num > 255)\n      return FALSE;\n    array[i] = (unsigned int)num;\n    p = endp;\n  }\n  return TRUE;\n}\n\nstatic CURLcode ftp_state_pasv_resp(struct Curl_easy *data,\n                                    int ftpcode)\n{\n  struct connectdata *conn = data->conn;\n  struct ftp_conn *ftpc = &conn->proto.ftpc;\n  CURLcode result;\n  struct Curl_dns_entry *addr = NULL;\n  enum resolve_t rc;\n  unsigned short connectport; /* the local port connect() should use! */\n  struct pingpong *pp = &ftpc->pp;\n  char *str =\n    Curl_dyn_ptr(&pp->recvbuf) + 4; /* start on the first letter */\n\n  /* if we come here again, make sure the former name is cleared */\n  Curl_safefree(ftpc->newhost);\n\n  if((ftpc->count1 == 0) &&\n     (ftpcode == 229)) {\n    /* positive EPSV response */\n    char *ptr = strchr(str, '(');\n    if(ptr) {\n      char sep;\n      ptr++;\n      /* |||12345| */\n      sep = ptr[0];\n      /* the ISDIGIT() check here is because strtoul() accepts leading minus\n         etc */\n      if((ptr[1] == sep) && (ptr[2] == sep) && ISDIGIT(ptr[3])) {\n        char *endp;\n        unsigned long num = strtoul(&ptr[3], &endp, 10);\n        if(*endp != sep)\n          ptr = NULL;\n        else if(num > 0xffff) {\n          failf(data, \"Illegal port number in EPSV reply\");\n          return CURLE_FTP_WEIRD_PASV_REPLY;\n        }\n        if(ptr) {\n          ftpc->newport = (unsigned short)(num & 0xffff);\n          ftpc->newhost = strdup(control_address(conn));\n          if(!ftpc->newhost)\n            return CURLE_OUT_OF_MEMORY;\n        }\n      }\n      else\n        ptr = NULL;\n    }\n    if(!ptr) {\n      failf(data, \"Weirdly formatted EPSV reply\");\n      return CURLE_FTP_WEIRD_PASV_REPLY;\n    }\n  }\n  else if((ftpc->count1 == 1) &&\n          (ftpcode == 227)) {\n    /* positive PASV response */\n    unsigned int ip[6];\n\n    /*\n     * Scan for a sequence of six comma-separated numbers and use them as\n     * IP+port indicators.\n     *\n     * Found reply-strings include:\n     * \"227 Entering Passive Mode (127,0,0,1,4,51)\"\n     * \"227 Data transfer will passively listen to 127,0,0,1,4,51\"\n     * \"227 Entering passive mode. 127,0,0,1,4,51\"\n     */\n    while(*str) {\n      if(match_pasv_6nums(str, ip))\n        break;\n      str++;\n    }\n\n    if(!*str) {\n      failf(data, \"Couldn't interpret the 227-response\");\n      return CURLE_FTP_WEIRD_227_FORMAT;\n    }\n\n    /* we got OK from server */\n    if(data->set.ftp_skip_ip) {\n      /* told to ignore the remotely given IP but instead use the host we used\n         for the control connection */\n      infof(data, \"Skip %u.%u.%u.%u for data connection, reuse %s instead\",\n            ip[0], ip[1], ip[2], ip[3],\n            conn->host.name);\n      ftpc->newhost = strdup(control_address(conn));\n    }\n    else\n      ftpc->newhost = aprintf(\"%u.%u.%u.%u\", ip[0], ip[1], ip[2], ip[3]);\n\n    if(!ftpc->newhost)\n      return CURLE_OUT_OF_MEMORY;\n\n    ftpc->newport = (unsigned short)(((ip[4]<<8) + ip[5]) & 0xffff);\n  }\n  else if(ftpc->count1 == 0) {\n    /* EPSV failed, move on to PASV */\n    return ftp_epsv_disable(data, conn);\n  }\n  else {\n    failf(data, \"Bad PASV/EPSV response: %03d\", ftpcode);\n    return CURLE_FTP_WEIRD_PASV_REPLY;\n  }\n\n#ifndef CURL_DISABLE_PROXY\n  if(conn->bits.proxy) {\n    /*\n     * This connection uses a proxy and we need to connect to the proxy again\n     * here. We don't want to rely on a former host lookup that might've\n     * expired now, instead we remake the lookup here and now!\n     */\n    const char * const host_name = conn->bits.socksproxy ?\n      conn->socks_proxy.host.name : conn->http_proxy.host.name;\n    rc = Curl_resolv(data, host_name, conn->primary.remote_port, FALSE, &addr);\n    if(rc == CURLRESOLV_PENDING)\n      /* BLOCKING, ignores the return code but 'addr' will be NULL in\n         case of failure */\n      (void)Curl_resolver_wait_resolv(data, &addr);\n\n    /* we connect to the proxy's port */\n    connectport = (unsigned short)conn->primary.remote_port;\n\n    if(!addr) {\n      failf(data, \"Can't resolve proxy host %s:%hu\", host_name, connectport);\n      return CURLE_COULDNT_RESOLVE_PROXY;\n    }\n  }\n  else\n#endif\n  {\n    /* normal, direct, ftp connection */\n    DEBUGASSERT(ftpc->newhost);\n\n    /* postponed address resolution in case of tcp fastopen */\n    if(conn->bits.tcp_fastopen && !conn->bits.reuse && !ftpc->newhost[0]) {\n      Curl_conn_ev_update_info(data, conn);\n      Curl_safefree(ftpc->newhost);\n      ftpc->newhost = strdup(control_address(conn));\n      if(!ftpc->newhost)\n        return CURLE_OUT_OF_MEMORY;\n    }\n\n    rc = Curl_resolv(data, ftpc->newhost, ftpc->newport, FALSE, &addr);\n    if(rc == CURLRESOLV_PENDING)\n      /* BLOCKING */\n      (void)Curl_resolver_wait_resolv(data, &addr);\n\n    connectport = ftpc->newport; /* we connect to the remote port */\n\n    if(!addr) {\n      failf(data, \"Can't resolve new host %s:%hu\", ftpc->newhost, connectport);\n      return CURLE_FTP_CANT_GET_HOST;\n    }\n  }\n\n  result = Curl_conn_setup(data, conn, SECONDARYSOCKET, addr,\n                           conn->bits.ftp_use_data_ssl?\n                           CURL_CF_SSL_ENABLE : CURL_CF_SSL_DISABLE);\n\n  if(result) {\n    Curl_resolv_unlock(data, addr); /* we're done using this address */\n    if(ftpc->count1 == 0 && ftpcode == 229)\n      return ftp_epsv_disable(data, conn);\n\n    return result;\n  }\n\n\n  /*\n   * When this is used from the multi interface, this might've returned with\n   * the 'connected' set to FALSE and thus we are now awaiting a non-blocking\n   * connect to connect.\n   */\n\n  if(data->set.verbose)\n    /* this just dumps information about this second connection */\n    ftp_pasv_verbose(data, addr->addr, ftpc->newhost, connectport);\n\n  Curl_resolv_unlock(data, addr); /* we're done using this address */\n\n  Curl_safefree(conn->secondaryhostname);\n  conn->secondary_port = ftpc->newport;\n  conn->secondaryhostname = strdup(ftpc->newhost);\n  if(!conn->secondaryhostname)\n    return CURLE_OUT_OF_MEMORY;\n\n  conn->bits.do_more = TRUE;\n  ftp_state(data, FTP_STOP); /* this phase is completed */\n\n  return result;\n}\n\nstatic CURLcode ftp_state_port_resp(struct Curl_easy *data,\n                                    int ftpcode)\n{\n  struct connectdata *conn = data->conn;\n  struct ftp_conn *ftpc = &conn->proto.ftpc;\n  ftpport fcmd = (ftpport)ftpc->count1;\n  CURLcode result = CURLE_OK;\n\n  /* The FTP spec tells a positive response should have code 200.\n     Be more permissive here to tolerate deviant servers. */\n  if(ftpcode / 100 != 2) {\n    /* the command failed */\n\n    if(EPRT == fcmd) {\n      infof(data, \"disabling EPRT usage\");\n      conn->bits.ftp_use_eprt = FALSE;\n    }\n    fcmd++;\n\n    if(fcmd == DONE) {\n      failf(data, \"Failed to do PORT\");\n      result = CURLE_FTP_PORT_FAILED;\n    }\n    else\n      /* try next */\n      result = ftp_state_use_port(data, fcmd);\n  }\n  else {\n    infof(data, \"Connect data stream actively\");\n    ftp_state(data, FTP_STOP); /* end of DO phase */\n    result = ftp_dophase_done(data, FALSE);\n  }\n\n  return result;\n}\n\nstatic int twodigit(const char *p)\n{\n  return (p[0]-'0') * 10 + (p[1]-'0');\n}\n\nstatic bool ftp_213_date(const char *p, int *year, int *month, int *day,\n                         int *hour, int *minute, int *second)\n{\n  size_t len = strlen(p);\n  if(len < 14)\n    return FALSE;\n  *year = twodigit(&p[0]) * 100 + twodigit(&p[2]);\n  *month = twodigit(&p[4]);\n  *day = twodigit(&p[6]);\n  *hour = twodigit(&p[8]);\n  *minute = twodigit(&p[10]);\n  *second = twodigit(&p[12]);\n\n  if((*month > 12) || (*day > 31) || (*hour > 23) || (*minute > 59) ||\n     (*second > 60))\n    return FALSE;\n  return TRUE;\n}\n\nstatic CURLcode client_write_header(struct Curl_easy *data,\n                                    char *buf, size_t blen)\n{\n  /* Some replies from an FTP server are written to the client\n   * as CLIENTWRITE_HEADER, formatted as if they came from a\n   * HTTP conversation.\n   * In all protocols, CLIENTWRITE_HEADER data is only passed to\n   * the body write callback when data->set.include_header is set\n   * via CURLOPT_HEADER.\n   * For historic reasons, FTP never played this game and expects\n   * all its HEADERs to do that always. Set that flag during the\n   * call to Curl_client_write() so it does the right thing.\n   *\n   * Notice that we cannot enable this flag for FTP in general,\n   * as an FTP transfer might involve a HTTP proxy connection and\n   * headers from CONNECT should not automatically be part of the\n   * output. */\n  CURLcode result;\n  int save = data->set.include_header;\n  data->set.include_header = TRUE;\n  result = Curl_client_write(data, CLIENTWRITE_HEADER, buf, blen);\n  data->set.include_header = save? TRUE:FALSE;\n  return result;\n}\n\nstatic CURLcode ftp_state_mdtm_resp(struct Curl_easy *data,\n                                    int ftpcode)\n{\n  CURLcode result = CURLE_OK;\n  struct FTP *ftp = data->req.p.ftp;\n  struct connectdata *conn = data->conn;\n  struct ftp_conn *ftpc = &conn->proto.ftpc;\n\n  switch(ftpcode) {\n  case 213:\n    {\n      /* we got a time. Format should be: \"YYYYMMDDHHMMSS[.sss]\" where the\n         last .sss part is optional and means fractions of a second */\n      int year, month, day, hour, minute, second;\n      struct pingpong *pp = &ftpc->pp;\n      char *resp = Curl_dyn_ptr(&pp->recvbuf) + 4;\n      if(ftp_213_date(resp, &year, &month, &day, &hour, &minute, &second)) {\n        /* we have a time, reformat it */\n        char timebuf[24];\n        msnprintf(timebuf, sizeof(timebuf),\n                  \"%04d%02d%02d %02d:%02d:%02d GMT\",\n                  year, month, day, hour, minute, second);\n        /* now, convert this into a time() value: */\n        data->info.filetime = Curl_getdate_capped(timebuf);\n      }\n\n#ifdef CURL_FTP_HTTPSTYLE_HEAD\n      /* If we asked for a time of the file and we actually got one as well,\n         we \"emulate\" an HTTP-style header in our output. */\n\n      if(data->req.no_body &&\n         ftpc->file &&\n         data->set.get_filetime &&\n         (data->info.filetime >= 0) ) {\n        char headerbuf[128];\n        int headerbuflen;\n        time_t filetime = data->info.filetime;\n        struct tm buffer;\n        const struct tm *tm = &buffer;\n\n        result = Curl_gmtime(filetime, &buffer);\n        if(result)\n          return result;\n\n        /* format: \"Tue, 15 Nov 1994 12:45:26\" */\n        headerbuflen = msnprintf(headerbuf, sizeof(headerbuf),\n                  \"Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\\r\\n\",\n                  Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],\n                  tm->tm_mday,\n                  Curl_month[tm->tm_mon],\n                  tm->tm_year + 1900,\n                  tm->tm_hour,\n                  tm->tm_min,\n                  tm->tm_sec);\n        result = client_write_header(data, headerbuf, headerbuflen);\n        if(result)\n          return result;\n      } /* end of a ridiculous amount of conditionals */\n#endif\n    }\n    break;\n  default:\n    infof(data, \"unsupported MDTM reply format\");\n    break;\n  case 550: /* 550 is used for several different problems, e.g.\n               \"No such file or directory\" or \"Permission denied\".\n               It does not mean that the file does not exist at all. */\n    infof(data, \"MDTM failed: file does not exist or permission problem,\"\n          \" continuing\");\n    break;\n  }\n\n  if(data->set.timecondition) {\n    if((data->info.filetime > 0) && (data->set.timevalue > 0)) {\n      switch(data->set.timecondition) {\n      case CURL_TIMECOND_IFMODSINCE:\n      default:\n        if(data->info.filetime <= data->set.timevalue) {\n          infof(data, \"The requested document is not new enough\");\n          ftp->transfer = PPTRANSFER_NONE; /* mark to not transfer data */\n          data->info.timecond = TRUE;\n          ftp_state(data, FTP_STOP);\n          return CURLE_OK;\n        }\n        break;\n      case CURL_TIMECOND_IFUNMODSINCE:\n        if(data->info.filetime > data->set.timevalue) {\n          infof(data, \"The requested document is not old enough\");\n          ftp->transfer = PPTRANSFER_NONE; /* mark to not transfer data */\n          data->info.timecond = TRUE;\n          ftp_state(data, FTP_STOP);\n          return CURLE_OK;\n        }\n        break;\n      } /* switch */\n    }\n    else {\n      infof(data, \"Skipping time comparison\");\n    }\n  }\n\n  if(!result)\n    result = ftp_state_type(data);\n\n  return result;\n}\n\nstatic CURLcode ftp_state_type_resp(struct Curl_easy *data,\n                                    int ftpcode,\n                                    ftpstate instate)\n{\n  CURLcode result = CURLE_OK;\n  struct connectdata *conn = data->conn;\n\n  if(ftpcode/100 != 2) {\n    /* \"sasserftpd\" and \"(u)r(x)bot ftpd\" both responds with 226 after a\n       successful 'TYPE I'. While that is not as RFC959 says, it is still a\n       positive response code and we allow that. */\n    failf(data, \"Couldn't set desired mode\");\n    return CURLE_FTP_COULDNT_SET_TYPE;\n  }\n  if(ftpcode != 200)\n    infof(data, \"Got a %03d response code instead of the assumed 200\",\n          ftpcode);\n\n  if(instate == FTP_TYPE)\n    result = ftp_state_size(data, conn);\n  else if(instate == FTP_LIST_TYPE)\n    result = ftp_state_list(data);\n  else if(instate == FTP_RETR_TYPE)\n    result = ftp_state_retr_prequote(data);\n  else if(instate == FTP_STOR_TYPE)\n    result = ftp_state_stor_prequote(data);\n\n  return result;\n}\n\nstatic CURLcode ftp_state_retr(struct Curl_easy *data,\n                               curl_off_t filesize)\n{\n  CURLcode result = CURLE_OK;\n  struct FTP *ftp = data->req.p.ftp;\n  struct connectdata *conn = data->conn;\n  struct ftp_conn *ftpc = &conn->proto.ftpc;\n\n  DEBUGF(infof(data, \"ftp_state_retr()\"));\n  if(data->set.max_filesize && (filesize > data->set.max_filesize)) {\n    failf(data, \"Maximum file size exceeded\");\n    return CURLE_FILESIZE_EXCEEDED;\n  }\n  ftp->downloadsize = filesize;\n\n  if(data->state.resume_from) {\n    /* We always (attempt to) get the size of downloads, so it is done before\n       this even when not doing resumes. */\n    if(filesize == -1) {\n      infof(data, \"ftp server doesn't support SIZE\");\n      /* We couldn't get the size and therefore we can't know if there really\n         is a part of the file left to get, although the server will just\n         close the connection when we start the connection so it won't cause\n         us any harm, just not make us exit as nicely. */\n    }\n    else {\n      /* We got a file size report, so we check that there actually is a\n         part of the file left to get, or else we go home.  */\n      if(data->state.resume_from< 0) {\n        /* We're supposed to download the last abs(from) bytes */\n        if(filesize < -data->state.resume_from) {\n          failf(data, \"Offset (%\" CURL_FORMAT_CURL_OFF_T\n                \") was beyond file size (%\" CURL_FORMAT_CURL_OFF_T \")\",\n                data->state.resume_from, filesize);\n          return CURLE_BAD_DOWNLOAD_RESUME;\n        }\n        /* convert to size to download */\n        ftp->downloadsize = -data->state.resume_from;\n        /* download from where? */\n        data->state.resume_from = filesize - ftp->downloadsize;\n      }\n      else {\n        if(filesize < data->state.resume_from) {\n          failf(data, \"Offset (%\" CURL_FORMAT_CURL_OFF_T\n                \") was beyond file size (%\" CURL_FORMAT_CURL_OFF_T \")\",\n                data->state.resume_from, filesize);\n          return CURLE_BAD_DOWNLOAD_RESUME;\n        }\n        /* Now store the number of bytes we are expected to download */\n        ftp->downloadsize = filesize-data->state.resume_from;\n      }\n    }\n\n    if(ftp->downloadsize == 0) {\n      /* no data to transfer */\n      Curl_xfer_setup(data, -1, -1, FALSE, -1);\n      infof(data, \"File already completely downloaded\");\n\n      /* Set ->transfer so that we won't get any error in ftp_done()\n       * because we didn't transfer the any file */\n      ftp->transfer = PPTRANSFER_NONE;\n      ftp_state(data, FTP_STOP);\n      return CURLE_OK;\n    }\n\n    /* Set resume file transfer offset */\n    infof(data, \"Instructs server to resume from offset %\"\n          CURL_FORMAT_CURL_OFF_T, data->state.resume_from);\n\n    result = Curl_pp_sendf(data, &ftpc->pp, \"REST %\" CURL_FORMAT_CURL_OFF_T,\n                           data->state.resume_from);\n    if(!result)\n      ftp_state(data, FTP_RETR_REST);\n  }\n  else {\n    /* no resume */\n    result = Curl_pp_sendf(data, &ftpc->pp, \"RETR %s\", ftpc->file);\n    if(!result)\n      ftp_state(data, FTP_RETR);\n  }\n\n  return result;\n}\n\nstatic CURLcode ftp_state_size_resp(struct Curl_easy *data,\n                                    int ftpcode,\n                                    ftpstate instate)\n{\n  CURLcode result = CURLE_OK;\n  curl_off_t filesize = -1;\n  char *buf = Curl_dyn_ptr(&data->conn->proto.ftpc.pp.recvbuf);\n  size_t len = data->conn->proto.ftpc.pp.nfinal;\n\n  /* get the size from the ascii string: */\n  if(ftpcode == 213) {\n    /* To allow servers to prepend \"rubbish\" in the response string, we scan\n       for all the digits at the end of the response and parse only those as a\n       number. */\n    char *start = &buf[4];\n    char *fdigit = memchr(start, '\\r', len);\n    if(fdigit) {\n      fdigit--;\n      if(*fdigit == '\\n')\n        fdigit--;\n      while(ISDIGIT(fdigit[-1]) && (fdigit > start))\n        fdigit--;\n    }\n    else\n      fdigit = start;\n    /* ignores parsing errors, which will make the size remain unknown */\n    (void)curlx_strtoofft(fdigit, NULL, 10, &filesize);\n\n  }\n  else if(ftpcode == 550) { /* \"No such file or directory\" */\n    /* allow a SIZE failure for (resumed) uploads, when probing what command\n       to use */\n    if(instate != FTP_STOR_SIZE) {\n      failf(data, \"The file does not exist\");\n      return CURLE_REMOTE_FILE_NOT_FOUND;\n    }\n  }\n\n  if(instate == FTP_SIZE) {\n#ifdef CURL_FTP_HTTPSTYLE_HEAD\n    if(-1 != filesize) {\n      char clbuf[128];\n      int clbuflen = msnprintf(clbuf, sizeof(clbuf),\n                \"Content-Length: %\" CURL_FORMAT_CURL_OFF_T \"\\r\\n\", filesize);\n      result = client_write_header(data, clbuf, clbuflen);\n      if(result)\n        return result;\n    }\n#endif\n    Curl_pgrsSetDownloadSize(data, filesize);\n    result = ftp_state_rest(data, data->conn);\n  }\n  else if(instate == FTP_RETR_SIZE) {\n    Curl_pgrsSetDownloadSize(data, filesize);\n    result = ftp_state_retr(data, filesize);\n  }\n  else if(instate == FTP_STOR_SIZE) {\n    data->state.resume_from = filesize;\n    result = ftp_state_ul_setup(data, TRUE);\n  }\n\n  return result;\n}\n\nstatic CURLcode ftp_state_rest_resp(struct Curl_easy *data,\n                                    struct connectdata *conn,\n                                    int ftpcode,\n                                    ftpstate instate)\n{\n  CURLcode result = CURLE_OK;\n  struct ftp_conn *ftpc = &conn->proto.ftpc;\n\n  switch(instate) {\n  case FTP_REST:\n  default:\n#ifdef CURL_FTP_HTTPSTYLE_HEAD\n    if(ftpcode == 350) {\n      char buffer[24]= { \"Accept-ranges: bytes\\r\\n\" };\n      result = client_write_header(data, buffer, strlen(buffer));\n      if(result)\n        return result;\n    }\n#endif\n    result = ftp_state_prepare_transfer(data);\n    break;\n\n  case FTP_RETR_REST:\n    if(ftpcode != 350) {\n      failf(data, \"Couldn't use REST\");\n      result = CURLE_FTP_COULDNT_USE_REST;\n    }\n    else {\n      result = Curl_pp_sendf(data, &ftpc->pp, \"RETR %s\", ftpc->file);\n      if(!result)\n        ftp_state(data, FTP_RETR);\n    }\n    break;\n  }\n\n  return result;\n}\n\nstatic CURLcode ftp_state_stor_resp(struct Curl_easy *data,\n                                    int ftpcode, ftpstate instate)\n{\n  CURLcode result = CURLE_OK;\n  struct connectdata *conn = data->conn;\n\n  if(ftpcode >= 400) {\n    failf(data, \"Failed FTP upload: %0d\", ftpcode);\n    ftp_state(data, FTP_STOP);\n    /* oops, we never close the sockets! */\n    return CURLE_UPLOAD_FAILED;\n  }\n\n  conn->proto.ftpc.state_saved = instate;\n\n  /* PORT means we are now awaiting the server to connect to us. */\n  if(data->set.ftp_use_port) {\n    bool connected;\n\n    ftp_state(data, FTP_STOP); /* no longer in STOR state */\n\n    result = AllowServerConnect(data, &connected);\n    if(result)\n      return result;\n\n    if(!connected) {\n      struct ftp_conn *ftpc = &conn->proto.ftpc;\n      infof(data, \"Data conn was not available immediately\");\n      ftpc->wait_data_conn = TRUE;\n    }\n\n    return CURLE_OK;\n  }\n  return InitiateTransfer(data);\n}\n\n/* for LIST and RETR responses */\nstatic CURLcode ftp_state_get_resp(struct Curl_easy *data,\n                                   int ftpcode,\n                                   ftpstate instate)\n{\n  CURLcode result = CURLE_OK;\n  struct FTP *ftp = data->req.p.ftp;\n  struct connectdata *conn = data->conn;\n\n  if((ftpcode == 150) || (ftpcode == 125)) {\n\n    /*\n      A;\n      150 Opening BINARY mode data connection for /etc/passwd (2241\n      bytes).  (ok, the file is being transferred)\n\n      B:\n      150 Opening ASCII mode data connection for /bin/ls\n\n      C:\n      150 ASCII data connection for /bin/ls (137.167.104.91,37445) (0 bytes).\n\n      D:\n      150 Opening ASCII mode data connection for [file] (0.0.0.0,0) (545 bytes)\n\n      E:\n      125 Data connection already open; Transfer starting. */\n\n    curl_off_t size = -1; /* default unknown size */\n\n\n    /*\n     * It appears that there are FTP-servers that return size 0 for files when\n     * SIZE is used on the file while being in BINARY mode. To work around\n     * that (stupid) behavior, we attempt to parse the RETR response even if\n     * the SIZE returned size zero.\n     *\n     * Debugging help from Salvatore Sorrentino on February 26, 2003.\n     */\n\n    if((instate != FTP_LIST) &&\n       !data->state.prefer_ascii &&\n       !data->set.ignorecl &&\n       (ftp->downloadsize < 1)) {\n      /*\n       * It seems directory listings either don't show the size or very\n       * often uses size 0 anyway. ASCII transfers may very well turn out\n       * that the transferred amount of data is not the same as this line\n       * tells, why using this number in those cases only confuses us.\n       *\n       * Example D above makes this parsing a little tricky */\n      char *bytes;\n      char *buf = Curl_dyn_ptr(&conn->proto.ftpc.pp.recvbuf);\n      bytes = strstr(buf, \" bytes\");\n      if(bytes) {\n        long in = (long)(--bytes-buf);\n        /* this is a hint there is size information in there! ;-) */\n        while(--in) {\n          /* scan for the left parenthesis and break there */\n          if('(' == *bytes)\n            break;\n          /* skip only digits */\n          if(!ISDIGIT(*bytes)) {\n            bytes = NULL;\n            break;\n          }\n          /* one more estep backwards */\n          bytes--;\n        }\n        /* if we have nothing but digits: */\n        if(bytes) {\n          ++bytes;\n          /* get the number! */\n          (void)curlx_strtoofft(bytes, NULL, 10, &size);\n        }\n      }\n    }\n    else if(ftp->downloadsize > -1)\n      size = ftp->downloadsize;\n\n    if(size > data->req.maxdownload && data->req.maxdownload > 0)\n      size = data->req.size = data->req.maxdownload;\n    else if((instate != FTP_LIST) && (data->state.prefer_ascii))\n      size = -1; /* kludge for servers that understate ASCII mode file size */\n\n    infof(data, \"Maxdownload = %\" CURL_FORMAT_CURL_OFF_T,\n          data->req.maxdownload);\n\n    if(instate != FTP_LIST)\n      infof(data, \"Getting file with size: %\" CURL_FORMAT_CURL_OFF_T,\n            size);\n\n    /* FTP download: */\n    conn->proto.ftpc.state_saved = instate;\n    conn->proto.ftpc.retr_size_saved = size;\n\n    if(data->set.ftp_use_port) {\n      bool connected;\n\n      result = AllowServerConnect(data, &connected);\n      if(result)\n        return result;\n\n      if(!connected) {\n        struct ftp_conn *ftpc = &conn->proto.ftpc;\n        infof(data, \"Data conn was not available immediately\");\n        ftp_state(data, FTP_STOP);\n        ftpc->wait_data_conn = TRUE;\n      }\n    }\n    else\n      return InitiateTransfer(data);\n  }\n  else {\n    if((instate == FTP_LIST) && (ftpcode == 450)) {\n      /* simply no matching files in the dir listing */\n      ftp->transfer = PPTRANSFER_NONE; /* don't download anything */\n      ftp_state(data, FTP_STOP); /* this phase is over */\n    }\n    else {\n      failf(data, \"RETR response: %03d\", ftpcode);\n      return instate == FTP_RETR && ftpcode == 550?\n        CURLE_REMOTE_FILE_NOT_FOUND:\n        CURLE_FTP_COULDNT_RETR_FILE;\n    }\n  }\n\n  return result;\n}\n\n/* after USER, PASS and ACCT */\nstatic CURLcode ftp_state_loggedin(struct Curl_easy *data)\n{\n  CURLcode result = CURLE_OK;\n  struct connectdata *conn = data->conn;\n\n  if(conn->bits.ftp_use_control_ssl) {\n    /* PBSZ = PROTECTION BUFFER SIZE.\n\n    The 'draft-murray-auth-ftp-ssl' (draft 12, page 7) says:\n\n    Specifically, the PROT command MUST be preceded by a PBSZ\n    command and a PBSZ command MUST be preceded by a successful\n    security data exchange (the TLS negotiation in this case)\n\n    ... (and on page 8):\n\n    Thus the PBSZ command must still be issued, but must have a\n    parameter of '0' to indicate that no buffering is taking place\n    and the data connection should not be encapsulated.\n    */\n    result = Curl_pp_sendf(data, &conn->proto.ftpc.pp, \"PBSZ %d\", 0);\n    if(!result)\n      ftp_state(data, FTP_PBSZ);\n  }\n  else {\n    result = ftp_state_pwd(data, conn);\n  }\n  return result;\n}\n\n/* for USER and PASS responses */\nstatic CURLcode ftp_state_user_resp(struct Curl_easy *data,\n                                    int ftpcode)\n{\n  CURLcode result = CURLE_OK;\n  struct connectdata *conn = data->conn;\n  struct ftp_conn *ftpc = &conn->proto.ftpc;\n\n  /* some need password anyway, and others just return 2xx ignored */\n  if((ftpcode == 331) && (ftpc->state == FTP_USER)) {\n    /* 331 Password required for ...\n       (the server requires to send the user's password too) */\n    result = Curl_pp_sendf(data, &ftpc->pp, \"PASS %s\",\n                           conn->passwd?conn->passwd:\"\");\n    if(!result)\n      ftp_state(data, FTP_PASS);\n  }\n  else if(ftpcode/100 == 2) {\n    /* 230 User ... logged in.\n       (the user logged in with or without password) */\n    result = ftp_state_loggedin(data);\n  }\n  else if(ftpcode == 332) {\n    if(data->set.str[STRING_FTP_ACCOUNT]) {\n      result = Curl_pp_sendf(data, &ftpc->pp, \"ACCT %s\",\n                             data->set.str[STRING_FTP_ACCOUNT]);\n      if(!result)\n        ftp_state(data, FTP_ACCT);\n    }\n    else {\n      failf(data, \"ACCT requested but none available\");\n      result = CURLE_LOGIN_DENIED;\n    }\n  }\n  else {\n    /* All other response codes, like:\n\n    530 User ... access denied\n    (the server denies to log the specified user) */\n\n    if(data->set.str[STRING_FTP_ALTERNATIVE_TO_USER] &&\n       !ftpc->ftp_trying_alternative) {\n      /* Ok, USER failed.  Let's try the supplied command. */\n      result =\n        Curl_pp_sendf(data, &ftpc->pp, \"%s\",\n                      data->set.str[STRING_FTP_ALTERNATIVE_TO_USER]);\n      if(!result) {\n        ftpc->ftp_trying_alternative = TRUE;\n        ftp_state(data, FTP_USER);\n      }\n    }\n    else {\n      failf(data, \"Access denied: %03d\", ftpcode);\n      result = CURLE_LOGIN_DENIED;\n    }\n  }\n  return result;\n}\n\n/* for ACCT response */\nstatic CURLcode ftp_state_acct_resp(struct Curl_easy *data,\n                                    int ftpcode)\n{\n  CURLcode result = CURLE_OK;\n  if(ftpcode != 230) {\n    failf(data, \"ACCT rejected by server: %03d\", ftpcode);\n    result = CURLE_FTP_WEIRD_PASS_REPLY; /* FIX */\n  }\n  else\n    result = ftp_state_loggedin(data);\n\n  return result;\n}\n\n\nstatic CURLcode ftp_statemachine(struct Curl_easy *data,\n                                 struct connectdata *conn)\n{\n  CURLcode result;\n  int ftpcode;\n  struct ftp_conn *ftpc = &conn->proto.ftpc;\n  struct pingpong *pp = &ftpc->pp;\n  static const char * const ftpauth[] = { \"SSL\", \"TLS\" };\n  size_t nread = 0;\n\n  if(pp->sendleft)\n    return Curl_pp_flushsend(data, pp);\n\n  result = ftp_readresp(data, FIRSTSOCKET, pp, &ftpcode, &nread);\n  if(result)\n    return result;\n\n  if(ftpcode) {\n    /* we have now received a full FTP server response */\n    switch(ftpc->state) {\n    case FTP_WAIT220:\n      if(ftpcode == 230) {\n        /* 230 User logged in - already! Take as 220 if TLS required. */\n        if(data->set.use_ssl <= CURLUSESSL_TRY ||\n           conn->bits.ftp_use_control_ssl)\n          return ftp_state_user_resp(data, ftpcode);\n      }\n      else if(ftpcode != 220) {\n        failf(data, \"Got a %03d ftp-server response when 220 was expected\",\n              ftpcode);\n        return CURLE_WEIRD_SERVER_REPLY;\n      }\n\n      /* We have received a 220 response fine, now we proceed. */\n#ifdef HAVE_GSSAPI\n      if(data->set.krb) {\n        /* If not anonymous login, try a secure login. Note that this\n           procedure is still BLOCKING. */\n\n        Curl_sec_request_prot(conn, \"private\");\n        /* We set private first as default, in case the line below fails to\n           set a valid level */\n        Curl_sec_request_prot(conn, data->set.str[STRING_KRB_LEVEL]);\n\n        if(Curl_sec_login(data, conn)) {\n          failf(data, \"secure login failed\");\n          return CURLE_WEIRD_SERVER_REPLY;\n        }\n        infof(data, \"Authentication successful\");\n      }\n#endif\n\n      if(data->set.use_ssl && !conn->bits.ftp_use_control_ssl) {\n        /* We don't have a SSL/TLS control connection yet, but FTPS is\n           requested. Try a FTPS connection now */\n\n        ftpc->count3 = 0;\n        switch(data->set.ftpsslauth) {\n        case CURLFTPAUTH_DEFAULT:\n        case CURLFTPAUTH_SSL:\n          ftpc->count2 = 1; /* add one to get next */\n          ftpc->count1 = 0;\n          break;\n        case CURLFTPAUTH_TLS:\n          ftpc->count2 = -1; /* subtract one to get next */\n          ftpc->count1 = 1;\n          break;\n        default:\n          failf(data, \"unsupported parameter to CURLOPT_FTPSSLAUTH: %d\",\n                (int)data->set.ftpsslauth);\n          return CURLE_UNKNOWN_OPTION; /* we don't know what to do */\n        }\n        result = Curl_pp_sendf(data, &ftpc->pp, \"AUTH %s\",\n                               ftpauth[ftpc->count1]);\n        if(!result)\n          ftp_state(data, FTP_AUTH);\n      }\n      else\n        result = ftp_state_user(data, conn);\n      break;\n\n    case FTP_AUTH:\n      /* we have gotten the response to a previous AUTH command */\n\n      if(pp->overflow)\n        return CURLE_WEIRD_SERVER_REPLY; /* Forbid pipelining in response. */\n\n      /* RFC2228 (page 5) says:\n       *\n       * If the server is willing to accept the named security mechanism,\n       * and does not require any security data, it must respond with\n       * reply code 234/334.\n       */\n\n      if((ftpcode == 234) || (ftpcode == 334)) {\n        /* this was BLOCKING, keep it so for now */\n        bool done;\n        if(!Curl_conn_is_ssl(conn, FIRSTSOCKET)) {\n          result = Curl_ssl_cfilter_add(data, conn, FIRSTSOCKET);\n          if(result) {\n            /* we failed and bail out */\n            return CURLE_USE_SSL_FAILED;\n          }\n        }\n        result = Curl_conn_connect(data, FIRSTSOCKET, TRUE, &done);\n        if(!result) {\n          conn->bits.ftp_use_data_ssl = FALSE; /* clear-text data */\n          conn->bits.ftp_use_control_ssl = TRUE; /* SSL on control */\n          result = ftp_state_user(data, conn);\n        }\n      }\n      else if(ftpc->count3 < 1) {\n        ftpc->count3++;\n        ftpc->count1 += ftpc->count2; /* get next attempt */\n        result = Curl_pp_sendf(data, &ftpc->pp, \"AUTH %s\",\n                               ftpauth[ftpc->count1]);\n        /* remain in this same state */\n      }\n      else {\n        if(data->set.use_ssl > CURLUSESSL_TRY)\n          /* we failed and CURLUSESSL_CONTROL or CURLUSESSL_ALL is set */\n          result = CURLE_USE_SSL_FAILED;\n        else\n          /* ignore the failure and continue */\n          result = ftp_state_user(data, conn);\n      }\n      break;\n\n    case FTP_USER:\n    case FTP_PASS:\n      result = ftp_state_user_resp(data, ftpcode);\n      break;\n\n    case FTP_ACCT:\n      result = ftp_state_acct_resp(data, ftpcode);\n      break;\n\n    case FTP_PBSZ:\n      result =\n        Curl_pp_sendf(data, &ftpc->pp, \"PROT %c\",\n                      data->set.use_ssl == CURLUSESSL_CONTROL ? 'C' : 'P');\n      if(!result)\n        ftp_state(data, FTP_PROT);\n      break;\n\n    case FTP_PROT:\n      if(ftpcode/100 == 2)\n        /* We have enabled SSL for the data connection! */\n        conn->bits.ftp_use_data_ssl =\n          (data->set.use_ssl != CURLUSESSL_CONTROL) ? TRUE : FALSE;\n      /* FTP servers typically responds with 500 if they decide to reject\n         our 'P' request */\n      else if(data->set.use_ssl > CURLUSESSL_CONTROL)\n        /* we failed and bails out */\n        return CURLE_USE_SSL_FAILED;\n\n      if(data->set.ftp_ccc) {\n        /* CCC - Clear Command Channel\n         */\n        result = Curl_pp_sendf(data, &ftpc->pp, \"%s\", \"CCC\");\n        if(!result)\n          ftp_state(data, FTP_CCC);\n      }\n      else\n        result = ftp_state_pwd(data, conn);\n      break;\n\n    case FTP_CCC:\n      if(ftpcode < 500) {\n        /* First shut down the SSL layer (note: this call will block) */\n        result = Curl_ssl_cfilter_remove(data, FIRSTSOCKET);\n\n        if(result)\n          failf(data, \"Failed to clear the command channel (CCC)\");\n      }\n      if(!result)\n        /* Then continue as normal */\n        result = ftp_state_pwd(data, conn);\n      break;\n\n    case FTP_PWD:\n      if(ftpcode == 257) {\n        char *ptr = Curl_dyn_ptr(&pp->recvbuf) + 4; /* start on the first\n                                                       letter */\n        bool entry_extracted = FALSE;\n        struct dynbuf out;\n        Curl_dyn_init(&out, 1000);\n\n        /* Reply format is like\n           257<space>[rubbish]\"<directory-name>\"<space><commentary> and the\n           RFC959 says\n\n           The directory name can contain any character; embedded\n           double-quotes should be escaped by double-quotes (the\n           \"quote-doubling\" convention).\n        */\n\n        /* scan for the first double-quote for non-standard responses */\n        while(*ptr != '\\n' && *ptr != '\\0' && *ptr != '\"')\n          ptr++;\n\n        if('\\\"' == *ptr) {\n          /* it started good */\n          for(ptr++; *ptr; ptr++) {\n            if('\\\"' == *ptr) {\n              if('\\\"' == ptr[1]) {\n                /* \"quote-doubling\" */\n                result = Curl_dyn_addn(&out, &ptr[1], 1);\n                ptr++;\n              }\n              else {\n                /* end of path */\n                if(Curl_dyn_len(&out))\n                  entry_extracted = TRUE;\n                break; /* get out of this loop */\n              }\n            }\n            else\n              result = Curl_dyn_addn(&out, ptr, 1);\n            if(result)\n              return result;\n          }\n        }\n        if(entry_extracted) {\n          /* If the path name does not look like an absolute path (i.e.: it\n             does not start with a '/'), we probably need some server-dependent\n             adjustments. For example, this is the case when connecting to\n             an OS400 FTP server: this server supports two name syntaxes,\n             the default one being incompatible with standard paths. In\n             addition, this server switches automatically to the regular path\n             syntax when one is encountered in a command: this results in\n             having an entrypath in the wrong syntax when later used in CWD.\n               The method used here is to check the server OS: we do it only\n             if the path name looks strange to minimize overhead on other\n             systems. */\n          char *dir = Curl_dyn_ptr(&out);\n\n          if(!ftpc->server_os && dir[0] != '/') {\n            result = Curl_pp_sendf(data, &ftpc->pp, \"%s\", \"SYST\");\n            if(result) {\n              free(dir);\n              return result;\n            }\n            Curl_safefree(ftpc->entrypath);\n            ftpc->entrypath = dir; /* remember this */\n            infof(data, \"Entry path is '%s'\", ftpc->entrypath);\n            /* also save it where getinfo can access it: */\n            data->state.most_recent_ftp_entrypath = ftpc->entrypath;\n            ftp_state(data, FTP_SYST);\n            break;\n          }\n\n          Curl_safefree(ftpc->entrypath);\n          ftpc->entrypath = dir; /* remember this */\n          infof(data, \"Entry path is '%s'\", ftpc->entrypath);\n          /* also save it where getinfo can access it: */\n          data->state.most_recent_ftp_entrypath = ftpc->entrypath;\n        }\n        else {\n          /* couldn't get the path */\n          Curl_dyn_free(&out);\n          infof(data, \"Failed to figure out path\");\n        }\n      }\n      ftp_state(data, FTP_STOP); /* we are done with the CONNECT phase! */\n      DEBUGF(infof(data, \"protocol connect phase DONE\"));\n      break;\n\n    case FTP_SYST:\n      if(ftpcode == 215) {\n        char *ptr = Curl_dyn_ptr(&pp->recvbuf) + 4; /* start on the first\n                                                       letter */\n        char *os;\n        char *start;\n\n        /* Reply format is like\n           215<space><OS-name><space><commentary>\n        */\n        while(*ptr == ' ')\n          ptr++;\n        for(start = ptr; *ptr && *ptr != ' '; ptr++)\n          ;\n        os = Curl_memdup0(start, ptr - start);\n        if(!os)\n          return CURLE_OUT_OF_MEMORY;\n\n        /* Check for special servers here. */\n        if(strcasecompare(os, \"OS/400\")) {\n          /* Force OS400 name format 1. */\n          result = Curl_pp_sendf(data, &ftpc->pp, \"%s\", \"SITE NAMEFMT 1\");\n          if(result) {\n            free(os);\n            return result;\n          }\n          /* remember target server OS */\n          Curl_safefree(ftpc->server_os);\n          ftpc->server_os = os;\n          ftp_state(data, FTP_NAMEFMT);\n          break;\n        }\n        /* Nothing special for the target server. */\n        /* remember target server OS */\n        Curl_safefree(ftpc->server_os);\n        ftpc->server_os = os;\n      }\n      else {\n        /* Cannot identify server OS. Continue anyway and cross fingers. */\n      }\n\n      ftp_state(data, FTP_STOP); /* we are done with the CONNECT phase! */\n      DEBUGF(infof(data, \"protocol connect phase DONE\"));\n      break;\n\n    case FTP_NAMEFMT:\n      if(ftpcode == 250) {\n        /* Name format change successful: reload initial path. */\n        ftp_state_pwd(data, conn);\n        break;\n      }\n\n      ftp_state(data, FTP_STOP); /* we are done with the CONNECT phase! */\n      DEBUGF(infof(data, \"protocol connect phase DONE\"));\n      break;\n\n    case FTP_QUOTE:\n    case FTP_POSTQUOTE:\n    case FTP_RETR_PREQUOTE:\n    case FTP_STOR_PREQUOTE:\n      if((ftpcode >= 400) && !ftpc->count2) {\n        /* failure response code, and not allowed to fail */\n        failf(data, \"QUOT command failed with %03d\", ftpcode);\n        result = CURLE_QUOTE_ERROR;\n      }\n      else\n        result = ftp_state_quote(data, FALSE, ftpc->state);\n      break;\n\n    case FTP_CWD:\n      if(ftpcode/100 != 2) {\n        /* failure to CWD there */\n        if(data->set.ftp_create_missing_dirs &&\n           ftpc->cwdcount && !ftpc->count2) {\n          /* try making it */\n          ftpc->count2++; /* counter to prevent CWD-MKD loops */\n\n          /* count3 is set to allow MKD to fail once per dir. In the case when\n          CWD fails and then MKD fails (due to another session raced it to\n          create the dir) this then allows for a second try to CWD to it. */\n          ftpc->count3 = (data->set.ftp_create_missing_dirs == 2) ? 1 : 0;\n\n          result = Curl_pp_sendf(data, &ftpc->pp, \"MKD %s\",\n                                 ftpc->dirs[ftpc->cwdcount - 1]);\n          if(!result)\n            ftp_state(data, FTP_MKD);\n        }\n        else {\n          /* return failure */\n          failf(data, \"Server denied you to change to the given directory\");\n          ftpc->cwdfail = TRUE; /* don't remember this path as we failed\n                                   to enter it */\n          result = CURLE_REMOTE_ACCESS_DENIED;\n        }\n      }\n      else {\n        /* success */\n        ftpc->count2 = 0;\n        if(++ftpc->cwdcount <= ftpc->dirdepth)\n          /* send next CWD */\n          result = Curl_pp_sendf(data, &ftpc->pp, \"CWD %s\",\n                                 ftpc->dirs[ftpc->cwdcount - 1]);\n        else\n          result = ftp_state_mdtm(data);\n      }\n      break;\n\n    case FTP_MKD:\n      if((ftpcode/100 != 2) && !ftpc->count3--) {\n        /* failure to MKD the dir */\n        failf(data, \"Failed to MKD dir: %03d\", ftpcode);\n        result = CURLE_REMOTE_ACCESS_DENIED;\n      }\n      else {\n        ftp_state(data, FTP_CWD);\n        /* send CWD */\n        result = Curl_pp_sendf(data, &ftpc->pp, \"CWD %s\",\n                               ftpc->dirs[ftpc->cwdcount - 1]);\n      }\n      break;\n\n    case FTP_MDTM:\n      result = ftp_state_mdtm_resp(data, ftpcode);\n      break;\n\n    case FTP_TYPE:\n    case FTP_LIST_TYPE:\n    case FTP_RETR_TYPE:\n    case FTP_STOR_TYPE:\n      result = ftp_state_type_resp(data, ftpcode, ftpc->state);\n      break;\n\n    case FTP_SIZE:\n    case FTP_RETR_SIZE:\n    case FTP_STOR_SIZE:\n      result = ftp_state_size_resp(data, ftpcode, ftpc->state);\n      break;\n\n    case FTP_REST:\n    case FTP_RETR_REST:\n      result = ftp_state_rest_resp(data, conn, ftpcode, ftpc->state);\n      break;\n\n    case FTP_PRET:\n      if(ftpcode != 200) {\n        /* there only is this one standard OK return code. */\n        failf(data, \"PRET command not accepted: %03d\", ftpcode);\n        return CURLE_FTP_PRET_FAILED;\n      }\n      result = ftp_state_use_pasv(data, conn);\n      break;\n\n    case FTP_PASV:\n      result = ftp_state_pasv_resp(data, ftpcode);\n      break;\n\n    case FTP_PORT:\n      result = ftp_state_port_resp(data, ftpcode);\n      break;\n\n    case FTP_LIST:\n    case FTP_RETR:\n      result = ftp_state_get_resp(data, ftpcode, ftpc->state);\n      break;\n\n    case FTP_STOR:\n      result = ftp_state_stor_resp(data, ftpcode, ftpc->state);\n      break;\n\n    case FTP_QUIT:\n    default:\n      /* internal error */\n      ftp_state(data, FTP_STOP);\n      break;\n    }\n  } /* if(ftpcode) */\n\n  return result;\n}\n\n\n/* called repeatedly until done from multi.c */\nstatic CURLcode ftp_multi_statemach(struct Curl_easy *data,\n                                    bool *done)\n{\n  struct connectdata *conn = data->conn;\n  struct ftp_conn *ftpc = &conn->proto.ftpc;\n  CURLcode result = Curl_pp_statemach(data, &ftpc->pp, FALSE, FALSE);\n\n  /* Check for the state outside of the Curl_socket_check() return code checks\n     since at times we are in fact already in this state when this function\n     gets called. */\n  *done = (ftpc->state == FTP_STOP) ? TRUE : FALSE;\n\n  return result;\n}\n\nstatic CURLcode ftp_block_statemach(struct Curl_easy *data,\n                                    struct connectdata *conn)\n{\n  struct ftp_conn *ftpc = &conn->proto.ftpc;\n  struct pingpong *pp = &ftpc->pp;\n  CURLcode result = CURLE_OK;\n\n  while(ftpc->state != FTP_STOP) {\n    result = Curl_pp_statemach(data, pp, TRUE, TRUE /* disconnecting */);\n    if(result)\n      break;\n  }\n\n  return result;\n}\n\n/*\n * ftp_connect() should do everything that is to be considered a part of\n * the connection phase.\n *\n * The variable 'done' points to will be TRUE if the protocol-layer connect\n * phase is done when this function returns, or FALSE if not.\n *\n */\nstatic CURLcode ftp_connect(struct Curl_easy *data,\n                            bool *done) /* see description above */\n{\n  CURLcode result;\n  struct connectdata *conn = data->conn;\n  struct ftp_conn *ftpc = &conn->proto.ftpc;\n  struct pingpong *pp = &ftpc->pp;\n\n  *done = FALSE; /* default to not done yet */\n\n  /* We always support persistent connections on ftp */\n  connkeep(conn, \"FTP default\");\n\n  PINGPONG_SETUP(pp, ftp_statemachine, ftp_endofresp);\n\n  if(conn->handler->flags & PROTOPT_SSL) {\n    /* BLOCKING */\n    result = Curl_conn_connect(data, FIRSTSOCKET, TRUE, done);\n    if(result)\n      return result;\n    conn->bits.ftp_use_control_ssl = TRUE;\n  }\n\n  Curl_pp_init(pp); /* once per transfer */\n\n  /* When we connect, we start in the state where we await the 220\n     response */\n  ftp_state(data, FTP_WAIT220);\n\n  result = ftp_multi_statemach(data, done);\n\n  return result;\n}\n\n/***********************************************************************\n *\n * ftp_done()\n *\n * The DONE function. This does what needs to be done after a single DO has\n * performed.\n *\n * Input argument is already checked for validity.\n */\nstatic CURLcode ftp_done(struct Curl_easy *data, CURLcode status,\n                         bool premature)\n{\n  struct connectdata *conn = data->conn;\n  struct FTP *ftp = data->req.p.ftp;\n  struct ftp_conn *ftpc = &conn->proto.ftpc;\n  struct pingpong *pp = &ftpc->pp;\n  ssize_t nread;\n  int ftpcode;\n  CURLcode result = CURLE_OK;\n  char *rawPath = NULL;\n  size_t pathLen = 0;\n\n  if(!ftp)\n    return CURLE_OK;\n\n  switch(status) {\n  case CURLE_BAD_DOWNLOAD_RESUME:\n  case CURLE_FTP_WEIRD_PASV_REPLY:\n  case CURLE_FTP_PORT_FAILED:\n  case CURLE_FTP_ACCEPT_FAILED:\n  case CURLE_FTP_ACCEPT_TIMEOUT:\n  case CURLE_FTP_COULDNT_SET_TYPE:\n  case CURLE_FTP_COULDNT_RETR_FILE:\n  case CURLE_PARTIAL_FILE:\n  case CURLE_UPLOAD_FAILED:\n  case CURLE_REMOTE_ACCESS_DENIED:\n  case CURLE_FILESIZE_EXCEEDED:\n  case CURLE_REMOTE_FILE_NOT_FOUND:\n  case CURLE_WRITE_ERROR:\n    /* the connection stays alive fine even though this happened */\n  case CURLE_OK: /* doesn't affect the control connection's status */\n    if(!premature)\n      break;\n\n    /* until we cope better with prematurely ended requests, let them\n     * fallback as if in complete failure */\n    FALLTHROUGH();\n  default:       /* by default, an error means the control connection is\n                    wedged and should not be used anymore */\n    ftpc->ctl_valid = FALSE;\n    ftpc->cwdfail = TRUE; /* set this TRUE to prevent us to remember the\n                             current path, as this connection is going */\n    connclose(conn, \"FTP ended with bad error code\");\n    result = status;      /* use the already set error code */\n    break;\n  }\n\n  if(data->state.wildcardmatch) {\n    if(data->set.chunk_end && ftpc->file) {\n      Curl_set_in_callback(data, true);\n      data->set.chunk_end(data->set.wildcardptr);\n      Curl_set_in_callback(data, false);\n    }\n    ftpc->known_filesize = -1;\n  }\n\n  if(!result)\n    /* get the url-decoded \"raw\" path */\n    result = Curl_urldecode(ftp->path, 0, &rawPath, &pathLen,\n                            REJECT_CTRL);\n  if(result) {\n    /* We can limp along anyway (and should try to since we may already be in\n     * the error path) */\n    ftpc->ctl_valid = FALSE; /* mark control connection as bad */\n    connclose(conn, \"FTP: out of memory!\"); /* mark for connection closure */\n    free(ftpc->prevpath);\n    ftpc->prevpath = NULL; /* no path remembering */\n  }\n  else { /* remember working directory for connection reuse */\n    if((data->set.ftp_filemethod == FTPFILE_NOCWD) && (rawPath[0] == '/'))\n      free(rawPath); /* full path => no CWDs happened => keep ftpc->prevpath */\n    else {\n      free(ftpc->prevpath);\n\n      if(!ftpc->cwdfail) {\n        if(data->set.ftp_filemethod == FTPFILE_NOCWD)\n          pathLen = 0; /* relative path => working directory is FTP home */\n        else\n          pathLen -= ftpc->file?strlen(ftpc->file):0; /* file is url-decoded */\n\n        rawPath[pathLen] = '\\0';\n        ftpc->prevpath = rawPath;\n      }\n      else {\n        free(rawPath);\n        ftpc->prevpath = NULL; /* no path */\n      }\n    }\n\n    if(ftpc->prevpath)\n      infof(data, \"Remembering we are in dir \\\"%s\\\"\", ftpc->prevpath);\n  }\n\n  /* free the dir tree and file parts */\n  freedirs(ftpc);\n\n  /* shut down the socket to inform the server we're done */\n\n#ifdef _WIN32_WCE\n  shutdown(conn->sock[SECONDARYSOCKET], 2);  /* SD_BOTH */\n#endif\n\n  if(conn->sock[SECONDARYSOCKET] != CURL_SOCKET_BAD) {\n    if(!result && ftpc->dont_check && data->req.maxdownload > 0) {\n      /* partial download completed */\n      result = Curl_pp_sendf(data, pp, \"%s\", \"ABOR\");\n      if(result) {\n        failf(data, \"Failure sending ABOR command: %s\",\n              curl_easy_strerror(result));\n        ftpc->ctl_valid = FALSE; /* mark control connection as bad */\n        connclose(conn, \"ABOR command failed\"); /* connection closure */\n      }\n    }\n\n    close_secondarysocket(data, conn);\n  }\n\n  if(!result && (ftp->transfer == PPTRANSFER_BODY) && ftpc->ctl_valid &&\n     pp->pending_resp && !premature) {\n    /*\n     * Let's see what the server says about the transfer we just performed,\n     * but lower the timeout as sometimes this connection has died while the\n     * data has been transferred. This happens when doing through NATs etc that\n     * abandon old silent connections.\n     */\n    timediff_t old_time = pp->response_time;\n\n    pp->response_time = 60*1000; /* give it only a minute for now */\n    pp->response = Curl_now(); /* timeout relative now */\n\n    result = Curl_GetFTPResponse(data, &nread, &ftpcode);\n\n    pp->response_time = old_time; /* set this back to previous value */\n\n    if(!nread && (CURLE_OPERATION_TIMEDOUT == result)) {\n      failf(data, \"control connection looks dead\");\n      ftpc->ctl_valid = FALSE; /* mark control connection as bad */\n      connclose(conn, \"Timeout or similar in FTP DONE operation\"); /* close */\n    }\n\n    if(result) {\n      Curl_safefree(ftp->pathalloc);\n      return result;\n    }\n\n    if(ftpc->dont_check && data->req.maxdownload > 0) {\n      /* we have just sent ABOR and there is no reliable way to check if it was\n       * successful or not; we have to close the connection now */\n      infof(data, \"partial download completed, closing connection\");\n      connclose(conn, \"Partial download with no ability to check\");\n      return result;\n    }\n\n    if(!ftpc->dont_check) {\n      /* 226 Transfer complete, 250 Requested file action okay, completed. */\n      switch(ftpcode) {\n      case 226:\n      case 250:\n        break;\n      case 552:\n        failf(data, \"Exceeded storage allocation\");\n        result = CURLE_REMOTE_DISK_FULL;\n        break;\n      default:\n        failf(data, \"server did not report OK, got %d\", ftpcode);\n        result = CURLE_PARTIAL_FILE;\n        break;\n      }\n    }\n  }\n\n  if(result || premature)\n    /* the response code from the transfer showed an error already so no\n       use checking further */\n    ;\n  else if(data->state.upload) {\n    if((-1 != data->state.infilesize) &&\n       (data->state.infilesize != data->req.writebytecount) &&\n       !data->set.crlf &&\n       (ftp->transfer == PPTRANSFER_BODY)) {\n      failf(data, \"Uploaded unaligned file size (%\" CURL_FORMAT_CURL_OFF_T\n            \" out of %\" CURL_FORMAT_CURL_OFF_T \" bytes)\",\n            data->req.writebytecount, data->state.infilesize);\n      result = CURLE_PARTIAL_FILE;\n    }\n  }\n  else {\n    if((-1 != data->req.size) &&\n       (data->req.size != data->req.bytecount) &&\n#ifdef CURL_DO_LINEEND_CONV\n       /* Most FTP servers don't adjust their file SIZE response for CRLFs, so\n        * we'll check to see if the discrepancy can be explained by the number\n        * of CRLFs we've changed to LFs.\n        */\n       ((data->req.size + data->state.crlf_conversions) !=\n        data->req.bytecount) &&\n#endif /* CURL_DO_LINEEND_CONV */\n       (data->req.maxdownload != data->req.bytecount)) {\n      failf(data, \"Received only partial file: %\" CURL_FORMAT_CURL_OFF_T\n            \" bytes\", data->req.bytecount);\n      result = CURLE_PARTIAL_FILE;\n    }\n    else if(!ftpc->dont_check &&\n            !data->req.bytecount &&\n            (data->req.size>0)) {\n      failf(data, \"No data was received\");\n      result = CURLE_FTP_COULDNT_RETR_FILE;\n    }\n  }\n\n  /* clear these for next connection */\n  ftp->transfer = PPTRANSFER_BODY;\n  ftpc->dont_check = FALSE;\n\n  /* Send any post-transfer QUOTE strings? */\n  if(!status && !result && !premature && data->set.postquote)\n    result = ftp_sendquote(data, conn, data->set.postquote);\n  Curl_safefree(ftp->pathalloc);\n  return result;\n}\n\n/***********************************************************************\n *\n * ftp_sendquote()\n *\n * Where a 'quote' means a list of custom commands to send to the server.\n * The quote list is passed as an argument.\n *\n * BLOCKING\n */\n\nstatic\nCURLcode ftp_sendquote(struct Curl_easy *data,\n                       struct connectdata *conn, struct curl_slist *quote)\n{\n  struct curl_slist *item;\n  struct ftp_conn *ftpc = &conn->proto.ftpc;\n  struct pingpong *pp = &ftpc->pp;\n\n  item = quote;\n  while(item) {\n    if(item->data) {\n      ssize_t nread;\n      char *cmd = item->data;\n      bool acceptfail = FALSE;\n      CURLcode result;\n      int ftpcode = 0;\n\n      /* if a command starts with an asterisk, which a legal FTP command never\n         can, the command will be allowed to fail without it causing any\n         aborts or cancels etc. It will cause libcurl to act as if the command\n         is successful, whatever the server responds. */\n\n      if(cmd[0] == '*') {\n        cmd++;\n        acceptfail = TRUE;\n      }\n\n      result = Curl_pp_sendf(data, &ftpc->pp, \"%s\", cmd);\n      if(!result) {\n        pp->response = Curl_now(); /* timeout relative now */\n        result = Curl_GetFTPResponse(data, &nread, &ftpcode);\n      }\n      if(result)\n        return result;\n\n      if(!acceptfail && (ftpcode >= 400)) {\n        failf(data, \"QUOT string not accepted: %s\", cmd);\n        return CURLE_QUOTE_ERROR;\n      }\n    }\n\n    item = item->next;\n  }\n\n  return CURLE_OK;\n}\n\n/***********************************************************************\n *\n * ftp_need_type()\n *\n * Returns TRUE if we in the current situation should send TYPE\n */\nstatic int ftp_need_type(struct connectdata *conn,\n                         bool ascii_wanted)\n{\n  return conn->proto.ftpc.transfertype != (ascii_wanted?'A':'I');\n}\n\n/***********************************************************************\n *\n * ftp_nb_type()\n *\n * Set TYPE. We only deal with ASCII or BINARY so this function\n * sets one of them.\n * If the transfer type is not sent, simulate on OK response in newstate\n */\nstatic CURLcode ftp_nb_type(struct Curl_easy *data,\n                            struct connectdata *conn,\n                            bool ascii, ftpstate newstate)\n{\n  struct ftp_conn *ftpc = &conn->proto.ftpc;\n  CURLcode result;\n  char want = (char)(ascii?'A':'I');\n\n  if(ftpc->transfertype == want) {\n    ftp_state(data, newstate);\n    return ftp_state_type_resp(data, 200, newstate);\n  }\n\n  result = Curl_pp_sendf(data, &ftpc->pp, \"TYPE %c\", want);\n  if(!result) {\n    ftp_state(data, newstate);\n\n    /* keep track of our current transfer type */\n    ftpc->transfertype = want;\n  }\n  return result;\n}\n\n/***************************************************************************\n *\n * ftp_pasv_verbose()\n *\n * This function only outputs some informationals about this second connection\n * when we've issued a PASV command before and thus we have connected to a\n * possibly new IP address.\n *\n */\n#ifndef CURL_DISABLE_VERBOSE_STRINGS\nstatic void\nftp_pasv_verbose(struct Curl_easy *data,\n                 struct Curl_addrinfo *ai,\n                 char *newhost, /* ascii version */\n                 int port)\n{\n  char buf[256];\n  Curl_printable_address(ai, buf, sizeof(buf));\n  infof(data, \"Connecting to %s (%s) port %d\", newhost, buf, port);\n}\n#endif\n\n/*\n * ftp_do_more()\n *\n * This function shall be called when the second FTP (data) connection is\n * connected.\n *\n * 'complete' can return 0 for incomplete, 1 for done and -1 for go back\n * (which basically is only for when PASV is being sent to retry a failed\n * EPSV).\n */\n\nstatic CURLcode ftp_do_more(struct Curl_easy *data, int *completep)\n{\n  struct connectdata *conn = data->conn;\n  struct ftp_conn *ftpc = &conn->proto.ftpc;\n  CURLcode result = CURLE_OK;\n  bool connected = FALSE;\n  bool complete = FALSE;\n\n  /* the ftp struct is inited in ftp_connect(). If we are connecting to an HTTP\n   * proxy then the state will not be valid until after that connection is\n   * complete */\n  struct FTP *ftp = NULL;\n\n  /* if the second connection isn't done yet, wait for it to have\n   * connected to the remote host. When using proxy tunneling, this\n   * means the tunnel needs to have been establish. However, we\n   * can not expect the remote host to talk to us in any way yet.\n   * So, when using ftps: the SSL handshake will not start until we\n   * tell the remote server that we are there. */\n  if(conn->cfilter[SECONDARYSOCKET]) {\n    result = Curl_conn_connect(data, SECONDARYSOCKET, FALSE, &connected);\n    if(result || !Curl_conn_is_ip_connected(data, SECONDARYSOCKET)) {\n      if(result && (ftpc->count1 == 0)) {\n        *completep = -1; /* go back to DOING please */\n        /* this is a EPSV connect failing, try PASV instead */\n        return ftp_epsv_disable(data, conn);\n      }\n      return result;\n    }\n  }\n\n  /* Curl_proxy_connect might have moved the protocol state */\n  ftp = data->req.p.ftp;\n\n  if(ftpc->state) {\n    /* already in a state so skip the initial commands.\n       They are only done to kickstart the do_more state */\n    result = ftp_multi_statemach(data, &complete);\n\n    *completep = (int)complete;\n\n    /* if we got an error or if we don't wait for a data connection return\n       immediately */\n    if(result || !ftpc->wait_data_conn)\n      return result;\n\n    /* if we reach the end of the FTP state machine here, *complete will be\n       TRUE but so is ftpc->wait_data_conn, which says we need to wait for the\n       data connection and therefore we're not actually complete */\n    *completep = 0;\n  }\n\n  if(ftp->transfer <= PPTRANSFER_INFO) {\n    /* a transfer is about to take place, or if not a file name was given\n       so we'll do a SIZE on it later and then we need the right TYPE first */\n\n    if(ftpc->wait_data_conn) {\n      bool serv_conned;\n\n      result = ReceivedServerConnect(data, &serv_conned);\n      if(result)\n        return result; /* Failed to accept data connection */\n\n      if(serv_conned) {\n        /* It looks data connection is established */\n        result = AcceptServerConnect(data);\n        ftpc->wait_data_conn = FALSE;\n        if(!result)\n          result = InitiateTransfer(data);\n\n        if(result)\n          return result;\n\n        *completep = 1; /* this state is now complete when the server has\n                           connected back to us */\n      }\n    }\n    else if(data->state.upload) {\n      result = ftp_nb_type(data, conn, data->state.prefer_ascii,\n                           FTP_STOR_TYPE);\n      if(result)\n        return result;\n\n      result = ftp_multi_statemach(data, &complete);\n      *completep = (int)complete;\n    }\n    else {\n      /* download */\n      ftp->downloadsize = -1; /* unknown as of yet */\n\n      result = Curl_range(data);\n\n      if(result == CURLE_OK && data->req.maxdownload >= 0) {\n        /* Don't check for successful transfer */\n        ftpc->dont_check = TRUE;\n      }\n\n      if(result)\n        ;\n      else if(data->state.list_only || !ftpc->file) {\n        /* The specified path ends with a slash, and therefore we think this\n           is a directory that is requested, use LIST. But before that we\n           need to set ASCII transfer mode. */\n\n        /* But only if a body transfer was requested. */\n        if(ftp->transfer == PPTRANSFER_BODY) {\n          result = ftp_nb_type(data, conn, TRUE, FTP_LIST_TYPE);\n          if(result)\n            return result;\n        }\n        /* otherwise just fall through */\n      }\n      else {\n        result = ftp_nb_type(data, conn, data->state.prefer_ascii,\n                             FTP_RETR_TYPE);\n        if(result)\n          return result;\n      }\n\n      result = ftp_multi_statemach(data, &complete);\n      *completep = (int)complete;\n    }\n    return result;\n  }\n\n  /* no data to transfer */\n  Curl_xfer_setup(data, -1, -1, FALSE, -1);\n\n  if(!ftpc->wait_data_conn) {\n    /* no waiting for the data connection so this is now complete */\n    *completep = 1;\n    DEBUGF(infof(data, \"DO-MORE phase ends with %d\", (int)result));\n  }\n\n  return result;\n}\n\n\n\n/***********************************************************************\n *\n * ftp_perform()\n *\n * This is the actual DO function for FTP. Get a file/directory according to\n * the options previously setup.\n */\n\nstatic\nCURLcode ftp_perform(struct Curl_easy *data,\n                     bool *connected,  /* connect status after PASV / PORT */\n                     bool *dophase_done)\n{\n  /* this is FTP and no proxy */\n  CURLcode result = CURLE_OK;\n\n  DEBUGF(infof(data, \"DO phase starts\"));\n\n  if(data->req.no_body) {\n    /* requested no body means no transfer... */\n    struct FTP *ftp = data->req.p.ftp;\n    ftp->transfer = PPTRANSFER_INFO;\n  }\n\n  *dophase_done = FALSE; /* not done yet */\n\n  /* start the first command in the DO phase */\n  result = ftp_state_quote(data, TRUE, FTP_QUOTE);\n  if(result)\n    return result;\n\n  /* run the state-machine */\n  result = ftp_multi_statemach(data, dophase_done);\n\n  *connected = Curl_conn_is_connected(data->conn, SECONDARYSOCKET);\n\n  infof(data, \"ftp_perform ends with SECONDARY: %d\", *connected);\n\n  if(*dophase_done)\n    DEBUGF(infof(data, \"DO phase is complete1\"));\n\n  return result;\n}\n\nstatic void wc_data_dtor(void *ptr)\n{\n  struct ftp_wc *ftpwc = ptr;\n  if(ftpwc && ftpwc->parser)\n    Curl_ftp_parselist_data_free(&ftpwc->parser);\n  free(ftpwc);\n}\n\nstatic CURLcode init_wc_data(struct Curl_easy *data)\n{\n  char *last_slash;\n  struct FTP *ftp = data->req.p.ftp;\n  char *path = ftp->path;\n  struct WildcardData *wildcard = data->wildcard;\n  CURLcode result = CURLE_OK;\n  struct ftp_wc *ftpwc = NULL;\n\n  last_slash = strrchr(ftp->path, '/');\n  if(last_slash) {\n    last_slash++;\n    if(last_slash[0] == '\\0') {\n      wildcard->state = CURLWC_CLEAN;\n      result = ftp_parse_url_path(data);\n      return result;\n    }\n    wildcard->pattern = strdup(last_slash);\n    if(!wildcard->pattern)\n      return CURLE_OUT_OF_MEMORY;\n    last_slash[0] = '\\0'; /* cut file from path */\n  }\n  else { /* there is only 'wildcard pattern' or nothing */\n    if(path[0]) {\n      wildcard->pattern = strdup(path);\n      if(!wildcard->pattern)\n        return CURLE_OUT_OF_MEMORY;\n      path[0] = '\\0';\n    }\n    else { /* only list */\n      wildcard->state = CURLWC_CLEAN;\n      result = ftp_parse_url_path(data);\n      return result;\n    }\n  }\n\n  /* program continues only if URL is not ending with slash, allocate needed\n     resources for wildcard transfer */\n\n  /* allocate ftp protocol specific wildcard data */\n  ftpwc = calloc(1, sizeof(struct ftp_wc));\n  if(!ftpwc) {\n    result = CURLE_OUT_OF_MEMORY;\n    goto fail;\n  }\n\n  /* INITIALIZE parselist structure */\n  ftpwc->parser = Curl_ftp_parselist_data_alloc();\n  if(!ftpwc->parser) {\n    result = CURLE_OUT_OF_MEMORY;\n    goto fail;\n  }\n\n  wildcard->ftpwc = ftpwc; /* put it to the WildcardData tmp pointer */\n  wildcard->dtor = wc_data_dtor;\n\n  /* wildcard does not support NOCWD option (assert it?) */\n  if(data->set.ftp_filemethod == FTPFILE_NOCWD)\n    data->set.ftp_filemethod = FTPFILE_MULTICWD;\n\n  /* try to parse ftp url */\n  result = ftp_parse_url_path(data);\n  if(result) {\n    goto fail;\n  }\n\n  wildcard->path = strdup(ftp->path);\n  if(!wildcard->path) {\n    result = CURLE_OUT_OF_MEMORY;\n    goto fail;\n  }\n\n  /* backup old write_function */\n  ftpwc->backup.write_function = data->set.fwrite_func;\n  /* parsing write function */\n  data->set.fwrite_func = Curl_ftp_parselist;\n  /* backup old file descriptor */\n  ftpwc->backup.file_descriptor = data->set.out;\n  /* let the writefunc callback know the transfer */\n  data->set.out = data;\n\n  infof(data, \"Wildcard - Parsing started\");\n  return CURLE_OK;\n\nfail:\n  if(ftpwc) {\n    Curl_ftp_parselist_data_free(&ftpwc->parser);\n    free(ftpwc);\n  }\n  Curl_safefree(wildcard->pattern);\n  wildcard->dtor = ZERO_NULL;\n  wildcard->ftpwc = NULL;\n  return result;\n}\n\nstatic CURLcode wc_statemach(struct Curl_easy *data)\n{\n  struct WildcardData * const wildcard = data->wildcard;\n  struct connectdata *conn = data->conn;\n  CURLcode result = CURLE_OK;\n\n  for(;;) {\n    switch(wildcard->state) {\n    case CURLWC_INIT:\n      result = init_wc_data(data);\n      if(wildcard->state == CURLWC_CLEAN)\n        /* only listing! */\n        return result;\n      wildcard->state = result ? CURLWC_ERROR : CURLWC_MATCHING;\n      return result;\n\n    case CURLWC_MATCHING: {\n      /* In this state is LIST response successfully parsed, so lets restore\n         previous WRITEFUNCTION callback and WRITEDATA pointer */\n      struct ftp_wc *ftpwc = wildcard->ftpwc;\n      data->set.fwrite_func = ftpwc->backup.write_function;\n      data->set.out = ftpwc->backup.file_descriptor;\n      ftpwc->backup.write_function = ZERO_NULL;\n      ftpwc->backup.file_descriptor = NULL;\n      wildcard->state = CURLWC_DOWNLOADING;\n\n      if(Curl_ftp_parselist_geterror(ftpwc->parser)) {\n        /* error found in LIST parsing */\n        wildcard->state = CURLWC_CLEAN;\n        continue;\n      }\n      if(wildcard->filelist.size == 0) {\n        /* no corresponding file */\n        wildcard->state = CURLWC_CLEAN;\n        return CURLE_REMOTE_FILE_NOT_FOUND;\n      }\n      continue;\n    }\n\n    case CURLWC_DOWNLOADING: {\n      /* filelist has at least one file, lets get first one */\n      struct ftp_conn *ftpc = &conn->proto.ftpc;\n      struct curl_fileinfo *finfo = wildcard->filelist.head->ptr;\n      struct FTP *ftp = data->req.p.ftp;\n\n      char *tmp_path = aprintf(\"%s%s\", wildcard->path, finfo->filename);\n      if(!tmp_path)\n        return CURLE_OUT_OF_MEMORY;\n\n      /* switch default ftp->path and tmp_path */\n      free(ftp->pathalloc);\n      ftp->pathalloc = ftp->path = tmp_path;\n\n      infof(data, \"Wildcard - START of \\\"%s\\\"\", finfo->filename);\n      if(data->set.chunk_bgn) {\n        long userresponse;\n        Curl_set_in_callback(data, true);\n        userresponse = data->set.chunk_bgn(\n          finfo, data->set.wildcardptr, (int)wildcard->filelist.size);\n        Curl_set_in_callback(data, false);\n        switch(userresponse) {\n        case CURL_CHUNK_BGN_FUNC_SKIP:\n          infof(data, \"Wildcard - \\\"%s\\\" skipped by user\",\n                finfo->filename);\n          wildcard->state = CURLWC_SKIP;\n          continue;\n        case CURL_CHUNK_BGN_FUNC_FAIL:\n          return CURLE_CHUNK_FAILED;\n        }\n      }\n\n      if(finfo->filetype != CURLFILETYPE_FILE) {\n        wildcard->state = CURLWC_SKIP;\n        continue;\n      }\n\n      if(finfo->flags & CURLFINFOFLAG_KNOWN_SIZE)\n        ftpc->known_filesize = finfo->size;\n\n      result = ftp_parse_url_path(data);\n      if(result)\n        return result;\n\n      /* we don't need the Curl_fileinfo of first file anymore */\n      Curl_llist_remove(&wildcard->filelist, wildcard->filelist.head, NULL);\n\n      if(wildcard->filelist.size == 0) { /* remains only one file to down. */\n        wildcard->state = CURLWC_CLEAN;\n        /* after that will be ftp_do called once again and no transfer\n           will be done because of CURLWC_CLEAN state */\n        return CURLE_OK;\n      }\n      return result;\n    }\n\n    case CURLWC_SKIP: {\n      if(data->set.chunk_end) {\n        Curl_set_in_callback(data, true);\n        data->set.chunk_end(data->set.wildcardptr);\n        Curl_set_in_callback(data, false);\n      }\n      Curl_llist_remove(&wildcard->filelist, wildcard->filelist.head, NULL);\n      wildcard->state = (wildcard->filelist.size == 0) ?\n        CURLWC_CLEAN : CURLWC_DOWNLOADING;\n      continue;\n    }\n\n    case CURLWC_CLEAN: {\n      struct ftp_wc *ftpwc = wildcard->ftpwc;\n      result = CURLE_OK;\n      if(ftpwc)\n        result = Curl_ftp_parselist_geterror(ftpwc->parser);\n\n      wildcard->state = result ? CURLWC_ERROR : CURLWC_DONE;\n      return result;\n    }\n\n    case CURLWC_DONE:\n    case CURLWC_ERROR:\n    case CURLWC_CLEAR:\n      if(wildcard->dtor) {\n        wildcard->dtor(wildcard->ftpwc);\n        wildcard->ftpwc = NULL;\n      }\n      return result;\n    }\n  }\n  /* UNREACHABLE */\n}\n\n/***********************************************************************\n *\n * ftp_do()\n *\n * This function is registered as 'curl_do' function. It decodes the path\n * parts etc as a wrapper to the actual DO function (ftp_perform).\n *\n * The input argument is already checked for validity.\n */\nstatic CURLcode ftp_do(struct Curl_easy *data, bool *done)\n{\n  CURLcode result = CURLE_OK;\n  struct connectdata *conn = data->conn;\n  struct ftp_conn *ftpc = &conn->proto.ftpc;\n\n  *done = FALSE; /* default to false */\n  ftpc->wait_data_conn = FALSE; /* default to no such wait */\n\n#ifdef CURL_DO_LINEEND_CONV\n  {\n    /* FTP data may need conversion. */\n    struct Curl_cwriter *ftp_lc_writer;\n\n    result = Curl_cwriter_create(&ftp_lc_writer, data, &ftp_cw_lc,\n                                 CURL_CW_CONTENT_DECODE);\n    if(result)\n      return result;\n\n    result = Curl_cwriter_add(data, ftp_lc_writer);\n    if(result) {\n      Curl_cwriter_free(data, ftp_lc_writer);\n      return result;\n    }\n  }\n#endif /* CURL_DO_LINEEND_CONV */\n\n  if(data->state.wildcardmatch) {\n    result = wc_statemach(data);\n    if(data->wildcard->state == CURLWC_SKIP ||\n       data->wildcard->state == CURLWC_DONE) {\n      /* do not call ftp_regular_transfer */\n      return CURLE_OK;\n    }\n    if(result) /* error, loop or skipping the file */\n      return result;\n  }\n  else { /* no wildcard FSM needed */\n    result = ftp_parse_url_path(data);\n    if(result)\n      return result;\n  }\n\n  result = ftp_regular_transfer(data, done);\n\n  return result;\n}\n\n/***********************************************************************\n *\n * ftp_quit()\n *\n * This should be called before calling sclose() on an ftp control connection\n * (not data connections). We should then wait for the response from the\n * server before returning. The calling code should then try to close the\n * connection.\n *\n */\nstatic CURLcode ftp_quit(struct Curl_easy *data, struct connectdata *conn)\n{\n  CURLcode result = CURLE_OK;\n\n  if(conn->proto.ftpc.ctl_valid) {\n    result = Curl_pp_sendf(data, &conn->proto.ftpc.pp, \"%s\", \"QUIT\");\n    if(result) {\n      failf(data, \"Failure sending QUIT command: %s\",\n            curl_easy_strerror(result));\n      conn->proto.ftpc.ctl_valid = FALSE; /* mark control connection as bad */\n      connclose(conn, \"QUIT command failed\"); /* mark for connection closure */\n      ftp_state(data, FTP_STOP);\n      return result;\n    }\n\n    ftp_state(data, FTP_QUIT);\n\n    result = ftp_block_statemach(data, conn);\n  }\n\n  return result;\n}\n\n/***********************************************************************\n *\n * ftp_disconnect()\n *\n * Disconnect from an FTP server. Cleanup protocol-specific per-connection\n * resources. BLOCKING.\n */\nstatic CURLcode ftp_disconnect(struct Curl_easy *data,\n                               struct connectdata *conn,\n                               bool dead_connection)\n{\n  struct ftp_conn *ftpc = &conn->proto.ftpc;\n  struct pingpong *pp = &ftpc->pp;\n\n  /* We cannot send quit unconditionally. If this connection is stale or\n     bad in any way, sending quit and waiting around here will make the\n     disconnect wait in vain and cause more problems than we need to.\n\n     ftp_quit() will check the state of ftp->ctl_valid. If it's ok it\n     will try to send the QUIT command, otherwise it will just return.\n  */\n  if(dead_connection)\n    ftpc->ctl_valid = FALSE;\n\n  /* The FTP session may or may not have been allocated/setup at this point! */\n  (void)ftp_quit(data, conn); /* ignore errors on the QUIT */\n\n  if(ftpc->entrypath) {\n    if(data->state.most_recent_ftp_entrypath == ftpc->entrypath) {\n      data->state.most_recent_ftp_entrypath = NULL;\n    }\n    Curl_safefree(ftpc->entrypath);\n  }\n\n  freedirs(ftpc);\n  Curl_safefree(ftpc->account);\n  Curl_safefree(ftpc->alternative_to_user);\n  Curl_safefree(ftpc->prevpath);\n  Curl_safefree(ftpc->server_os);\n  Curl_pp_disconnect(pp);\n  Curl_sec_end(conn);\n  return CURLE_OK;\n}\n\n#ifdef _MSC_VER\n/* warning C4706: assignment within conditional expression */\n#pragma warning(disable:4706)\n#endif\n\n/***********************************************************************\n *\n * ftp_parse_url_path()\n *\n * Parse the URL path into separate path components.\n *\n */\nstatic\nCURLcode ftp_parse_url_path(struct Curl_easy *data)\n{\n  /* the ftp struct is already inited in ftp_connect() */\n  struct FTP *ftp = data->req.p.ftp;\n  struct connectdata *conn = data->conn;\n  struct ftp_conn *ftpc = &conn->proto.ftpc;\n  const char *slashPos = NULL;\n  const char *fileName = NULL;\n  CURLcode result = CURLE_OK;\n  char *rawPath = NULL; /* url-decoded \"raw\" path */\n  size_t pathLen = 0;\n\n  ftpc->ctl_valid = FALSE;\n  ftpc->cwdfail = FALSE;\n\n  /* url-decode ftp path before further evaluation */\n  result = Curl_urldecode(ftp->path, 0, &rawPath, &pathLen, REJECT_CTRL);\n  if(result) {\n    failf(data, \"path contains control characters\");\n    return result;\n  }\n\n  switch(data->set.ftp_filemethod) {\n    case FTPFILE_NOCWD: /* fastest, but less standard-compliant */\n\n      if((pathLen > 0) && (rawPath[pathLen - 1] != '/'))\n        fileName = rawPath;  /* this is a full file path */\n      /*\n        else: ftpc->file is not used anywhere other than for operations on\n              a file. In other words, never for directory operations.\n              So we can safely leave filename as NULL here and use it as a\n              argument in dir/file decisions.\n      */\n      break;\n\n    case FTPFILE_SINGLECWD:\n      slashPos = strrchr(rawPath, '/');\n      if(slashPos) {\n        /* get path before last slash, except for / */\n        size_t dirlen = slashPos - rawPath;\n        if(dirlen == 0)\n          dirlen = 1;\n\n        ftpc->dirs = calloc(1, sizeof(ftpc->dirs[0]));\n        if(!ftpc->dirs) {\n          free(rawPath);\n          return CURLE_OUT_OF_MEMORY;\n        }\n\n        ftpc->dirs[0] = Curl_memdup0(rawPath, dirlen);\n        if(!ftpc->dirs[0]) {\n          free(rawPath);\n          return CURLE_OUT_OF_MEMORY;\n        }\n\n        ftpc->dirdepth = 1; /* we consider it to be a single dir */\n        fileName = slashPos + 1; /* rest is file name */\n      }\n      else\n        fileName = rawPath; /* file name only (or empty) */\n      break;\n\n    default: /* allow pretty much anything */\n    case FTPFILE_MULTICWD: {\n      /* current position: begin of next path component */\n      const char *curPos = rawPath;\n\n      /* number of entries allocated for the 'dirs' array */\n      size_t dirAlloc = 0;\n      const char *str = rawPath;\n      for(; *str != 0; ++str)\n        if(*str == '/')\n          ++dirAlloc;\n\n      if(dirAlloc) {\n        ftpc->dirs = calloc(dirAlloc, sizeof(ftpc->dirs[0]));\n        if(!ftpc->dirs) {\n          free(rawPath);\n          return CURLE_OUT_OF_MEMORY;\n        }\n\n        /* parse the URL path into separate path components */\n        while((slashPos = strchr(curPos, '/'))) {\n          size_t compLen = slashPos - curPos;\n\n          /* path starts with a slash: add that as a directory */\n          if((compLen == 0) && (ftpc->dirdepth == 0))\n            ++compLen;\n\n          /* we skip empty path components, like \"x//y\" since the FTP command\n             CWD requires a parameter and a non-existent parameter a) doesn't\n             work on many servers and b) has no effect on the others. */\n          if(compLen > 0) {\n            char *comp = Curl_memdup0(curPos, compLen);\n            if(!comp) {\n              free(rawPath);\n              return CURLE_OUT_OF_MEMORY;\n            }\n            ftpc->dirs[ftpc->dirdepth++] = comp;\n          }\n          curPos = slashPos + 1;\n        }\n      }\n      DEBUGASSERT((size_t)ftpc->dirdepth <= dirAlloc);\n      fileName = curPos; /* the rest is the file name (or empty) */\n    }\n    break;\n  } /* switch */\n\n  if(fileName && *fileName)\n    ftpc->file = strdup(fileName);\n  else\n    ftpc->file = NULL; /* instead of point to a zero byte,\n                            we make it a NULL pointer */\n\n  if(data->state.upload && !ftpc->file && (ftp->transfer == PPTRANSFER_BODY)) {\n    /* We need a file name when uploading. Return error! */\n    failf(data, \"Uploading to a URL without a file name\");\n    free(rawPath);\n    return CURLE_URL_MALFORMAT;\n  }\n\n  ftpc->cwddone = FALSE; /* default to not done */\n\n  if((data->set.ftp_filemethod == FTPFILE_NOCWD) && (rawPath[0] == '/'))\n    ftpc->cwddone = TRUE; /* skip CWD for absolute paths */\n  else { /* newly created FTP connections are already in entry path */\n    const char *oldPath = conn->bits.reuse ? ftpc->prevpath : \"\";\n    if(oldPath) {\n      size_t n = pathLen;\n      if(data->set.ftp_filemethod == FTPFILE_NOCWD)\n        n = 0; /* CWD to entry for relative paths */\n      else\n        n -= ftpc->file?strlen(ftpc->file):0;\n\n      if((strlen(oldPath) == n) && !strncmp(rawPath, oldPath, n)) {\n        infof(data, \"Request has same path as previous transfer\");\n        ftpc->cwddone = TRUE;\n      }\n    }\n  }\n\n  free(rawPath);\n  return CURLE_OK;\n}\n\n/* call this when the DO phase has completed */\nstatic CURLcode ftp_dophase_done(struct Curl_easy *data, bool connected)\n{\n  struct connectdata *conn = data->conn;\n  struct FTP *ftp = data->req.p.ftp;\n  struct ftp_conn *ftpc = &conn->proto.ftpc;\n\n  if(connected) {\n    int completed;\n    CURLcode result = ftp_do_more(data, &completed);\n\n    if(result) {\n      close_secondarysocket(data, conn);\n      return result;\n    }\n  }\n\n  if(ftp->transfer != PPTRANSFER_BODY)\n    /* no data to transfer */\n    Curl_xfer_setup(data, -1, -1, FALSE, -1);\n  else if(!connected)\n    /* since we didn't connect now, we want do_more to get called */\n    conn->bits.do_more = TRUE;\n\n  ftpc->ctl_valid = TRUE; /* seems good */\n\n  return CURLE_OK;\n}\n\n/* called from multi.c while DOing */\nstatic CURLcode ftp_doing(struct Curl_easy *data,\n                          bool *dophase_done)\n{\n  CURLcode result = ftp_multi_statemach(data, dophase_done);\n\n  if(result)\n    DEBUGF(infof(data, \"DO phase failed\"));\n  else if(*dophase_done) {\n    result = ftp_dophase_done(data, FALSE /* not connected */);\n\n    DEBUGF(infof(data, \"DO phase is complete2\"));\n  }\n  return result;\n}\n\n/***********************************************************************\n *\n * ftp_regular_transfer()\n *\n * The input argument is already checked for validity.\n *\n * Performs all commands done before a regular transfer between a local and a\n * remote host.\n *\n * ftp->ctl_valid starts out as FALSE, and gets set to TRUE if we reach the\n * ftp_done() function without finding any major problem.\n */\nstatic\nCURLcode ftp_regular_transfer(struct Curl_easy *data,\n                              bool *dophase_done)\n{\n  CURLcode result = CURLE_OK;\n  bool connected = FALSE;\n  struct connectdata *conn = data->conn;\n  struct ftp_conn *ftpc = &conn->proto.ftpc;\n  data->req.size = -1; /* make sure this is unknown at this point */\n\n  Curl_pgrsSetUploadCounter(data, 0);\n  Curl_pgrsSetDownloadCounter(data, 0);\n  Curl_pgrsSetUploadSize(data, -1);\n  Curl_pgrsSetDownloadSize(data, -1);\n\n  ftpc->ctl_valid = TRUE; /* starts good */\n\n  result = ftp_perform(data,\n                       &connected, /* have we connected after PASV/PORT */\n                       dophase_done); /* all commands in the DO-phase done? */\n\n  if(!result) {\n\n    if(!*dophase_done)\n      /* the DO phase has not completed yet */\n      return CURLE_OK;\n\n    result = ftp_dophase_done(data, connected);\n\n    if(result)\n      return result;\n  }\n  else\n    freedirs(ftpc);\n\n  return result;\n}\n\nstatic CURLcode ftp_setup_connection(struct Curl_easy *data,\n                                     struct connectdata *conn)\n{\n  char *type;\n  struct FTP *ftp;\n  CURLcode result = CURLE_OK;\n  struct ftp_conn *ftpc = &conn->proto.ftpc;\n\n  ftp = calloc(1, sizeof(struct FTP));\n  if(!ftp)\n    return CURLE_OUT_OF_MEMORY;\n\n  /* clone connection related data that is FTP specific */\n  if(data->set.str[STRING_FTP_ACCOUNT]) {\n    ftpc->account = strdup(data->set.str[STRING_FTP_ACCOUNT]);\n    if(!ftpc->account) {\n      free(ftp);\n      return CURLE_OUT_OF_MEMORY;\n    }\n  }\n  if(data->set.str[STRING_FTP_ALTERNATIVE_TO_USER]) {\n    ftpc->alternative_to_user =\n      strdup(data->set.str[STRING_FTP_ALTERNATIVE_TO_USER]);\n    if(!ftpc->alternative_to_user) {\n      Curl_safefree(ftpc->account);\n      free(ftp);\n      return CURLE_OUT_OF_MEMORY;\n    }\n  }\n  data->req.p.ftp = ftp;\n\n  ftp->path = &data->state.up.path[1]; /* don't include the initial slash */\n\n  /* FTP URLs support an extension like \";type=<typecode>\" that\n   * we'll try to get now! */\n  type = strstr(ftp->path, \";type=\");\n\n  if(!type)\n    type = strstr(conn->host.rawalloc, \";type=\");\n\n  if(type) {\n    char command;\n    *type = 0;                     /* it was in the middle of the hostname */\n    command = Curl_raw_toupper(type[6]);\n\n    switch(command) {\n    case 'A': /* ASCII mode */\n      data->state.prefer_ascii = TRUE;\n      break;\n\n    case 'D': /* directory mode */\n      data->state.list_only = TRUE;\n      break;\n\n    case 'I': /* binary mode */\n    default:\n      /* switch off ASCII */\n      data->state.prefer_ascii = FALSE;\n      break;\n    }\n  }\n\n  /* get some initial data into the ftp struct */\n  ftp->transfer = PPTRANSFER_BODY;\n  ftp->downloadsize = 0;\n  ftpc->known_filesize = -1; /* unknown size for now */\n  ftpc->use_ssl = data->set.use_ssl;\n  ftpc->ccc = data->set.ftp_ccc;\n\n  return result;\n}\n\n#endif /* CURL_DISABLE_FTP */\n` was unexpected","path":"/home/qqq/curl-8.7.0/lib/ftp.c"},{"code":3,"level":"warn","type":["PartialParsing",[{"path":"/home/qqq/curl-8.7.0/lib/socketpair.c","start":{"line":154,"col":1,"offset":0},"end":{"line":154,"col":7,"offset":6}},{"path":"/home/qqq/curl-8.7.0/lib/socketpair.c","start":{"line":157,"col":1,"offset":0},"end":{"line":157,"col":6,"offset":5}},{"path":"/home/qqq/curl-8.7.0/lib/socketpair.c","start":{"line":163,"col":1,"offset":0},"end":{"line":163,"col":7,"offset":6}}]],"message":"Syntax error at line /home/qqq/curl-8.7.0/lib/socketpair.c:154:\n `#ifdef` was unexpected","path":"/home/qqq/curl-8.7.0/lib/socketpair.c","spans":[{"file":"/home/qqq/curl-8.7.0/lib/socketpair.c","start":{"line":154,"col":1,"offset":0},"end":{"line":154,"col":7,"offset":6}},{"file":"/home/qqq/curl-8.7.0/lib/socketpair.c","start":{"line":157,"col":1,"offset":0},"end":{"line":157,"col":6,"offset":5}},{"file":"/home/qqq/curl-8.7.0/lib/socketpair.c","start":{"line":163,"col":1,"offset":0},"end":{"line":163,"col":7,"offset":6}}]},{"code":3,"level":"warn","type":["PartialParsing",[{"path":"/home/qqq/curl-8.7.0/src/tool_vms.c","start":{"line":41,"col":6,"offset":0},"end":{"line":41,"col":10,"offset":4}},{"path":"/home/qqq/curl-8.7.0/src/tool_vms.c","start":{"line":42,"col":6,"offset":0},"end":{"line":42,"col":10,"offset":4}},{"path":"/home/qqq/curl-8.7.0/src/tool_vms.c","start":{"line":165,"col":18,"offset":0},"end":{"line":165,"col":22,"offset":4}},{"path":"/home/qqq/curl-8.7.0/src/tool_vms.c","start":{"line":169,"col":20,"offset":0},"end":{"line":169,"col":24,"offset":4}},{"path":"/home/qqq/curl-8.7.0/src/tool_vms.c","start":{"line":170,"col":24,"offset":0},"end":{"line":170,"col":28,"offset":4}},{"path":"/home/qqq/curl-8.7.0/src/tool_vms.c","start":{"line":171,"col":24,"offset":0},"end":{"line":171,"col":28,"offset":4}},{"path":"/home/qqq/curl-8.7.0/src/tool_vms.c","start":{"line":177,"col":17,"offset":0},"end":{"line":177,"col":21,"offset":4}},{"path":"/home/qqq/curl-8.7.0/src/tool_vms.c","start":{"line":211,"col":5,"offset":0},"end":{"line":211,"col":8,"offset":3}},{"path":"/home/qqq/curl-8.7.0/src/tool_vms.c","start":{"line":213,"col":5,"offset":0},"end":{"line":213,"col":12,"offset":7}},{"path":"/home/qqq/curl-8.7.0/src/tool_vms.c","start":{"line":213,"col":35,"offset":0},"end":{"line":213,"col":46,"offset":11}}]],"message":"Syntax error at line /home/qqq/curl-8.7.0/src/tool_vms.c:41:\n `decc` was unexpected","path":"/home/qqq/curl-8.7.0/src/tool_vms.c","spans":[{"file":"/home/qqq/curl-8.7.0/src/tool_vms.c","start":{"line":41,"col":6,"offset":0},"end":{"line":41,"col":10,"offset":4}},{"file":"/home/qqq/curl-8.7.0/src/tool_vms.c","start":{"line":42,"col":6,"offset":0},"end":{"line":42,"col":10,"offset":4}},{"file":"/home/qqq/curl-8.7.0/src/tool_vms.c","start":{"line":165,"col":18,"offset":0},"end":{"line":165,"col":22,"offset":4}},{"file":"/home/qqq/curl-8.7.0/src/tool_vms.c","start":{"line":169,"col":20,"offset":0},"end":{"line":169,"col":24,"offset":4}},{"file":"/home/qqq/curl-8.7.0/src/tool_vms.c","start":{"line":170,"col":24,"offset":0},"end":{"line":170,"col":28,"offset":4}},{"file":"/home/qqq/curl-8.7.0/src/tool_vms.c","start":{"line":171,"col":24,"offset":0},"end":{"line":171,"col":28,"offset":4}},{"file":"/home/qqq/curl-8.7.0/src/tool_vms.c","start":{"line":177,"col":17,"offset":0},"end":{"line":177,"col":21,"offset":4}},{"file":"/home/qqq/curl-8.7.0/src/tool_vms.c","start":{"line":211,"col":5,"offset":0},"end":{"line":211,"col":8,"offset":3}},{"file":"/home/qqq/curl-8.7.0/src/tool_vms.c","start":{"line":213,"col":5,"offset":0},"end":{"line":213,"col":12,"offset":7}},{"file":"/home/qqq/curl-8.7.0/src/tool_vms.c","start":{"line":213,"col":35,"offset":0},"end":{"line":213,"col":46,"offset":11}}]},{"code":3,"level":"warn","type":["PartialParsing",[{"path":"/home/qqq/curl-8.7.0/lib/hostip4.c","start":{"line":181,"col":3,"offset":0},"end":{"line":181,"col":7,"offset":4}},{"path":"/home/qqq/curl-8.7.0/lib/hostip4.c","start":{"line":275,"col":1,"offset":0},"end":{"line":275,"col":7,"offset":6}}]],"message":"Syntax error at line /home/qqq/curl-8.7.0/lib/hostip4.c:181:\n `else` was unexpected","path":"/home/qqq/curl-8.7.0/lib/hostip4.c","spans":[{"file":"/home/qqq/curl-8.7.0/lib/hostip4.c","start":{"line":181,"col":3,"offset":0},"end":{"line":181,"col":7,"offset":4}},{"file":"/home/qqq/curl-8.7.0/lib/hostip4.c","start":{"line":275,"col":1,"offset":0},"end":{"line":275,"col":7,"offset":6}}]},{"code":3,"level":"warn","type":["PartialParsing",[{"path":"/home/qqq/curl-8.7.0/lib/curl_addrinfo.c","start":{"line":80,"col":36,"offset":0},"end":{"line":80,"col":42,"offset":6}},{"path":"/home/qqq/curl-8.7.0/lib/curl_addrinfo.c","start":{"line":282,"col":1,"offset":0},"end":{"line":282,"col":7,"offset":6}}]],"message":"Syntax error at line /home/qqq/curl-8.7.0/lib/curl_addrinfo.c:80:\n `canext` was unexpected","path":"/home/qqq/curl-8.7.0/lib/curl_addrinfo.c","spans":[{"file":"/home/qqq/curl-8.7.0/lib/curl_addrinfo.c","start":{"line":80,"col":36,"offset":0},"end":{"line":80,"col":42,"offset":6}},{"file":"/home/qqq/curl-8.7.0/lib/curl_addrinfo.c","start":{"line":282,"col":1,"offset":0},"end":{"line":282,"col":7,"offset":6}}]},{"code":3,"level":"warn","type":["PartialParsing",[{"path":"/home/qqq/curl-8.7.0/src/tool_doswin.c","start":{"line":135,"col":1,"offset":0},"end":{"line":135,"col":7,"offset":6}},{"path":"/home/qqq/curl-8.7.0/src/tool_doswin.c","start":{"line":165,"col":1,"offset":0},"end":{"line":165,"col":7,"offset":6}},{"path":"/home/qqq/curl-8.7.0/src/tool_doswin.c","start":{"line":728,"col":13,"offset":0},"end":{"line":728,"col":19,"offset":6}}]],"message":"Syntax error at line /home/qqq/curl-8.7.0/src/tool_doswin.c:135:\n `#endif` was unexpected","path":"/home/qqq/curl-8.7.0/src/tool_doswin.c","spans":[{"file":"/home/qqq/curl-8.7.0/src/tool_doswin.c","start":{"line":135,"col":1,"offset":0},"end":{"line":135,"col":7,"offset":6}},{"file":"/home/qqq/curl-8.7.0/src/tool_doswin.c","start":{"line":165,"col":1,"offset":0},"end":{"line":165,"col":7,"offset":6}},{"file":"/home/qqq/curl-8.7.0/src/tool_doswin.c","start":{"line":728,"col":13,"offset":0},"end":{"line":728,"col":19,"offset":6}}]},{"code":3,"level":"warn","type":"Syntax error","message":"Syntax error at line /home/qqq/curl-8.7.0/lib/vtls/wolfssl.c:1:\n `/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n * SPDX-License-Identifier: curl\n *\n ***************************************************************************/\n\n/*\n * Source file for all wolfSSL specific code for the TLS/SSL layer. No code\n * but vtls.c should ever call or use these functions.\n *\n */\n\n#include \"curl_setup.h\"\n\n#ifdef USE_WOLFSSL\n\n#define WOLFSSL_OPTIONS_IGNORE_SYS\n#include <wolfssl/version.h>\n#include <wolfssl/options.h>\n\n/* To determine what functions are available we rely on one or both of:\n   - the user's options.h generated by wolfSSL\n   - the symbols detected by curl's configure\n   Since they are markedly different from one another, and one or the other may\n   not be available, we do some checking below to bring things in sync. */\n\n/* HAVE_ALPN is wolfSSL's build time symbol for enabling ALPN in options.h. */\n#ifndef HAVE_ALPN\n#ifdef HAVE_WOLFSSL_USEALPN\n#define HAVE_ALPN\n#endif\n#endif\n\n#include <limits.h>\n\n#include \"urldata.h\"\n#include \"sendf.h\"\n#include \"inet_pton.h\"\n#include \"vtls.h\"\n#include \"vtls_int.h\"\n#include \"keylog.h\"\n#include \"parsedate.h\"\n#include \"connect.h\" /* for the connect timeout */\n#include \"select.h\"\n#include \"strcase.h\"\n#include \"x509asn1.h\"\n#include \"curl_printf.h\"\n#include \"multiif.h\"\n\n#include <wolfssl/openssl/ssl.h>\n#include <wolfssl/ssl.h>\n#include <wolfssl/error-ssl.h>\n#include \"wolfssl.h\"\n\n/* The last #include files should be: */\n#include \"curl_memory.h\"\n#include \"memdebug.h\"\n\n/* KEEP_PEER_CERT is a product of the presence of build time symbol\n   OPENSSL_EXTRA without NO_CERTS, depending on the version. KEEP_PEER_CERT is\n   in wolfSSL's settings.h, and the latter two are build time symbols in\n   options.h. */\n#ifndef KEEP_PEER_CERT\n#if defined(HAVE_WOLFSSL_GET_PEER_CERTIFICATE) || \\\n    (defined(OPENSSL_EXTRA) && !defined(NO_CERTS))\n#define KEEP_PEER_CERT\n#endif\n#endif\n\n#if defined(HAVE_WOLFSSL_FULL_BIO) && HAVE_WOLFSSL_FULL_BIO\n#define USE_BIO_CHAIN\n#else\n#undef USE_BIO_CHAIN\n#endif\n\nstruct wolfssl_ssl_backend_data {\n  WOLFSSL_CTX *ctx;\n  WOLFSSL     *handle;\n  CURLcode    io_result;   /* result of last BIO cfilter operation */\n};\n\n#ifdef OPENSSL_EXTRA\n/*\n * Availability note:\n * The TLS 1.3 secret callback (wolfSSL_set_tls13_secret_cb) was added in\n * WolfSSL 4.4.0, but requires the -DHAVE_SECRET_CALLBACK build option. If that\n * option is not set, then TLS 1.3 will not be logged.\n * For TLS 1.2 and before, we use wolfSSL_get_keys().\n * SSL_get_client_random and wolfSSL_get_keys require OPENSSL_EXTRA\n * (--enable-opensslextra or --enable-all).\n */\n#if defined(HAVE_SECRET_CALLBACK) && defined(WOLFSSL_TLS13)\nstatic int\nwolfssl_tls13_secret_callback(SSL *ssl, int id, const unsigned char *secret,\n                              int secretSz, void *ctx)\n{\n  const char *label;\n  unsigned char client_random[SSL3_RANDOM_SIZE];\n  (void)ctx;\n\n  if(!ssl || !Curl_tls_keylog_enabled()) {\n    return 0;\n  }\n\n  switch(id) {\n  case CLIENT_EARLY_TRAFFIC_SECRET:\n    label = \"CLIENT_EARLY_TRAFFIC_SECRET\";\n    break;\n  case CLIENT_HANDSHAKE_TRAFFIC_SECRET:\n    label = \"CLIENT_HANDSHAKE_TRAFFIC_SECRET\";\n    break;\n  case SERVER_HANDSHAKE_TRAFFIC_SECRET:\n    label = \"SERVER_HANDSHAKE_TRAFFIC_SECRET\";\n    break;\n  case CLIENT_TRAFFIC_SECRET:\n    label = \"CLIENT_TRAFFIC_SECRET_0\";\n    break;\n  case SERVER_TRAFFIC_SECRET:\n    label = \"SERVER_TRAFFIC_SECRET_0\";\n    break;\n  case EARLY_EXPORTER_SECRET:\n    label = \"EARLY_EXPORTER_SECRET\";\n    break;\n  case EXPORTER_SECRET:\n    label = \"EXPORTER_SECRET\";\n    break;\n  default:\n    return 0;\n  }\n\n  if(SSL_get_client_random(ssl, client_random, SSL3_RANDOM_SIZE) == 0) {\n    /* Should never happen as wolfSSL_KeepArrays() was called before. */\n    return 0;\n  }\n\n  Curl_tls_keylog_write(label, client_random, secret, secretSz);\n  return 0;\n}\n#endif /* defined(HAVE_SECRET_CALLBACK) && defined(WOLFSSL_TLS13) */\n\nstatic void\nwolfssl_log_tls12_secret(SSL *ssl)\n{\n  unsigned char *ms, *sr, *cr;\n  unsigned int msLen, srLen, crLen, i, x = 0;\n\n#if LIBWOLFSSL_VERSION_HEX >= 0x0300d000 /* >= 3.13.0 */\n  /* wolfSSL_GetVersion is available since 3.13, we use it instead of\n   * SSL_version since the latter relies on OPENSSL_ALL (--enable-opensslall or\n   * --enable-all). Failing to perform this check could result in an unusable\n   * key log line when TLS 1.3 is actually negotiated. */\n  switch(wolfSSL_GetVersion(ssl)) {\n  case WOLFSSL_SSLV3:\n  case WOLFSSL_TLSV1:\n  case WOLFSSL_TLSV1_1:\n  case WOLFSSL_TLSV1_2:\n    break;\n  default:\n    /* TLS 1.3 does not use this mechanism, the \"master secret\" returned below\n     * is not directly usable. */\n    return;\n  }\n#endif\n\n  if(wolfSSL_get_keys(ssl, &ms, &msLen, &sr, &srLen, &cr, &crLen) !=\n     SSL_SUCCESS) {\n    return;\n  }\n\n  /* Check for a missing master secret and skip logging. That can happen if\n   * curl rejects the server certificate and aborts the handshake.\n   */\n  for(i = 0; i < msLen; i++) {\n    x |= ms[i];\n  }\n  if(x == 0) {\n    return;\n  }\n\n  Curl_tls_keylog_write(\"CLIENT_RANDOM\", cr, ms, msLen);\n}\n#endif /* OPENSSL_EXTRA */\n\nstatic int do_file_type(const char *type)\n{\n  if(!type || !type[0])\n    return SSL_FILETYPE_PEM;\n  if(strcasecompare(type, \"PEM\"))\n    return SSL_FILETYPE_PEM;\n  if(strcasecompare(type, \"DER\"))\n    return SSL_FILETYPE_ASN1;\n  return -1;\n}\n\n#ifdef HAVE_LIBOQS\nstruct group_name_map {\n  const word16 group;\n  const char   *name;\n};\n\nstatic const struct group_name_map gnm[] = {\n  { WOLFSSL_KYBER_LEVEL1, \"KYBER_LEVEL1\" },\n  { WOLFSSL_KYBER_LEVEL3, \"KYBER_LEVEL3\" },\n  { WOLFSSL_KYBER_LEVEL5, \"KYBER_LEVEL5\" },\n  { WOLFSSL_P256_KYBER_LEVEL1, \"P256_KYBER_LEVEL1\" },\n  { WOLFSSL_P384_KYBER_LEVEL3, \"P384_KYBER_LEVEL3\" },\n  { WOLFSSL_P521_KYBER_LEVEL5, \"P521_KYBER_LEVEL5\" },\n  { 0, NULL }\n};\n#endif\n\n#ifdef USE_BIO_CHAIN\n\nstatic int wolfssl_bio_cf_create(WOLFSSL_BIO *bio)\n{\n  wolfSSL_BIO_set_shutdown(bio, 1);\n  wolfSSL_BIO_set_data(bio, NULL);\n  return 1;\n}\n\nstatic int wolfssl_bio_cf_destroy(WOLFSSL_BIO *bio)\n{\n  if(!bio)\n    return 0;\n  return 1;\n}\n\nstatic long wolfssl_bio_cf_ctrl(WOLFSSL_BIO *bio, int cmd, long num, void *ptr)\n{\n  struct Curl_cfilter *cf = BIO_get_data(bio);\n  long ret = 1;\n\n  (void)cf;\n  (void)ptr;\n  switch(cmd) {\n  case BIO_CTRL_GET_CLOSE:\n    ret = (long)wolfSSL_BIO_get_shutdown(bio);\n    break;\n  case BIO_CTRL_SET_CLOSE:\n    wolfSSL_BIO_set_shutdown(bio, (int)num);\n    break;\n  case BIO_CTRL_FLUSH:\n    /* we do no delayed writes, but if we ever would, this\n     * needs to trigger it. */\n    ret = 1;\n    break;\n  case BIO_CTRL_DUP:\n    ret = 1;\n    break;\n#ifdef BIO_CTRL_EOF\n  case BIO_CTRL_EOF:\n    /* EOF has been reached on input? */\n    return (!cf->next || !cf->next->connected);\n#endif\n  default:\n    ret = 0;\n    break;\n  }\n  return ret;\n}\n\nstatic int wolfssl_bio_cf_out_write(WOLFSSL_BIO *bio,\n                                    const char *buf, int blen)\n{\n  struct Curl_cfilter *cf = wolfSSL_BIO_get_data(bio);\n  struct ssl_connect_data *connssl = cf->ctx;\n  struct wolfssl_ssl_backend_data *backend =\n    (struct wolfssl_ssl_backend_data *)connssl->backend;\n  struct Curl_easy *data = CF_DATA_CURRENT(cf);\n  ssize_t nwritten;\n  CURLcode result = CURLE_OK;\n\n  DEBUGASSERT(data);\n  nwritten = Curl_conn_cf_send(cf->next, data, buf, blen, &result);\n  backend->io_result = result;\n  CURL_TRC_CF(data, cf, \"bio_write(len=%d) -> %zd, %d\",\n              blen, nwritten, result);\n  wolfSSL_BIO_clear_retry_flags(bio);\n  if(nwritten < 0 && CURLE_AGAIN == result)\n    BIO_set_retry_write(bio);\n  return (int)nwritten;\n}\n\nstatic int wolfssl_bio_cf_in_read(WOLFSSL_BIO *bio, char *buf, int blen)\n{\n  struct Curl_cfilter *cf = wolfSSL_BIO_get_data(bio);\n  struct ssl_connect_data *connssl = cf->ctx;\n  struct wolfssl_ssl_backend_data *backend =\n    (struct wolfssl_ssl_backend_data *)connssl->backend;\n  struct Curl_easy *data = CF_DATA_CURRENT(cf);\n  ssize_t nread;\n  CURLcode result = CURLE_OK;\n\n  DEBUGASSERT(data);\n  /* OpenSSL catches this case, so should we. */\n  if(!buf)\n    return 0;\n\n  nread = Curl_conn_cf_recv(cf->next, data, buf, blen, &result);\n  backend->io_result = result;\n  CURL_TRC_CF(data, cf, \"bio_read(len=%d) -> %zd, %d\", blen, nread, result);\n  wolfSSL_BIO_clear_retry_flags(bio);\n  if(nread < 0 && CURLE_AGAIN == result)\n    BIO_set_retry_read(bio);\n  else if(nread == 0)\n    connssl->peer_closed = TRUE;\n  return (int)nread;\n}\n\nstatic WOLFSSL_BIO_METHOD *wolfssl_bio_cf_method = NULL;\n\nstatic void wolfssl_bio_cf_init_methods(void)\n{\n  wolfssl_bio_cf_method = wolfSSL_BIO_meth_new(BIO_TYPE_MEM, \"wolfSSL CF BIO\");\n  wolfSSL_BIO_meth_set_write(wolfssl_bio_cf_method, &wolfssl_bio_cf_out_write);\n  wolfSSL_BIO_meth_set_read(wolfssl_bio_cf_method, &wolfssl_bio_cf_in_read);\n  wolfSSL_BIO_meth_set_ctrl(wolfssl_bio_cf_method, &wolfssl_bio_cf_ctrl);\n  wolfSSL_BIO_meth_set_create(wolfssl_bio_cf_method, &wolfssl_bio_cf_create);\n  wolfSSL_BIO_meth_set_destroy(wolfssl_bio_cf_method, &wolfssl_bio_cf_destroy);\n}\n\nstatic void wolfssl_bio_cf_free_methods(void)\n{\n  wolfSSL_BIO_meth_free(wolfssl_bio_cf_method);\n}\n\n#else /* USE_BIO_CHAIN */\n\n#define wolfssl_bio_cf_init_methods() Curl_nop_stmt\n#define wolfssl_bio_cf_free_methods() Curl_nop_stmt\n\n#endif /* !USE_BIO_CHAIN */\n\n/*\n * This function loads all the client/CA certificates and CRLs. Setup the TLS\n * layer and do all necessary magic.\n */\nstatic CURLcode\nwolfssl_connect_step1(struct Curl_cfilter *cf, struct Curl_easy *data)\n{\n  char *ciphers, *curves;\n  struct ssl_connect_data *connssl = cf->ctx;\n  struct wolfssl_ssl_backend_data *backend =\n    (struct wolfssl_ssl_backend_data *)connssl->backend;\n  struct ssl_primary_config *conn_config = Curl_ssl_cf_get_primary_config(cf);\n  const struct curl_blob *ca_info_blob = conn_config->ca_info_blob;\n  const struct ssl_config_data *ssl_config = Curl_ssl_cf_get_config(cf, data);\n  const char * const ssl_cafile =\n    /* CURLOPT_CAINFO_BLOB overrides CURLOPT_CAINFO */\n    (ca_info_blob ? NULL : conn_config->CAfile);\n  const char * const ssl_capath = conn_config->CApath;\n  WOLFSSL_METHOD* req_method = NULL;\n#ifdef HAVE_LIBOQS\n  word16 oqsAlg = 0;\n  size_t idx = 0;\n#endif\n#ifdef HAVE_SNI\n  bool sni = FALSE;\n#define use_sni(x)  sni = (x)\n#else\n#define use_sni(x)  Curl_nop_stmt\n#endif\n  bool imported_native_ca = false;\n  bool imported_ca_info_blob = false;\n\n  DEBUGASSERT(backend);\n\n  if(connssl->state == ssl_connection_complete)\n    return CURLE_OK;\n\n  if(conn_config->version_max != CURL_SSLVERSION_MAX_NONE) {\n    failf(data, \"wolfSSL does not support to set maximum SSL/TLS version\");\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n\n  /* check to see if we've been told to use an explicit SSL/TLS version */\n  switch(conn_config->version) {\n  case CURL_SSLVERSION_DEFAULT:\n  case CURL_SSLVERSION_TLSv1:\n#if LIBWOLFSSL_VERSION_HEX >= 0x03003000 /* >= 3.3.0 */\n    /* minimum protocol version is set later after the CTX object is created */\n    req_method = SSLv23_client_method();\n#else\n    infof(data, \"wolfSSL <3.3.0 cannot be configured to use TLS 1.0-1.2, \"\n          \"TLS 1.0 is used exclusively\");\n    req_method = TLSv1_client_method();\n#endif\n    use_sni(TRUE);\n    break;\n  case CURL_SSLVERSION_TLSv1_0:\n#if defined(WOLFSSL_ALLOW_TLSV10) && !defined(NO_OLD_TLS)\n    req_method = TLSv1_client_method();\n    use_sni(TRUE);\n#else\n    failf(data, \"wolfSSL does not support TLS 1.0\");\n    return CURLE_NOT_BUILT_IN;\n#endif\n    break;\n  case CURL_SSLVERSION_TLSv1_1:\n#ifndef NO_OLD_TLS\n    req_method = TLSv1_1_client_method();\n    use_sni(TRUE);\n#else\n    failf(data, \"wolfSSL does not support TLS 1.1\");\n    return CURLE_NOT_BUILT_IN;\n#endif\n    break;\n  case CURL_SSLVERSION_TLSv1_2:\n#ifndef WOLFSSL_NO_TLS12\n    req_method = TLSv1_2_client_method();\n    use_sni(TRUE);\n#else\n    failf(data, \"wolfSSL does not support TLS 1.2\");\n    return CURLE_NOT_BUILT_IN;\n#endif\n    break;\n  case CURL_SSLVERSION_TLSv1_3:\n#ifdef WOLFSSL_TLS13\n    req_method = wolfTLSv1_3_client_method();\n    use_sni(TRUE);\n    break;\n#else\n    failf(data, \"wolfSSL: TLS 1.3 is not yet supported\");\n    return CURLE_SSL_CONNECT_ERROR;\n#endif\n  default:\n    failf(data, \"Unrecognized parameter passed via CURLOPT_SSLVERSION\");\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n\n  if(!req_method) {\n    failf(data, \"SSL: couldn't create a method\");\n    return CURLE_OUT_OF_MEMORY;\n  }\n\n  if(backend->ctx)\n    wolfSSL_CTX_free(backend->ctx);\n  backend->ctx = wolfSSL_CTX_new(req_method);\n\n  if(!backend->ctx) {\n    failf(data, \"SSL: couldn't create a context\");\n    return CURLE_OUT_OF_MEMORY;\n  }\n\n  switch(conn_config->version) {\n  case CURL_SSLVERSION_DEFAULT:\n  case CURL_SSLVERSION_TLSv1:\n#if LIBWOLFSSL_VERSION_HEX > 0x03004006 /* > 3.4.6 */\n    /* Versions 3.3.0 to 3.4.6 we know the minimum protocol version is\n     * whatever minimum version of TLS was built in and at least TLS 1.0. For\n     * later library versions that could change (eg TLS 1.0 built in but\n     * defaults to TLS 1.1) so we have this short circuit evaluation to find\n     * the minimum supported TLS version.\n    */\n    if((wolfSSL_CTX_SetMinVersion(backend->ctx, WOLFSSL_TLSV1) != 1) &&\n       (wolfSSL_CTX_SetMinVersion(backend->ctx, WOLFSSL_TLSV1_1) != 1) &&\n       (wolfSSL_CTX_SetMinVersion(backend->ctx, WOLFSSL_TLSV1_2) != 1)\n#ifdef WOLFSSL_TLS13\n       && (wolfSSL_CTX_SetMinVersion(backend->ctx, WOLFSSL_TLSV1_3) != 1)\n#endif\n      ) {\n      failf(data, \"SSL: couldn't set the minimum protocol version\");\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n#endif\n  default:\n    break;\n  }\n\n  ciphers = conn_config->cipher_list;\n  if(ciphers) {\n    if(!SSL_CTX_set_cipher_list(backend->ctx, ciphers)) {\n      failf(data, \"failed setting cipher list: %s\", ciphers);\n      return CURLE_SSL_CIPHER;\n    }\n    infof(data, \"Cipher selection: %s\", ciphers);\n  }\n\n  curves = conn_config->curves;\n  if(curves) {\n\n#ifdef HAVE_LIBOQS\n    for(idx = 0; gnm[idx].name != NULL; idx++) {\n      if(strncmp(curves, gnm[idx].name, strlen(gnm[idx].name)) == 0) {\n        oqsAlg = gnm[idx].group;\n        break;\n      }\n    }\n\n    if(oqsAlg == 0)\n#endif\n    {\n      if(!SSL_CTX_set1_curves_list(backend->ctx, curves)) {\n        failf(data, \"failed setting curves list: '%s'\", curves);\n        return CURLE_SSL_CIPHER;\n      }\n    }\n  }\n\n#if !defined(NO_FILESYSTEM) && defined(WOLFSSL_SYS_CA_CERTS)\n  /* load native CA certificates */\n  if(ssl_config->native_ca_store) {\n    if(wolfSSL_CTX_load_system_CA_certs(backend->ctx) != WOLFSSL_SUCCESS) {\n      infof(data, \"error importing native CA store, continuing anyway\");\n    }\n    else {\n      imported_native_ca = true;\n      infof(data, \"successfully imported native CA store\");\n    }\n  }\n#endif /* !NO_FILESYSTEM */\n\n  /* load certificate blob */\n  if(ca_info_blob) {\n    if(wolfSSL_CTX_load_verify_buffer(backend->ctx, ca_info_blob->data,\n                                      ca_info_blob->len,\n                                      SSL_FILETYPE_PEM) != SSL_SUCCESS) {\n      if(imported_native_ca) {\n        infof(data, \"error importing CA certificate blob, continuing anyway\");\n      }\n      else {\n        failf(data, \"error importing CA certificate blob\");\n        return CURLE_SSL_CACERT_BADFILE;\n      }\n    }\n    else {\n      imported_ca_info_blob = true;\n      infof(data, \"successfully imported CA certificate blob\");\n    }\n  }\n\n#ifndef NO_FILESYSTEM\n  /* load trusted cacert from file if not blob */\n  if(ssl_cafile || ssl_capath) {\n    int rc =\n      wolfSSL_CTX_load_verify_locations_ex(backend->ctx,\n                                           ssl_cafile,\n                                           ssl_capath,\n                                           WOLFSSL_LOAD_FLAG_IGNORE_ERR);\n    if(SSL_SUCCESS != rc) {\n      if(conn_config->verifypeer && !imported_ca_info_blob &&\n         !imported_native_ca) {\n        /* Fail if we insist on successfully verifying the server. */\n        failf(data, \"error setting certificate verify locations:\"\n              \" CAfile: %s CApath: %s\",\n              ssl_cafile ? ssl_cafile : \"none\",\n              ssl_capath ? ssl_capath : \"none\");\n        return CURLE_SSL_CACERT_BADFILE;\n      }\n      else {\n        /* Just continue with a warning if no strict certificate\n           verification is required. */\n        infof(data, \"error setting certificate verify locations,\"\n              \" continuing anyway:\");\n      }\n    }\n    else {\n      /* Everything is fine. */\n      infof(data, \"successfully set certificate verify locations:\");\n    }\n    infof(data, \" CAfile: %s\", ssl_cafile ? ssl_cafile : \"none\");\n    infof(data, \" CApath: %s\", ssl_capath ? ssl_capath : \"none\");\n  }\n\n  /* Load the client certificate, and private key */\n  if(ssl_config->primary.clientcert && ssl_config->key) {\n    int file_type = do_file_type(ssl_config->cert_type);\n\n    if(file_type == WOLFSSL_FILETYPE_PEM) {\n      if(wolfSSL_CTX_use_certificate_chain_file(backend->ctx,\n                                                ssl_config->primary.clientcert)\n         != 1) {\n        failf(data, \"unable to use client certificate\");\n        return CURLE_SSL_CONNECT_ERROR;\n      }\n    }\n    else if(file_type == WOLFSSL_FILETYPE_ASN1) {\n      if(wolfSSL_CTX_use_certificate_file(backend->ctx,\n                                          ssl_config->primary.clientcert,\n                                          file_type) != 1) {\n        failf(data, \"unable to use client certificate\");\n        return CURLE_SSL_CONNECT_ERROR;\n      }\n    }\n    else {\n      failf(data, \"unknown cert type\");\n      return CURLE_BAD_FUNCTION_ARGUMENT;\n    }\n\n    file_type = do_file_type(ssl_config->key_type);\n    if(wolfSSL_CTX_use_PrivateKey_file(backend->ctx, ssl_config->key,\n                                       file_type) != 1) {\n      failf(data, \"unable to set private key\");\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n  }\n#endif /* !NO_FILESYSTEM */\n\n  /* SSL always tries to verify the peer, this only says whether it should\n   * fail to connect if the verification fails, or if it should continue\n   * anyway. In the latter case the result of the verification is checked with\n   * SSL_get_verify_result() below. */\n  wolfSSL_CTX_set_verify(backend->ctx,\n                         conn_config->verifypeer?SSL_VERIFY_PEER:\n                         SSL_VERIFY_NONE, NULL);\n\n#ifdef HAVE_SNI\n  if(sni && connssl->peer.sni) {\n    size_t sni_len = strlen(connssl->peer.sni);\n    if((sni_len < USHRT_MAX)) {\n      if(wolfSSL_CTX_UseSNI(backend->ctx, WOLFSSL_SNI_HOST_NAME,\n                            connssl->peer.sni,\n                            (unsigned short)sni_len) != 1) {\n        failf(data, \"Failed to set SNI\");\n        return CURLE_SSL_CONNECT_ERROR;\n      }\n    }\n  }\n#endif\n\n  /* give application a chance to interfere with SSL set up. */\n  if(data->set.ssl.fsslctx) {\n    CURLcode result = (*data->set.ssl.fsslctx)(data, backend->ctx,\n                                               data->set.ssl.fsslctxp);\n    if(result) {\n      failf(data, \"error signaled by ssl ctx callback\");\n      return result;\n    }\n  }\n#ifdef NO_FILESYSTEM\n  else if(conn_config->verifypeer) {\n    failf(data, \"SSL: Certificates can't be loaded because wolfSSL was built\"\n          \" with \\\"no filesystem\\\". Either disable peer verification\"\n          \" (insecure) or if you are building an application with libcurl you\"\n          \" can load certificates via CURLOPT_SSL_CTX_FUNCTION.\");\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n#endif\n\n  /* Let's make an SSL structure */\n  if(backend->handle)\n    wolfSSL_free(backend->handle);\n  backend->handle = wolfSSL_new(backend->ctx);\n  if(!backend->handle) {\n    failf(data, \"SSL: couldn't create a handle\");\n    return CURLE_OUT_OF_MEMORY;\n  }\n\n#ifdef HAVE_LIBOQS\n  if(oqsAlg) {\n    if(wolfSSL_UseKeyShare(backend->handle, oqsAlg) != WOLFSSL_SUCCESS) {\n      failf(data, \"unable to use oqs KEM\");\n    }\n  }\n#endif\n\n#ifdef HAVE_ALPN\n  if(connssl->alpn) {\n    struct alpn_proto_buf proto;\n    CURLcode result;\n\n    result = Curl_alpn_to_proto_str(&proto, connssl->alpn);\n    if(result ||\n       wolfSSL_UseALPN(backend->handle, (char *)proto.data, proto.len,\n                       WOLFSSL_ALPN_CONTINUE_ON_MISMATCH) != SSL_SUCCESS) {\n      failf(data, \"SSL: failed setting ALPN protocols\");\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n    infof(data, VTLS_INFOF_ALPN_OFFER_1STR, proto.data);\n  }\n#endif /* HAVE_ALPN */\n\n#ifdef OPENSSL_EXTRA\n  if(Curl_tls_keylog_enabled()) {\n    /* Ensure the Client Random is preserved. */\n    wolfSSL_KeepArrays(backend->handle);\n#if defined(HAVE_SECRET_CALLBACK) && defined(WOLFSSL_TLS13)\n    wolfSSL_set_tls13_secret_cb(backend->handle,\n                                wolfssl_tls13_secret_callback, NULL);\n#endif\n  }\n#endif /* OPENSSL_EXTRA */\n\n#ifdef HAVE_SECURE_RENEGOTIATION\n  if(wolfSSL_UseSecureRenegotiation(backend->handle) != SSL_SUCCESS) {\n    failf(data, \"SSL: failed setting secure renegotiation\");\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n#endif /* HAVE_SECURE_RENEGOTIATION */\n\n  /* Check if there's a cached ID we can/should use here! */\n  if(ssl_config->primary.sessionid) {\n    void *ssl_sessionid = NULL;\n\n    Curl_ssl_sessionid_lock(data);\n    if(!Curl_ssl_getsessionid(cf, data, &ssl_sessionid, NULL)) {\n      /* we got a session id, use it! */\n      if(!SSL_set_session(backend->handle, ssl_sessionid)) {\n        Curl_ssl_delsessionid(data, ssl_sessionid);\n        infof(data, \"Can't use session ID, going on without\");\n      }\n      else\n        infof(data, \"SSL reusing session ID\");\n    }\n    Curl_ssl_sessionid_unlock(data);\n  }\n\n#ifdef USE_BIO_CHAIN\n  {\n    WOLFSSL_BIO *bio;\n\n    bio = BIO_new(wolfssl_bio_cf_method);\n    if(!bio)\n      return CURLE_OUT_OF_MEMORY;\n\n    wolfSSL_BIO_set_data(bio, cf);\n    wolfSSL_set_bio(backend->handle, bio, bio);\n  }\n#else /* USE_BIO_CHAIN */\n  /* pass the raw socket into the SSL layer */\n  if(!wolfSSL_set_fd(backend->handle,\n                     (int)Curl_conn_cf_get_socket(cf, data))) {\n    failf(data, \"SSL: SSL_set_fd failed\");\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n#endif /* !USE_BIO_CHAIN */\n\n  connssl->connecting_state = ssl_connect_2;\n  return CURLE_OK;\n}\n\n\nstatic CURLcode\nwolfssl_connect_step2(struct Curl_cfilter *cf, struct Curl_easy *data)\n{\n  int ret = -1;\n  struct ssl_connect_data *connssl = cf->ctx;\n  struct wolfssl_ssl_backend_data *backend =\n    (struct wolfssl_ssl_backend_data *)connssl->backend;\n  struct ssl_primary_config *conn_config = Curl_ssl_cf_get_primary_config(cf);\n  const char * const pinnedpubkey = Curl_ssl_cf_is_proxy(cf)?\n    data->set.str[STRING_SSL_PINNEDPUBLICKEY_PROXY]:\n    data->set.str[STRING_SSL_PINNEDPUBLICKEY];\n\n  DEBUGASSERT(backend);\n\n  wolfSSL_ERR_clear_error();\n\n  /* Enable RFC2818 checks */\n  if(conn_config->verifyhost) {\n    char *snihost = connssl->peer.sni?\n                    connssl->peer.sni : connssl->peer.hostname;\n    if(wolfSSL_check_domain_name(backend->handle, snihost) == SSL_FAILURE)\n      return CURLE_SSL_CONNECT_ERROR;\n  }\n\n  ret = wolfSSL_connect(backend->handle);\n\n#ifdef OPENSSL_EXTRA\n  if(Curl_tls_keylog_enabled()) {\n    /* If key logging is enabled, wait for the handshake to complete and then\n     * proceed with logging secrets (for TLS 1.2 or older).\n     *\n     * During the handshake (ret==-1), wolfSSL_want_read() is true as it waits\n     * for the server response. At that point the master secret is not yet\n     * available, so we must not try to read it.\n     * To log the secret on completion with a handshake failure, detect\n     * completion via the observation that there is nothing to read or write.\n     * Note that OpenSSL SSL_want_read() is always true here. If wolfSSL ever\n     * changes, the worst case is that no key is logged on error.\n     */\n    if(ret == SSL_SUCCESS ||\n       (!wolfSSL_want_read(backend->handle) &&\n        !wolfSSL_want_write(backend->handle))) {\n      wolfssl_log_tls12_secret(backend->handle);\n      /* Client Random and master secrets are no longer needed, erase these.\n       * Ignored while the handshake is still in progress. */\n      wolfSSL_FreeArrays(backend->handle);\n    }\n  }\n#endif  /* OPENSSL_EXTRA */\n\n  if(ret != 1) {\n    char error_buffer[WOLFSSL_MAX_ERROR_SZ];\n    int  detail = wolfSSL_get_error(backend->handle, ret);\n\n    if(SSL_ERROR_WANT_READ == detail) {\n      connssl->connecting_state = ssl_connect_2_reading;\n      return CURLE_OK;\n    }\n    else if(SSL_ERROR_WANT_WRITE == detail) {\n      connssl->connecting_state = ssl_connect_2_writing;\n      return CURLE_OK;\n    }\n    /* There is no easy way to override only the CN matching.\n     * This will enable the override of both mismatching SubjectAltNames\n     * as also mismatching CN fields */\n    else if(DOMAIN_NAME_MISMATCH == detail) {\n#if 1\n      failf(data, \" subject alt name(s) or common name do not match \\\"%s\\\"\",\n            connssl->peer.dispname);\n      return CURLE_PEER_FAILED_VERIFICATION;\n#else\n      /* When the wolfssl_check_domain_name() is used and you desire to\n       * continue on a DOMAIN_NAME_MISMATCH, i.e. 'ssl_config.verifyhost\n       * == 0', CyaSSL version 2.4.0 will fail with an INCOMPLETE_DATA\n       * error. The only way to do this is currently to switch the\n       * Wolfssl_check_domain_name() in and out based on the\n       * 'ssl_config.verifyhost' value. */\n      if(conn_config->verifyhost) {\n        failf(data,\n              \" subject alt name(s) or common name do not match \\\"%s\\\"\\n\",\n              connssl->dispname);\n        return CURLE_PEER_FAILED_VERIFICATION;\n      }\n      else {\n        infof(data,\n              \" subject alt name(s) and/or common name do not match \\\"%s\\\"\",\n              connssl->dispname);\n        return CURLE_OK;\n      }\n#endif\n    }\n#if LIBWOLFSSL_VERSION_HEX >= 0x02007000 /* 2.7.0 */\n    else if(ASN_NO_SIGNER_E == detail) {\n      if(conn_config->verifypeer) {\n        failf(data, \" CA signer not available for verification\");\n        return CURLE_SSL_CACERT_BADFILE;\n      }\n      else {\n        /* Just continue with a warning if no strict certificate\n           verification is required. */\n        infof(data, \"CA signer not available for verification, \"\n                    \"continuing anyway\");\n      }\n    }\n#endif\n    else if(backend->io_result == CURLE_AGAIN) {\n      return CURLE_OK;\n    }\n    else {\n      failf(data, \"SSL_connect failed with error %d: %s\", detail,\n            wolfSSL_ERR_error_string(detail, error_buffer));\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n  }\n\n  if(pinnedpubkey) {\n#ifdef KEEP_PEER_CERT\n    X509 *x509;\n    const char *x509_der;\n    int x509_der_len;\n    struct Curl_X509certificate x509_parsed;\n    struct Curl_asn1Element *pubkey;\n    CURLcode result;\n\n    x509 = wolfSSL_get_peer_certificate(backend->handle);\n    if(!x509) {\n      failf(data, \"SSL: failed retrieving server certificate\");\n      return CURLE_SSL_PINNEDPUBKEYNOTMATCH;\n    }\n\n    x509_der = (const char *)wolfSSL_X509_get_der(x509, &x509_der_len);\n    if(!x509_der) {\n      failf(data, \"SSL: failed retrieving ASN.1 server certificate\");\n      return CURLE_SSL_PINNEDPUBKEYNOTMATCH;\n    }\n\n    memset(&x509_parsed, 0, sizeof(x509_parsed));\n    if(Curl_parseX509(&x509_parsed, x509_der, x509_der + x509_der_len))\n      return CURLE_SSL_PINNEDPUBKEYNOTMATCH;\n\n    pubkey = &x509_parsed.subjectPublicKeyInfo;\n    if(!pubkey->header || pubkey->end <= pubkey->header) {\n      failf(data, \"SSL: failed retrieving public key from server certificate\");\n      return CURLE_SSL_PINNEDPUBKEYNOTMATCH;\n    }\n\n    result = Curl_pin_peer_pubkey(data,\n                                  pinnedpubkey,\n                                  (const unsigned char *)pubkey->header,\n                                  (size_t)(pubkey->end - pubkey->header));\n    if(result) {\n      failf(data, \"SSL: public key does not match pinned public key\");\n      return result;\n    }\n#else\n    failf(data, \"Library lacks pinning support built-in\");\n    return CURLE_NOT_BUILT_IN;\n#endif\n  }\n\n#ifdef HAVE_ALPN\n  if(connssl->alpn) {\n    int rc;\n    char *protocol = NULL;\n    unsigned short protocol_len = 0;\n\n    rc = wolfSSL_ALPN_GetProtocol(backend->handle, &protocol, &protocol_len);\n\n    if(rc == SSL_SUCCESS) {\n      Curl_alpn_set_negotiated(cf, data, (const unsigned char *)protocol,\n                               protocol_len);\n    }\n    else if(rc == SSL_ALPN_NOT_FOUND)\n      Curl_alpn_set_negotiated(cf, data, NULL, 0);\n    else {\n      failf(data, \"ALPN, failure getting protocol, error %d\", rc);\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n  }\n#endif /* HAVE_ALPN */\n\n  connssl->connecting_state = ssl_connect_3;\n#if (LIBWOLFSSL_VERSION_HEX >= 0x03009010)\n  infof(data, \"SSL connection using %s / %s\",\n        wolfSSL_get_version(backend->handle),\n        wolfSSL_get_cipher_name(backend->handle));\n#else\n  infof(data, \"SSL connected\");\n#endif\n\n  return CURLE_OK;\n}\n\n\nstatic CURLcode\nwolfssl_connect_step3(struct Curl_cfilter *cf, struct Curl_easy *data)\n{\n  CURLcode result = CURLE_OK;\n  struct ssl_connect_data *connssl = cf->ctx;\n  struct wolfssl_ssl_backend_data *backend =\n    (struct wolfssl_ssl_backend_data *)connssl->backend;\n  const struct ssl_config_data *ssl_config = Curl_ssl_cf_get_config(cf, data);\n\n  DEBUGASSERT(ssl_connect_3 == connssl->connecting_state);\n  DEBUGASSERT(backend);\n\n  if(ssl_config->primary.sessionid) {\n    bool incache;\n    bool added = FALSE;\n    void *old_ssl_sessionid = NULL;\n    /* wolfSSL_get1_session allocates memory that has to be freed. */\n    WOLFSSL_SESSION *our_ssl_sessionid = wolfSSL_get1_session(backend->handle);\n\n    if(our_ssl_sessionid) {\n      Curl_ssl_sessionid_lock(data);\n      incache = !(Curl_ssl_getsessionid(cf, data, &old_ssl_sessionid, NULL));\n      if(incache) {\n        if(old_ssl_sessionid != our_ssl_sessionid) {\n          infof(data, \"old SSL session ID is stale, removing\");\n          Curl_ssl_delsessionid(data, old_ssl_sessionid);\n          incache = FALSE;\n        }\n      }\n\n      if(!incache) {\n        result = Curl_ssl_addsessionid(cf, data, our_ssl_sessionid, 0, NULL);\n        if(result) {\n          Curl_ssl_sessionid_unlock(data);\n          wolfSSL_SESSION_free(our_ssl_sessionid);\n          failf(data, \"failed to store ssl session\");\n          return result;\n        }\n        else {\n          added = TRUE;\n        }\n      }\n      Curl_ssl_sessionid_unlock(data);\n\n      if(!added) {\n        /* If the session info wasn't added to the cache, free our copy. */\n        wolfSSL_SESSION_free(our_ssl_sessionid);\n      }\n    }\n  }\n\n  connssl->connecting_state = ssl_connect_done;\n\n  return result;\n}\n\n\nstatic ssize_t wolfssl_send(struct Curl_cfilter *cf,\n                            struct Curl_easy *data,\n                            const void *mem,\n                            size_t len,\n                            CURLcode *curlcode)\n{\n  struct ssl_connect_data *connssl = cf->ctx;\n  struct wolfssl_ssl_backend_data *backend =\n    (struct wolfssl_ssl_backend_data *)connssl->backend;\n  char error_buffer[WOLFSSL_MAX_ERROR_SZ];\n  int memlen = (len > (size_t)INT_MAX) ? INT_MAX : (int)len;\n  int rc;\n\n  DEBUGASSERT(backend);\n\n  wolfSSL_ERR_clear_error();\n\n  rc = wolfSSL_write(backend->handle, mem, memlen);\n  if(rc <= 0) {\n    int err = wolfSSL_get_error(backend->handle, rc);\n\n    switch(err) {\n    case SSL_ERROR_WANT_READ:\n    case SSL_ERROR_WANT_WRITE:\n      /* there's data pending, re-invoke SSL_write() */\n      CURL_TRC_CF(data, cf, \"wolfssl_send(len=%zu) -> AGAIN\", len);\n      *curlcode = CURLE_AGAIN;\n      return -1;\n    default:\n      if(backend->io_result == CURLE_AGAIN) {\n        CURL_TRC_CF(data, cf, \"wolfssl_send(len=%zu) -> AGAIN\", len);\n        *curlcode = CURLE_AGAIN;\n        return -1;\n      }\n      CURL_TRC_CF(data, cf, \"wolfssl_send(len=%zu) -> %d, %d\", len, rc, err);\n      failf(data, \"SSL write: %s, errno %d\",\n            wolfSSL_ERR_error_string(err, error_buffer),\n            SOCKERRNO);\n      *curlcode = CURLE_SEND_ERROR;\n      return -1;\n    }\n  }\n  CURL_TRC_CF(data, cf, \"wolfssl_send(len=%zu) -> %d\", len, rc);\n  return rc;\n}\n\nstatic void wolfssl_close(struct Curl_cfilter *cf, struct Curl_easy *data)\n{\n  struct ssl_connect_data *connssl = cf->ctx;\n  struct wolfssl_ssl_backend_data *backend =\n    (struct wolfssl_ssl_backend_data *)connssl->backend;\n\n  (void) data;\n\n  DEBUGASSERT(backend);\n\n  if(backend->handle) {\n    char buf[32];\n    /* Maybe the server has already sent a close notify alert.\n       Read it to avoid an RST on the TCP connection. */\n    (void)wolfSSL_read(backend->handle, buf, (int)sizeof(buf));\n    if(!connssl->peer_closed)\n      (void)wolfSSL_shutdown(backend->handle);\n    wolfSSL_free(backend->handle);\n    backend->handle = NULL;\n  }\n  if(backend->ctx) {\n    wolfSSL_CTX_free(backend->ctx);\n    backend->ctx = NULL;\n  }\n}\n\nstatic ssize_t wolfssl_recv(struct Curl_cfilter *cf,\n                            struct Curl_easy *data,\n                            char *buf, size_t blen,\n                            CURLcode *curlcode)\n{\n  struct ssl_connect_data *connssl = cf->ctx;\n  struct wolfssl_ssl_backend_data *backend =\n    (struct wolfssl_ssl_backend_data *)connssl->backend;\n  char error_buffer[WOLFSSL_MAX_ERROR_SZ];\n  int buffsize = (blen > (size_t)INT_MAX) ? INT_MAX : (int)blen;\n  int nread;\n\n  DEBUGASSERT(backend);\n\n  wolfSSL_ERR_clear_error();\n  *curlcode = CURLE_OK;\n\n  nread = wolfSSL_read(backend->handle, buf, buffsize);\n\n  if(nread <= 0) {\n    int err = wolfSSL_get_error(backend->handle, nread);\n\n    switch(err) {\n    case SSL_ERROR_ZERO_RETURN: /* no more data */\n      CURL_TRC_CF(data, cf, \"wolfssl_recv(len=%zu) -> CLOSED\", blen);\n      *curlcode = CURLE_OK;\n      return 0;\n    case SSL_ERROR_NONE:\n    case SSL_ERROR_WANT_READ:\n    case SSL_ERROR_WANT_WRITE:\n      /* there's data pending, re-invoke wolfSSL_read() */\n      CURL_TRC_CF(data, cf, \"wolfssl_recv(len=%zu) -> AGAIN\", blen);\n      *curlcode = CURLE_AGAIN;\n      return -1;\n    default:\n      if(backend->io_result == CURLE_AGAIN) {\n        CURL_TRC_CF(data, cf, \"wolfssl_recv(len=%zu) -> AGAIN\", blen);\n        *curlcode = CURLE_AGAIN;\n        return -1;\n      }\n      failf(data, \"SSL read: %s, errno %d\",\n            wolfSSL_ERR_error_string(err, error_buffer), SOCKERRNO);\n      *curlcode = CURLE_RECV_ERROR;\n      return -1;\n    }\n  }\n  CURL_TRC_CF(data, cf, \"wolfssl_recv(len=%zu) -> %d\", blen, nread);\n  return nread;\n}\n\n\nstatic void wolfssl_session_free(void *ptr)\n{\n  wolfSSL_SESSION_free(ptr);\n}\n\n\nstatic size_t wolfssl_version(char *buffer, size_t size)\n{\n#if LIBWOLFSSL_VERSION_HEX >= 0x03006000\n  return msnprintf(buffer, size, \"wolfSSL/%s\", wolfSSL_lib_version());\n#elif defined(WOLFSSL_VERSION)\n  return msnprintf(buffer, size, \"wolfSSL/%s\", WOLFSSL_VERSION);\n#endif\n}\n\n\nstatic int wolfssl_init(void)\n{\n  int ret;\n\n#ifdef OPENSSL_EXTRA\n  Curl_tls_keylog_open();\n#endif\n  ret = (wolfSSL_Init() == SSL_SUCCESS);\n  wolfssl_bio_cf_init_methods();\n  return ret;\n}\n\n\nstatic void wolfssl_cleanup(void)\n{\n  wolfssl_bio_cf_free_methods();\n  wolfSSL_Cleanup();\n#ifdef OPENSSL_EXTRA\n  Curl_tls_keylog_close();\n#endif\n}\n\n\nstatic bool wolfssl_data_pending(struct Curl_cfilter *cf,\n                                 const struct Curl_easy *data)\n{\n  struct ssl_connect_data *ctx = cf->ctx;\n  struct wolfssl_ssl_backend_data *backend;\n\n  (void)data;\n  DEBUGASSERT(ctx && ctx->backend);\n\n  backend = (struct wolfssl_ssl_backend_data *)ctx->backend;\n  if(backend->handle)   /* SSL is in use */\n    return (0 != wolfSSL_pending(backend->handle)) ? TRUE : FALSE;\n  else\n    return FALSE;\n}\n\n\n/*\n * This function is called to shut down the SSL layer but keep the\n * socket open (CCC - Clear Command Channel)\n */\nstatic int wolfssl_shutdown(struct Curl_cfilter *cf,\n                            struct Curl_easy *data)\n{\n  struct ssl_connect_data *ctx = cf->ctx;\n  struct wolfssl_ssl_backend_data *backend;\n  int retval = 0;\n\n  (void)data;\n  DEBUGASSERT(ctx && ctx->backend);\n\n  backend = (struct wolfssl_ssl_backend_data *)ctx->backend;\n  if(backend->handle) {\n    wolfSSL_ERR_clear_error();\n    wolfSSL_free(backend->handle);\n    backend->handle = NULL;\n  }\n  return retval;\n}\n\n\nstatic CURLcode\nwolfssl_connect_common(struct Curl_cfilter *cf,\n                       struct Curl_easy *data,\n                       bool nonblocking,\n                       bool *done)\n{\n  CURLcode result;\n  struct ssl_connect_data *connssl = cf->ctx;\n  curl_socket_t sockfd = Curl_conn_cf_get_socket(cf, data);\n  int what;\n\n  /* check if the connection has already been established */\n  if(ssl_connection_complete == connssl->state) {\n    *done = TRUE;\n    return CURLE_OK;\n  }\n\n  if(ssl_connect_1 == connssl->connecting_state) {\n    /* Find out how much more time we're allowed */\n    const timediff_t timeout_ms = Curl_timeleft(data, NULL, TRUE);\n\n    if(timeout_ms < 0) {\n      /* no need to continue if time already is up */\n      failf(data, \"SSL connection timeout\");\n      return CURLE_OPERATION_TIMEDOUT;\n    }\n\n    result = wolfssl_connect_step1(cf, data);\n    if(result)\n      return result;\n  }\n\n  while(ssl_connect_2 == connssl->connecting_state ||\n        ssl_connect_2_reading == connssl->connecting_state ||\n        ssl_connect_2_writing == connssl->connecting_state) {\n\n    /* check allowed time left */\n    const timediff_t timeout_ms = Curl_timeleft(data, NULL, TRUE);\n\n    if(timeout_ms < 0) {\n      /* no need to continue if time already is up */\n      failf(data, \"SSL connection timeout\");\n      return CURLE_OPERATION_TIMEDOUT;\n    }\n\n    /* if ssl is expecting something, check if it's available. */\n    if(connssl->connecting_state == ssl_connect_2_reading\n       || connssl->connecting_state == ssl_connect_2_writing) {\n\n      curl_socket_t writefd = ssl_connect_2_writing ==\n        connssl->connecting_state?sockfd:CURL_SOCKET_BAD;\n      curl_socket_t readfd = ssl_connect_2_reading ==\n        connssl->connecting_state?sockfd:CURL_SOCKET_BAD;\n\n      what = Curl_socket_check(readfd, CURL_SOCKET_BAD, writefd,\n                               nonblocking?0:timeout_ms);\n      if(what < 0) {\n        /* fatal error */\n        failf(data, \"select/poll on SSL socket, errno: %d\", SOCKERRNO);\n        return CURLE_SSL_CONNECT_ERROR;\n      }\n      else if(0 == what) {\n        if(nonblocking) {\n          *done = FALSE;\n          return CURLE_OK;\n        }\n        else {\n          /* timeout */\n          failf(data, \"SSL connection timeout\");\n          return CURLE_OPERATION_TIMEDOUT;\n        }\n      }\n      /* socket is readable or writable */\n    }\n\n    /* Run transaction, and return to the caller if it failed or if\n     * this connection is part of a multi handle and this loop would\n     * execute again. This permits the owner of a multi handle to\n     * abort a connection attempt before step2 has completed while\n     * ensuring that a client using select() or epoll() will always\n     * have a valid fdset to wait on.\n     */\n    result = wolfssl_connect_step2(cf, data);\n    if(result || (nonblocking &&\n                  (ssl_connect_2 == connssl->connecting_state ||\n                   ssl_connect_2_reading == connssl->connecting_state ||\n                   ssl_connect_2_writing == connssl->connecting_state)))\n      return result;\n  } /* repeat step2 until all transactions are done. */\n\n  if(ssl_connect_3 == connssl->connecting_state) {\n    result = wolfssl_connect_step3(cf, data);\n    if(result)\n      return result;\n  }\n\n  if(ssl_connect_done == connssl->connecting_state) {\n    connssl->state = ssl_connection_complete;\n    *done = TRUE;\n  }\n  else\n    *done = FALSE;\n\n  /* Reset our connect state machine */\n  connssl->connecting_state = ssl_connect_1;\n\n  return CURLE_OK;\n}\n\n\nstatic CURLcode wolfssl_connect_nonblocking(struct Curl_cfilter *cf,\n                                            struct Curl_easy *data,\n                                            bool *done)\n{\n  return wolfssl_connect_common(cf, data, TRUE, done);\n}\n\n\nstatic CURLcode wolfssl_connect(struct Curl_cfilter *cf,\n                                struct Curl_easy *data)\n{\n  CURLcode result;\n  bool done = FALSE;\n\n  result = wolfssl_connect_common(cf, data, FALSE, &done);\n  if(result)\n    return result;\n\n  DEBUGASSERT(done);\n\n  return CURLE_OK;\n}\n\nstatic CURLcode wolfssl_random(struct Curl_easy *data,\n                               unsigned char *entropy, size_t length)\n{\n  WC_RNG rng;\n  (void)data;\n  if(wc_InitRng(&rng))\n    return CURLE_FAILED_INIT;\n  if(length > UINT_MAX)\n    return CURLE_FAILED_INIT;\n  if(wc_RNG_GenerateBlock(&rng, entropy, (unsigned)length))\n    return CURLE_FAILED_INIT;\n  if(wc_FreeRng(&rng))\n    return CURLE_FAILED_INIT;\n  return CURLE_OK;\n}\n\nstatic CURLcode wolfssl_sha256sum(const unsigned char *tmp, /* input */\n                                  size_t tmplen,\n                                  unsigned char *sha256sum /* output */,\n                                  size_t unused)\n{\n  wc_Sha256 SHA256pw;\n  (void)unused;\n  if(wc_InitSha256(&SHA256pw))\n    return CURLE_FAILED_INIT;\n  wc_Sha256Update(&SHA256pw, tmp, (word32)tmplen);\n  wc_Sha256Final(&SHA256pw, sha256sum);\n  return CURLE_OK;\n}\n\nstatic void *wolfssl_get_internals(struct ssl_connect_data *connssl,\n                                   CURLINFO info UNUSED_PARAM)\n{\n  struct wolfssl_ssl_backend_data *backend =\n    (struct wolfssl_ssl_backend_data *)connssl->backend;\n  (void)info;\n  DEBUGASSERT(backend);\n  return backend->handle;\n}\n\nconst struct Curl_ssl Curl_ssl_wolfssl = {\n  { CURLSSLBACKEND_WOLFSSL, \"WolfSSL\" }, /* info */\n\n#ifdef KEEP_PEER_CERT\n  SSLSUPP_PINNEDPUBKEY |\n#endif\n#ifdef USE_BIO_CHAIN\n  SSLSUPP_HTTPS_PROXY |\n#endif\n  SSLSUPP_CA_PATH |\n  SSLSUPP_CAINFO_BLOB |\n  SSLSUPP_SSL_CTX,\n\n  sizeof(struct wolfssl_ssl_backend_data),\n\n  wolfssl_init,                    /* init */\n  wolfssl_cleanup,                 /* cleanup */\n  wolfssl_version,                 /* version */\n  Curl_none_check_cxn,             /* check_cxn */\n  wolfssl_shutdown,                /* shutdown */\n  wolfssl_data_pending,            /* data_pending */\n  wolfssl_random,                  /* random */\n  Curl_none_cert_status_request,   /* cert_status_request */\n  wolfssl_connect,                 /* connect */\n  wolfssl_connect_nonblocking,     /* connect_nonblocking */\n  Curl_ssl_adjust_pollset,         /* adjust_pollset */\n  wolfssl_get_internals,           /* get_internals */\n  wolfssl_close,                   /* close_one */\n  Curl_none_close_all,             /* close_all */\n  wolfssl_session_free,            /* session_free */\n  Curl_none_set_engine,            /* set_engine */\n  Curl_none_set_engine_default,    /* set_engine_default */\n  Curl_none_engines_list,          /* engines_list */\n  Curl_none_false_start,           /* false_start */\n  wolfssl_sha256sum,               /* sha256sum */\n  NULL,                            /* associate_connection */\n  NULL,                            /* disassociate_connection */\n  NULL,                            /* free_multi_ssl_backend_data */\n  wolfssl_recv,                    /* recv decrypted data */\n  wolfssl_send,                    /* send data to encrypt */\n};\n\n#endif\n` was unexpected","path":"/home/qqq/curl-8.7.0/lib/vtls/wolfssl.c"},{"code":3,"level":"warn","type":"Syntax error","message":"Syntax error at line /home/qqq/curl-8.7.0/lib/cf-socket.c:1:\n `/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n * SPDX-License-Identifier: curl\n *\n ***************************************************************************/\n\n#include \"curl_setup.h\"\n\n#ifdef HAVE_NETINET_IN_H\n#include <netinet/in.h> /* <netinet/tcp.h> may need it */\n#endif\n#ifdef HAVE_SYS_UN_H\n#include <sys/un.h> /* for sockaddr_un */\n#endif\n#ifdef HAVE_LINUX_TCP_H\n#include <linux/tcp.h>\n#elif defined(HAVE_NETINET_TCP_H)\n#include <netinet/tcp.h>\n#endif\n#ifdef HAVE_SYS_IOCTL_H\n#include <sys/ioctl.h>\n#endif\n#ifdef HAVE_NETDB_H\n#include <netdb.h>\n#endif\n#ifdef HAVE_FCNTL_H\n#include <fcntl.h>\n#endif\n#ifdef HAVE_ARPA_INET_H\n#include <arpa/inet.h>\n#endif\n\n#ifdef __VMS\n#include <in.h>\n#include <inet.h>\n#endif\n\n#include \"urldata.h\"\n#include \"bufq.h\"\n#include \"sendf.h\"\n#include \"if2ip.h\"\n#include \"strerror.h\"\n#include \"cfilters.h\"\n#include \"cf-socket.h\"\n#include \"connect.h\"\n#include \"select.h\"\n#include \"url.h\" /* for Curl_safefree() */\n#include \"multiif.h\"\n#include \"sockaddr.h\" /* required for Curl_sockaddr_storage */\n#include \"inet_ntop.h\"\n#include \"inet_pton.h\"\n#include \"progress.h\"\n#include \"warnless.h\"\n#include \"conncache.h\"\n#include \"multihandle.h\"\n#include \"rand.h\"\n#include \"share.h\"\n#include \"version_win32.h\"\n\n/* The last 3 #include files should be in this order */\n#include \"curl_printf.h\"\n#include \"curl_memory.h\"\n#include \"memdebug.h\"\n\n\n#if defined(ENABLE_IPV6) && defined(IPV6_V6ONLY) && defined(_WIN32)\n/* It makes support for IPv4-mapped IPv6 addresses.\n * Linux kernel, NetBSD, FreeBSD and Darwin: default is off;\n * Windows Vista and later: default is on;\n * DragonFly BSD: acts like off, and dummy setting;\n * OpenBSD and earlier Windows: unsupported.\n * Linux: controlled by /proc/sys/net/ipv6/bindv6only.\n */\nstatic void set_ipv6_v6only(curl_socket_t sockfd, int on)\n{\n  (void)setsockopt(sockfd, IPPROTO_IPV6, IPV6_V6ONLY, (void *)&on, sizeof(on));\n}\n#else\n#define set_ipv6_v6only(x,y)\n#endif\n\nstatic void tcpnodelay(struct Curl_easy *data, curl_socket_t sockfd)\n{\n#if defined(TCP_NODELAY)\n  curl_socklen_t onoff = (curl_socklen_t) 1;\n  int level = IPPROTO_TCP;\n  char buffer[STRERROR_LEN];\n\n  if(setsockopt(sockfd, level, TCP_NODELAY, (void *)&onoff,\n                sizeof(onoff)) < 0)\n    infof(data, \"Could not set TCP_NODELAY: %s\",\n          Curl_strerror(SOCKERRNO, buffer, sizeof(buffer)));\n#else\n  (void)data;\n  (void)sockfd;\n#endif\n}\n\n#ifdef SO_NOSIGPIPE\n/* The preferred method on Mac OS X (10.2 and later) to prevent SIGPIPEs when\n   sending data to a dead peer (instead of relying on the 4th argument to send\n   being MSG_NOSIGNAL). Possibly also existing and in use on other BSD\n   systems? */\nstatic void nosigpipe(struct Curl_easy *data,\n                      curl_socket_t sockfd)\n{\n  int onoff = 1;\n  (void)data;\n  if(setsockopt(sockfd, SOL_SOCKET, SO_NOSIGPIPE, (void *)&onoff,\n                sizeof(onoff)) < 0) {\n#if !defined(CURL_DISABLE_VERBOSE_STRINGS)\n    char buffer[STRERROR_LEN];\n    infof(data, \"Could not set SO_NOSIGPIPE: %s\",\n          Curl_strerror(SOCKERRNO, buffer, sizeof(buffer)));\n#endif\n  }\n}\n#else\n#define nosigpipe(x,y) Curl_nop_stmt\n#endif\n\n#if defined(__DragonFly__) || defined(USE_WINSOCK)\n/* DragonFlyBSD and Windows use millisecond units */\n#define KEEPALIVE_FACTOR(x) (x *= 1000)\n#else\n#define KEEPALIVE_FACTOR(x)\n#endif\n\n#if defined(USE_WINSOCK) && !defined(SIO_KEEPALIVE_VALS)\n#define SIO_KEEPALIVE_VALS    _WSAIOW(IOC_VENDOR,4)\n\nstruct tcp_keepalive {\n  u_long onoff;\n  u_long keepalivetime;\n  u_long keepaliveinterval;\n};\n#endif\n\nstatic void\ntcpkeepalive(struct Curl_easy *data,\n             curl_socket_t sockfd)\n{\n  int optval = data->set.tcp_keepalive?1:0;\n\n  /* only set IDLE and INTVL if setting KEEPALIVE is successful */\n  if(setsockopt(sockfd, SOL_SOCKET, SO_KEEPALIVE,\n        (void *)&optval, sizeof(optval)) < 0) {\n    infof(data, \"Failed to set SO_KEEPALIVE on fd \"\n          \"%\" CURL_FORMAT_SOCKET_T \": errno %d\",\n          sockfd, SOCKERRNO);\n  }\n  else {\n#if defined(SIO_KEEPALIVE_VALS)\n    struct tcp_keepalive vals;\n    DWORD dummy;\n    vals.onoff = 1;\n    optval = curlx_sltosi(data->set.tcp_keepidle);\n    KEEPALIVE_FACTOR(optval);\n    vals.keepalivetime = optval;\n    optval = curlx_sltosi(data->set.tcp_keepintvl);\n    KEEPALIVE_FACTOR(optval);\n    vals.keepaliveinterval = optval;\n    if(WSAIoctl(sockfd, SIO_KEEPALIVE_VALS, (LPVOID) &vals, sizeof(vals),\n                NULL, 0, &dummy, NULL, NULL) != 0) {\n      infof(data, \"Failed to set SIO_KEEPALIVE_VALS on fd \"\n                  \"%\" CURL_FORMAT_SOCKET_T \": errno %d\",\n                  sockfd, SOCKERRNO);\n    }\n#else\n#ifdef TCP_KEEPIDLE\n    optval = curlx_sltosi(data->set.tcp_keepidle);\n    KEEPALIVE_FACTOR(optval);\n    if(setsockopt(sockfd, IPPROTO_TCP, TCP_KEEPIDLE,\n          (void *)&optval, sizeof(optval)) < 0) {\n      infof(data, \"Failed to set TCP_KEEPIDLE on fd \"\n            \"%\" CURL_FORMAT_SOCKET_T \": errno %d\",\n            sockfd, SOCKERRNO);\n    }\n#elif defined(TCP_KEEPALIVE)\n    /* Mac OS X style */\n    optval = curlx_sltosi(data->set.tcp_keepidle);\n    KEEPALIVE_FACTOR(optval);\n    if(setsockopt(sockfd, IPPROTO_TCP, TCP_KEEPALIVE,\n      (void *)&optval, sizeof(optval)) < 0) {\n      infof(data, \"Failed to set TCP_KEEPALIVE on fd \"\n            \"%\" CURL_FORMAT_SOCKET_T \": errno %d\",\n            sockfd, SOCKERRNO);\n    }\n#endif\n#ifdef TCP_KEEPINTVL\n    optval = curlx_sltosi(data->set.tcp_keepintvl);\n    KEEPALIVE_FACTOR(optval);\n    if(setsockopt(sockfd, IPPROTO_TCP, TCP_KEEPINTVL,\n          (void *)&optval, sizeof(optval)) < 0) {\n      infof(data, \"Failed to set TCP_KEEPINTVL on fd \"\n            \"%\" CURL_FORMAT_SOCKET_T \": errno %d\",\n            sockfd, SOCKERRNO);\n    }\n#endif\n#endif\n  }\n}\n\n/**\n * Assign the address `ai` to the Curl_sockaddr_ex `dest` and\n * set the transport used.\n */\nvoid Curl_sock_assign_addr(struct Curl_sockaddr_ex *dest,\n                           const struct Curl_addrinfo *ai,\n                           int transport)\n{\n  /*\n   * The Curl_sockaddr_ex structure is basically libcurl's external API\n   * curl_sockaddr structure with enough space available to directly hold\n   * any protocol-specific address structures. The variable declared here\n   * will be used to pass / receive data to/from the fopensocket callback\n   * if this has been set, before that, it is initialized from parameters.\n   */\n  dest->family = ai->ai_family;\n  switch(transport) {\n  case TRNSPRT_TCP:\n    dest->socktype = SOCK_STREAM;\n    dest->protocol = IPPROTO_TCP;\n    break;\n  case TRNSPRT_UNIX:\n    dest->socktype = SOCK_STREAM;\n    dest->protocol = IPPROTO_IP;\n    break;\n  default: /* UDP and QUIC */\n    dest->socktype = SOCK_DGRAM;\n    dest->protocol = IPPROTO_UDP;\n    break;\n  }\n  dest->addrlen = ai->ai_addrlen;\n\n  if(dest->addrlen > sizeof(struct Curl_sockaddr_storage))\n    dest->addrlen = sizeof(struct Curl_sockaddr_storage);\n  memcpy(&dest->sa_addr, ai->ai_addr, dest->addrlen);\n}\n\nstatic CURLcode socket_open(struct Curl_easy *data,\n                            struct Curl_sockaddr_ex *addr,\n                            curl_socket_t *sockfd)\n{\n  DEBUGASSERT(data);\n  DEBUGASSERT(data->conn);\n  if(data->set.fopensocket) {\n   /*\n    * If the opensocket callback is set, all the destination address\n    * information is passed to the callback. Depending on this information the\n    * callback may opt to abort the connection, this is indicated returning\n    * CURL_SOCKET_BAD; otherwise it will return a not-connected socket. When\n    * the callback returns a valid socket the destination address information\n    * might have been changed and this 'new' address will actually be used\n    * here to connect.\n    */\n    Curl_set_in_callback(data, true);\n    *sockfd = data->set.fopensocket(data->set.opensocket_client,\n                                    CURLSOCKTYPE_IPCXN,\n                                    (struct curl_sockaddr *)addr);\n    Curl_set_in_callback(data, false);\n  }\n  else {\n    /* opensocket callback not set, so simply create the socket now */\n    *sockfd = socket(addr->family, addr->socktype, addr->protocol);\n  }\n\n  if(*sockfd == CURL_SOCKET_BAD)\n    /* no socket, no connection */\n    return CURLE_COULDNT_CONNECT;\n\n#if defined(ENABLE_IPV6) && defined(HAVE_SOCKADDR_IN6_SIN6_SCOPE_ID)\n  if(data->conn->scope_id && (addr->family == AF_INET6)) {\n    struct sockaddr_in6 * const sa6 = (void *)&addr->sa_addr;\n    sa6->sin6_scope_id = data->conn->scope_id;\n  }\n#endif\n  return CURLE_OK;\n}\n\n/*\n * Create a socket based on info from 'conn' and 'ai'.\n *\n * 'addr' should be a pointer to the correct struct to get data back, or NULL.\n * 'sockfd' must be a pointer to a socket descriptor.\n *\n * If the open socket callback is set, used that!\n *\n */\nCURLcode Curl_socket_open(struct Curl_easy *data,\n                            const struct Curl_addrinfo *ai,\n                            struct Curl_sockaddr_ex *addr,\n                            int transport,\n                            curl_socket_t *sockfd)\n{\n  struct Curl_sockaddr_ex dummy;\n\n  if(!addr)\n    /* if the caller doesn't want info back, use a local temp copy */\n    addr = &dummy;\n\n  Curl_sock_assign_addr(addr, ai, transport);\n  return socket_open(data, addr, sockfd);\n}\n\nstatic int socket_close(struct Curl_easy *data, struct connectdata *conn,\n                        int use_callback, curl_socket_t sock)\n{\n  if(use_callback && conn && conn->fclosesocket) {\n    int rc;\n    Curl_multi_closed(data, sock);\n    Curl_set_in_callback(data, true);\n    rc = conn->fclosesocket(conn->closesocket_client, sock);\n    Curl_set_in_callback(data, false);\n    return rc;\n  }\n\n  if(conn)\n    /* tell the multi-socket code about this */\n    Curl_multi_closed(data, sock);\n\n  sclose(sock);\n\n  return 0;\n}\n\n/*\n * Close a socket.\n *\n * 'conn' can be NULL, beware!\n */\nint Curl_socket_close(struct Curl_easy *data, struct connectdata *conn,\n                      curl_socket_t sock)\n{\n  return socket_close(data, conn, FALSE, sock);\n}\n\n#ifdef USE_WINSOCK\n/* When you run a program that uses the Windows Sockets API, you may\n   experience slow performance when you copy data to a TCP server.\n\n   https://support.microsoft.com/kb/823764\n\n   Work-around: Make the Socket Send Buffer Size Larger Than the Program Send\n   Buffer Size\n\n   The problem described in this knowledge-base is applied only to pre-Vista\n   Windows.  Following function trying to detect OS version and skips\n   SO_SNDBUF adjustment for Windows Vista and above.\n*/\n#define DETECT_OS_NONE 0\n#define DETECT_OS_PREVISTA 1\n#define DETECT_OS_VISTA_OR_LATER 2\n\nvoid Curl_sndbufset(curl_socket_t sockfd)\n{\n  int val = CURL_MAX_WRITE_SIZE + 32;\n  int curval = 0;\n  int curlen = sizeof(curval);\n\n  static int detectOsState = DETECT_OS_NONE;\n\n  if(detectOsState == DETECT_OS_NONE) {\n    if(curlx_verify_windows_version(6, 0, 0, PLATFORM_WINNT,\n                                    VERSION_GREATER_THAN_EQUAL))\n      detectOsState = DETECT_OS_VISTA_OR_LATER;\n    else\n      detectOsState = DETECT_OS_PREVISTA;\n  }\n\n  if(detectOsState == DETECT_OS_VISTA_OR_LATER)\n    return;\n\n  if(getsockopt(sockfd, SOL_SOCKET, SO_SNDBUF, (char *)&curval, &curlen) == 0)\n    if(curval > val)\n      return;\n\n  setsockopt(sockfd, SOL_SOCKET, SO_SNDBUF, (const char *)&val, sizeof(val));\n}\n#endif\n\n#ifndef CURL_DISABLE_BINDLOCAL\nstatic CURLcode bindlocal(struct Curl_easy *data, struct connectdata *conn,\n                          curl_socket_t sockfd, int af, unsigned int scope)\n{\n  struct Curl_sockaddr_storage sa;\n  struct sockaddr *sock = (struct sockaddr *)&sa;  /* bind to this address */\n  curl_socklen_t sizeof_sa = 0; /* size of the data sock points to */\n  struct sockaddr_in *si4 = (struct sockaddr_in *)&sa;\n#ifdef ENABLE_IPV6\n  struct sockaddr_in6 *si6 = (struct sockaddr_in6 *)&sa;\n#endif\n\n  struct Curl_dns_entry *h = NULL;\n  unsigned short port = data->set.localport; /* use this port number, 0 for\n                                                \"random\" */\n  /* how many port numbers to try to bind to, increasing one at a time */\n  int portnum = data->set.localportrange;\n  const char *dev = data->set.str[STRING_DEVICE];\n  int error;\n#ifdef IP_BIND_ADDRESS_NO_PORT\n  int on = 1;\n#endif\n#ifndef ENABLE_IPV6\n  (void)scope;\n#endif\n\n  /*************************************************************\n   * Select device to bind socket to\n   *************************************************************/\n  if(!dev && !port)\n    /* no local kind of binding was requested */\n    return CURLE_OK;\n\n  memset(&sa, 0, sizeof(struct Curl_sockaddr_storage));\n\n  if(dev && (strlen(dev)<255) ) {\n    char myhost[256] = \"\";\n    int done = 0; /* -1 for error, 1 for address found */\n    bool is_interface = FALSE;\n    bool is_host = FALSE;\n    static const char *if_prefix = \"if!\";\n    static const char *host_prefix = \"host!\";\n\n    if(strncmp(if_prefix, dev, strlen(if_prefix)) == 0) {\n      dev += strlen(if_prefix);\n      is_interface = TRUE;\n    }\n    else if(strncmp(host_prefix, dev, strlen(host_prefix)) == 0) {\n      dev += strlen(host_prefix);\n      is_host = TRUE;\n    }\n\n    /* interface */\n    if(!is_host) {\n#ifdef SO_BINDTODEVICE\n      /*\n       * This binds the local socket to a particular interface. This will\n       * force even requests to other local interfaces to go out the external\n       * interface. Only bind to the interface when specified as interface,\n       * not just as a hostname or ip address.\n       *\n       * The interface might be a VRF, eg: vrf-blue, which means it cannot be\n       * converted to an IP address and would fail Curl_if2ip. Simply try to\n       * use it straight away.\n       */\n      if(setsockopt(sockfd, SOL_SOCKET, SO_BINDTODEVICE,\n                    dev, (curl_socklen_t)strlen(dev) + 1) == 0) {\n        /* This is often \"errno 1, error: Operation not permitted\" if you're\n         * not running as root or another suitable privileged user. If it\n         * succeeds it means the parameter was a valid interface and not an IP\n         * address. Return immediately.\n         */\n        infof(data, \"socket successfully bound to interface '%s'\", dev);\n        return CURLE_OK;\n      }\n#endif\n\n      switch(Curl_if2ip(af,\n#ifdef ENABLE_IPV6\n                        scope, conn->scope_id,\n#endif\n                        dev, myhost, sizeof(myhost))) {\n        case IF2IP_NOT_FOUND:\n          if(is_interface) {\n            /* Do not fall back to treating it as a host name */\n            failf(data, \"Couldn't bind to interface '%s'\", dev);\n            return CURLE_INTERFACE_FAILED;\n          }\n          break;\n        case IF2IP_AF_NOT_SUPPORTED:\n          /* Signal the caller to try another address family if available */\n          return CURLE_UNSUPPORTED_PROTOCOL;\n        case IF2IP_FOUND:\n          is_interface = TRUE;\n          /*\n           * We now have the numerical IP address in the 'myhost' buffer\n           */\n          infof(data, \"Local Interface %s is ip %s using address family %i\",\n                dev, myhost, af);\n          done = 1;\n          break;\n      }\n    }\n    if(!is_interface) {\n      /*\n       * This was not an interface, resolve the name as a host name\n       * or IP number\n       *\n       * Temporarily force name resolution to use only the address type\n       * of the connection. The resolve functions should really be changed\n       * to take a type parameter instead.\n       */\n      unsigned char ipver = conn->ip_version;\n      int rc;\n\n      if(af == AF_INET)\n        conn->ip_version = CURL_IPRESOLVE_V4;\n#ifdef ENABLE_IPV6\n      else if(af == AF_INET6)\n        conn->ip_version = CURL_IPRESOLVE_V6;\n#endif\n\n      rc = Curl_resolv(data, dev, 80, FALSE, &h);\n      if(rc == CURLRESOLV_PENDING)\n        (void)Curl_resolver_wait_resolv(data, &h);\n      conn->ip_version = ipver;\n\n      if(h) {\n        /* convert the resolved address, sizeof myhost >= INET_ADDRSTRLEN */\n        Curl_printable_address(h->addr, myhost, sizeof(myhost));\n        infof(data, \"Name '%s' family %i resolved to '%s' family %i\",\n              dev, af, myhost, h->addr->ai_family);\n        Curl_resolv_unlock(data, h);\n        if(af != h->addr->ai_family) {\n          /* bad IP version combo, signal the caller to try another address\n             family if available */\n          return CURLE_UNSUPPORTED_PROTOCOL;\n        }\n        done = 1;\n      }\n      else {\n        /*\n         * provided dev was no interface (or interfaces are not supported\n         * e.g. solaris) no ip address and no domain we fail here\n         */\n        done = -1;\n      }\n    }\n\n    if(done > 0) {\n#ifdef ENABLE_IPV6\n      /* IPv6 address */\n      if(af == AF_INET6) {\n#ifdef HAVE_SOCKADDR_IN6_SIN6_SCOPE_ID\n        char *scope_ptr = strchr(myhost, '%');\n        if(scope_ptr)\n          *(scope_ptr++) = '\\0';\n#endif\n        if(Curl_inet_pton(AF_INET6, myhost, &si6->sin6_addr) > 0) {\n          si6->sin6_family = AF_INET6;\n          si6->sin6_port = htons(port);\n#ifdef HAVE_SOCKADDR_IN6_SIN6_SCOPE_ID\n          if(scope_ptr) {\n            /* The \"myhost\" string either comes from Curl_if2ip or from\n               Curl_printable_address. The latter returns only numeric scope\n               IDs and the former returns none at all.  So the scope ID, if\n               present, is known to be numeric */\n            unsigned long scope_id = strtoul(scope_ptr, NULL, 10);\n            if(scope_id > UINT_MAX)\n              return CURLE_UNSUPPORTED_PROTOCOL;\n\n            si6->sin6_scope_id = (unsigned int)scope_id;\n          }\n#endif\n        }\n        sizeof_sa = sizeof(struct sockaddr_in6);\n      }\n      else\n#endif\n      /* IPv4 address */\n      if((af == AF_INET) &&\n         (Curl_inet_pton(AF_INET, myhost, &si4->sin_addr) > 0)) {\n        si4->sin_family = AF_INET;\n        si4->sin_port = htons(port);\n        sizeof_sa = sizeof(struct sockaddr_in);\n      }\n    }\n\n    if(done < 1) {\n      /* errorbuf is set false so failf will overwrite any message already in\n         the error buffer, so the user receives this error message instead of a\n         generic resolve error. */\n      data->state.errorbuf = FALSE;\n      failf(data, \"Couldn't bind to '%s'\", dev);\n      return CURLE_INTERFACE_FAILED;\n    }\n  }\n  else {\n    /* no device was given, prepare sa to match af's needs */\n#ifdef ENABLE_IPV6\n    if(af == AF_INET6) {\n      si6->sin6_family = AF_INET6;\n      si6->sin6_port = htons(port);\n      sizeof_sa = sizeof(struct sockaddr_in6);\n    }\n    else\n#endif\n    if(af == AF_INET) {\n      si4->sin_family = AF_INET;\n      si4->sin_port = htons(port);\n      sizeof_sa = sizeof(struct sockaddr_in);\n    }\n  }\n#ifdef IP_BIND_ADDRESS_NO_PORT\n  (void)setsockopt(sockfd, SOL_IP, IP_BIND_ADDRESS_NO_PORT, &on, sizeof(on));\n#endif\n  for(;;) {\n    if(bind(sockfd, sock, sizeof_sa) >= 0) {\n      /* we succeeded to bind */\n      struct Curl_sockaddr_storage add;\n      curl_socklen_t size = sizeof(add);\n      memset(&add, 0, sizeof(struct Curl_sockaddr_storage));\n      if(getsockname(sockfd, (struct sockaddr *) &add, &size) < 0) {\n        char buffer[STRERROR_LEN];\n        data->state.os_errno = error = SOCKERRNO;\n        failf(data, \"getsockname() failed with errno %d: %s\",\n              error, Curl_strerror(error, buffer, sizeof(buffer)));\n        return CURLE_INTERFACE_FAILED;\n      }\n      infof(data, \"Local port: %hu\", port);\n      conn->bits.bound = TRUE;\n      return CURLE_OK;\n    }\n\n    if(--portnum > 0) {\n      port++; /* try next port */\n      if(port == 0)\n        break;\n      infof(data, \"Bind to local port %d failed, trying next\", port - 1);\n      /* We reuse/clobber the port variable here below */\n      if(sock->sa_family == AF_INET)\n        si4->sin_port = ntohs(port);\n#ifdef ENABLE_IPV6\n      else\n        si6->sin6_port = ntohs(port);\n#endif\n    }\n    else\n      break;\n  }\n  {\n    char buffer[STRERROR_LEN];\n    data->state.os_errno = error = SOCKERRNO;\n    failf(data, \"bind failed with errno %d: %s\",\n          error, Curl_strerror(error, buffer, sizeof(buffer)));\n  }\n\n  return CURLE_INTERFACE_FAILED;\n}\n#endif\n\n/*\n * verifyconnect() returns TRUE if the connect really has happened.\n */\nstatic bool verifyconnect(curl_socket_t sockfd, int *error)\n{\n  bool rc = TRUE;\n#ifdef SO_ERROR\n  int err = 0;\n  curl_socklen_t errSize = sizeof(err);\n\n#ifdef _WIN32\n  /*\n   * In October 2003 we effectively nullified this function on Windows due to\n   * problems with it using all CPU in multi-threaded cases.\n   *\n   * In May 2004, we bring it back to offer more info back on connect failures.\n   * Gisle Vanem could reproduce the former problems with this function, but\n   * could avoid them by adding this SleepEx() call below:\n   *\n   *    \"I don't have Rational Quantify, but the hint from his post was\n   *    ntdll::NtRemoveIoCompletion(). So I'd assume the SleepEx (or maybe\n   *    just Sleep(0) would be enough?) would release whatever\n   *    mutex/critical-section the ntdll call is waiting on.\n   *\n   *    Someone got to verify this on Win-NT 4.0, 2000.\"\n   */\n\n#ifdef _WIN32_WCE\n  Sleep(0);\n#else\n  SleepEx(0, FALSE);\n#endif\n\n#endif\n\n  if(0 != getsockopt(sockfd, SOL_SOCKET, SO_ERROR, (void *)&err, &errSize))\n    err = SOCKERRNO;\n#ifdef _WIN32_WCE\n  /* Old WinCE versions don't support SO_ERROR */\n  if(WSAENOPROTOOPT == err) {\n    SET_SOCKERRNO(0);\n    err = 0;\n  }\n#endif\n#if defined(EBADIOCTL) && defined(__minix)\n  /* Minix 3.1.x doesn't support getsockopt on UDP sockets */\n  if(EBADIOCTL == err) {\n    SET_SOCKERRNO(0);\n    err = 0;\n  }\n#endif\n  if((0 == err) || (EISCONN == err))\n    /* we are connected, awesome! */\n    rc = TRUE;\n  else\n    /* This wasn't a successful connect */\n    rc = FALSE;\n  if(error)\n    *error = err;\n#else\n  (void)sockfd;\n  if(error)\n    *error = SOCKERRNO;\n#endif\n  return rc;\n}\n\n/**\n * Determine the curl code for a socket connect() == -1 with errno.\n */\nstatic CURLcode socket_connect_result(struct Curl_easy *data,\n                                      const char *ipaddress, int error)\n{\n  switch(error) {\n  case EINPROGRESS:\n  case EWOULDBLOCK:\n#if defined(EAGAIN)\n#if (EAGAIN) != (EWOULDBLOCK)\n    /* On some platforms EAGAIN and EWOULDBLOCK are the\n     * same value, and on others they are different, hence\n     * the odd #if\n     */\n  case EAGAIN:\n#endif\n#endif\n    return CURLE_OK;\n\n  default:\n    /* unknown error, fallthrough and try another address! */\n#ifdef CURL_DISABLE_VERBOSE_STRINGS\n    (void)ipaddress;\n#else\n    {\n      char buffer[STRERROR_LEN];\n      infof(data, \"Immediate connect fail for %s: %s\",\n            ipaddress, Curl_strerror(error, buffer, sizeof(buffer)));\n    }\n#endif\n    data->state.os_errno = error;\n    /* connect failed */\n    return CURLE_COULDNT_CONNECT;\n  }\n}\n\n/* We have a recv buffer to enhance reads with len < NW_SMALL_READS.\n * This happens often on TLS connections where the TLS implementation\n * tries to read the head of a TLS record, determine the length of the\n * full record and then make a subsequent read for that.\n * On large reads, we will not fill the buffer to avoid the double copy. */\n#define NW_RECV_CHUNK_SIZE    (64 * 1024)\n#define NW_RECV_CHUNKS         1\n#define NW_SMALL_READS        (1024)\n\nstruct cf_socket_ctx {\n  int transport;\n  struct Curl_sockaddr_ex addr;      /* address to connect to */\n  curl_socket_t sock;                /* current attempt socket */\n  struct bufq recvbuf;               /* used when `buffer_recv` is set */\n  struct ip_quadruple ip;            /* The IP quadruple 2x(addr+port) */\n  struct curltime started_at;        /* when socket was created */\n  struct curltime connected_at;      /* when socket connected/got first byte */\n  struct curltime first_byte_at;     /* when first byte was recvd */\n  int error;                         /* errno of last failure or 0 */\n#ifdef DEBUGBUILD\n  int wblock_percent;                /* percent of writes doing EAGAIN */\n  int wpartial_percent;              /* percent of bytes written in send */\n  int rblock_percent;                /* percent of reads doing EAGAIN */\n  size_t recv_max;                  /* max enforced read size */\n#endif\n  BIT(got_first_byte);               /* if first byte was received */\n  BIT(accepted);                     /* socket was accepted, not connected */\n  BIT(sock_connected);               /* socket is \"connected\", e.g. in UDP */\n  BIT(active);\n  BIT(buffer_recv);\n};\n\nstatic void cf_socket_ctx_init(struct cf_socket_ctx *ctx,\n                               const struct Curl_addrinfo *ai,\n                               int transport)\n{\n  memset(ctx, 0, sizeof(*ctx));\n  ctx->sock = CURL_SOCKET_BAD;\n  ctx->transport = transport;\n  Curl_sock_assign_addr(&ctx->addr, ai, transport);\n  Curl_bufq_init(&ctx->recvbuf, NW_RECV_CHUNK_SIZE, NW_RECV_CHUNKS);\n#ifdef DEBUGBUILD\n  {\n    char *p = getenv(\"CURL_DBG_SOCK_WBLOCK\");\n    if(p) {\n      long l = strtol(p, NULL, 10);\n      if(l >= 0 && l <= 100)\n        ctx->wblock_percent = (int)l;\n    }\n    p = getenv(\"CURL_DBG_SOCK_WPARTIAL\");\n    if(p) {\n      long l = strtol(p, NULL, 10);\n      if(l >= 0 && l <= 100)\n        ctx->wpartial_percent = (int)l;\n    }\n    p = getenv(\"CURL_DBG_SOCK_RBLOCK\");\n    if(p) {\n      long l = strtol(p, NULL, 10);\n      if(l >= 0 && l <= 100)\n        ctx->rblock_percent = (int)l;\n    }\n    p = getenv(\"CURL_DBG_SOCK_RMAX\");\n    if(p) {\n      long l = strtol(p, NULL, 10);\n      if(l >= 0)\n        ctx->recv_max = (size_t)l;\n    }\n  }\n#endif\n}\n\nstruct reader_ctx {\n  struct Curl_cfilter *cf;\n  struct Curl_easy *data;\n};\n\nstatic ssize_t nw_in_read(void *reader_ctx,\n                           unsigned char *buf, size_t len,\n                           CURLcode *err)\n{\n  struct reader_ctx *rctx = reader_ctx;\n  struct cf_socket_ctx *ctx = rctx->cf->ctx;\n  ssize_t nread;\n\n  *err = CURLE_OK;\n  nread = sread(ctx->sock, buf, len);\n\n  if(-1 == nread) {\n    int sockerr = SOCKERRNO;\n\n    if(\n#ifdef WSAEWOULDBLOCK\n      /* This is how Windows does it */\n      (WSAEWOULDBLOCK == sockerr)\n#else\n      /* errno may be EWOULDBLOCK or on some systems EAGAIN when it returned\n         due to its inability to send off data without blocking. We therefore\n         treat both error codes the same here */\n      (EWOULDBLOCK == sockerr) || (EAGAIN == sockerr) || (EINTR == sockerr)\n#endif\n      ) {\n      /* this is just a case of EWOULDBLOCK */\n      *err = CURLE_AGAIN;\n      nread = -1;\n    }\n    else {\n      char buffer[STRERROR_LEN];\n\n      failf(rctx->data, \"Recv failure: %s\",\n            Curl_strerror(sockerr, buffer, sizeof(buffer)));\n      rctx->data->state.os_errno = sockerr;\n      *err = CURLE_RECV_ERROR;\n      nread = -1;\n    }\n  }\n  CURL_TRC_CF(rctx->data, rctx->cf, \"nw_in_read(len=%zu, fd=%\"\n              CURL_FORMAT_SOCKET_T \") -> %d, err=%d\",\n              len, ctx->sock, (int)nread, *err);\n  return nread;\n}\n\nstatic void cf_socket_close(struct Curl_cfilter *cf, struct Curl_easy *data)\n{\n  struct cf_socket_ctx *ctx = cf->ctx;\n\n  if(ctx && CURL_SOCKET_BAD != ctx->sock) {\n    CURL_TRC_CF(data, cf, \"cf_socket_close(%\" CURL_FORMAT_SOCKET_T\n                \")\", ctx->sock);\n    if(ctx->sock == cf->conn->sock[cf->sockindex])\n      cf->conn->sock[cf->sockindex] = CURL_SOCKET_BAD;\n    socket_close(data, cf->conn, !ctx->accepted, ctx->sock);\n    ctx->sock = CURL_SOCKET_BAD;\n    if(ctx->active && cf->sockindex == FIRSTSOCKET)\n      cf->conn->remote_addr = NULL;\n    Curl_bufq_reset(&ctx->recvbuf);\n    ctx->active = FALSE;\n    ctx->buffer_recv = FALSE;\n    memset(&ctx->started_at, 0, sizeof(ctx->started_at));\n    memset(&ctx->connected_at, 0, sizeof(ctx->connected_at));\n  }\n\n  cf->connected = FALSE;\n}\n\nstatic void cf_socket_destroy(struct Curl_cfilter *cf, struct Curl_easy *data)\n{\n  struct cf_socket_ctx *ctx = cf->ctx;\n\n  cf_socket_close(cf, data);\n  CURL_TRC_CF(data, cf, \"destroy\");\n  Curl_bufq_free(&ctx->recvbuf);\n  free(ctx);\n  cf->ctx = NULL;\n}\n\nstatic CURLcode set_local_ip(struct Curl_cfilter *cf,\n                             struct Curl_easy *data)\n{\n  struct cf_socket_ctx *ctx = cf->ctx;\n\n#ifdef HAVE_GETSOCKNAME\n  if(!(data->conn->handler->protocol & CURLPROTO_TFTP)) {\n    /* TFTP does not connect, so it cannot get the IP like this */\n\n    char buffer[STRERROR_LEN];\n    struct Curl_sockaddr_storage ssloc;\n    curl_socklen_t slen = sizeof(struct Curl_sockaddr_storage);\n\n    memset(&ssloc, 0, sizeof(ssloc));\n    if(getsockname(ctx->sock, (struct sockaddr*) &ssloc, &slen)) {\n      int error = SOCKERRNO;\n      failf(data, \"getsockname() failed with errno %d: %s\",\n            error, Curl_strerror(error, buffer, sizeof(buffer)));\n      return CURLE_FAILED_INIT;\n    }\n    if(!Curl_addr2string((struct sockaddr*)&ssloc, slen,\n                         ctx->ip.local_ip, &ctx->ip.local_port)) {\n      failf(data, \"ssloc inet_ntop() failed with errno %d: %s\",\n            errno, Curl_strerror(errno, buffer, sizeof(buffer)));\n      return CURLE_FAILED_INIT;\n    }\n  }\n#else\n  (void)data;\n  ctx->l_ip[0] = 0;\n  ctx->l_port = -1;\n#endif\n  return CURLE_OK;\n}\n\nstatic CURLcode set_remote_ip(struct Curl_cfilter *cf,\n                              struct Curl_easy *data)\n{\n  struct cf_socket_ctx *ctx = cf->ctx;\n\n  /* store remote address and port used in this connection attempt */\n  if(!Curl_addr2string(&ctx->addr.sa_addr, ctx->addr.addrlen,\n                       ctx->ip.remote_ip, &ctx->ip.remote_port)) {\n    char buffer[STRERROR_LEN];\n\n    ctx->error = errno;\n    /* malformed address or bug in inet_ntop, try next address */\n    failf(data, \"sa_addr inet_ntop() failed with errno %d: %s\",\n          errno, Curl_strerror(errno, buffer, sizeof(buffer)));\n    return CURLE_FAILED_INIT;\n  }\n  return CURLE_OK;\n}\n\nstatic CURLcode cf_socket_open(struct Curl_cfilter *cf,\n                              struct Curl_easy *data)\n{\n  struct cf_socket_ctx *ctx = cf->ctx;\n  int error = 0;\n  bool isconnected = FALSE;\n  CURLcode result = CURLE_COULDNT_CONNECT;\n  bool is_tcp;\n\n  (void)data;\n  DEBUGASSERT(ctx->sock == CURL_SOCKET_BAD);\n  ctx->started_at = Curl_now();\n  result = socket_open(data, &ctx->addr, &ctx->sock);\n  if(result)\n    goto out;\n\n  result = set_remote_ip(cf, data);\n  if(result)\n    goto out;\n\n#ifdef ENABLE_IPV6\n  if(ctx->addr.family == AF_INET6) {\n    set_ipv6_v6only(ctx->sock, 0);\n    infof(data, \"  Trying [%s]:%d...\", ctx->ip.remote_ip, ctx->ip.remote_port);\n  }\n  else\n#endif\n    infof(data, \"  Trying %s:%d...\", ctx->ip.remote_ip, ctx->ip.remote_port);\n\n#ifdef ENABLE_IPV6\n  is_tcp = (ctx->addr.family == AF_INET\n            || ctx->addr.family == AF_INET6) &&\n           ctx->addr.socktype == SOCK_STREAM;\n#else\n  is_tcp = (ctx->addr.family == AF_INET) &&\n           ctx->addr.socktype == SOCK_STREAM;\n#endif\n  if(is_tcp && data->set.tcp_nodelay)\n    tcpnodelay(data, ctx->sock);\n\n  nosigpipe(data, ctx->sock);\n\n  Curl_sndbufset(ctx->sock);\n\n  if(is_tcp && data->set.tcp_keepalive)\n    tcpkeepalive(data, ctx->sock);\n\n  if(data->set.fsockopt) {\n    /* activate callback for setting socket options */\n    Curl_set_in_callback(data, true);\n    error = data->set.fsockopt(data->set.sockopt_client,\n                               ctx->sock,\n                               CURLSOCKTYPE_IPCXN);\n    Curl_set_in_callback(data, false);\n\n    if(error == CURL_SOCKOPT_ALREADY_CONNECTED)\n      isconnected = TRUE;\n    else if(error) {\n      result = CURLE_ABORTED_BY_CALLBACK;\n      goto out;\n    }\n  }\n\n#ifndef CURL_DISABLE_BINDLOCAL\n  /* possibly bind the local end to an IP, interface or port */\n  if(ctx->addr.family == AF_INET\n#ifdef ENABLE_IPV6\n     || ctx->addr.family == AF_INET6\n#endif\n    ) {\n    result = bindlocal(data, cf->conn, ctx->sock, ctx->addr.family,\n                       Curl_ipv6_scope(&ctx->addr.sa_addr));\n    if(result) {\n      if(result == CURLE_UNSUPPORTED_PROTOCOL) {\n        /* The address family is not supported on this interface.\n           We can continue trying addresses */\n        result = CURLE_COULDNT_CONNECT;\n      }\n      goto out;\n    }\n  }\n#endif\n\n  /* set socket non-blocking */\n  (void)curlx_nonblock(ctx->sock, TRUE);\n  ctx->sock_connected = (ctx->addr.socktype != SOCK_DGRAM);\nout:\n  if(result) {\n    if(ctx->sock != CURL_SOCKET_BAD) {\n      socket_close(data, cf->conn, TRUE, ctx->sock);\n      ctx->sock = CURL_SOCKET_BAD;\n    }\n  }\n  else if(isconnected) {\n    set_local_ip(cf, data);\n    ctx->connected_at = Curl_now();\n    cf->connected = TRUE;\n  }\n  CURL_TRC_CF(data, cf, \"cf_socket_open() -> %d, fd=%\" CURL_FORMAT_SOCKET_T,\n              result, ctx->sock);\n  return result;\n}\n\nstatic int do_connect(struct Curl_cfilter *cf, struct Curl_easy *data,\n                      bool is_tcp_fastopen)\n{\n  struct cf_socket_ctx *ctx = cf->ctx;\n#ifdef TCP_FASTOPEN_CONNECT\n  int optval = 1;\n#endif\n  int rc = -1;\n\n  (void)data;\n  if(is_tcp_fastopen) {\n#if defined(CONNECT_DATA_IDEMPOTENT) /* Darwin */\n#  if defined(HAVE_BUILTIN_AVAILABLE)\n    /* while connectx function is available since macOS 10.11 / iOS 9,\n       it did not have the interface declared correctly until\n       Xcode 9 / macOS SDK 10.13 */\n    if(__builtin_available(macOS 10.11, iOS 9.0, tvOS 9.0, watchOS 2.0, *)) {\n      sa_endpoints_t endpoints;\n      endpoints.sae_srcif = 0;\n      endpoints.sae_srcaddr = NULL;\n      endpoints.sae_srcaddrlen = 0;\n      endpoints.sae_dstaddr = &ctx->addr.sa_addr;\n      endpoints.sae_dstaddrlen = ctx->addr.addrlen;\n\n      rc = connectx(ctx->sock, &endpoints, SAE_ASSOCID_ANY,\n                    CONNECT_RESUME_ON_READ_WRITE | CONNECT_DATA_IDEMPOTENT,\n                    NULL, 0, NULL, NULL);\n    }\n    else {\n      rc = connect(ctx->sock, &ctx->addr.sa_addr, ctx->addr.addrlen);\n    }\n#  else\n    rc = connect(ctx->sock, &ctx->addr.sa_addr, ctx->addr.addrlen);\n#  endif /* HAVE_BUILTIN_AVAILABLE */\n#elif defined(TCP_FASTOPEN_CONNECT) /* Linux >= 4.11 */\n    if(setsockopt(ctx->sock, IPPROTO_TCP, TCP_FASTOPEN_CONNECT,\n                  (void *)&optval, sizeof(optval)) < 0)\n      infof(data, \"Failed to enable TCP Fast Open on fd %\"\n            CURL_FORMAT_SOCKET_T, ctx->sock);\n\n    rc = connect(ctx->sock, &ctx->addr.sa_addr, ctx->addr.addrlen);\n#elif defined(MSG_FASTOPEN) /* old Linux */\n    if(cf->conn->given->flags & PROTOPT_SSL)\n      rc = connect(ctx->sock, &ctx->addr.sa_addr, ctx->addr.addrlen);\n    else\n      rc = 0; /* Do nothing */\n#endif\n  }\n  else {\n    rc = connect(ctx->sock, &ctx->addr.sa_addr, ctx->addr.addrlen);\n  }\n  return rc;\n}\n\nstatic CURLcode cf_tcp_connect(struct Curl_cfilter *cf,\n                               struct Curl_easy *data,\n                               bool blocking, bool *done)\n{\n  struct cf_socket_ctx *ctx = cf->ctx;\n  CURLcode result = CURLE_COULDNT_CONNECT;\n  int rc = 0;\n\n  (void)data;\n  if(cf->connected) {\n    *done = TRUE;\n    return CURLE_OK;\n  }\n\n  /* TODO: need to support blocking connect? */\n  if(blocking)\n    return CURLE_UNSUPPORTED_PROTOCOL;\n\n  *done = FALSE; /* a very negative world view is best */\n  if(ctx->sock == CURL_SOCKET_BAD) {\n    int error;\n\n    result = cf_socket_open(cf, data);\n    if(result)\n      goto out;\n\n    if(cf->connected) {\n      *done = TRUE;\n      return CURLE_OK;\n    }\n\n    /* Connect TCP socket */\n    rc = do_connect(cf, data, cf->conn->bits.tcp_fastopen);\n    error = SOCKERRNO;\n    set_local_ip(cf, data);\n    CURL_TRC_CF(data, cf, \"local address %s port %d...\",\n                ctx->ip.local_ip, ctx->ip.local_port);\n    if(-1 == rc) {\n      result = socket_connect_result(data, ctx->ip.remote_ip, error);\n      goto out;\n    }\n  }\n\n#ifdef mpeix\n  /* Call this function once now, and ignore the results. We do this to\n     \"clear\" the error state on the socket so that we can later read it\n     reliably. This is reported necessary on the MPE/iX operating\n     system. */\n  (void)verifyconnect(ctx->sock, NULL);\n#endif\n  /* check socket for connect */\n  rc = SOCKET_WRITABLE(ctx->sock, 0);\n\n  if(rc == 0) { /* no connection yet */\n    CURL_TRC_CF(data, cf, \"not connected yet\");\n    return CURLE_OK;\n  }\n  else if(rc == CURL_CSELECT_OUT || cf->conn->bits.tcp_fastopen) {\n    if(verifyconnect(ctx->sock, &ctx->error)) {\n      /* we are connected with TCP, awesome! */\n      ctx->connected_at = Curl_now();\n      set_local_ip(cf, data);\n      *done = TRUE;\n      cf->connected = TRUE;\n      CURL_TRC_CF(data, cf, \"connected\");\n      return CURLE_OK;\n    }\n  }\n  else if(rc & CURL_CSELECT_ERR) {\n    (void)verifyconnect(ctx->sock, &ctx->error);\n    result = CURLE_COULDNT_CONNECT;\n  }\n\nout:\n  if(result) {\n    if(ctx->error) {\n      set_local_ip(cf, data);\n      data->state.os_errno = ctx->error;\n      SET_SOCKERRNO(ctx->error);\n#ifndef CURL_DISABLE_VERBOSE_STRINGS\n      {\n        char buffer[STRERROR_LEN];\n        infof(data, \"connect to %s port %u from %s port %d failed: %s\",\n              ctx->ip.remote_ip, ctx->ip.remote_port,\n              ctx->ip.local_ip, ctx->ip.local_port,\n              Curl_strerror(ctx->error, buffer, sizeof(buffer)));\n      }\n#endif\n    }\n    if(ctx->sock != CURL_SOCKET_BAD) {\n      socket_close(data, cf->conn, TRUE, ctx->sock);\n      ctx->sock = CURL_SOCKET_BAD;\n    }\n    *done = FALSE;\n  }\n  return result;\n}\n\nstatic void cf_socket_get_host(struct Curl_cfilter *cf,\n                               struct Curl_easy *data,\n                               const char **phost,\n                               const char **pdisplay_host,\n                               int *pport)\n{\n  struct cf_socket_ctx *ctx = cf->ctx;\n  (void)data;\n  *phost = cf->conn->host.name;\n  *pdisplay_host = cf->conn->host.dispname;\n  *pport = ctx->ip.remote_port;\n}\n\nstatic void cf_socket_adjust_pollset(struct Curl_cfilter *cf,\n                                      struct Curl_easy *data,\n                                      struct easy_pollset *ps)\n{\n  struct cf_socket_ctx *ctx = cf->ctx;\n\n  if(ctx->sock != CURL_SOCKET_BAD) {\n    if(!cf->connected) {\n      Curl_pollset_set_out_only(data, ps, ctx->sock);\n      CURL_TRC_CF(data, cf, \"adjust_pollset, !connected, POLLOUT fd=%\"\n                  CURL_FORMAT_SOCKET_T, ctx->sock);\n    }\n    else if(!ctx->active) {\n      Curl_pollset_add_in(data, ps, ctx->sock);\n      CURL_TRC_CF(data, cf, \"adjust_pollset, !active, POLLIN fd=%\"\n                  CURL_FORMAT_SOCKET_T, ctx->sock);\n    }\n  }\n}\n\nstatic bool cf_socket_data_pending(struct Curl_cfilter *cf,\n                                   const struct Curl_easy *data)\n{\n  struct cf_socket_ctx *ctx = cf->ctx;\n  int readable;\n\n  (void)data;\n  if(!Curl_bufq_is_empty(&ctx->recvbuf))\n    return TRUE;\n\n  readable = SOCKET_READABLE(ctx->sock, 0);\n  return (readable > 0 && (readable & CURL_CSELECT_IN));\n}\n\nstatic ssize_t cf_socket_send(struct Curl_cfilter *cf, struct Curl_easy *data,\n                              const void *buf, size_t len, CURLcode *err)\n{\n  struct cf_socket_ctx *ctx = cf->ctx;\n  curl_socket_t fdsave;\n  ssize_t nwritten;\n  size_t orig_len = len;\n\n  *err = CURLE_OK;\n  fdsave = cf->conn->sock[cf->sockindex];\n  cf->conn->sock[cf->sockindex] = ctx->sock;\n\n#ifdef DEBUGBUILD\n  /* simulate network blocking/partial writes */\n  if(ctx->wblock_percent > 0) {\n    unsigned char c;\n    Curl_rand(data, &c, 1);\n    if(c >= ((100-ctx->wblock_percent)*256/100)) {\n      CURL_TRC_CF(data, cf, \"send(len=%zu) SIMULATE EWOULDBLOCK\", orig_len);\n      *err = CURLE_AGAIN;\n      nwritten = -1;\n      cf->conn->sock[cf->sockindex] = fdsave;\n      return nwritten;\n    }\n  }\n  if(cf->cft != &Curl_cft_udp && ctx->wpartial_percent > 0 && len > 8) {\n    len = len * ctx->wpartial_percent / 100;\n    if(!len)\n      len = 1;\n    CURL_TRC_CF(data, cf, \"send(len=%zu) SIMULATE partial write of %zu bytes\",\n                orig_len, len);\n  }\n#endif\n\n#if defined(MSG_FASTOPEN) && !defined(TCP_FASTOPEN_CONNECT) /* Linux */\n  if(cf->conn->bits.tcp_fastopen) {\n    nwritten = sendto(ctx->sock, buf, len, MSG_FASTOPEN,\n                      &cf->conn->remote_addr->sa_addr,\n                      cf->conn->remote_addr->addrlen);\n    cf->conn->bits.tcp_fastopen = FALSE;\n  }\n  else\n#endif\n    nwritten = swrite(ctx->sock, buf, len);\n\n  if(-1 == nwritten) {\n    int sockerr = SOCKERRNO;\n\n    if(\n#ifdef WSAEWOULDBLOCK\n      /* This is how Windows does it */\n      (WSAEWOULDBLOCK == sockerr)\n#else\n      /* errno may be EWOULDBLOCK or on some systems EAGAIN when it returned\n         due to its inability to send off data without blocking. We therefore\n         treat both error codes the same here */\n      (EWOULDBLOCK == sockerr) || (EAGAIN == sockerr) || (EINTR == sockerr) ||\n      (EINPROGRESS == sockerr)\n#endif\n      ) {\n      /* this is just a case of EWOULDBLOCK */\n      *err = CURLE_AGAIN;\n    }\n    else {\n      char buffer[STRERROR_LEN];\n      failf(data, \"Send failure: %s\",\n            Curl_strerror(sockerr, buffer, sizeof(buffer)));\n      data->state.os_errno = sockerr;\n      *err = CURLE_SEND_ERROR;\n    }\n  }\n\n  CURL_TRC_CF(data, cf, \"send(len=%zu) -> %d, err=%d\",\n              orig_len, (int)nwritten, *err);\n  cf->conn->sock[cf->sockindex] = fdsave;\n  return nwritten;\n}\n\nstatic ssize_t cf_socket_recv(struct Curl_cfilter *cf, struct Curl_easy *data,\n                              char *buf, size_t len, CURLcode *err)\n{\n  struct cf_socket_ctx *ctx = cf->ctx;\n  curl_socket_t fdsave;\n  ssize_t nread;\n\n  *err = CURLE_OK;\n\n  fdsave = cf->conn->sock[cf->sockindex];\n  cf->conn->sock[cf->sockindex] = ctx->sock;\n\n#ifdef DEBUGBUILD\n  /* simulate network blocking/partial reads */\n  if(cf->cft != &Curl_cft_udp && ctx->rblock_percent > 0) {\n    unsigned char c;\n    Curl_rand(data, &c, 1);\n    if(c >= ((100-ctx->rblock_percent)*256/100)) {\n      CURL_TRC_CF(data, cf, \"recv(len=%zu) SIMULATE EWOULDBLOCK\", len);\n      *err = CURLE_AGAIN;\n      nread = -1;\n      cf->conn->sock[cf->sockindex] = fdsave;\n      return nread;\n    }\n  }\n  if(cf->cft != &Curl_cft_udp && ctx->recv_max && ctx->recv_max < len) {\n    size_t orig_len = len;\n    len = ctx->recv_max;\n    CURL_TRC_CF(data, cf, \"recv(len=%zu) SIMULATE max read of %zu bytes\",\n                orig_len, len);\n  }\n#endif\n\n  if(ctx->buffer_recv && !Curl_bufq_is_empty(&ctx->recvbuf)) {\n    CURL_TRC_CF(data, cf, \"recv from buffer\");\n    nread = Curl_bufq_read(&ctx->recvbuf, (unsigned char *)buf, len, err);\n  }\n  else {\n    struct reader_ctx rctx;\n\n    rctx.cf = cf;\n    rctx.data = data;\n\n    /* \"small\" reads may trigger filling our buffer, \"large\" reads\n     * are probably not worth the additional copy */\n    if(ctx->buffer_recv && len < NW_SMALL_READS) {\n      ssize_t nwritten;\n      nwritten = Curl_bufq_slurp(&ctx->recvbuf, nw_in_read, &rctx, err);\n      if(nwritten < 0 && !Curl_bufq_is_empty(&ctx->recvbuf)) {\n        /* we have a partial read with an error. need to deliver\n         * what we got, return the error later. */\n        CURL_TRC_CF(data, cf, \"partial read: empty buffer first\");\n        nread = Curl_bufq_read(&ctx->recvbuf, (unsigned char *)buf, len, err);\n      }\n      else if(nwritten < 0) {\n        nread = -1;\n        goto out;\n      }\n      else if(nwritten == 0) {\n        /* eof */\n        *err = CURLE_OK;\n        nread = 0;\n      }\n      else {\n        CURL_TRC_CF(data, cf, \"buffered %zd additional bytes\", nwritten);\n        nread = Curl_bufq_read(&ctx->recvbuf, (unsigned char *)buf, len, err);\n      }\n    }\n    else {\n      nread = nw_in_read(&rctx, (unsigned char *)buf, len, err);\n    }\n  }\n\nout:\n  CURL_TRC_CF(data, cf, \"recv(len=%zu) -> %d, err=%d\", len, (int)nread,\n              *err);\n  if(nread > 0 && !ctx->got_first_byte) {\n    ctx->first_byte_at = Curl_now();\n    ctx->got_first_byte = TRUE;\n  }\n  cf->conn->sock[cf->sockindex] = fdsave;\n  return nread;\n}\n\nstatic void cf_socket_active(struct Curl_cfilter *cf, struct Curl_easy *data)\n{\n  struct cf_socket_ctx *ctx = cf->ctx;\n\n  /* use this socket from now on */\n  cf->conn->sock[cf->sockindex] = ctx->sock;\n  set_local_ip(cf, data);\n  if(cf->sockindex == SECONDARYSOCKET)\n    cf->conn->secondary = ctx->ip;\n  else\n    cf->conn->primary = ctx->ip;\n  /* the first socket info gets some specials */\n  if(cf->sockindex == FIRSTSOCKET) {\n    cf->conn->remote_addr = &ctx->addr;\n  #ifdef ENABLE_IPV6\n    cf->conn->bits.ipv6 = (ctx->addr.family == AF_INET6)? TRUE : FALSE;\n  #endif\n    Curl_persistconninfo(data, cf->conn, &ctx->ip);\n    /* buffering is currently disabled by default because we have stalls\n     * in parallel transfers where not all buffered data is consumed and no\n     * socket events happen.\n     */\n    ctx->buffer_recv = FALSE;\n  }\n  ctx->active = TRUE;\n}\n\nstatic CURLcode cf_socket_cntrl(struct Curl_cfilter *cf,\n                                struct Curl_easy *data,\n                                int event, int arg1, void *arg2)\n{\n  struct cf_socket_ctx *ctx = cf->ctx;\n\n  (void)arg1;\n  (void)arg2;\n  switch(event) {\n  case CF_CTRL_CONN_INFO_UPDATE:\n    cf_socket_active(cf, data);\n    break;\n  case CF_CTRL_DATA_SETUP:\n    Curl_persistconninfo(data, cf->conn, &ctx->ip);\n    break;\n  case CF_CTRL_FORGET_SOCKET:\n    ctx->sock = CURL_SOCKET_BAD;\n    break;\n  }\n  return CURLE_OK;\n}\n\nstatic bool cf_socket_conn_is_alive(struct Curl_cfilter *cf,\n                                    struct Curl_easy *data,\n                                    bool *input_pending)\n{\n  struct cf_socket_ctx *ctx = cf->ctx;\n  struct pollfd pfd[1];\n  int r;\n\n  *input_pending = FALSE;\n  (void)data;\n  if(!ctx || ctx->sock == CURL_SOCKET_BAD)\n    return FALSE;\n\n  /* Check with 0 timeout if there are any events pending on the socket */\n  pfd[0].fd = ctx->sock;\n  pfd[0].events = POLLRDNORM|POLLIN|POLLRDBAND|POLLPRI;\n  pfd[0].revents = 0;\n\n  r = Curl_poll(pfd, 1, 0);\n  if(r < 0) {\n    CURL_TRC_CF(data, cf, \"is_alive: poll error, assume dead\");\n    return FALSE;\n  }\n  else if(r == 0) {\n    CURL_TRC_CF(data, cf, \"is_alive: poll timeout, assume alive\");\n    return TRUE;\n  }\n  else if(pfd[0].revents & (POLLERR|POLLHUP|POLLPRI|POLLNVAL)) {\n    CURL_TRC_CF(data, cf, \"is_alive: err/hup/etc events, assume dead\");\n    return FALSE;\n  }\n\n  CURL_TRC_CF(data, cf, \"is_alive: valid events, looks alive\");\n  *input_pending = TRUE;\n  return TRUE;\n}\n\nstatic CURLcode cf_socket_query(struct Curl_cfilter *cf,\n                                struct Curl_easy *data,\n                                int query, int *pres1, void *pres2)\n{\n  struct cf_socket_ctx *ctx = cf->ctx;\n\n  switch(query) {\n  case CF_QUERY_SOCKET:\n    DEBUGASSERT(pres2);\n    *((curl_socket_t *)pres2) = ctx->sock;\n    return CURLE_OK;\n  case CF_QUERY_CONNECT_REPLY_MS:\n    if(ctx->got_first_byte) {\n      timediff_t ms = Curl_timediff(ctx->first_byte_at, ctx->started_at);\n      *pres1 = (ms < INT_MAX)? (int)ms : INT_MAX;\n    }\n    else\n      *pres1 = -1;\n    return CURLE_OK;\n  case CF_QUERY_TIMER_CONNECT: {\n    struct curltime *when = pres2;\n    switch(ctx->transport) {\n    case TRNSPRT_UDP:\n    case TRNSPRT_QUIC:\n      /* Since UDP connected sockets work different from TCP, we use the\n       * time of the first byte from the peer as the \"connect\" time. */\n      if(ctx->got_first_byte) {\n        *when = ctx->first_byte_at;\n        break;\n      }\n      FALLTHROUGH();\n    default:\n      *when = ctx->connected_at;\n      break;\n    }\n    return CURLE_OK;\n  }\n  default:\n    break;\n  }\n  return cf->next?\n    cf->next->cft->query(cf->next, data, query, pres1, pres2) :\n    CURLE_UNKNOWN_OPTION;\n}\n\nstruct Curl_cftype Curl_cft_tcp = {\n  \"TCP\",\n  CF_TYPE_IP_CONNECT,\n  CURL_LOG_LVL_NONE,\n  cf_socket_destroy,\n  cf_tcp_connect,\n  cf_socket_close,\n  cf_socket_get_host,\n  cf_socket_adjust_pollset,\n  cf_socket_data_pending,\n  cf_socket_send,\n  cf_socket_recv,\n  cf_socket_cntrl,\n  cf_socket_conn_is_alive,\n  Curl_cf_def_conn_keep_alive,\n  cf_socket_query,\n};\n\nCURLcode Curl_cf_tcp_create(struct Curl_cfilter **pcf,\n                            struct Curl_easy *data,\n                            struct connectdata *conn,\n                            const struct Curl_addrinfo *ai,\n                            int transport)\n{\n  struct cf_socket_ctx *ctx = NULL;\n  struct Curl_cfilter *cf = NULL;\n  CURLcode result;\n\n  (void)data;\n  (void)conn;\n  DEBUGASSERT(transport == TRNSPRT_TCP);\n  ctx = calloc(1, sizeof(*ctx));\n  if(!ctx) {\n    result = CURLE_OUT_OF_MEMORY;\n    goto out;\n  }\n  cf_socket_ctx_init(ctx, ai, transport);\n\n  result = Curl_cf_create(&cf, &Curl_cft_tcp, ctx);\n\nout:\n  *pcf = (!result)? cf : NULL;\n  if(result) {\n    Curl_safefree(cf);\n    Curl_safefree(ctx);\n  }\n\n  return result;\n}\n\nstatic CURLcode cf_udp_setup_quic(struct Curl_cfilter *cf,\n                               struct Curl_easy *data)\n{\n  struct cf_socket_ctx *ctx = cf->ctx;\n  int rc;\n\n  /* QUIC needs a connected socket, nonblocking */\n  DEBUGASSERT(ctx->sock != CURL_SOCKET_BAD);\n\n#if defined(__APPLE__) && defined(USE_OPENSSL_QUIC)\n  (void)rc;\n  /* On macOS OpenSSL QUIC fails on connected sockets.\n   * see: <https://github.com/openssl/openssl/issues/23251> */\n#else\n  rc = connect(ctx->sock, &ctx->addr.sa_addr, ctx->addr.addrlen);\n  if(-1 == rc) {\n    return socket_connect_result(data, ctx->ip.remote_ip, SOCKERRNO);\n  }\n  ctx->sock_connected = TRUE;\n#endif\n  set_local_ip(cf, data);\n  CURL_TRC_CF(data, cf, \"%s socket %\" CURL_FORMAT_SOCKET_T\n              \" connected: [%s:%d] -> [%s:%d]\",\n              (ctx->transport == TRNSPRT_QUIC)? \"QUIC\" : \"UDP\",\n              ctx->sock, ctx->ip.local_ip, ctx->ip.local_port,\n              ctx->ip.remote_ip, ctx->ip.remote_port);\n\n  (void)curlx_nonblock(ctx->sock, TRUE);\n  switch(ctx->addr.family) {\n#if defined(__linux__) && defined(IP_MTU_DISCOVER)\n  case AF_INET: {\n    int val = IP_PMTUDISC_DO;\n    (void)setsockopt(ctx->sock, IPPROTO_IP, IP_MTU_DISCOVER, &val,\n                     sizeof(val));\n    break;\n  }\n#endif\n#if defined(__linux__) && defined(IPV6_MTU_DISCOVER)\n  case AF_INET6: {\n    int val = IPV6_PMTUDISC_DO;\n    (void)setsockopt(ctx->sock, IPPROTO_IPV6, IPV6_MTU_DISCOVER, &val,\n                     sizeof(val));\n    break;\n  }\n#endif\n  }\n  return CURLE_OK;\n}\n\nstatic CURLcode cf_udp_connect(struct Curl_cfilter *cf,\n                               struct Curl_easy *data,\n                               bool blocking, bool *done)\n{\n  struct cf_socket_ctx *ctx = cf->ctx;\n  CURLcode result = CURLE_COULDNT_CONNECT;\n\n  (void)blocking;\n  if(cf->connected) {\n    *done = TRUE;\n    return CURLE_OK;\n  }\n  *done = FALSE;\n  if(ctx->sock == CURL_SOCKET_BAD) {\n    result = cf_socket_open(cf, data);\n    if(result) {\n      CURL_TRC_CF(data, cf, \"cf_udp_connect(), open failed -> %d\", result);\n      goto out;\n    }\n\n    if(ctx->transport == TRNSPRT_QUIC) {\n      result = cf_udp_setup_quic(cf, data);\n      if(result)\n        goto out;\n      CURL_TRC_CF(data, cf, \"cf_udp_connect(), opened socket=%\"\n                  CURL_FORMAT_SOCKET_T \" (%s:%d)\",\n                  ctx->sock, ctx->ip.local_ip, ctx->ip.local_port);\n    }\n    else {\n      CURL_TRC_CF(data, cf, \"cf_udp_connect(), opened socket=%\"\n                  CURL_FORMAT_SOCKET_T \" (unconnected)\", ctx->sock);\n    }\n    *done = TRUE;\n    cf->connected = TRUE;\n  }\nout:\n  return result;\n}\n\nstruct Curl_cftype Curl_cft_udp = {\n  \"UDP\",\n  CF_TYPE_IP_CONNECT,\n  CURL_LOG_LVL_NONE,\n  cf_socket_destroy,\n  cf_udp_connect,\n  cf_socket_close,\n  cf_socket_get_host,\n  cf_socket_adjust_pollset,\n  cf_socket_data_pending,\n  cf_socket_send,\n  cf_socket_recv,\n  cf_socket_cntrl,\n  cf_socket_conn_is_alive,\n  Curl_cf_def_conn_keep_alive,\n  cf_socket_query,\n};\n\nCURLcode Curl_cf_udp_create(struct Curl_cfilter **pcf,\n                            struct Curl_easy *data,\n                            struct connectdata *conn,\n                            const struct Curl_addrinfo *ai,\n                            int transport)\n{\n  struct cf_socket_ctx *ctx = NULL;\n  struct Curl_cfilter *cf = NULL;\n  CURLcode result;\n\n  (void)data;\n  (void)conn;\n  DEBUGASSERT(transport == TRNSPRT_UDP || transport == TRNSPRT_QUIC);\n  ctx = calloc(1, sizeof(*ctx));\n  if(!ctx) {\n    result = CURLE_OUT_OF_MEMORY;\n    goto out;\n  }\n  cf_socket_ctx_init(ctx, ai, transport);\n\n  result = Curl_cf_create(&cf, &Curl_cft_udp, ctx);\n\nout:\n  *pcf = (!result)? cf : NULL;\n  if(result) {\n    Curl_safefree(cf);\n    Curl_safefree(ctx);\n  }\n\n  return result;\n}\n\n/* this is the TCP filter which can also handle this case */\nstruct Curl_cftype Curl_cft_unix = {\n  \"UNIX\",\n  CF_TYPE_IP_CONNECT,\n  CURL_LOG_LVL_NONE,\n  cf_socket_destroy,\n  cf_tcp_connect,\n  cf_socket_close,\n  cf_socket_get_host,\n  cf_socket_adjust_pollset,\n  cf_socket_data_pending,\n  cf_socket_send,\n  cf_socket_recv,\n  cf_socket_cntrl,\n  cf_socket_conn_is_alive,\n  Curl_cf_def_conn_keep_alive,\n  cf_socket_query,\n};\n\nCURLcode Curl_cf_unix_create(struct Curl_cfilter **pcf,\n                             struct Curl_easy *data,\n                             struct connectdata *conn,\n                             const struct Curl_addrinfo *ai,\n                             int transport)\n{\n  struct cf_socket_ctx *ctx = NULL;\n  struct Curl_cfilter *cf = NULL;\n  CURLcode result;\n\n  (void)data;\n  (void)conn;\n  DEBUGASSERT(transport == TRNSPRT_UNIX);\n  ctx = calloc(1, sizeof(*ctx));\n  if(!ctx) {\n    result = CURLE_OUT_OF_MEMORY;\n    goto out;\n  }\n  cf_socket_ctx_init(ctx, ai, transport);\n\n  result = Curl_cf_create(&cf, &Curl_cft_unix, ctx);\n\nout:\n  *pcf = (!result)? cf : NULL;\n  if(result) {\n    Curl_safefree(cf);\n    Curl_safefree(ctx);\n  }\n\n  return result;\n}\n\nstatic CURLcode cf_tcp_accept_connect(struct Curl_cfilter *cf,\n                                      struct Curl_easy *data,\n                                      bool blocking, bool *done)\n{\n  /* we start accepted, if we ever close, we cannot go on */\n  (void)data;\n  (void)blocking;\n  if(cf->connected) {\n    *done = TRUE;\n    return CURLE_OK;\n  }\n  return CURLE_FAILED_INIT;\n}\n\nstruct Curl_cftype Curl_cft_tcp_accept = {\n  \"TCP-ACCEPT\",\n  CF_TYPE_IP_CONNECT,\n  CURL_LOG_LVL_NONE,\n  cf_socket_destroy,\n  cf_tcp_accept_connect,\n  cf_socket_close,\n  cf_socket_get_host,              /* TODO: not accurate */\n  cf_socket_adjust_pollset,\n  cf_socket_data_pending,\n  cf_socket_send,\n  cf_socket_recv,\n  cf_socket_cntrl,\n  cf_socket_conn_is_alive,\n  Curl_cf_def_conn_keep_alive,\n  cf_socket_query,\n};\n\nCURLcode Curl_conn_tcp_listen_set(struct Curl_easy *data,\n                                  struct connectdata *conn,\n                                  int sockindex, curl_socket_t *s)\n{\n  CURLcode result;\n  struct Curl_cfilter *cf = NULL;\n  struct cf_socket_ctx *ctx = NULL;\n\n  /* replace any existing */\n  Curl_conn_cf_discard_all(data, conn, sockindex);\n  DEBUGASSERT(conn->sock[sockindex] == CURL_SOCKET_BAD);\n\n  ctx = calloc(1, sizeof(*ctx));\n  if(!ctx) {\n    result = CURLE_OUT_OF_MEMORY;\n    goto out;\n  }\n  ctx->transport = conn->transport;\n  ctx->sock = *s;\n  ctx->accepted = FALSE;\n  result = Curl_cf_create(&cf, &Curl_cft_tcp_accept, ctx);\n  if(result)\n    goto out;\n  Curl_conn_cf_add(data, conn, sockindex, cf);\n\n  conn->sock[sockindex] = ctx->sock;\n  set_local_ip(cf, data);\n  ctx->active = TRUE;\n  ctx->connected_at = Curl_now();\n  cf->connected = TRUE;\n  CURL_TRC_CF(data, cf, \"Curl_conn_tcp_listen_set(%\"\n              CURL_FORMAT_SOCKET_T \")\", ctx->sock);\n\nout:\n  if(result) {\n    Curl_safefree(cf);\n    Curl_safefree(ctx);\n  }\n  return result;\n}\n\nstatic void set_accepted_remote_ip(struct Curl_cfilter *cf,\n                                   struct Curl_easy *data)\n{\n  struct cf_socket_ctx *ctx = cf->ctx;\n#ifdef HAVE_GETPEERNAME\n  char buffer[STRERROR_LEN];\n  struct Curl_sockaddr_storage ssrem;\n  curl_socklen_t plen;\n\n  ctx->ip.remote_ip[0] = 0;\n  ctx->ip.remote_port = 0;\n  plen = sizeof(ssrem);\n  memset(&ssrem, 0, plen);\n  if(getpeername(ctx->sock, (struct sockaddr*) &ssrem, &plen)) {\n    int error = SOCKERRNO;\n    failf(data, \"getpeername() failed with errno %d: %s\",\n          error, Curl_strerror(error, buffer, sizeof(buffer)));\n    return;\n  }\n  if(!Curl_addr2string((struct sockaddr*)&ssrem, plen,\n                       ctx->ip.remote_ip, &ctx->ip.remote_port)) {\n    failf(data, \"ssrem inet_ntop() failed with errno %d: %s\",\n          errno, Curl_strerror(errno, buffer, sizeof(buffer)));\n    return;\n  }\n#else\n  ctx->ip.remote_ip[0] = 0;\n  ctx->ip.remote_port = 0;\n  (void)data;\n#endif\n}\n\nCURLcode Curl_conn_tcp_accepted_set(struct Curl_easy *data,\n                                    struct connectdata *conn,\n                                    int sockindex, curl_socket_t *s)\n{\n  struct Curl_cfilter *cf = NULL;\n  struct cf_socket_ctx *ctx = NULL;\n\n  cf = conn->cfilter[sockindex];\n  if(!cf || cf->cft != &Curl_cft_tcp_accept)\n    return CURLE_FAILED_INIT;\n\n  ctx = cf->ctx;\n  /* discard the listen socket */\n  socket_close(data, conn, TRUE, ctx->sock);\n  ctx->sock = *s;\n  conn->sock[sockindex] = ctx->sock;\n  set_accepted_remote_ip(cf, data);\n  set_local_ip(cf, data);\n  ctx->active = TRUE;\n  ctx->accepted = TRUE;\n  ctx->connected_at = Curl_now();\n  cf->connected = TRUE;\n  CURL_TRC_CF(data, cf, \"accepted_set(sock=%\" CURL_FORMAT_SOCKET_T\n              \", remote=%s port=%d)\",\n              ctx->sock, ctx->ip.remote_ip, ctx->ip.remote_port);\n\n  return CURLE_OK;\n}\n\n/**\n * Return TRUE iff `cf` is a socket filter.\n */\nstatic bool cf_is_socket(struct Curl_cfilter *cf)\n{\n  return cf && (cf->cft == &Curl_cft_tcp ||\n                cf->cft == &Curl_cft_udp ||\n                cf->cft == &Curl_cft_unix ||\n                cf->cft == &Curl_cft_tcp_accept);\n}\n\nCURLcode Curl_cf_socket_peek(struct Curl_cfilter *cf,\n                             struct Curl_easy *data,\n                             curl_socket_t *psock,\n                             const struct Curl_sockaddr_ex **paddr,\n                             struct ip_quadruple *pip)\n{\n  (void)data;\n  if(cf_is_socket(cf) && cf->ctx) {\n    struct cf_socket_ctx *ctx = cf->ctx;\n\n    if(psock)\n      *psock = ctx->sock;\n    if(paddr)\n      *paddr = &ctx->addr;\n    if(pip)\n      *pip = ctx->ip;\n    return CURLE_OK;\n  }\n  return CURLE_FAILED_INIT;\n}\n` was unexpected","path":"/home/qqq/curl-8.7.0/lib/cf-socket.c"},{"code":3,"level":"warn","type":"Syntax error","message":"Syntax error at line /home/qqq/curl-8.7.0/lib/vssh/libssh.c:1:\n `/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) Red Hat, Inc.\n *\n * Authors: Nikos Mavrogiannopoulos, Tomas Mraz, Stanislav Zidek,\n *          Robert Kolcun, Andreas Schneider\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n * SPDX-License-Identifier: curl\n *\n ***************************************************************************/\n\n#include \"curl_setup.h\"\n\n#ifdef USE_LIBSSH\n\n#include <limits.h>\n\n/* in 0.10.0 or later, ignore deprecated warnings */\n#define SSH_SUPPRESS_DEPRECATED\n#include <libssh/libssh.h>\n#include <libssh/sftp.h>\n\n#ifdef HAVE_NETINET_IN_H\n#include <netinet/in.h>\n#endif\n#ifdef HAVE_ARPA_INET_H\n#include <arpa/inet.h>\n#endif\n#ifdef HAVE_NETDB_H\n#include <netdb.h>\n#endif\n#ifdef __VMS\n#include <in.h>\n#include <inet.h>\n#endif\n\n#include <curl/curl.h>\n#include \"urldata.h\"\n#include \"sendf.h\"\n#include \"hostip.h\"\n#include \"progress.h\"\n#include \"transfer.h\"\n#include \"escape.h\"\n#include \"http.h\"               /* for HTTP proxy tunnel stuff */\n#include \"ssh.h\"\n#include \"url.h\"\n#include \"speedcheck.h\"\n#include \"getinfo.h\"\n#include \"strdup.h\"\n#include \"strcase.h\"\n#include \"vtls/vtls.h\"\n#include \"cfilters.h\"\n#include \"connect.h\"\n#include \"inet_ntop.h\"\n#include \"parsedate.h\"          /* for the week day and month names */\n#include \"sockaddr.h\"           /* required for Curl_sockaddr_storage */\n#include \"strtoofft.h\"\n#include \"multiif.h\"\n#include \"select.h\"\n#include \"warnless.h\"\n#include \"curl_path.h\"\n\n#ifdef HAVE_SYS_STAT_H\n#include <sys/stat.h>\n#endif\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n#ifdef HAVE_FCNTL_H\n#include <fcntl.h>\n#endif\n\n/* The last 3 #include files should be in this order */\n#include \"curl_printf.h\"\n#include \"curl_memory.h\"\n#include \"memdebug.h\"\n\n/* A recent macro provided by libssh. Or make our own. */\n#ifndef SSH_STRING_FREE_CHAR\n#define SSH_STRING_FREE_CHAR(x)                 \\\n  do {                                          \\\n    if(x) {                                     \\\n      ssh_string_free_char(x);                  \\\n      x = NULL;                                 \\\n    }                                           \\\n  } while(0)\n#endif\n\n/* These stat values may not be the same as the user's S_IFMT / S_IFLNK */\n#ifndef SSH_S_IFMT\n#define SSH_S_IFMT   00170000\n#endif\n#ifndef SSH_S_IFLNK\n#define SSH_S_IFLNK  0120000\n#endif\n\n/* Local functions: */\nstatic CURLcode myssh_connect(struct Curl_easy *data, bool *done);\nstatic CURLcode myssh_multi_statemach(struct Curl_easy *data,\n                                      bool *done);\nstatic CURLcode myssh_do_it(struct Curl_easy *data, bool *done);\n\nstatic CURLcode scp_done(struct Curl_easy *data,\n                         CURLcode, bool premature);\nstatic CURLcode scp_doing(struct Curl_easy *data, bool *dophase_done);\nstatic CURLcode scp_disconnect(struct Curl_easy *data,\n                               struct connectdata *conn,\n                               bool dead_connection);\n\nstatic CURLcode sftp_done(struct Curl_easy *data,\n                          CURLcode, bool premature);\nstatic CURLcode sftp_doing(struct Curl_easy *data,\n                           bool *dophase_done);\nstatic CURLcode sftp_disconnect(struct Curl_easy *data,\n                                struct connectdata *conn,\n                                bool dead);\nstatic\nCURLcode sftp_perform(struct Curl_easy *data,\n                      bool *connected,\n                      bool *dophase_done);\n\nstatic void sftp_quote(struct Curl_easy *data);\nstatic void sftp_quote_stat(struct Curl_easy *data);\nstatic int myssh_getsock(struct Curl_easy *data,\n                         struct connectdata *conn, curl_socket_t *sock);\n\nstatic CURLcode myssh_setup_connection(struct Curl_easy *data,\n                                       struct connectdata *conn);\n\n/*\n * SCP protocol handler.\n */\n\nconst struct Curl_handler Curl_handler_scp = {\n  \"SCP\",                        /* scheme */\n  myssh_setup_connection,       /* setup_connection */\n  myssh_do_it,                  /* do_it */\n  scp_done,                     /* done */\n  ZERO_NULL,                    /* do_more */\n  myssh_connect,                /* connect_it */\n  myssh_multi_statemach,        /* connecting */\n  scp_doing,                    /* doing */\n  myssh_getsock,                /* proto_getsock */\n  myssh_getsock,                /* doing_getsock */\n  ZERO_NULL,                    /* domore_getsock */\n  myssh_getsock,                /* perform_getsock */\n  scp_disconnect,               /* disconnect */\n  ZERO_NULL,                    /* write_resp */\n  ZERO_NULL,                    /* connection_check */\n  ZERO_NULL,                    /* attach connection */\n  PORT_SSH,                     /* defport */\n  CURLPROTO_SCP,                /* protocol */\n  CURLPROTO_SCP,                /* family */\n  PROTOPT_DIRLOCK | PROTOPT_CLOSEACTION | PROTOPT_NOURLQUERY    /* flags */\n};\n\n/*\n * SFTP protocol handler.\n */\n\nconst struct Curl_handler Curl_handler_sftp = {\n  \"SFTP\",                               /* scheme */\n  myssh_setup_connection,               /* setup_connection */\n  myssh_do_it,                          /* do_it */\n  sftp_done,                            /* done */\n  ZERO_NULL,                            /* do_more */\n  myssh_connect,                        /* connect_it */\n  myssh_multi_statemach,                /* connecting */\n  sftp_doing,                           /* doing */\n  myssh_getsock,                        /* proto_getsock */\n  myssh_getsock,                        /* doing_getsock */\n  ZERO_NULL,                            /* domore_getsock */\n  myssh_getsock,                        /* perform_getsock */\n  sftp_disconnect,                      /* disconnect */\n  ZERO_NULL,                            /* write_resp */\n  ZERO_NULL,                            /* connection_check */\n  ZERO_NULL,                            /* attach connection */\n  PORT_SSH,                             /* defport */\n  CURLPROTO_SFTP,                       /* protocol */\n  CURLPROTO_SFTP,                       /* family */\n  PROTOPT_DIRLOCK | PROTOPT_CLOSEACTION\n  | PROTOPT_NOURLQUERY                  /* flags */\n};\n\nstatic CURLcode sftp_error_to_CURLE(int err)\n{\n  switch(err) {\n    case SSH_FX_OK:\n      return CURLE_OK;\n\n    case SSH_FX_NO_SUCH_FILE:\n    case SSH_FX_NO_SUCH_PATH:\n      return CURLE_REMOTE_FILE_NOT_FOUND;\n\n    case SSH_FX_PERMISSION_DENIED:\n    case SSH_FX_WRITE_PROTECT:\n      return CURLE_REMOTE_ACCESS_DENIED;\n\n    case SSH_FX_FILE_ALREADY_EXISTS:\n      return CURLE_REMOTE_FILE_EXISTS;\n\n    default:\n      break;\n  }\n\n  return CURLE_SSH;\n}\n\n#ifndef DEBUGBUILD\n#define state(x,y) mystate(x,y)\n#else\n#define state(x,y) mystate(x,y, __LINE__)\n#endif\n\n/*\n * SSH State machine related code\n */\n/* This is the ONLY way to change SSH state! */\nstatic void mystate(struct Curl_easy *data, sshstate nowstate\n#ifdef DEBUGBUILD\n                    , int lineno\n#endif\n  )\n{\n  struct connectdata *conn = data->conn;\n  struct ssh_conn *sshc = &conn->proto.sshc;\n#if defined(DEBUGBUILD) && !defined(CURL_DISABLE_VERBOSE_STRINGS)\n  /* for debug purposes */\n  static const char *const names[] = {\n    \"SSH_STOP\",\n    \"SSH_INIT\",\n    \"SSH_S_STARTUP\",\n    \"SSH_HOSTKEY\",\n    \"SSH_AUTHLIST\",\n    \"SSH_AUTH_PKEY_INIT\",\n    \"SSH_AUTH_PKEY\",\n    \"SSH_AUTH_PASS_INIT\",\n    \"SSH_AUTH_PASS\",\n    \"SSH_AUTH_AGENT_INIT\",\n    \"SSH_AUTH_AGENT_LIST\",\n    \"SSH_AUTH_AGENT\",\n    \"SSH_AUTH_HOST_INIT\",\n    \"SSH_AUTH_HOST\",\n    \"SSH_AUTH_KEY_INIT\",\n    \"SSH_AUTH_KEY\",\n    \"SSH_AUTH_GSSAPI\",\n    \"SSH_AUTH_DONE\",\n    \"SSH_SFTP_INIT\",\n    \"SSH_SFTP_REALPATH\",\n    \"SSH_SFTP_QUOTE_INIT\",\n    \"SSH_SFTP_POSTQUOTE_INIT\",\n    \"SSH_SFTP_QUOTE\",\n    \"SSH_SFTP_NEXT_QUOTE\",\n    \"SSH_SFTP_QUOTE_STAT\",\n    \"SSH_SFTP_QUOTE_SETSTAT\",\n    \"SSH_SFTP_QUOTE_SYMLINK\",\n    \"SSH_SFTP_QUOTE_MKDIR\",\n    \"SSH_SFTP_QUOTE_RENAME\",\n    \"SSH_SFTP_QUOTE_RMDIR\",\n    \"SSH_SFTP_QUOTE_UNLINK\",\n    \"SSH_SFTP_QUOTE_STATVFS\",\n    \"SSH_SFTP_GETINFO\",\n    \"SSH_SFTP_FILETIME\",\n    \"SSH_SFTP_TRANS_INIT\",\n    \"SSH_SFTP_UPLOAD_INIT\",\n    \"SSH_SFTP_CREATE_DIRS_INIT\",\n    \"SSH_SFTP_CREATE_DIRS\",\n    \"SSH_SFTP_CREATE_DIRS_MKDIR\",\n    \"SSH_SFTP_READDIR_INIT\",\n    \"SSH_SFTP_READDIR\",\n    \"SSH_SFTP_READDIR_LINK\",\n    \"SSH_SFTP_READDIR_BOTTOM\",\n    \"SSH_SFTP_READDIR_DONE\",\n    \"SSH_SFTP_DOWNLOAD_INIT\",\n    \"SSH_SFTP_DOWNLOAD_STAT\",\n    \"SSH_SFTP_CLOSE\",\n    \"SSH_SFTP_SHUTDOWN\",\n    \"SSH_SCP_TRANS_INIT\",\n    \"SSH_SCP_UPLOAD_INIT\",\n    \"SSH_SCP_DOWNLOAD_INIT\",\n    \"SSH_SCP_DOWNLOAD\",\n    \"SSH_SCP_DONE\",\n    \"SSH_SCP_SEND_EOF\",\n    \"SSH_SCP_WAIT_EOF\",\n    \"SSH_SCP_WAIT_CLOSE\",\n    \"SSH_SCP_CHANNEL_FREE\",\n    \"SSH_SESSION_DISCONNECT\",\n    \"SSH_SESSION_FREE\",\n    \"QUIT\"\n  };\n\n\n  if(sshc->state != nowstate) {\n    infof(data, \"SSH %p state change from %s to %s (line %d)\",\n          (void *) sshc, names[sshc->state], names[nowstate],\n          lineno);\n  }\n#endif\n\n  sshc->state = nowstate;\n}\n\n/* Multiple options:\n * 1. data->set.str[STRING_SSH_HOST_PUBLIC_KEY_MD5] is set with an MD5\n *    hash (90s style auth, not sure we should have it here)\n * 2. data->set.ssh_keyfunc callback is set. Then we do trust on first\n *    use. We even save on knownhosts if CURLKHSTAT_FINE_ADD_TO_FILE\n *    is returned by it.\n * 3. none of the above. We only accept if it is present on known hosts.\n *\n * Returns SSH_OK or SSH_ERROR.\n */\nstatic int myssh_is_known(struct Curl_easy *data)\n{\n  int rc;\n  struct connectdata *conn = data->conn;\n  struct ssh_conn *sshc = &conn->proto.sshc;\n  ssh_key pubkey;\n  size_t hlen;\n  unsigned char *hash = NULL;\n  char *found_base64 = NULL;\n  char *known_base64 = NULL;\n  int vstate;\n  enum curl_khmatch keymatch;\n  struct curl_khkey foundkey;\n  struct curl_khkey *knownkeyp = NULL;\n  curl_sshkeycallback func =\n    data->set.ssh_keyfunc;\n\n#if LIBSSH_VERSION_INT >= SSH_VERSION_INT(0,9,0)\n  struct ssh_knownhosts_entry *knownhostsentry = NULL;\n  struct curl_khkey knownkey;\n#endif\n\n#if LIBSSH_VERSION_INT >= SSH_VERSION_INT(0,8,0)\n  rc = ssh_get_server_publickey(sshc->ssh_session, &pubkey);\n#else\n  rc = ssh_get_publickey(sshc->ssh_session, &pubkey);\n#endif\n  if(rc != SSH_OK)\n    return rc;\n\n  if(data->set.str[STRING_SSH_HOST_PUBLIC_KEY_MD5]) {\n    int i;\n    char md5buffer[33];\n    const char *pubkey_md5 = data->set.str[STRING_SSH_HOST_PUBLIC_KEY_MD5];\n\n    rc = ssh_get_publickey_hash(pubkey, SSH_PUBLICKEY_HASH_MD5,\n                                &hash, &hlen);\n    if(rc != SSH_OK || hlen != 16) {\n      failf(data,\n            \"Denied establishing ssh session: md5 fingerprint not available\");\n      goto cleanup;\n    }\n\n    for(i = 0; i < 16; i++)\n      msnprintf(&md5buffer[i*2], 3, \"%02x\", (unsigned char)hash[i]);\n\n    infof(data, \"SSH MD5 fingerprint: %s\", md5buffer);\n\n    if(!strcasecompare(md5buffer, pubkey_md5)) {\n      failf(data,\n            \"Denied establishing ssh session: mismatch md5 fingerprint. \"\n            \"Remote %s is not equal to %s\", md5buffer, pubkey_md5);\n      rc = SSH_ERROR;\n      goto cleanup;\n    }\n\n    rc = SSH_OK;\n    goto cleanup;\n  }\n\n  if(data->set.ssl.primary.verifyhost != TRUE) {\n    rc = SSH_OK;\n    goto cleanup;\n  }\n\n#if LIBSSH_VERSION_INT >= SSH_VERSION_INT(0,9,0)\n  /* Get the known_key from the known hosts file */\n  vstate = ssh_session_get_known_hosts_entry(sshc->ssh_session,\n                                             &knownhostsentry);\n\n  /* Case an entry was found in a known hosts file */\n  if(knownhostsentry) {\n    if(knownhostsentry->publickey) {\n      rc = ssh_pki_export_pubkey_base64(knownhostsentry->publickey,\n                                        &known_base64);\n      if(rc != SSH_OK) {\n        goto cleanup;\n      }\n      knownkey.key = known_base64;\n      knownkey.len = strlen(known_base64);\n\n      switch(ssh_key_type(knownhostsentry->publickey)) {\n        case SSH_KEYTYPE_RSA:\n          knownkey.keytype = CURLKHTYPE_RSA;\n          break;\n        case SSH_KEYTYPE_RSA1:\n          knownkey.keytype = CURLKHTYPE_RSA1;\n          break;\n        case SSH_KEYTYPE_ECDSA:\n        case SSH_KEYTYPE_ECDSA_P256:\n        case SSH_KEYTYPE_ECDSA_P384:\n        case SSH_KEYTYPE_ECDSA_P521:\n          knownkey.keytype = CURLKHTYPE_ECDSA;\n          break;\n        case SSH_KEYTYPE_ED25519:\n          knownkey.keytype = CURLKHTYPE_ED25519;\n          break;\n        case SSH_KEYTYPE_DSS:\n          knownkey.keytype = CURLKHTYPE_DSS;\n          break;\n        default:\n          rc = SSH_ERROR;\n          goto cleanup;\n      }\n      knownkeyp = &knownkey;\n    }\n  }\n\n  switch(vstate) {\n    case SSH_KNOWN_HOSTS_OK:\n      keymatch = CURLKHMATCH_OK;\n      break;\n    case SSH_KNOWN_HOSTS_OTHER:\n    case SSH_KNOWN_HOSTS_NOT_FOUND:\n    case SSH_KNOWN_HOSTS_UNKNOWN:\n    case SSH_KNOWN_HOSTS_ERROR:\n      keymatch = CURLKHMATCH_MISSING;\n      break;\n  default:\n      keymatch = CURLKHMATCH_MISMATCH;\n      break;\n  }\n\n#else\n  vstate = ssh_is_server_known(sshc->ssh_session);\n  switch(vstate) {\n    case SSH_SERVER_KNOWN_OK:\n      keymatch = CURLKHMATCH_OK;\n      break;\n    case SSH_SERVER_FILE_NOT_FOUND:\n    case SSH_SERVER_NOT_KNOWN:\n      keymatch = CURLKHMATCH_MISSING;\n      break;\n  default:\n      keymatch = CURLKHMATCH_MISMATCH;\n      break;\n  }\n#endif\n\n  if(func) { /* use callback to determine action */\n    rc = ssh_pki_export_pubkey_base64(pubkey, &found_base64);\n    if(rc != SSH_OK)\n      goto cleanup;\n\n    foundkey.key = found_base64;\n    foundkey.len = strlen(found_base64);\n\n    switch(ssh_key_type(pubkey)) {\n      case SSH_KEYTYPE_RSA:\n        foundkey.keytype = CURLKHTYPE_RSA;\n        break;\n      case SSH_KEYTYPE_RSA1:\n        foundkey.keytype = CURLKHTYPE_RSA1;\n        break;\n      case SSH_KEYTYPE_ECDSA:\n#if LIBSSH_VERSION_INT >= SSH_VERSION_INT(0,9,0)\n      case SSH_KEYTYPE_ECDSA_P256:\n      case SSH_KEYTYPE_ECDSA_P384:\n      case SSH_KEYTYPE_ECDSA_P521:\n#endif\n        foundkey.keytype = CURLKHTYPE_ECDSA;\n        break;\n#if LIBSSH_VERSION_INT >= SSH_VERSION_INT(0,7,0)\n      case SSH_KEYTYPE_ED25519:\n        foundkey.keytype = CURLKHTYPE_ED25519;\n        break;\n#endif\n      case SSH_KEYTYPE_DSS:\n        foundkey.keytype = CURLKHTYPE_DSS;\n        break;\n      default:\n        rc = SSH_ERROR;\n        goto cleanup;\n    }\n\n    Curl_set_in_callback(data, true);\n    rc = func(data, knownkeyp, /* from the knownhosts file */\n              &foundkey, /* from the remote host */\n              keymatch, data->set.ssh_keyfunc_userp);\n    Curl_set_in_callback(data, false);\n\n    switch(rc) {\n      case CURLKHSTAT_FINE_ADD_TO_FILE:\n#if LIBSSH_VERSION_INT >= SSH_VERSION_INT(0,8,0)\n        rc = ssh_session_update_known_hosts(sshc->ssh_session);\n#else\n        rc = ssh_write_knownhost(sshc->ssh_session);\n#endif\n        if(rc != SSH_OK) {\n          goto cleanup;\n        }\n        break;\n      case CURLKHSTAT_FINE:\n        break;\n      default: /* REJECT/DEFER */\n        rc = SSH_ERROR;\n        goto cleanup;\n    }\n  }\n  else {\n    if(keymatch != CURLKHMATCH_OK) {\n      rc = SSH_ERROR;\n      goto cleanup;\n    }\n  }\n  rc = SSH_OK;\n\ncleanup:\n  if(found_base64) {\n    (free)(found_base64);\n  }\n  if(known_base64) {\n    (free)(known_base64);\n  }\n  if(hash)\n    ssh_clean_pubkey_hash(&hash);\n  ssh_key_free(pubkey);\n#if LIBSSH_VERSION_INT >= SSH_VERSION_INT(0,9,0)\n  if(knownhostsentry) {\n    ssh_knownhosts_entry_free(knownhostsentry);\n  }\n#endif\n  return rc;\n}\n\n#define MOVE_TO_ERROR_STATE(_r) do {            \\\n    state(data, SSH_SESSION_DISCONNECT);        \\\n    sshc->actualcode = _r;                      \\\n    rc = SSH_ERROR;                             \\\n  } while(0)\n\n#define MOVE_TO_SFTP_CLOSE_STATE() do {                         \\\n    state(data, SSH_SFTP_CLOSE);                                \\\n    sshc->actualcode =                                          \\\n      sftp_error_to_CURLE(sftp_get_error(sshc->sftp_session));  \\\n    rc = SSH_ERROR;                                             \\\n  } while(0)\n\n#define MOVE_TO_PASSWD_AUTH do {                        \\\n    if(sshc->auth_methods & SSH_AUTH_METHOD_PASSWORD) { \\\n      rc = SSH_OK;                                      \\\n      state(data, SSH_AUTH_PASS_INIT);                  \\\n    }                                                   \\\n    else {                                              \\\n      MOVE_TO_ERROR_STATE(CURLE_LOGIN_DENIED);          \\\n    }                                                   \\\n  } while(0)\n\n#define MOVE_TO_KEY_AUTH do {                                   \\\n    if(sshc->auth_methods & SSH_AUTH_METHOD_INTERACTIVE) {      \\\n      rc = SSH_OK;                                              \\\n      state(data, SSH_AUTH_KEY_INIT);                           \\\n    }                                                           \\\n    else {                                                      \\\n      MOVE_TO_PASSWD_AUTH;                                      \\\n    }                                                           \\\n  } while(0)\n\n#define MOVE_TO_GSSAPI_AUTH do {                                \\\n    if(sshc->auth_methods & SSH_AUTH_METHOD_GSSAPI_MIC) {       \\\n      rc = SSH_OK;                                              \\\n      state(data, SSH_AUTH_GSSAPI);                             \\\n    }                                                           \\\n    else {                                                      \\\n      MOVE_TO_KEY_AUTH;                                         \\\n    }                                                           \\\n  } while(0)\n\nstatic\nint myssh_auth_interactive(struct connectdata *conn)\n{\n  int rc;\n  struct ssh_conn *sshc = &conn->proto.sshc;\n  int nprompts;\n\nrestart:\n  switch(sshc->kbd_state) {\n    case 0:\n      rc = ssh_userauth_kbdint(sshc->ssh_session, NULL, NULL);\n      if(rc == SSH_AUTH_AGAIN)\n        return SSH_AGAIN;\n\n      if(rc != SSH_AUTH_INFO)\n        return SSH_ERROR;\n\n      nprompts = ssh_userauth_kbdint_getnprompts(sshc->ssh_session);\n      if(nprompts != 1)\n        return SSH_ERROR;\n\n      rc = ssh_userauth_kbdint_setanswer(sshc->ssh_session, 0, conn->passwd);\n      if(rc < 0)\n        return SSH_ERROR;\n\n      FALLTHROUGH();\n    case 1:\n      sshc->kbd_state = 1;\n\n      rc = ssh_userauth_kbdint(sshc->ssh_session, NULL, NULL);\n      if(rc == SSH_AUTH_AGAIN)\n        return SSH_AGAIN;\n      else if(rc == SSH_AUTH_SUCCESS)\n        rc = SSH_OK;\n      else if(rc == SSH_AUTH_INFO) {\n        nprompts = ssh_userauth_kbdint_getnprompts(sshc->ssh_session);\n        if(nprompts)\n          return SSH_ERROR;\n\n        sshc->kbd_state = 2;\n        goto restart;\n      }\n      else\n        rc = SSH_ERROR;\n      break;\n    case 2:\n      sshc->kbd_state = 2;\n\n      rc = ssh_userauth_kbdint(sshc->ssh_session, NULL, NULL);\n      if(rc == SSH_AUTH_AGAIN)\n        return SSH_AGAIN;\n      else if(rc == SSH_AUTH_SUCCESS)\n        rc = SSH_OK;\n      else\n        rc = SSH_ERROR;\n\n      break;\n    default:\n      return SSH_ERROR;\n  }\n\n  sshc->kbd_state = 0;\n  return rc;\n}\n\n/*\n * ssh_statemach_act() runs the SSH state machine as far as it can without\n * blocking and without reaching the end.  The data the pointer 'block' points\n * to will be set to TRUE if the libssh function returns SSH_AGAIN\n * meaning it wants to be called again when the socket is ready\n */\nstatic CURLcode myssh_statemach_act(struct Curl_easy *data, bool *block)\n{\n  CURLcode result = CURLE_OK;\n  struct connectdata *conn = data->conn;\n  struct SSHPROTO *protop = data->req.p.ssh;\n  struct ssh_conn *sshc = &conn->proto.sshc;\n  curl_socket_t sock = conn->sock[FIRSTSOCKET];\n  int rc = SSH_NO_ERROR, err;\n  int seekerr = CURL_SEEKFUNC_OK;\n  const char *err_msg;\n  *block = 0;                   /* we're not blocking by default */\n\n  do {\n\n    switch(sshc->state) {\n    case SSH_INIT:\n      sshc->secondCreateDirs = 0;\n      sshc->nextstate = SSH_NO_STATE;\n      sshc->actualcode = CURLE_OK;\n\n#if 0\n      ssh_set_log_level(SSH_LOG_PROTOCOL);\n#endif\n\n      /* Set libssh to non-blocking, since everything internally is\n         non-blocking */\n      ssh_set_blocking(sshc->ssh_session, 0);\n\n      state(data, SSH_S_STARTUP);\n      FALLTHROUGH();\n\n    case SSH_S_STARTUP:\n      rc = ssh_connect(sshc->ssh_session);\n      if(rc == SSH_AGAIN)\n        break;\n\n      if(rc != SSH_OK) {\n        failf(data, \"Failure establishing ssh session\");\n        MOVE_TO_ERROR_STATE(CURLE_FAILED_INIT);\n        break;\n      }\n\n      state(data, SSH_HOSTKEY);\n\n      FALLTHROUGH();\n    case SSH_HOSTKEY:\n\n      rc = myssh_is_known(data);\n      if(rc != SSH_OK) {\n        MOVE_TO_ERROR_STATE(CURLE_PEER_FAILED_VERIFICATION);\n        break;\n      }\n\n      state(data, SSH_AUTHLIST);\n      FALLTHROUGH();\n    case SSH_AUTHLIST:{\n        sshc->authed = FALSE;\n\n        rc = ssh_userauth_none(sshc->ssh_session, NULL);\n        if(rc == SSH_AUTH_AGAIN) {\n          rc = SSH_AGAIN;\n          break;\n        }\n\n        if(rc == SSH_AUTH_SUCCESS) {\n          sshc->authed = TRUE;\n          infof(data, \"Authenticated with none\");\n          state(data, SSH_AUTH_DONE);\n          break;\n        }\n        else if(rc == SSH_AUTH_ERROR) {\n          MOVE_TO_ERROR_STATE(CURLE_LOGIN_DENIED);\n          break;\n        }\n\n        sshc->auth_methods = ssh_userauth_list(sshc->ssh_session, NULL);\n        if(sshc->auth_methods)\n          infof(data, \"SSH authentication methods available: %s%s%s%s\",\n                sshc->auth_methods & SSH_AUTH_METHOD_PUBLICKEY ?\n                \"public key, \": \"\",\n                sshc->auth_methods & SSH_AUTH_METHOD_GSSAPI_MIC ?\n                \"GSSAPI, \" : \"\",\n                sshc->auth_methods & SSH_AUTH_METHOD_INTERACTIVE ?\n                \"keyboard-interactive, \" : \"\",\n                sshc->auth_methods & SSH_AUTH_METHOD_PASSWORD ?\n                \"password\": \"\");\n        if(sshc->auth_methods & SSH_AUTH_METHOD_PUBLICKEY) {\n          state(data, SSH_AUTH_PKEY_INIT);\n          infof(data, \"Authentication using SSH public key file\");\n        }\n        else if(sshc->auth_methods & SSH_AUTH_METHOD_GSSAPI_MIC) {\n          state(data, SSH_AUTH_GSSAPI);\n        }\n        else if(sshc->auth_methods & SSH_AUTH_METHOD_INTERACTIVE) {\n          state(data, SSH_AUTH_KEY_INIT);\n        }\n        else if(sshc->auth_methods & SSH_AUTH_METHOD_PASSWORD) {\n          state(data, SSH_AUTH_PASS_INIT);\n        }\n        else {                  /* unsupported authentication method */\n          MOVE_TO_ERROR_STATE(CURLE_LOGIN_DENIED);\n          break;\n        }\n\n        break;\n      }\n    case SSH_AUTH_PKEY_INIT:\n      if(!(data->set.ssh_auth_types & CURLSSH_AUTH_PUBLICKEY)) {\n        MOVE_TO_GSSAPI_AUTH;\n        break;\n      }\n\n      /* Two choices, (1) private key was given on CMD,\n       * (2) use the \"default\" keys. */\n      if(data->set.str[STRING_SSH_PRIVATE_KEY]) {\n        if(sshc->pubkey && !data->set.ssl.key_passwd) {\n          rc = ssh_userauth_try_publickey(sshc->ssh_session, NULL,\n                                          sshc->pubkey);\n          if(rc == SSH_AUTH_AGAIN) {\n            rc = SSH_AGAIN;\n            break;\n          }\n\n          if(rc != SSH_OK) {\n            MOVE_TO_GSSAPI_AUTH;\n            break;\n          }\n        }\n\n        rc = ssh_pki_import_privkey_file(data->\n                                         set.str[STRING_SSH_PRIVATE_KEY],\n                                         data->set.ssl.key_passwd, NULL,\n                                         NULL, &sshc->privkey);\n        if(rc != SSH_OK) {\n          failf(data, \"Could not load private key file %s\",\n                data->set.str[STRING_SSH_PRIVATE_KEY]);\n          MOVE_TO_ERROR_STATE(CURLE_LOGIN_DENIED);\n          break;\n        }\n\n        state(data, SSH_AUTH_PKEY);\n        break;\n\n      }\n      else {\n        rc = ssh_userauth_publickey_auto(sshc->ssh_session, NULL,\n                                         data->set.ssl.key_passwd);\n        if(rc == SSH_AUTH_AGAIN) {\n          rc = SSH_AGAIN;\n          break;\n        }\n        if(rc == SSH_AUTH_SUCCESS) {\n          rc = SSH_OK;\n          sshc->authed = TRUE;\n          infof(data, \"Completed public key authentication\");\n          state(data, SSH_AUTH_DONE);\n          break;\n        }\n\n        MOVE_TO_GSSAPI_AUTH;\n      }\n      break;\n    case SSH_AUTH_PKEY:\n      rc = ssh_userauth_publickey(sshc->ssh_session, NULL, sshc->privkey);\n      if(rc == SSH_AUTH_AGAIN) {\n        rc = SSH_AGAIN;\n        break;\n      }\n\n      if(rc == SSH_AUTH_SUCCESS) {\n        sshc->authed = TRUE;\n        infof(data, \"Completed public key authentication\");\n        state(data, SSH_AUTH_DONE);\n        break;\n      }\n      else {\n        infof(data, \"Failed public key authentication (rc: %d)\", rc);\n        MOVE_TO_GSSAPI_AUTH;\n      }\n      break;\n\n    case SSH_AUTH_GSSAPI:\n      if(!(data->set.ssh_auth_types & CURLSSH_AUTH_GSSAPI)) {\n        MOVE_TO_KEY_AUTH;\n        break;\n      }\n\n      rc = ssh_userauth_gssapi(sshc->ssh_session);\n      if(rc == SSH_AUTH_AGAIN) {\n        rc = SSH_AGAIN;\n        break;\n      }\n\n      if(rc == SSH_AUTH_SUCCESS) {\n        rc = SSH_OK;\n        sshc->authed = TRUE;\n        infof(data, \"Completed gssapi authentication\");\n        state(data, SSH_AUTH_DONE);\n        break;\n      }\n\n      MOVE_TO_KEY_AUTH;\n      break;\n\n    case SSH_AUTH_KEY_INIT:\n      if(data->set.ssh_auth_types & CURLSSH_AUTH_KEYBOARD) {\n        state(data, SSH_AUTH_KEY);\n      }\n      else {\n        MOVE_TO_PASSWD_AUTH;\n      }\n      break;\n\n    case SSH_AUTH_KEY:\n      /* keyboard-interactive authentication */\n      rc = myssh_auth_interactive(conn);\n      if(rc == SSH_AGAIN) {\n        break;\n      }\n      if(rc == SSH_OK) {\n        sshc->authed = TRUE;\n        infof(data, \"completed keyboard interactive authentication\");\n        state(data, SSH_AUTH_DONE);\n      }\n      else {\n        MOVE_TO_PASSWD_AUTH;\n      }\n      break;\n\n    case SSH_AUTH_PASS_INIT:\n      if(!(data->set.ssh_auth_types & CURLSSH_AUTH_PASSWORD)) {\n        MOVE_TO_ERROR_STATE(CURLE_LOGIN_DENIED);\n        break;\n      }\n      state(data, SSH_AUTH_PASS);\n      FALLTHROUGH();\n\n    case SSH_AUTH_PASS:\n      rc = ssh_userauth_password(sshc->ssh_session, NULL, conn->passwd);\n      if(rc == SSH_AUTH_AGAIN) {\n        rc = SSH_AGAIN;\n        break;\n      }\n\n      if(rc == SSH_AUTH_SUCCESS) {\n        sshc->authed = TRUE;\n        infof(data, \"Completed password authentication\");\n        state(data, SSH_AUTH_DONE);\n      }\n      else {\n        MOVE_TO_ERROR_STATE(CURLE_LOGIN_DENIED);\n      }\n      break;\n\n    case SSH_AUTH_DONE:\n      if(!sshc->authed) {\n        failf(data, \"Authentication failure\");\n        MOVE_TO_ERROR_STATE(CURLE_LOGIN_DENIED);\n        break;\n      }\n\n      /*\n       * At this point we have an authenticated ssh session.\n       */\n      infof(data, \"Authentication complete\");\n\n      Curl_pgrsTime(data, TIMER_APPCONNECT);      /* SSH is connected */\n\n      conn->sockfd = sock;\n      conn->writesockfd = CURL_SOCKET_BAD;\n\n      if(conn->handler->protocol == CURLPROTO_SFTP) {\n        state(data, SSH_SFTP_INIT);\n        break;\n      }\n      infof(data, \"SSH CONNECT phase done\");\n      state(data, SSH_STOP);\n      break;\n\n    case SSH_SFTP_INIT:\n      ssh_set_blocking(sshc->ssh_session, 1);\n\n      sshc->sftp_session = sftp_new(sshc->ssh_session);\n      if(!sshc->sftp_session) {\n        failf(data, \"Failure initializing sftp session: %s\",\n              ssh_get_error(sshc->ssh_session));\n        MOVE_TO_ERROR_STATE(CURLE_COULDNT_CONNECT);\n        break;\n      }\n\n      rc = sftp_init(sshc->sftp_session);\n      if(rc != SSH_OK) {\n        failf(data, \"Failure initializing sftp session: %s\",\n              ssh_get_error(sshc->ssh_session));\n        MOVE_TO_ERROR_STATE(sftp_error_to_CURLE(SSH_FX_FAILURE));\n        break;\n      }\n      state(data, SSH_SFTP_REALPATH);\n      FALLTHROUGH();\n    case SSH_SFTP_REALPATH:\n      /*\n       * Get the \"home\" directory\n       */\n      sshc->homedir = sftp_canonicalize_path(sshc->sftp_session, \".\");\n      if(!sshc->homedir) {\n        MOVE_TO_ERROR_STATE(CURLE_COULDNT_CONNECT);\n        break;\n      }\n      data->state.most_recent_ftp_entrypath = sshc->homedir;\n\n      /* This is the last step in the SFTP connect phase. Do note that while\n         we get the homedir here, we get the \"workingpath\" in the DO action\n         since the homedir will remain the same between request but the\n         working path will not. */\n      DEBUGF(infof(data, \"SSH CONNECT phase done\"));\n      state(data, SSH_STOP);\n      break;\n\n    case SSH_SFTP_QUOTE_INIT:\n      result = Curl_getworkingpath(data, sshc->homedir, &protop->path);\n      if(result) {\n        sshc->actualcode = result;\n        state(data, SSH_STOP);\n        break;\n      }\n\n      if(data->set.quote) {\n        infof(data, \"Sending quote commands\");\n        sshc->quote_item = data->set.quote;\n        state(data, SSH_SFTP_QUOTE);\n      }\n      else {\n        state(data, SSH_SFTP_GETINFO);\n      }\n      break;\n\n    case SSH_SFTP_POSTQUOTE_INIT:\n      if(data->set.postquote) {\n        infof(data, \"Sending quote commands\");\n        sshc->quote_item = data->set.postquote;\n        state(data, SSH_SFTP_QUOTE);\n      }\n      else {\n        state(data, SSH_STOP);\n      }\n      break;\n\n    case SSH_SFTP_QUOTE:\n      /* Send any quote commands */\n      sftp_quote(data);\n      break;\n\n    case SSH_SFTP_NEXT_QUOTE:\n      Curl_safefree(sshc->quote_path1);\n      Curl_safefree(sshc->quote_path2);\n\n      sshc->quote_item = sshc->quote_item->next;\n\n      if(sshc->quote_item) {\n        state(data, SSH_SFTP_QUOTE);\n      }\n      else {\n        if(sshc->nextstate != SSH_NO_STATE) {\n          state(data, sshc->nextstate);\n          sshc->nextstate = SSH_NO_STATE;\n        }\n        else {\n          state(data, SSH_SFTP_GETINFO);\n        }\n      }\n      break;\n\n    case SSH_SFTP_QUOTE_STAT:\n      sftp_quote_stat(data);\n      break;\n\n    case SSH_SFTP_QUOTE_SETSTAT:\n      rc = sftp_setstat(sshc->sftp_session, sshc->quote_path2,\n                        sshc->quote_attrs);\n      if(rc && !sshc->acceptfail) {\n        Curl_safefree(sshc->quote_path1);\n        Curl_safefree(sshc->quote_path2);\n        failf(data, \"Attempt to set SFTP stats failed: %s\",\n              ssh_get_error(sshc->ssh_session));\n        state(data, SSH_SFTP_CLOSE);\n        sshc->nextstate = SSH_NO_STATE;\n        sshc->actualcode = CURLE_QUOTE_ERROR;\n        /* sshc->actualcode = sftp_error_to_CURLE(err);\n         * we do not send the actual error; we return\n         * the error the libssh2 backend is returning */\n        break;\n      }\n      state(data, SSH_SFTP_NEXT_QUOTE);\n      break;\n\n    case SSH_SFTP_QUOTE_SYMLINK:\n      rc = sftp_symlink(sshc->sftp_session, sshc->quote_path2,\n                        sshc->quote_path1);\n      if(rc && !sshc->acceptfail) {\n        Curl_safefree(sshc->quote_path1);\n        Curl_safefree(sshc->quote_path2);\n        failf(data, \"symlink command failed: %s\",\n              ssh_get_error(sshc->ssh_session));\n        state(data, SSH_SFTP_CLOSE);\n        sshc->nextstate = SSH_NO_STATE;\n        sshc->actualcode = CURLE_QUOTE_ERROR;\n        break;\n      }\n      state(data, SSH_SFTP_NEXT_QUOTE);\n      break;\n\n    case SSH_SFTP_QUOTE_MKDIR:\n      rc = sftp_mkdir(sshc->sftp_session, sshc->quote_path1,\n                      (mode_t)data->set.new_directory_perms);\n      if(rc && !sshc->acceptfail) {\n        Curl_safefree(sshc->quote_path1);\n        failf(data, \"mkdir command failed: %s\",\n              ssh_get_error(sshc->ssh_session));\n        state(data, SSH_SFTP_CLOSE);\n        sshc->nextstate = SSH_NO_STATE;\n        sshc->actualcode = CURLE_QUOTE_ERROR;\n        break;\n      }\n      state(data, SSH_SFTP_NEXT_QUOTE);\n      break;\n\n    case SSH_SFTP_QUOTE_RENAME:\n      rc = sftp_rename(sshc->sftp_session, sshc->quote_path1,\n                       sshc->quote_path2);\n      if(rc && !sshc->acceptfail) {\n        Curl_safefree(sshc->quote_path1);\n        Curl_safefree(sshc->quote_path2);\n        failf(data, \"rename command failed: %s\",\n              ssh_get_error(sshc->ssh_session));\n        state(data, SSH_SFTP_CLOSE);\n        sshc->nextstate = SSH_NO_STATE;\n        sshc->actualcode = CURLE_QUOTE_ERROR;\n        break;\n      }\n      state(data, SSH_SFTP_NEXT_QUOTE);\n      break;\n\n    case SSH_SFTP_QUOTE_RMDIR:\n      rc = sftp_rmdir(sshc->sftp_session, sshc->quote_path1);\n      if(rc && !sshc->acceptfail) {\n        Curl_safefree(sshc->quote_path1);\n        failf(data, \"rmdir command failed: %s\",\n              ssh_get_error(sshc->ssh_session));\n        state(data, SSH_SFTP_CLOSE);\n        sshc->nextstate = SSH_NO_STATE;\n        sshc->actualcode = CURLE_QUOTE_ERROR;\n        break;\n      }\n      state(data, SSH_SFTP_NEXT_QUOTE);\n      break;\n\n    case SSH_SFTP_QUOTE_UNLINK:\n      rc = sftp_unlink(sshc->sftp_session, sshc->quote_path1);\n      if(rc && !sshc->acceptfail) {\n        Curl_safefree(sshc->quote_path1);\n        failf(data, \"rm command failed: %s\",\n              ssh_get_error(sshc->ssh_session));\n        state(data, SSH_SFTP_CLOSE);\n        sshc->nextstate = SSH_NO_STATE;\n        sshc->actualcode = CURLE_QUOTE_ERROR;\n        break;\n      }\n      state(data, SSH_SFTP_NEXT_QUOTE);\n      break;\n\n    case SSH_SFTP_QUOTE_STATVFS:\n    {\n      sftp_statvfs_t statvfs;\n\n      statvfs = sftp_statvfs(sshc->sftp_session, sshc->quote_path1);\n      if(!statvfs && !sshc->acceptfail) {\n        Curl_safefree(sshc->quote_path1);\n        failf(data, \"statvfs command failed: %s\",\n              ssh_get_error(sshc->ssh_session));\n        state(data, SSH_SFTP_CLOSE);\n        sshc->nextstate = SSH_NO_STATE;\n        sshc->actualcode = CURLE_QUOTE_ERROR;\n        break;\n      }\n      else if(statvfs) {\n        #ifdef _MSC_VER\n        #define CURL_LIBSSH_VFS_SIZE_MASK \"I64u\"\n        #else\n        #define CURL_LIBSSH_VFS_SIZE_MASK PRIu64\n        #endif\n        char *tmp = aprintf(\"statvfs:\\n\"\n                            \"f_bsize: %\" CURL_LIBSSH_VFS_SIZE_MASK \"\\n\"\n                            \"f_frsize: %\" CURL_LIBSSH_VFS_SIZE_MASK \"\\n\"\n                            \"f_blocks: %\" CURL_LIBSSH_VFS_SIZE_MASK \"\\n\"\n                            \"f_bfree: %\" CURL_LIBSSH_VFS_SIZE_MASK \"\\n\"\n                            \"f_bavail: %\" CURL_LIBSSH_VFS_SIZE_MASK \"\\n\"\n                            \"f_files: %\" CURL_LIBSSH_VFS_SIZE_MASK \"\\n\"\n                            \"f_ffree: %\" CURL_LIBSSH_VFS_SIZE_MASK \"\\n\"\n                            \"f_favail: %\" CURL_LIBSSH_VFS_SIZE_MASK \"\\n\"\n                            \"f_fsid: %\" CURL_LIBSSH_VFS_SIZE_MASK \"\\n\"\n                            \"f_flag: %\" CURL_LIBSSH_VFS_SIZE_MASK \"\\n\"\n                            \"f_namemax: %\" CURL_LIBSSH_VFS_SIZE_MASK \"\\n\",\n                            statvfs->f_bsize, statvfs->f_frsize,\n                            statvfs->f_blocks, statvfs->f_bfree,\n                            statvfs->f_bavail, statvfs->f_files,\n                            statvfs->f_ffree, statvfs->f_favail,\n                            statvfs->f_fsid, statvfs->f_flag,\n                            statvfs->f_namemax);\n        sftp_statvfs_free(statvfs);\n\n        if(!tmp) {\n          result = CURLE_OUT_OF_MEMORY;\n          state(data, SSH_SFTP_CLOSE);\n          sshc->nextstate = SSH_NO_STATE;\n          break;\n        }\n\n        result = Curl_client_write(data, CLIENTWRITE_HEADER, tmp, strlen(tmp));\n        free(tmp);\n        if(result) {\n          state(data, SSH_SFTP_CLOSE);\n          sshc->nextstate = SSH_NO_STATE;\n          sshc->actualcode = result;\n        }\n      }\n      state(data, SSH_SFTP_NEXT_QUOTE);\n      break;\n    }\n\n    case SSH_SFTP_GETINFO:\n      if(data->set.get_filetime) {\n        state(data, SSH_SFTP_FILETIME);\n      }\n      else {\n        state(data, SSH_SFTP_TRANS_INIT);\n      }\n      break;\n\n    case SSH_SFTP_FILETIME:\n    {\n      sftp_attributes attrs;\n\n      attrs = sftp_stat(sshc->sftp_session, protop->path);\n      if(attrs) {\n        data->info.filetime = attrs->mtime;\n        sftp_attributes_free(attrs);\n      }\n\n      state(data, SSH_SFTP_TRANS_INIT);\n      break;\n    }\n\n    case SSH_SFTP_TRANS_INIT:\n      if(data->state.upload)\n        state(data, SSH_SFTP_UPLOAD_INIT);\n      else {\n        if(protop->path[strlen(protop->path)-1] == '/')\n          state(data, SSH_SFTP_READDIR_INIT);\n        else\n          state(data, SSH_SFTP_DOWNLOAD_INIT);\n      }\n      break;\n\n    case SSH_SFTP_UPLOAD_INIT:\n    {\n      int flags;\n\n      if(data->state.resume_from) {\n        sftp_attributes attrs;\n\n        if(data->state.resume_from < 0) {\n          attrs = sftp_stat(sshc->sftp_session, protop->path);\n          if(attrs) {\n            curl_off_t size = attrs->size;\n            if(size < 0) {\n              failf(data, \"Bad file size (%\" CURL_FORMAT_CURL_OFF_T \")\", size);\n              MOVE_TO_ERROR_STATE(CURLE_BAD_DOWNLOAD_RESUME);\n              break;\n            }\n            data->state.resume_from = attrs->size;\n\n            sftp_attributes_free(attrs);\n          }\n          else {\n            data->state.resume_from = 0;\n          }\n        }\n      }\n\n      if(data->set.remote_append)\n        /* Try to open for append, but create if nonexisting */\n        flags = O_WRONLY|O_CREAT|O_APPEND;\n      else if(data->state.resume_from > 0)\n        /* If we have restart position then open for append */\n        flags = O_WRONLY|O_APPEND;\n      else\n        /* Clear file before writing (normal behavior) */\n        flags = O_WRONLY|O_CREAT|O_TRUNC;\n\n      if(sshc->sftp_file)\n        sftp_close(sshc->sftp_file);\n      sshc->sftp_file =\n        sftp_open(sshc->sftp_session, protop->path,\n                  flags, (mode_t)data->set.new_file_perms);\n      if(!sshc->sftp_file) {\n        err = sftp_get_error(sshc->sftp_session);\n\n        if(((err == SSH_FX_NO_SUCH_FILE || err == SSH_FX_FAILURE ||\n             err == SSH_FX_NO_SUCH_PATH)) &&\n             (data->set.ftp_create_missing_dirs &&\n             (strlen(protop->path) > 1))) {\n               /* try to create the path remotely */\n               rc = 0;\n               sshc->secondCreateDirs = 1;\n               state(data, SSH_SFTP_CREATE_DIRS_INIT);\n               break;\n        }\n        else {\n          MOVE_TO_SFTP_CLOSE_STATE();\n          break;\n        }\n      }\n\n      /* If we have a restart point then we need to seek to the correct\n         position. */\n      if(data->state.resume_from > 0) {\n        /* Let's read off the proper amount of bytes from the input. */\n        if(data->set.seek_func) {\n          Curl_set_in_callback(data, true);\n          seekerr = data->set.seek_func(data->set.seek_client,\n                                        data->state.resume_from, SEEK_SET);\n          Curl_set_in_callback(data, false);\n        }\n\n        if(seekerr != CURL_SEEKFUNC_OK) {\n          curl_off_t passed = 0;\n\n          if(seekerr != CURL_SEEKFUNC_CANTSEEK) {\n            failf(data, \"Could not seek stream\");\n            return CURLE_FTP_COULDNT_USE_REST;\n          }\n          /* seekerr == CURL_SEEKFUNC_CANTSEEK (can't seek to offset) */\n          do {\n            char scratch[4*1024];\n            size_t readthisamountnow =\n              (data->state.resume_from - passed >\n                (curl_off_t)sizeof(scratch)) ?\n              sizeof(scratch) : curlx_sotouz(data->state.resume_from - passed);\n\n            size_t actuallyread =\n              data->state.fread_func(scratch, 1,\n                                     readthisamountnow, data->state.in);\n\n            passed += actuallyread;\n            if((actuallyread == 0) || (actuallyread > readthisamountnow)) {\n              /* this checks for greater-than only to make sure that the\n                 CURL_READFUNC_ABORT return code still aborts */\n              failf(data, \"Failed to read data\");\n              MOVE_TO_ERROR_STATE(CURLE_FTP_COULDNT_USE_REST);\n              break;\n            }\n          } while(passed < data->state.resume_from);\n          if(rc)\n            break;\n        }\n\n        /* now, decrease the size of the read */\n        if(data->state.infilesize > 0) {\n          data->state.infilesize -= data->state.resume_from;\n          data->req.size = data->state.infilesize;\n          Curl_pgrsSetUploadSize(data, data->state.infilesize);\n        }\n\n        rc = sftp_seek64(sshc->sftp_file, data->state.resume_from);\n        if(rc) {\n          MOVE_TO_SFTP_CLOSE_STATE();\n          break;\n        }\n      }\n      if(data->state.infilesize > 0) {\n        data->req.size = data->state.infilesize;\n        Curl_pgrsSetUploadSize(data, data->state.infilesize);\n      }\n      /* upload data */\n      Curl_xfer_setup(data, -1, -1, FALSE, FIRSTSOCKET);\n\n      /* not set by Curl_xfer_setup to preserve keepon bits */\n      conn->sockfd = conn->writesockfd;\n\n      /* store this original bitmask setup to use later on if we can't\n         figure out a \"real\" bitmask */\n      sshc->orig_waitfor = data->req.keepon;\n\n      /* we want to use the _sending_ function even when the socket turns\n         out readable as the underlying libssh sftp send function will deal\n         with both accordingly */\n      data->state.select_bits = CURL_CSELECT_OUT;\n\n      /* since we don't really wait for anything at this point, we want the\n         state machine to move on as soon as possible so we set a very short\n         timeout here */\n      Curl_expire(data, 0, EXPIRE_RUN_NOW);\n\n      state(data, SSH_STOP);\n      break;\n    }\n\n    case SSH_SFTP_CREATE_DIRS_INIT:\n      if(strlen(protop->path) > 1) {\n        sshc->slash_pos = protop->path + 1; /* ignore the leading '/' */\n        state(data, SSH_SFTP_CREATE_DIRS);\n      }\n      else {\n        state(data, SSH_SFTP_UPLOAD_INIT);\n      }\n      break;\n\n    case SSH_SFTP_CREATE_DIRS:\n      sshc->slash_pos = strchr(sshc->slash_pos, '/');\n      if(sshc->slash_pos) {\n        *sshc->slash_pos = 0;\n\n        infof(data, \"Creating directory '%s'\", protop->path);\n        state(data, SSH_SFTP_CREATE_DIRS_MKDIR);\n        break;\n      }\n      state(data, SSH_SFTP_UPLOAD_INIT);\n      break;\n\n    case SSH_SFTP_CREATE_DIRS_MKDIR:\n      /* 'mode' - parameter is preliminary - default to 0644 */\n      rc = sftp_mkdir(sshc->sftp_session, protop->path,\n                      (mode_t)data->set.new_directory_perms);\n      *sshc->slash_pos = '/';\n      ++sshc->slash_pos;\n      if(rc < 0) {\n        /*\n         * Abort if failure wasn't that the dir already exists or the\n         * permission was denied (creation might succeed further down the\n         * path) - retry on unspecific FAILURE also\n         */\n        err = sftp_get_error(sshc->sftp_session);\n        if((err != SSH_FX_FILE_ALREADY_EXISTS) &&\n           (err != SSH_FX_FAILURE) &&\n           (err != SSH_FX_PERMISSION_DENIED)) {\n          MOVE_TO_SFTP_CLOSE_STATE();\n          break;\n        }\n        rc = 0; /* clear rc and continue */\n      }\n      state(data, SSH_SFTP_CREATE_DIRS);\n      break;\n\n    case SSH_SFTP_READDIR_INIT:\n      Curl_pgrsSetDownloadSize(data, -1);\n      if(data->req.no_body) {\n        state(data, SSH_STOP);\n        break;\n      }\n\n      /*\n       * This is a directory that we are trying to get, so produce a directory\n       * listing\n       */\n      sshc->sftp_dir = sftp_opendir(sshc->sftp_session,\n                                    protop->path);\n      if(!sshc->sftp_dir) {\n        failf(data, \"Could not open directory for reading: %s\",\n              ssh_get_error(sshc->ssh_session));\n        MOVE_TO_SFTP_CLOSE_STATE();\n        break;\n      }\n      state(data, SSH_SFTP_READDIR);\n      break;\n\n    case SSH_SFTP_READDIR:\n      Curl_dyn_reset(&sshc->readdir_buf);\n      if(sshc->readdir_attrs)\n        sftp_attributes_free(sshc->readdir_attrs);\n\n      sshc->readdir_attrs = sftp_readdir(sshc->sftp_session, sshc->sftp_dir);\n      if(sshc->readdir_attrs) {\n        sshc->readdir_filename = sshc->readdir_attrs->name;\n        sshc->readdir_longentry = sshc->readdir_attrs->longname;\n        sshc->readdir_len = strlen(sshc->readdir_filename);\n\n        if(data->set.list_only) {\n          char *tmpLine;\n\n          tmpLine = aprintf(\"%s\\n\", sshc->readdir_filename);\n          if(!tmpLine) {\n            state(data, SSH_SFTP_CLOSE);\n            sshc->actualcode = CURLE_OUT_OF_MEMORY;\n            break;\n          }\n          result = Curl_client_write(data, CLIENTWRITE_BODY,\n                                     tmpLine, sshc->readdir_len + 1);\n          free(tmpLine);\n\n          if(result) {\n            state(data, SSH_STOP);\n            break;\n          }\n\n        }\n        else {\n          if(Curl_dyn_add(&sshc->readdir_buf, sshc->readdir_longentry)) {\n            sshc->actualcode = CURLE_OUT_OF_MEMORY;\n            state(data, SSH_STOP);\n            break;\n          }\n\n          if((sshc->readdir_attrs->flags & SSH_FILEXFER_ATTR_PERMISSIONS) &&\n             ((sshc->readdir_attrs->permissions & SSH_S_IFMT) ==\n              SSH_S_IFLNK)) {\n            sshc->readdir_linkPath = aprintf(\"%s%s\", protop->path,\n                                             sshc->readdir_filename);\n\n            if(!sshc->readdir_linkPath) {\n              state(data, SSH_SFTP_CLOSE);\n              sshc->actualcode = CURLE_OUT_OF_MEMORY;\n              break;\n            }\n\n            state(data, SSH_SFTP_READDIR_LINK);\n            break;\n          }\n          state(data, SSH_SFTP_READDIR_BOTTOM);\n          break;\n        }\n      }\n      else if(sftp_dir_eof(sshc->sftp_dir)) {\n        state(data, SSH_SFTP_READDIR_DONE);\n        break;\n      }\n      else {\n        failf(data, \"Could not open remote file for reading: %s\",\n              ssh_get_error(sshc->ssh_session));\n        MOVE_TO_SFTP_CLOSE_STATE();\n        break;\n      }\n      break;\n\n    case SSH_SFTP_READDIR_LINK:\n      if(sshc->readdir_link_attrs)\n        sftp_attributes_free(sshc->readdir_link_attrs);\n\n      sshc->readdir_link_attrs = sftp_lstat(sshc->sftp_session,\n                                            sshc->readdir_linkPath);\n      if(sshc->readdir_link_attrs == 0) {\n        failf(data, \"Could not read symlink for reading: %s\",\n              ssh_get_error(sshc->ssh_session));\n        MOVE_TO_SFTP_CLOSE_STATE();\n        break;\n      }\n\n      if(!sshc->readdir_link_attrs->name) {\n        sshc->readdir_tmp = sftp_readlink(sshc->sftp_session,\n                                          sshc->readdir_linkPath);\n        if(!sshc->readdir_filename)\n          sshc->readdir_len = 0;\n        else\n          sshc->readdir_len = strlen(sshc->readdir_tmp);\n        sshc->readdir_longentry = NULL;\n        sshc->readdir_filename = sshc->readdir_tmp;\n      }\n      else {\n        sshc->readdir_len = strlen(sshc->readdir_link_attrs->name);\n        sshc->readdir_filename = sshc->readdir_link_attrs->name;\n        sshc->readdir_longentry = sshc->readdir_link_attrs->longname;\n      }\n\n      Curl_safefree(sshc->readdir_linkPath);\n\n      if(Curl_dyn_addf(&sshc->readdir_buf, \" -> %s\",\n                       sshc->readdir_filename)) {\n        sshc->actualcode = CURLE_OUT_OF_MEMORY;\n        break;\n      }\n\n      sftp_attributes_free(sshc->readdir_link_attrs);\n      sshc->readdir_link_attrs = NULL;\n      sshc->readdir_filename = NULL;\n      sshc->readdir_longentry = NULL;\n\n      state(data, SSH_SFTP_READDIR_BOTTOM);\n      FALLTHROUGH();\n    case SSH_SFTP_READDIR_BOTTOM:\n      if(Curl_dyn_addn(&sshc->readdir_buf, \"\\n\", 1))\n        result = CURLE_OUT_OF_MEMORY;\n      else\n        result = Curl_client_write(data, CLIENTWRITE_BODY,\n                                   Curl_dyn_ptr(&sshc->readdir_buf),\n                                   Curl_dyn_len(&sshc->readdir_buf));\n\n      ssh_string_free_char(sshc->readdir_tmp);\n      sshc->readdir_tmp = NULL;\n\n      if(result) {\n        state(data, SSH_STOP);\n      }\n      else\n        state(data, SSH_SFTP_READDIR);\n      break;\n\n    case SSH_SFTP_READDIR_DONE:\n      sftp_closedir(sshc->sftp_dir);\n      sshc->sftp_dir = NULL;\n\n      /* no data to transfer */\n      Curl_xfer_setup(data, -1, -1, FALSE, -1);\n      state(data, SSH_STOP);\n      break;\n\n    case SSH_SFTP_DOWNLOAD_INIT:\n      /*\n       * Work on getting the specified file\n       */\n      if(sshc->sftp_file)\n        sftp_close(sshc->sftp_file);\n\n      sshc->sftp_file = sftp_open(sshc->sftp_session, protop->path,\n                                  O_RDONLY, (mode_t)data->set.new_file_perms);\n      if(!sshc->sftp_file) {\n        failf(data, \"Could not open remote file for reading: %s\",\n              ssh_get_error(sshc->ssh_session));\n\n        MOVE_TO_SFTP_CLOSE_STATE();\n        break;\n      }\n      sftp_file_set_nonblocking(sshc->sftp_file);\n      state(data, SSH_SFTP_DOWNLOAD_STAT);\n      break;\n\n    case SSH_SFTP_DOWNLOAD_STAT:\n    {\n      sftp_attributes attrs;\n      curl_off_t size;\n\n      attrs = sftp_fstat(sshc->sftp_file);\n      if(!attrs ||\n              !(attrs->flags & SSH_FILEXFER_ATTR_SIZE) ||\n              (attrs->size == 0)) {\n        /*\n         * sftp_fstat didn't return an error, so maybe the server\n         * just doesn't support stat()\n         * OR the server doesn't return a file size with a stat()\n         * OR file size is 0\n         */\n        data->req.size = -1;\n        data->req.maxdownload = -1;\n        Curl_pgrsSetDownloadSize(data, -1);\n        size = 0;\n      }\n      else {\n        size = attrs->size;\n\n        sftp_attributes_free(attrs);\n\n        if(size < 0) {\n          failf(data, \"Bad file size (%\" CURL_FORMAT_CURL_OFF_T \")\", size);\n          return CURLE_BAD_DOWNLOAD_RESUME;\n        }\n        if(data->state.use_range) {\n          curl_off_t from, to;\n          char *ptr;\n          char *ptr2;\n          CURLofft to_t;\n          CURLofft from_t;\n\n          from_t = curlx_strtoofft(data->state.range, &ptr, 10, &from);\n          if(from_t == CURL_OFFT_FLOW) {\n            return CURLE_RANGE_ERROR;\n          }\n          while(*ptr && (ISBLANK(*ptr) || (*ptr == '-')))\n            ptr++;\n          to_t = curlx_strtoofft(ptr, &ptr2, 10, &to);\n          if(to_t == CURL_OFFT_FLOW) {\n            return CURLE_RANGE_ERROR;\n          }\n          if((to_t == CURL_OFFT_INVAL) /* no \"to\" value given */\n             || (to >= size)) {\n            to = size - 1;\n          }\n          if(from_t) {\n            /* from is relative to end of file */\n            from = size - to;\n            to = size - 1;\n          }\n          if(from > size) {\n            failf(data, \"Offset (%\"\n                  CURL_FORMAT_CURL_OFF_T \") was beyond file size (%\"\n                  CURL_FORMAT_CURL_OFF_T \")\", from, size);\n            return CURLE_BAD_DOWNLOAD_RESUME;\n          }\n          if(from > to) {\n            from = to;\n            size = 0;\n          }\n          else {\n            if((to - from) == CURL_OFF_T_MAX)\n              return CURLE_RANGE_ERROR;\n            size = to - from + 1;\n          }\n\n          rc = sftp_seek64(sshc->sftp_file, from);\n          if(rc) {\n            MOVE_TO_SFTP_CLOSE_STATE();\n            break;\n          }\n        }\n        data->req.size = size;\n        data->req.maxdownload = size;\n        Curl_pgrsSetDownloadSize(data, size);\n      }\n\n      /* We can resume if we can seek to the resume position */\n      if(data->state.resume_from) {\n        if(data->state.resume_from < 0) {\n          /* We're supposed to download the last abs(from) bytes */\n          if((curl_off_t)size < -data->state.resume_from) {\n            failf(data, \"Offset (%\"\n                  CURL_FORMAT_CURL_OFF_T \") was beyond file size (%\"\n                  CURL_FORMAT_CURL_OFF_T \")\",\n                  data->state.resume_from, size);\n            return CURLE_BAD_DOWNLOAD_RESUME;\n          }\n          /* download from where? */\n          data->state.resume_from += size;\n        }\n        else {\n          if((curl_off_t)size < data->state.resume_from) {\n            failf(data, \"Offset (%\" CURL_FORMAT_CURL_OFF_T\n                  \") was beyond file size (%\" CURL_FORMAT_CURL_OFF_T \")\",\n                  data->state.resume_from, size);\n            return CURLE_BAD_DOWNLOAD_RESUME;\n          }\n        }\n        /* Now store the number of bytes we are expected to download */\n        data->req.size = size - data->state.resume_from;\n        data->req.maxdownload = size - data->state.resume_from;\n        Curl_pgrsSetDownloadSize(data,\n                                 size - data->state.resume_from);\n\n        rc = sftp_seek64(sshc->sftp_file, data->state.resume_from);\n        if(rc) {\n          MOVE_TO_SFTP_CLOSE_STATE();\n          break;\n        }\n      }\n    }\n\n    /* Setup the actual download */\n    if(data->req.size == 0) {\n      /* no data to transfer */\n      Curl_xfer_setup(data, -1, -1, FALSE, -1);\n      infof(data, \"File already completely downloaded\");\n      state(data, SSH_STOP);\n      break;\n    }\n    Curl_xfer_setup(data, FIRSTSOCKET, data->req.size, FALSE, -1);\n\n    /* not set by Curl_xfer_setup to preserve keepon bits */\n    conn->writesockfd = conn->sockfd;\n\n    /* we want to use the _receiving_ function even when the socket turns\n       out writableable as the underlying libssh recv function will deal\n       with both accordingly */\n    data->state.select_bits = CURL_CSELECT_IN;\n\n    if(result) {\n      /* this should never occur; the close state should be entered\n         at the time the error occurs */\n      state(data, SSH_SFTP_CLOSE);\n      sshc->actualcode = result;\n    }\n    else {\n      sshc->sftp_recv_state = 0;\n      state(data, SSH_STOP);\n    }\n    break;\n\n    case SSH_SFTP_CLOSE:\n      if(sshc->sftp_file) {\n        sftp_close(sshc->sftp_file);\n        sshc->sftp_file = NULL;\n      }\n      Curl_safefree(protop->path);\n\n      DEBUGF(infof(data, \"SFTP DONE done\"));\n\n      /* Check if nextstate is set and move .nextstate could be POSTQUOTE_INIT\n         After nextstate is executed, the control should come back to\n         SSH_SFTP_CLOSE to pass the correct result back  */\n      if(sshc->nextstate != SSH_NO_STATE &&\n         sshc->nextstate != SSH_SFTP_CLOSE) {\n        state(data, sshc->nextstate);\n        sshc->nextstate = SSH_SFTP_CLOSE;\n      }\n      else {\n        state(data, SSH_STOP);\n        result = sshc->actualcode;\n      }\n      break;\n\n    case SSH_SFTP_SHUTDOWN:\n      /* during times we get here due to a broken transfer and then the\n         sftp_handle might not have been taken down so make sure that is done\n         before we proceed */\n\n      if(sshc->sftp_file) {\n        sftp_close(sshc->sftp_file);\n        sshc->sftp_file = NULL;\n      }\n\n      if(sshc->sftp_session) {\n        sftp_free(sshc->sftp_session);\n        sshc->sftp_session = NULL;\n      }\n\n      SSH_STRING_FREE_CHAR(sshc->homedir);\n      data->state.most_recent_ftp_entrypath = NULL;\n\n      state(data, SSH_SESSION_DISCONNECT);\n      break;\n\n    case SSH_SCP_TRANS_INIT:\n      result = Curl_getworkingpath(data, sshc->homedir, &protop->path);\n      if(result) {\n        sshc->actualcode = result;\n        state(data, SSH_STOP);\n        break;\n      }\n\n      /* Functions from the SCP subsystem cannot handle/return SSH_AGAIN */\n      ssh_set_blocking(sshc->ssh_session, 1);\n\n      if(data->state.upload) {\n        if(data->state.infilesize < 0) {\n          failf(data, \"SCP requires a known file size for upload\");\n          sshc->actualcode = CURLE_UPLOAD_FAILED;\n          MOVE_TO_ERROR_STATE(CURLE_UPLOAD_FAILED);\n          break;\n        }\n\n        sshc->scp_session =\n          ssh_scp_new(sshc->ssh_session, SSH_SCP_WRITE, protop->path);\n        state(data, SSH_SCP_UPLOAD_INIT);\n      }\n      else {\n        sshc->scp_session =\n          ssh_scp_new(sshc->ssh_session, SSH_SCP_READ, protop->path);\n        state(data, SSH_SCP_DOWNLOAD_INIT);\n      }\n\n      if(!sshc->scp_session) {\n        err_msg = ssh_get_error(sshc->ssh_session);\n        failf(data, \"%s\", err_msg);\n        MOVE_TO_ERROR_STATE(CURLE_UPLOAD_FAILED);\n      }\n\n      break;\n\n    case SSH_SCP_UPLOAD_INIT:\n\n      rc = ssh_scp_init(sshc->scp_session);\n      if(rc != SSH_OK) {\n        err_msg = ssh_get_error(sshc->ssh_session);\n        failf(data, \"%s\", err_msg);\n        MOVE_TO_ERROR_STATE(CURLE_UPLOAD_FAILED);\n        break;\n      }\n\n      rc = ssh_scp_push_file(sshc->scp_session, protop->path,\n                             data->state.infilesize,\n                             (int)data->set.new_file_perms);\n      if(rc != SSH_OK) {\n        err_msg = ssh_get_error(sshc->ssh_session);\n        failf(data, \"%s\", err_msg);\n        MOVE_TO_ERROR_STATE(CURLE_UPLOAD_FAILED);\n        break;\n      }\n\n      /* upload data */\n      Curl_xfer_setup(data, -1, data->req.size, FALSE, FIRSTSOCKET);\n\n      /* not set by Curl_xfer_setup to preserve keepon bits */\n      conn->sockfd = conn->writesockfd;\n\n      /* store this original bitmask setup to use later on if we can't\n         figure out a \"real\" bitmask */\n      sshc->orig_waitfor = data->req.keepon;\n\n      /* we want to use the _sending_ function even when the socket turns\n         out readable as the underlying libssh scp send function will deal\n         with both accordingly */\n      data->state.select_bits = CURL_CSELECT_OUT;\n\n      state(data, SSH_STOP);\n\n      break;\n\n    case SSH_SCP_DOWNLOAD_INIT:\n\n      rc = ssh_scp_init(sshc->scp_session);\n      if(rc != SSH_OK) {\n        err_msg = ssh_get_error(sshc->ssh_session);\n        failf(data, \"%s\", err_msg);\n        MOVE_TO_ERROR_STATE(CURLE_COULDNT_CONNECT);\n        break;\n      }\n      state(data, SSH_SCP_DOWNLOAD);\n      FALLTHROUGH();\n\n    case SSH_SCP_DOWNLOAD:{\n        curl_off_t bytecount;\n\n        rc = ssh_scp_pull_request(sshc->scp_session);\n        if(rc != SSH_SCP_REQUEST_NEWFILE) {\n          err_msg = ssh_get_error(sshc->ssh_session);\n          failf(data, \"%s\", err_msg);\n          MOVE_TO_ERROR_STATE(CURLE_REMOTE_FILE_NOT_FOUND);\n          break;\n        }\n\n        /* download data */\n        bytecount = ssh_scp_request_get_size(sshc->scp_session);\n        data->req.maxdownload = (curl_off_t) bytecount;\n        Curl_xfer_setup(data, FIRSTSOCKET, bytecount, FALSE, -1);\n\n        /* not set by Curl_xfer_setup to preserve keepon bits */\n        conn->writesockfd = conn->sockfd;\n\n        /* we want to use the _receiving_ function even when the socket turns\n           out writableable as the underlying libssh recv function will deal\n           with both accordingly */\n        data->state.select_bits = CURL_CSELECT_IN;\n\n        state(data, SSH_STOP);\n        break;\n      }\n    case SSH_SCP_DONE:\n      if(data->state.upload)\n        state(data, SSH_SCP_SEND_EOF);\n      else\n        state(data, SSH_SCP_CHANNEL_FREE);\n      break;\n\n    case SSH_SCP_SEND_EOF:\n      if(sshc->scp_session) {\n        rc = ssh_scp_close(sshc->scp_session);\n        if(rc == SSH_AGAIN) {\n          /* Currently the ssh_scp_close handles waiting for EOF in\n           * blocking way.\n           */\n          break;\n        }\n        if(rc != SSH_OK) {\n          infof(data, \"Failed to close libssh scp channel: %s\",\n                ssh_get_error(sshc->ssh_session));\n        }\n      }\n\n      state(data, SSH_SCP_CHANNEL_FREE);\n      break;\n\n    case SSH_SCP_CHANNEL_FREE:\n      if(sshc->scp_session) {\n        ssh_scp_free(sshc->scp_session);\n        sshc->scp_session = NULL;\n      }\n      DEBUGF(infof(data, \"SCP DONE phase complete\"));\n\n      ssh_set_blocking(sshc->ssh_session, 0);\n\n      state(data, SSH_SESSION_DISCONNECT);\n      FALLTHROUGH();\n\n    case SSH_SESSION_DISCONNECT:\n      /* during weird times when we've been prematurely aborted, the channel\n         is still alive when we reach this state and we MUST kill the channel\n         properly first */\n      if(sshc->scp_session) {\n        ssh_scp_free(sshc->scp_session);\n        sshc->scp_session = NULL;\n      }\n\n      ssh_disconnect(sshc->ssh_session);\n      if(!ssh_version(SSH_VERSION_INT(0, 10, 0))) {\n        /* conn->sock[FIRSTSOCKET] is closed by ssh_disconnect behind our back,\n           tell the connection to forget about it. This libssh\n           bug is fixed in 0.10.0. */\n        Curl_conn_forget_socket(data, FIRSTSOCKET);\n      }\n\n      SSH_STRING_FREE_CHAR(sshc->homedir);\n      data->state.most_recent_ftp_entrypath = NULL;\n\n      state(data, SSH_SESSION_FREE);\n      FALLTHROUGH();\n    case SSH_SESSION_FREE:\n      if(sshc->ssh_session) {\n        ssh_free(sshc->ssh_session);\n        sshc->ssh_session = NULL;\n      }\n\n      /* worst-case scenario cleanup */\n\n      DEBUGASSERT(sshc->ssh_session == NULL);\n      DEBUGASSERT(sshc->scp_session == NULL);\n\n      if(sshc->readdir_tmp) {\n        ssh_string_free_char(sshc->readdir_tmp);\n        sshc->readdir_tmp = NULL;\n      }\n\n      if(sshc->quote_attrs)\n        sftp_attributes_free(sshc->quote_attrs);\n\n      if(sshc->readdir_attrs)\n        sftp_attributes_free(sshc->readdir_attrs);\n\n      if(sshc->readdir_link_attrs)\n        sftp_attributes_free(sshc->readdir_link_attrs);\n\n      if(sshc->privkey)\n        ssh_key_free(sshc->privkey);\n      if(sshc->pubkey)\n        ssh_key_free(sshc->pubkey);\n\n      Curl_safefree(sshc->rsa_pub);\n      Curl_safefree(sshc->rsa);\n      Curl_safefree(sshc->quote_path1);\n      Curl_safefree(sshc->quote_path2);\n      Curl_dyn_free(&sshc->readdir_buf);\n      Curl_safefree(sshc->readdir_linkPath);\n      SSH_STRING_FREE_CHAR(sshc->homedir);\n\n      /* the code we are about to return */\n      result = sshc->actualcode;\n\n      memset(sshc, 0, sizeof(struct ssh_conn));\n\n      connclose(conn, \"SSH session free\");\n      sshc->state = SSH_SESSION_FREE;   /* current */\n      sshc->nextstate = SSH_NO_STATE;\n      state(data, SSH_STOP);\n      break;\n\n    case SSH_QUIT:\n    default:\n      /* internal error */\n      sshc->nextstate = SSH_NO_STATE;\n      state(data, SSH_STOP);\n      break;\n\n    }\n  } while(!rc && (sshc->state != SSH_STOP));\n\n\n  if(rc == SSH_AGAIN) {\n    /* we would block, we need to wait for the socket to be ready (in the\n       right direction too)! */\n    *block = TRUE;\n  }\n\n  return result;\n}\n\n\n/* called by the multi interface to figure out what socket(s) to wait for and\n   for what actions in the DO_DONE, PERFORM and WAITPERFORM states */\nstatic int myssh_getsock(struct Curl_easy *data,\n                         struct connectdata *conn,\n                         curl_socket_t *sock)\n{\n  int bitmap = GETSOCK_BLANK;\n  (void)data;\n  sock[0] = conn->sock[FIRSTSOCKET];\n\n  if(conn->waitfor & KEEP_RECV)\n    bitmap |= GETSOCK_READSOCK(FIRSTSOCKET);\n\n  if(conn->waitfor & KEEP_SEND)\n    bitmap |= GETSOCK_WRITESOCK(FIRSTSOCKET);\n\n  if(!conn->waitfor)\n    bitmap |= GETSOCK_WRITESOCK(FIRSTSOCKET);\n\n  return bitmap;\n}\n\nstatic void myssh_block2waitfor(struct connectdata *conn, bool block)\n{\n  struct ssh_conn *sshc = &conn->proto.sshc;\n\n  /* If it didn't block, or nothing was returned by ssh_get_poll_flags\n   * have the original set */\n  conn->waitfor = sshc->orig_waitfor;\n\n  if(block) {\n    int dir = ssh_get_poll_flags(sshc->ssh_session);\n    if(dir & SSH_READ_PENDING) {\n      /* translate the libssh define bits into our own bit defines */\n      conn->waitfor = KEEP_RECV;\n    }\n    else if(dir & SSH_WRITE_PENDING) {\n      conn->waitfor = KEEP_SEND;\n    }\n  }\n}\n\n/* called repeatedly until done from multi.c */\nstatic CURLcode myssh_multi_statemach(struct Curl_easy *data,\n                                      bool *done)\n{\n  struct connectdata *conn = data->conn;\n  struct ssh_conn *sshc = &conn->proto.sshc;\n  bool block;    /* we store the status and use that to provide a ssh_getsock()\n                    implementation */\n  CURLcode result = myssh_statemach_act(data, &block);\n\n  *done = (sshc->state == SSH_STOP) ? TRUE : FALSE;\n  myssh_block2waitfor(conn, block);\n\n  return result;\n}\n\nstatic CURLcode myssh_block_statemach(struct Curl_easy *data,\n                                      bool disconnect)\n{\n  struct connectdata *conn = data->conn;\n  struct ssh_conn *sshc = &conn->proto.sshc;\n  CURLcode result = CURLE_OK;\n\n  while((sshc->state != SSH_STOP) && !result) {\n    bool block;\n    timediff_t left = 1000;\n    struct curltime now = Curl_now();\n\n    result = myssh_statemach_act(data, &block);\n    if(result)\n      break;\n\n    if(!disconnect) {\n      if(Curl_pgrsUpdate(data))\n        return CURLE_ABORTED_BY_CALLBACK;\n\n      result = Curl_speedcheck(data, now);\n      if(result)\n        break;\n\n      left = Curl_timeleft(data, NULL, FALSE);\n      if(left < 0) {\n        failf(data, \"Operation timed out\");\n        return CURLE_OPERATION_TIMEDOUT;\n      }\n    }\n\n    if(block) {\n      curl_socket_t fd_read = conn->sock[FIRSTSOCKET];\n      /* wait for the socket to become ready */\n      (void) Curl_socket_check(fd_read, CURL_SOCKET_BAD,\n                               CURL_SOCKET_BAD, left > 1000 ? 1000 : left);\n    }\n\n  }\n\n  return result;\n}\n\n/*\n * SSH setup connection\n */\nstatic CURLcode myssh_setup_connection(struct Curl_easy *data,\n                                       struct connectdata *conn)\n{\n  struct SSHPROTO *ssh;\n  struct ssh_conn *sshc = &conn->proto.sshc;\n\n  data->req.p.ssh = ssh = calloc(1, sizeof(struct SSHPROTO));\n  if(!ssh)\n    return CURLE_OUT_OF_MEMORY;\n  Curl_dyn_init(&sshc->readdir_buf, PATH_MAX * 2);\n\n  return CURLE_OK;\n}\n\nstatic Curl_recv scp_recv, sftp_recv;\nstatic Curl_send scp_send, sftp_send;\n\n/*\n * Curl_ssh_connect() gets called from Curl_protocol_connect() to allow us to\n * do protocol-specific actions at connect-time.\n */\nstatic CURLcode myssh_connect(struct Curl_easy *data, bool *done)\n{\n  struct ssh_conn *ssh;\n  CURLcode result;\n  struct connectdata *conn = data->conn;\n  curl_socket_t sock = conn->sock[FIRSTSOCKET];\n  int rc;\n\n  /* initialize per-handle data if not already */\n  if(!data->req.p.ssh)\n    myssh_setup_connection(data, conn);\n\n  /* We default to persistent connections. We set this already in this connect\n     function to make the reuse checks properly be able to check this bit. */\n  connkeep(conn, \"SSH default\");\n\n  if(conn->handler->protocol & CURLPROTO_SCP) {\n    conn->recv[FIRSTSOCKET] = scp_recv;\n    conn->send[FIRSTSOCKET] = scp_send;\n  }\n  else {\n    conn->recv[FIRSTSOCKET] = sftp_recv;\n    conn->send[FIRSTSOCKET] = sftp_send;\n  }\n\n  ssh = &conn->proto.sshc;\n\n  ssh->ssh_session = ssh_new();\n  if(!ssh->ssh_session) {\n    failf(data, \"Failure initialising ssh session\");\n    return CURLE_FAILED_INIT;\n  }\n\n  rc = ssh_options_set(ssh->ssh_session, SSH_OPTIONS_HOST, conn->host.name);\n  if(rc != SSH_OK) {\n    failf(data, \"Could not set remote host\");\n    return CURLE_FAILED_INIT;\n  }\n\n  rc = ssh_options_parse_config(ssh->ssh_session, NULL);\n  if(rc != SSH_OK) {\n    infof(data, \"Could not parse SSH configuration files\");\n    /* ignore */\n  }\n\n  rc = ssh_options_set(ssh->ssh_session, SSH_OPTIONS_FD, &sock);\n  if(rc != SSH_OK) {\n    failf(data, \"Could not set socket\");\n    return CURLE_FAILED_INIT;\n  }\n\n  if(conn->user && conn->user[0] != '\\0') {\n    infof(data, \"User: %s\", conn->user);\n    rc = ssh_options_set(ssh->ssh_session, SSH_OPTIONS_USER, conn->user);\n    if(rc != SSH_OK) {\n      failf(data, \"Could not set user\");\n      return CURLE_FAILED_INIT;\n    }\n  }\n\n  if(data->set.str[STRING_SSH_KNOWNHOSTS]) {\n    infof(data, \"Known hosts: %s\", data->set.str[STRING_SSH_KNOWNHOSTS]);\n    rc = ssh_options_set(ssh->ssh_session, SSH_OPTIONS_KNOWNHOSTS,\n                         data->set.str[STRING_SSH_KNOWNHOSTS]);\n    if(rc != SSH_OK) {\n      failf(data, \"Could not set known hosts file path\");\n      return CURLE_FAILED_INIT;\n    }\n  }\n\n  if(conn->remote_port) {\n    rc = ssh_options_set(ssh->ssh_session, SSH_OPTIONS_PORT,\n                         &conn->remote_port);\n    if(rc != SSH_OK) {\n      failf(data, \"Could not set remote port\");\n      return CURLE_FAILED_INIT;\n    }\n  }\n\n  if(data->set.ssh_compression) {\n    rc = ssh_options_set(ssh->ssh_session, SSH_OPTIONS_COMPRESSION,\n                         \"zlib,zlib@openssh.com,none\");\n    if(rc != SSH_OK) {\n      failf(data, \"Could not set compression\");\n      return CURLE_FAILED_INIT;\n    }\n  }\n\n  ssh->privkey = NULL;\n  ssh->pubkey = NULL;\n\n  if(data->set.str[STRING_SSH_PUBLIC_KEY]) {\n    rc = ssh_pki_import_pubkey_file(data->set.str[STRING_SSH_PUBLIC_KEY],\n                                    &ssh->pubkey);\n    if(rc != SSH_OK) {\n      failf(data, \"Could not load public key file\");\n      return CURLE_FAILED_INIT;\n    }\n  }\n\n  /* we do not verify here, we do it at the state machine,\n   * after connection */\n\n  state(data, SSH_INIT);\n\n  result = myssh_multi_statemach(data, done);\n\n  return result;\n}\n\n/* called from multi.c while DOing */\nstatic CURLcode scp_doing(struct Curl_easy *data, bool *dophase_done)\n{\n  CURLcode result;\n\n  result = myssh_multi_statemach(data, dophase_done);\n\n  if(*dophase_done) {\n    DEBUGF(infof(data, \"DO phase is complete\"));\n  }\n  return result;\n}\n\n/*\n ***********************************************************************\n *\n * scp_perform()\n *\n * This is the actual DO function for SCP. Get a file according to\n * the options previously setup.\n */\n\nstatic\nCURLcode scp_perform(struct Curl_easy *data,\n                     bool *connected, bool *dophase_done)\n{\n  CURLcode result = CURLE_OK;\n\n  DEBUGF(infof(data, \"DO phase starts\"));\n\n  *dophase_done = FALSE;        /* not done yet */\n\n  /* start the first command in the DO phase */\n  state(data, SSH_SCP_TRANS_INIT);\n\n  result = myssh_multi_statemach(data, dophase_done);\n\n  *connected = Curl_conn_is_connected(data->conn, FIRSTSOCKET);\n\n  if(*dophase_done) {\n    DEBUGF(infof(data, \"DO phase is complete\"));\n  }\n\n  return result;\n}\n\nstatic CURLcode myssh_do_it(struct Curl_easy *data, bool *done)\n{\n  CURLcode result;\n  bool connected = 0;\n  struct connectdata *conn = data->conn;\n  struct ssh_conn *sshc = &conn->proto.sshc;\n\n  *done = FALSE;                /* default to false */\n\n  data->req.size = -1;          /* make sure this is unknown at this point */\n\n  sshc->actualcode = CURLE_OK;  /* reset error code */\n  sshc->secondCreateDirs = 0;   /* reset the create dir attempt state\n                                   variable */\n\n  Curl_pgrsSetUploadCounter(data, 0);\n  Curl_pgrsSetDownloadCounter(data, 0);\n  Curl_pgrsSetUploadSize(data, -1);\n  Curl_pgrsSetDownloadSize(data, -1);\n\n  if(conn->handler->protocol & CURLPROTO_SCP)\n    result = scp_perform(data, &connected, done);\n  else\n    result = sftp_perform(data, &connected, done);\n\n  return result;\n}\n\n/* BLOCKING, but the function is using the state machine so the only reason\n   this is still blocking is that the multi interface code has no support for\n   disconnecting operations that takes a while */\nstatic CURLcode scp_disconnect(struct Curl_easy *data,\n                               struct connectdata *conn,\n                               bool dead_connection)\n{\n  CURLcode result = CURLE_OK;\n  struct ssh_conn *ssh = &conn->proto.sshc;\n  (void) dead_connection;\n\n  if(ssh->ssh_session) {\n    /* only if there's a session still around to use! */\n\n    state(data, SSH_SESSION_DISCONNECT);\n\n    result = myssh_block_statemach(data, TRUE);\n  }\n\n  return result;\n}\n\n/* generic done function for both SCP and SFTP called from their specific\n   done functions */\nstatic CURLcode myssh_done(struct Curl_easy *data, CURLcode status)\n{\n  CURLcode result = CURLE_OK;\n  struct SSHPROTO *protop = data->req.p.ssh;\n\n  if(!status) {\n    /* run the state-machine */\n    result = myssh_block_statemach(data, FALSE);\n  }\n  else\n    result = status;\n\n  if(protop)\n    Curl_safefree(protop->path);\n  if(Curl_pgrsDone(data))\n    return CURLE_ABORTED_BY_CALLBACK;\n\n  data->req.keepon = 0;   /* clear all bits */\n  return result;\n}\n\n\nstatic CURLcode scp_done(struct Curl_easy *data, CURLcode status,\n                         bool premature)\n{\n  (void) premature;             /* not used */\n\n  if(!status)\n    state(data, SSH_SCP_DONE);\n\n  return myssh_done(data, status);\n\n}\n\nstatic ssize_t scp_send(struct Curl_easy *data, int sockindex,\n                        const void *mem, size_t len, CURLcode *err)\n{\n  int rc;\n  struct connectdata *conn = data->conn;\n  (void) sockindex; /* we only support SCP on the fixed known primary socket */\n  (void) err;\n\n  rc = ssh_scp_write(conn->proto.sshc.scp_session, mem, len);\n\n#if 0\n  /* The following code is misleading, mostly added as wishful thinking\n   * that libssh at some point will implement non-blocking ssh_scp_write/read.\n   * Currently rc can only be number of bytes read or SSH_ERROR. */\n  myssh_block2waitfor(conn, (rc == SSH_AGAIN) ? TRUE : FALSE);\n\n  if(rc == SSH_AGAIN) {\n    *err = CURLE_AGAIN;\n    return 0;\n  }\n  else\n#endif\n  if(rc != SSH_OK) {\n    *err = CURLE_SSH;\n    return -1;\n  }\n\n  return len;\n}\n\nstatic ssize_t scp_recv(struct Curl_easy *data, int sockindex,\n                        char *mem, size_t len, CURLcode *err)\n{\n  ssize_t nread;\n  struct connectdata *conn = data->conn;\n  (void) err;\n  (void) sockindex; /* we only support SCP on the fixed known primary socket */\n\n  /* libssh returns int */\n  nread = ssh_scp_read(conn->proto.sshc.scp_session, mem, len);\n\n#if 0\n  /* The following code is misleading, mostly added as wishful thinking\n   * that libssh at some point will implement non-blocking ssh_scp_write/read.\n   * Currently rc can only be SSH_OK or SSH_ERROR. */\n\n  myssh_block2waitfor(conn, (nread == SSH_AGAIN) ? TRUE : FALSE);\n  if(nread == SSH_AGAIN) {\n    *err = CURLE_AGAIN;\n    nread = -1;\n  }\n#endif\n\n  return nread;\n}\n\n/*\n * =============== SFTP ===============\n */\n\n/*\n ***********************************************************************\n *\n * sftp_perform()\n *\n * This is the actual DO function for SFTP. Get a file/directory according to\n * the options previously setup.\n */\n\nstatic\nCURLcode sftp_perform(struct Curl_easy *data,\n                      bool *connected,\n                      bool *dophase_done)\n{\n  CURLcode result = CURLE_OK;\n\n  DEBUGF(infof(data, \"DO phase starts\"));\n\n  *dophase_done = FALSE; /* not done yet */\n\n  /* start the first command in the DO phase */\n  state(data, SSH_SFTP_QUOTE_INIT);\n\n  /* run the state-machine */\n  result = myssh_multi_statemach(data, dophase_done);\n\n  *connected = Curl_conn_is_connected(data->conn, FIRSTSOCKET);\n\n  if(*dophase_done) {\n    DEBUGF(infof(data, \"DO phase is complete\"));\n  }\n\n  return result;\n}\n\n/* called from multi.c while DOing */\nstatic CURLcode sftp_doing(struct Curl_easy *data,\n                           bool *dophase_done)\n{\n  CURLcode result = myssh_multi_statemach(data, dophase_done);\n  if(*dophase_done) {\n    DEBUGF(infof(data, \"DO phase is complete\"));\n  }\n  return result;\n}\n\n/* BLOCKING, but the function is using the state machine so the only reason\n   this is still blocking is that the multi interface code has no support for\n   disconnecting operations that takes a while */\nstatic CURLcode sftp_disconnect(struct Curl_easy *data,\n                                struct connectdata *conn,\n                                bool dead_connection)\n{\n  CURLcode result = CURLE_OK;\n  (void) dead_connection;\n\n  DEBUGF(infof(data, \"SSH DISCONNECT starts now\"));\n\n  if(conn->proto.sshc.ssh_session) {\n    /* only if there's a session still around to use! */\n    state(data, SSH_SFTP_SHUTDOWN);\n    result = myssh_block_statemach(data, TRUE);\n  }\n\n  DEBUGF(infof(data, \"SSH DISCONNECT is done\"));\n\n  return result;\n\n}\n\nstatic CURLcode sftp_done(struct Curl_easy *data, CURLcode status,\n                          bool premature)\n{\n  struct connectdata *conn = data->conn;\n  struct ssh_conn *sshc = &conn->proto.sshc;\n\n  if(!status) {\n    /* Post quote commands are executed after the SFTP_CLOSE state to avoid\n       errors that could happen due to open file handles during POSTQUOTE\n       operation */\n    if(!premature && data->set.postquote && !conn->bits.retry)\n      sshc->nextstate = SSH_SFTP_POSTQUOTE_INIT;\n    state(data, SSH_SFTP_CLOSE);\n  }\n  return myssh_done(data, status);\n}\n\n/* return number of sent bytes */\nstatic ssize_t sftp_send(struct Curl_easy *data, int sockindex,\n                         const void *mem, size_t len, CURLcode *err)\n{\n  ssize_t nwrite;\n  struct connectdata *conn = data->conn;\n  (void)sockindex;\n\n  /* limit the writes to the maximum specified in Section 3 of\n   * https://datatracker.ietf.org/doc/html/draft-ietf-secsh-filexfer-02\n   */\n  if(len > 32768)\n    len = 32768;\n\n  nwrite = sftp_write(conn->proto.sshc.sftp_file, mem, len);\n\n  myssh_block2waitfor(conn, FALSE);\n\n#if 0 /* not returned by libssh on write */\n  if(nwrite == SSH_AGAIN) {\n    *err = CURLE_AGAIN;\n    nwrite = 0;\n  }\n  else\n#endif\n  if(nwrite < 0) {\n    *err = CURLE_SSH;\n    nwrite = -1;\n  }\n\n  return nwrite;\n}\n\n/*\n * Return number of received (decrypted) bytes\n * or <0 on error\n */\nstatic ssize_t sftp_recv(struct Curl_easy *data, int sockindex,\n                         char *mem, size_t len, CURLcode *err)\n{\n  ssize_t nread;\n  struct connectdata *conn = data->conn;\n  (void)sockindex;\n\n  DEBUGASSERT(len < CURL_MAX_READ_SIZE);\n\n  switch(conn->proto.sshc.sftp_recv_state) {\n    case 0:\n      conn->proto.sshc.sftp_file_index =\n        sftp_async_read_begin(conn->proto.sshc.sftp_file,\n                              (uint32_t)len);\n      if(conn->proto.sshc.sftp_file_index < 0) {\n        *err = CURLE_RECV_ERROR;\n        return -1;\n      }\n\n      FALLTHROUGH();\n    case 1:\n      conn->proto.sshc.sftp_recv_state = 1;\n\n      nread = sftp_async_read(conn->proto.sshc.sftp_file,\n                              mem, (uint32_t)len,\n                              conn->proto.sshc.sftp_file_index);\n\n      myssh_block2waitfor(conn, (nread == SSH_AGAIN)?TRUE:FALSE);\n\n      if(nread == SSH_AGAIN) {\n        *err = CURLE_AGAIN;\n        return -1;\n      }\n      else if(nread < 0) {\n        *err = CURLE_RECV_ERROR;\n        return -1;\n      }\n\n      conn->proto.sshc.sftp_recv_state = 0;\n      return nread;\n\n    default:\n      /* we never reach here */\n      return -1;\n  }\n}\n\nstatic void sftp_quote(struct Curl_easy *data)\n{\n  const char *cp;\n  struct connectdata *conn = data->conn;\n  struct SSHPROTO *protop = data->req.p.ssh;\n  struct ssh_conn *sshc = &conn->proto.sshc;\n  CURLcode result;\n\n  /*\n   * Support some of the \"FTP\" commands\n   */\n  char *cmd = sshc->quote_item->data;\n  sshc->acceptfail = FALSE;\n\n  /* if a command starts with an asterisk, which a legal SFTP command never\n     can, the command will be allowed to fail without it causing any\n     aborts or cancels etc. It will cause libcurl to act as if the command\n     is successful, whatever the server responds. */\n\n  if(cmd[0] == '*') {\n    cmd++;\n    sshc->acceptfail = TRUE;\n  }\n\n  if(strcasecompare(\"pwd\", cmd)) {\n    /* output debug output if that is requested */\n    char *tmp = aprintf(\"257 \\\"%s\\\" is current directory.\\n\",\n                        protop->path);\n    if(!tmp) {\n      sshc->actualcode = CURLE_OUT_OF_MEMORY;\n      state(data, SSH_SFTP_CLOSE);\n      sshc->nextstate = SSH_NO_STATE;\n      return;\n    }\n    Curl_debug(data, CURLINFO_HEADER_OUT, (char *) \"PWD\\n\", 4);\n    Curl_debug(data, CURLINFO_HEADER_IN, tmp, strlen(tmp));\n\n    /* this sends an FTP-like \"header\" to the header callback so that the\n       current directory can be read very similar to how it is read when\n       using ordinary FTP. */\n    result = Curl_client_write(data, CLIENTWRITE_HEADER, tmp, strlen(tmp));\n    free(tmp);\n    if(result) {\n      state(data, SSH_SFTP_CLOSE);\n      sshc->nextstate = SSH_NO_STATE;\n      sshc->actualcode = result;\n    }\n    else\n      state(data, SSH_SFTP_NEXT_QUOTE);\n    return;\n  }\n\n  /*\n   * the arguments following the command must be separated from the\n   * command with a space so we can check for it unconditionally\n   */\n  cp = strchr(cmd, ' ');\n  if(!cp) {\n    failf(data, \"Syntax error in SFTP command. Supply parameter(s)\");\n    state(data, SSH_SFTP_CLOSE);\n    sshc->nextstate = SSH_NO_STATE;\n    sshc->actualcode = CURLE_QUOTE_ERROR;\n    return;\n  }\n\n  /*\n   * also, every command takes at least one argument so we get that\n   * first argument right now\n   */\n  result = Curl_get_pathname(&cp, &sshc->quote_path1, sshc->homedir);\n  if(result) {\n    if(result == CURLE_OUT_OF_MEMORY)\n      failf(data, \"Out of memory\");\n    else\n      failf(data, \"Syntax error: Bad first parameter\");\n    state(data, SSH_SFTP_CLOSE);\n    sshc->nextstate = SSH_NO_STATE;\n    sshc->actualcode = result;\n    return;\n  }\n\n  /*\n   * SFTP is a binary protocol, so we don't send text commands\n   * to the server. Instead, we scan for commands used by\n   * OpenSSH's sftp program and call the appropriate libssh\n   * functions.\n   */\n  if(strncasecompare(cmd, \"chgrp \", 6) ||\n     strncasecompare(cmd, \"chmod \", 6) ||\n     strncasecompare(cmd, \"chown \", 6) ||\n     strncasecompare(cmd, \"atime \", 6) ||\n     strncasecompare(cmd, \"mtime \", 6)) {\n    /* attribute change */\n\n    /* sshc->quote_path1 contains the mode to set */\n    /* get the destination */\n    result = Curl_get_pathname(&cp, &sshc->quote_path2, sshc->homedir);\n    if(result) {\n      if(result == CURLE_OUT_OF_MEMORY)\n        failf(data, \"Out of memory\");\n      else\n        failf(data, \"Syntax error in chgrp/chmod/chown/atime/mtime: \"\n              \"Bad second parameter\");\n      Curl_safefree(sshc->quote_path1);\n      state(data, SSH_SFTP_CLOSE);\n      sshc->nextstate = SSH_NO_STATE;\n      sshc->actualcode = result;\n      return;\n    }\n    sshc->quote_attrs = NULL;\n    state(data, SSH_SFTP_QUOTE_STAT);\n    return;\n  }\n  if(strncasecompare(cmd, \"ln \", 3) ||\n     strncasecompare(cmd, \"symlink \", 8)) {\n    /* symbolic linking */\n    /* sshc->quote_path1 is the source */\n    /* get the destination */\n    result = Curl_get_pathname(&cp, &sshc->quote_path2, sshc->homedir);\n    if(result) {\n      if(result == CURLE_OUT_OF_MEMORY)\n        failf(data, \"Out of memory\");\n      else\n        failf(data, \"Syntax error in ln/symlink: Bad second parameter\");\n      Curl_safefree(sshc->quote_path1);\n      state(data, SSH_SFTP_CLOSE);\n      sshc->nextstate = SSH_NO_STATE;\n      sshc->actualcode = result;\n      return;\n    }\n    state(data, SSH_SFTP_QUOTE_SYMLINK);\n    return;\n  }\n  else if(strncasecompare(cmd, \"mkdir \", 6)) {\n    /* create dir */\n    state(data, SSH_SFTP_QUOTE_MKDIR);\n    return;\n  }\n  else if(strncasecompare(cmd, \"rename \", 7)) {\n    /* rename file */\n    /* first param is the source path */\n    /* second param is the dest. path */\n    result = Curl_get_pathname(&cp, &sshc->quote_path2, sshc->homedir);\n    if(result) {\n      if(result == CURLE_OUT_OF_MEMORY)\n        failf(data, \"Out of memory\");\n      else\n        failf(data, \"Syntax error in rename: Bad second parameter\");\n      Curl_safefree(sshc->quote_path1);\n      state(data, SSH_SFTP_CLOSE);\n      sshc->nextstate = SSH_NO_STATE;\n      sshc->actualcode = result;\n      return;\n    }\n    state(data, SSH_SFTP_QUOTE_RENAME);\n    return;\n  }\n  else if(strncasecompare(cmd, \"rmdir \", 6)) {\n    /* delete dir */\n    state(data, SSH_SFTP_QUOTE_RMDIR);\n    return;\n  }\n  else if(strncasecompare(cmd, \"rm \", 3)) {\n    state(data, SSH_SFTP_QUOTE_UNLINK);\n    return;\n  }\n#ifdef HAS_STATVFS_SUPPORT\n  else if(strncasecompare(cmd, \"statvfs \", 8)) {\n    state(data, SSH_SFTP_QUOTE_STATVFS);\n    return;\n  }\n#endif\n\n  failf(data, \"Unknown SFTP command\");\n  Curl_safefree(sshc->quote_path1);\n  Curl_safefree(sshc->quote_path2);\n  state(data, SSH_SFTP_CLOSE);\n  sshc->nextstate = SSH_NO_STATE;\n  sshc->actualcode = CURLE_QUOTE_ERROR;\n}\n\nstatic void sftp_quote_stat(struct Curl_easy *data)\n{\n  struct connectdata *conn = data->conn;\n  struct ssh_conn *sshc = &conn->proto.sshc;\n  char *cmd = sshc->quote_item->data;\n  sshc->acceptfail = FALSE;\n\n  /* if a command starts with an asterisk, which a legal SFTP command never\n     can, the command will be allowed to fail without it causing any\n     aborts or cancels etc. It will cause libcurl to act as if the command\n     is successful, whatever the server responds. */\n\n  if(cmd[0] == '*') {\n    cmd++;\n    sshc->acceptfail = TRUE;\n  }\n\n  /* We read the file attributes, store them in sshc->quote_attrs\n   * and modify them accordingly to command. Then we switch to\n   * QUOTE_SETSTAT state to write new ones.\n   */\n\n  if(sshc->quote_attrs)\n    sftp_attributes_free(sshc->quote_attrs);\n  sshc->quote_attrs = sftp_stat(sshc->sftp_session, sshc->quote_path2);\n  if(!sshc->quote_attrs) {\n    Curl_safefree(sshc->quote_path1);\n    Curl_safefree(sshc->quote_path2);\n    failf(data, \"Attempt to get SFTP stats failed: %d\",\n          sftp_get_error(sshc->sftp_session));\n    state(data, SSH_SFTP_CLOSE);\n    sshc->nextstate = SSH_NO_STATE;\n    sshc->actualcode = CURLE_QUOTE_ERROR;\n    return;\n  }\n\n  /* Now set the new attributes... */\n  if(strncasecompare(cmd, \"chgrp\", 5)) {\n    sshc->quote_attrs->gid = (uint32_t)strtoul(sshc->quote_path1, NULL, 10);\n    if(sshc->quote_attrs->gid == 0 && !ISDIGIT(sshc->quote_path1[0]) &&\n        !sshc->acceptfail) {\n      Curl_safefree(sshc->quote_path1);\n      Curl_safefree(sshc->quote_path2);\n      failf(data, \"Syntax error: chgrp gid not a number\");\n      state(data, SSH_SFTP_CLOSE);\n      sshc->nextstate = SSH_NO_STATE;\n      sshc->actualcode = CURLE_QUOTE_ERROR;\n      return;\n    }\n    sshc->quote_attrs->flags |= SSH_FILEXFER_ATTR_UIDGID;\n  }\n  else if(strncasecompare(cmd, \"chmod\", 5)) {\n    mode_t perms;\n    perms = (mode_t)strtoul(sshc->quote_path1, NULL, 8);\n    /* permissions are octal */\n    if(perms == 0 && !ISDIGIT(sshc->quote_path1[0])) {\n      Curl_safefree(sshc->quote_path1);\n      Curl_safefree(sshc->quote_path2);\n      failf(data, \"Syntax error: chmod permissions not a number\");\n      state(data, SSH_SFTP_CLOSE);\n      sshc->nextstate = SSH_NO_STATE;\n      sshc->actualcode = CURLE_QUOTE_ERROR;\n      return;\n    }\n    sshc->quote_attrs->permissions = perms;\n    sshc->quote_attrs->flags |= SSH_FILEXFER_ATTR_PERMISSIONS;\n  }\n  else if(strncasecompare(cmd, \"chown\", 5)) {\n    sshc->quote_attrs->uid = (uint32_t)strtoul(sshc->quote_path1, NULL, 10);\n    if(sshc->quote_attrs->uid == 0 && !ISDIGIT(sshc->quote_path1[0]) &&\n        !sshc->acceptfail) {\n      Curl_safefree(sshc->quote_path1);\n      Curl_safefree(sshc->quote_path2);\n      failf(data, \"Syntax error: chown uid not a number\");\n      state(data, SSH_SFTP_CLOSE);\n      sshc->nextstate = SSH_NO_STATE;\n      sshc->actualcode = CURLE_QUOTE_ERROR;\n      return;\n    }\n    sshc->quote_attrs->flags |= SSH_FILEXFER_ATTR_UIDGID;\n  }\n  else if(strncasecompare(cmd, \"atime\", 5) ||\n          strncasecompare(cmd, \"mtime\", 5)) {\n    time_t date = Curl_getdate_capped(sshc->quote_path1);\n    bool fail = FALSE;\n    if(date == -1) {\n      failf(data, \"incorrect date format for %.*s\", 5, cmd);\n      fail = TRUE;\n    }\n#if SIZEOF_TIME_T > 4\n    else if(date > 0xffffffff) {\n      failf(data, \"date overflow\");\n      fail = TRUE; /* avoid setting a capped time */\n    }\n#endif\n    if(fail) {\n      Curl_safefree(sshc->quote_path1);\n      Curl_safefree(sshc->quote_path2);\n      state(data, SSH_SFTP_CLOSE);\n      sshc->nextstate = SSH_NO_STATE;\n      sshc->actualcode = CURLE_QUOTE_ERROR;\n      return;\n    }\n    if(strncasecompare(cmd, \"atime\", 5))\n      sshc->quote_attrs->atime = (uint32_t)date;\n    else /* mtime */\n      sshc->quote_attrs->mtime = (uint32_t)date;\n\n    sshc->quote_attrs->flags |= SSH_FILEXFER_ATTR_ACMODTIME;\n  }\n\n  /* Now send the completed structure... */\n  state(data, SSH_SFTP_QUOTE_SETSTAT);\n  return;\n}\n\nCURLcode Curl_ssh_init(void)\n{\n  if(ssh_init()) {\n    DEBUGF(fprintf(stderr, \"Error: libssh_init failed\\n\"));\n    return CURLE_FAILED_INIT;\n  }\n  return CURLE_OK;\n}\n\nvoid Curl_ssh_cleanup(void)\n{\n  (void)ssh_finalize();\n}\n\nvoid Curl_ssh_version(char *buffer, size_t buflen)\n{\n  (void)msnprintf(buffer, buflen, \"libssh/%s\", ssh_version(0));\n}\n\n#endif                          /* USE_LIBSSH */\n` was unexpected","path":"/home/qqq/curl-8.7.0/lib/vssh/libssh.c"},{"code":3,"level":"warn","type":"Syntax error","message":"Syntax error at line /home/qqq/curl-8.7.0/lib/vssh/libssh2.c:1:\n `/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n * SPDX-License-Identifier: curl\n *\n ***************************************************************************/\n\n/* #define CURL_LIBSSH2_DEBUG */\n\n#include \"curl_setup.h\"\n\n#ifdef USE_LIBSSH2\n\n#include <limits.h>\n\n#include <libssh2.h>\n#include <libssh2_sftp.h>\n\n#ifdef HAVE_FCNTL_H\n#include <fcntl.h>\n#endif\n\n#ifdef HAVE_NETINET_IN_H\n#include <netinet/in.h>\n#endif\n#ifdef HAVE_ARPA_INET_H\n#include <arpa/inet.h>\n#endif\n#ifdef HAVE_NETDB_H\n#include <netdb.h>\n#endif\n#ifdef __VMS\n#include <in.h>\n#include <inet.h>\n#endif\n\n#include <curl/curl.h>\n#include \"urldata.h\"\n#include \"sendf.h\"\n#include \"hostip.h\"\n#include \"progress.h\"\n#include \"transfer.h\"\n#include \"escape.h\"\n#include \"http.h\" /* for HTTP proxy tunnel stuff */\n#include \"ssh.h\"\n#include \"url.h\"\n#include \"speedcheck.h\"\n#include \"getinfo.h\"\n#include \"strdup.h\"\n#include \"strcase.h\"\n#include \"vtls/vtls.h\"\n#include \"cfilters.h\"\n#include \"connect.h\"\n#include \"inet_ntop.h\"\n#include \"parsedate.h\" /* for the week day and month names */\n#include \"sockaddr.h\" /* required for Curl_sockaddr_storage */\n#include \"strtoofft.h\"\n#include \"multiif.h\"\n#include \"select.h\"\n#include \"warnless.h\"\n#include \"curl_path.h\"\n\n#include <curl_base64.h> /* for base64 encoding/decoding */\n#include <curl_sha256.h>\n\n\n/* The last 3 #include files should be in this order */\n#include \"curl_printf.h\"\n#include \"curl_memory.h\"\n#include \"memdebug.h\"\n\n#if LIBSSH2_VERSION_NUM >= 0x010206\n/* libssh2_sftp_statvfs and friends were added in 1.2.6 */\n#define HAS_STATVFS_SUPPORT 1\n#endif\n\n#define sftp_libssh2_realpath(s,p,t,m)                          \\\n  libssh2_sftp_symlink_ex((s), (p), curlx_uztoui(strlen(p)),    \\\n                          (t), (m), LIBSSH2_SFTP_REALPATH)\n\n/* Local functions: */\nstatic const char *sftp_libssh2_strerror(unsigned long err);\nstatic LIBSSH2_ALLOC_FUNC(my_libssh2_malloc);\nstatic LIBSSH2_REALLOC_FUNC(my_libssh2_realloc);\nstatic LIBSSH2_FREE_FUNC(my_libssh2_free);\nstatic CURLcode ssh_force_knownhost_key_type(struct Curl_easy *data);\nstatic CURLcode ssh_connect(struct Curl_easy *data, bool *done);\nstatic CURLcode ssh_multi_statemach(struct Curl_easy *data, bool *done);\nstatic CURLcode ssh_do(struct Curl_easy *data, bool *done);\nstatic CURLcode scp_done(struct Curl_easy *data, CURLcode c, bool premature);\nstatic CURLcode scp_doing(struct Curl_easy *data, bool *dophase_done);\nstatic CURLcode scp_disconnect(struct Curl_easy *data,\n                               struct connectdata *conn, bool dead_connection);\nstatic CURLcode sftp_done(struct Curl_easy *data, CURLcode, bool premature);\nstatic CURLcode sftp_doing(struct Curl_easy *data, bool *dophase_done);\nstatic CURLcode sftp_disconnect(struct Curl_easy *data,\n                                struct connectdata *conn, bool dead);\nstatic CURLcode sftp_perform(struct Curl_easy *data, bool *connected,\n                             bool *dophase_done);\nstatic int ssh_getsock(struct Curl_easy *data, struct connectdata *conn,\n                       curl_socket_t *sock);\nstatic CURLcode ssh_setup_connection(struct Curl_easy *data,\n                                     struct connectdata *conn);\nstatic void ssh_attach(struct Curl_easy *data, struct connectdata *conn);\n\n/*\n * SCP protocol handler.\n */\n\nconst struct Curl_handler Curl_handler_scp = {\n  \"SCP\",                                /* scheme */\n  ssh_setup_connection,                 /* setup_connection */\n  ssh_do,                               /* do_it */\n  scp_done,                             /* done */\n  ZERO_NULL,                            /* do_more */\n  ssh_connect,                          /* connect_it */\n  ssh_multi_statemach,                  /* connecting */\n  scp_doing,                            /* doing */\n  ssh_getsock,                          /* proto_getsock */\n  ssh_getsock,                          /* doing_getsock */\n  ZERO_NULL,                            /* domore_getsock */\n  ssh_getsock,                          /* perform_getsock */\n  scp_disconnect,                       /* disconnect */\n  ZERO_NULL,                            /* write_resp */\n  ZERO_NULL,                            /* connection_check */\n  ssh_attach,                           /* attach */\n  PORT_SSH,                             /* defport */\n  CURLPROTO_SCP,                        /* protocol */\n  CURLPROTO_SCP,                        /* family */\n  PROTOPT_DIRLOCK | PROTOPT_CLOSEACTION\n  | PROTOPT_NOURLQUERY                  /* flags */\n};\n\n\n/*\n * SFTP protocol handler.\n */\n\nconst struct Curl_handler Curl_handler_sftp = {\n  \"SFTP\",                               /* scheme */\n  ssh_setup_connection,                 /* setup_connection */\n  ssh_do,                               /* do_it */\n  sftp_done,                            /* done */\n  ZERO_NULL,                            /* do_more */\n  ssh_connect,                          /* connect_it */\n  ssh_multi_statemach,                  /* connecting */\n  sftp_doing,                           /* doing */\n  ssh_getsock,                          /* proto_getsock */\n  ssh_getsock,                          /* doing_getsock */\n  ZERO_NULL,                            /* domore_getsock */\n  ssh_getsock,                          /* perform_getsock */\n  sftp_disconnect,                      /* disconnect */\n  ZERO_NULL,                            /* write_resp */\n  ZERO_NULL,                            /* connection_check */\n  ssh_attach,                           /* attach */\n  PORT_SSH,                             /* defport */\n  CURLPROTO_SFTP,                       /* protocol */\n  CURLPROTO_SFTP,                       /* family */\n  PROTOPT_DIRLOCK | PROTOPT_CLOSEACTION\n  | PROTOPT_NOURLQUERY                  /* flags */\n};\n\nstatic void\nkbd_callback(const char *name, int name_len, const char *instruction,\n             int instruction_len, int num_prompts,\n             const LIBSSH2_USERAUTH_KBDINT_PROMPT *prompts,\n             LIBSSH2_USERAUTH_KBDINT_RESPONSE *responses,\n             void **abstract)\n{\n  struct Curl_easy *data = (struct Curl_easy *)*abstract;\n\n#ifdef CURL_LIBSSH2_DEBUG\n  fprintf(stderr, \"name=%s\\n\", name);\n  fprintf(stderr, \"name_len=%d\\n\", name_len);\n  fprintf(stderr, \"instruction=%s\\n\", instruction);\n  fprintf(stderr, \"instruction_len=%d\\n\", instruction_len);\n  fprintf(stderr, \"num_prompts=%d\\n\", num_prompts);\n#else\n  (void)name;\n  (void)name_len;\n  (void)instruction;\n  (void)instruction_len;\n#endif  /* CURL_LIBSSH2_DEBUG */\n  if(num_prompts == 1) {\n    struct connectdata *conn = data->conn;\n    responses[0].text = strdup(conn->passwd);\n    responses[0].length = curlx_uztoui(strlen(conn->passwd));\n  }\n  (void)prompts;\n} /* kbd_callback */\n\nstatic CURLcode sftp_libssh2_error_to_CURLE(unsigned long err)\n{\n  switch(err) {\n    case LIBSSH2_FX_OK:\n      return CURLE_OK;\n\n    case LIBSSH2_FX_NO_SUCH_FILE:\n    case LIBSSH2_FX_NO_SUCH_PATH:\n      return CURLE_REMOTE_FILE_NOT_FOUND;\n\n    case LIBSSH2_FX_PERMISSION_DENIED:\n    case LIBSSH2_FX_WRITE_PROTECT:\n    case LIBSSH2_FX_LOCK_CONFlICT:\n      return CURLE_REMOTE_ACCESS_DENIED;\n\n    case LIBSSH2_FX_NO_SPACE_ON_FILESYSTEM:\n    case LIBSSH2_FX_QUOTA_EXCEEDED:\n      return CURLE_REMOTE_DISK_FULL;\n\n    case LIBSSH2_FX_FILE_ALREADY_EXISTS:\n      return CURLE_REMOTE_FILE_EXISTS;\n\n    case LIBSSH2_FX_DIR_NOT_EMPTY:\n      return CURLE_QUOTE_ERROR;\n\n    default:\n      break;\n  }\n\n  return CURLE_SSH;\n}\n\nstatic CURLcode libssh2_session_error_to_CURLE(int err)\n{\n  switch(err) {\n    /* Ordered by order of appearance in libssh2.h */\n    case LIBSSH2_ERROR_NONE:\n      return CURLE_OK;\n\n    /* This is the error returned by libssh2_scp_recv2\n     * on unknown file */\n    case LIBSSH2_ERROR_SCP_PROTOCOL:\n      return CURLE_REMOTE_FILE_NOT_FOUND;\n\n    case LIBSSH2_ERROR_SOCKET_NONE:\n      return CURLE_COULDNT_CONNECT;\n\n    case LIBSSH2_ERROR_ALLOC:\n      return CURLE_OUT_OF_MEMORY;\n\n    case LIBSSH2_ERROR_SOCKET_SEND:\n      return CURLE_SEND_ERROR;\n\n    case LIBSSH2_ERROR_HOSTKEY_INIT:\n    case LIBSSH2_ERROR_HOSTKEY_SIGN:\n    case LIBSSH2_ERROR_PUBLICKEY_UNRECOGNIZED:\n    case LIBSSH2_ERROR_PUBLICKEY_UNVERIFIED:\n      return CURLE_PEER_FAILED_VERIFICATION;\n\n    case LIBSSH2_ERROR_PASSWORD_EXPIRED:\n      return CURLE_LOGIN_DENIED;\n\n    case LIBSSH2_ERROR_SOCKET_TIMEOUT:\n    case LIBSSH2_ERROR_TIMEOUT:\n      return CURLE_OPERATION_TIMEDOUT;\n\n    case LIBSSH2_ERROR_EAGAIN:\n      return CURLE_AGAIN;\n  }\n\n  return CURLE_SSH;\n}\n\nstatic LIBSSH2_ALLOC_FUNC(my_libssh2_malloc)\n{\n  (void)abstract; /* arg not used */\n  return malloc(count);\n}\n\nstatic LIBSSH2_REALLOC_FUNC(my_libssh2_realloc)\n{\n  (void)abstract; /* arg not used */\n  return realloc(ptr, count);\n}\n\nstatic LIBSSH2_FREE_FUNC(my_libssh2_free)\n{\n  (void)abstract; /* arg not used */\n  if(ptr) /* ssh2 agent sometimes call free with null ptr */\n    free(ptr);\n}\n\n/*\n * SSH State machine related code\n */\n/* This is the ONLY way to change SSH state! */\nstatic void state(struct Curl_easy *data, sshstate nowstate)\n{\n  struct connectdata *conn = data->conn;\n  struct ssh_conn *sshc = &conn->proto.sshc;\n#if defined(DEBUGBUILD) && !defined(CURL_DISABLE_VERBOSE_STRINGS)\n  /* for debug purposes */\n  static const char * const names[] = {\n    \"SSH_STOP\",\n    \"SSH_INIT\",\n    \"SSH_S_STARTUP\",\n    \"SSH_HOSTKEY\",\n    \"SSH_AUTHLIST\",\n    \"SSH_AUTH_PKEY_INIT\",\n    \"SSH_AUTH_PKEY\",\n    \"SSH_AUTH_PASS_INIT\",\n    \"SSH_AUTH_PASS\",\n    \"SSH_AUTH_AGENT_INIT\",\n    \"SSH_AUTH_AGENT_LIST\",\n    \"SSH_AUTH_AGENT\",\n    \"SSH_AUTH_HOST_INIT\",\n    \"SSH_AUTH_HOST\",\n    \"SSH_AUTH_KEY_INIT\",\n    \"SSH_AUTH_KEY\",\n    \"SSH_AUTH_GSSAPI\",\n    \"SSH_AUTH_DONE\",\n    \"SSH_SFTP_INIT\",\n    \"SSH_SFTP_REALPATH\",\n    \"SSH_SFTP_QUOTE_INIT\",\n    \"SSH_SFTP_POSTQUOTE_INIT\",\n    \"SSH_SFTP_QUOTE\",\n    \"SSH_SFTP_NEXT_QUOTE\",\n    \"SSH_SFTP_QUOTE_STAT\",\n    \"SSH_SFTP_QUOTE_SETSTAT\",\n    \"SSH_SFTP_QUOTE_SYMLINK\",\n    \"SSH_SFTP_QUOTE_MKDIR\",\n    \"SSH_SFTP_QUOTE_RENAME\",\n    \"SSH_SFTP_QUOTE_RMDIR\",\n    \"SSH_SFTP_QUOTE_UNLINK\",\n    \"SSH_SFTP_QUOTE_STATVFS\",\n    \"SSH_SFTP_GETINFO\",\n    \"SSH_SFTP_FILETIME\",\n    \"SSH_SFTP_TRANS_INIT\",\n    \"SSH_SFTP_UPLOAD_INIT\",\n    \"SSH_SFTP_CREATE_DIRS_INIT\",\n    \"SSH_SFTP_CREATE_DIRS\",\n    \"SSH_SFTP_CREATE_DIRS_MKDIR\",\n    \"SSH_SFTP_READDIR_INIT\",\n    \"SSH_SFTP_READDIR\",\n    \"SSH_SFTP_READDIR_LINK\",\n    \"SSH_SFTP_READDIR_BOTTOM\",\n    \"SSH_SFTP_READDIR_DONE\",\n    \"SSH_SFTP_DOWNLOAD_INIT\",\n    \"SSH_SFTP_DOWNLOAD_STAT\",\n    \"SSH_SFTP_CLOSE\",\n    \"SSH_SFTP_SHUTDOWN\",\n    \"SSH_SCP_TRANS_INIT\",\n    \"SSH_SCP_UPLOAD_INIT\",\n    \"SSH_SCP_DOWNLOAD_INIT\",\n    \"SSH_SCP_DOWNLOAD\",\n    \"SSH_SCP_DONE\",\n    \"SSH_SCP_SEND_EOF\",\n    \"SSH_SCP_WAIT_EOF\",\n    \"SSH_SCP_WAIT_CLOSE\",\n    \"SSH_SCP_CHANNEL_FREE\",\n    \"SSH_SESSION_DISCONNECT\",\n    \"SSH_SESSION_FREE\",\n    \"QUIT\"\n  };\n\n  /* a precaution to make sure the lists are in sync */\n  DEBUGASSERT(sizeof(names)/sizeof(names[0]) == SSH_LAST);\n\n  if(sshc->state != nowstate) {\n    infof(data, \"SFTP %p state change from %s to %s\",\n          (void *)sshc, names[sshc->state], names[nowstate]);\n  }\n#endif\n\n  sshc->state = nowstate;\n}\n\n\n#ifdef HAVE_LIBSSH2_KNOWNHOST_API\nstatic int sshkeycallback(struct Curl_easy *easy,\n                          const struct curl_khkey *knownkey, /* known */\n                          const struct curl_khkey *foundkey, /* found */\n                          enum curl_khmatch match,\n                          void *clientp)\n{\n  (void)easy;\n  (void)knownkey;\n  (void)foundkey;\n  (void)clientp;\n\n  /* we only allow perfect matches, and we reject everything else */\n  return (match != CURLKHMATCH_OK)?CURLKHSTAT_REJECT:CURLKHSTAT_FINE;\n}\n#endif\n\n/*\n * Earlier libssh2 versions didn't have the ability to seek to 64bit positions\n * with 32bit size_t.\n */\n#ifdef HAVE_LIBSSH2_SFTP_SEEK64\n#define SFTP_SEEK(x,y) libssh2_sftp_seek64(x, (libssh2_uint64_t)y)\n#else\n#define SFTP_SEEK(x,y) libssh2_sftp_seek(x, (size_t)y)\n#endif\n\n/*\n * Earlier libssh2 versions didn't do SCP properly beyond 32bit sizes on 32bit\n * architectures so we check of the necessary function is present.\n */\n#ifndef HAVE_LIBSSH2_SCP_SEND64\n#define SCP_SEND(a,b,c,d) libssh2_scp_send_ex(a, b, (int)(c), (size_t)d, 0, 0)\n#else\n#define SCP_SEND(a,b,c,d) libssh2_scp_send64(a, b, (int)(c),            \\\n                                             (libssh2_uint64_t)d, 0, 0)\n#endif\n\n/*\n * libssh2 1.2.8 fixed the problem with 32bit ints used for sockets on win64.\n */\n#ifdef HAVE_LIBSSH2_SESSION_HANDSHAKE\n#define session_startup(x,y) libssh2_session_handshake(x, y)\n#else\n#define session_startup(x,y) libssh2_session_startup(x, (int)y)\n#endif\nstatic int convert_ssh2_keytype(int sshkeytype)\n{\n  int keytype = CURLKHTYPE_UNKNOWN;\n  switch(sshkeytype) {\n  case LIBSSH2_HOSTKEY_TYPE_RSA:\n    keytype = CURLKHTYPE_RSA;\n    break;\n  case LIBSSH2_HOSTKEY_TYPE_DSS:\n    keytype = CURLKHTYPE_DSS;\n    break;\n#ifdef LIBSSH2_HOSTKEY_TYPE_ECDSA_256\n  case LIBSSH2_HOSTKEY_TYPE_ECDSA_256:\n    keytype = CURLKHTYPE_ECDSA;\n    break;\n#endif\n#ifdef LIBSSH2_HOSTKEY_TYPE_ECDSA_384\n  case LIBSSH2_HOSTKEY_TYPE_ECDSA_384:\n    keytype = CURLKHTYPE_ECDSA;\n    break;\n#endif\n#ifdef LIBSSH2_HOSTKEY_TYPE_ECDSA_521\n  case LIBSSH2_HOSTKEY_TYPE_ECDSA_521:\n    keytype = CURLKHTYPE_ECDSA;\n    break;\n#endif\n#ifdef LIBSSH2_HOSTKEY_TYPE_ED25519\n  case LIBSSH2_HOSTKEY_TYPE_ED25519:\n    keytype = CURLKHTYPE_ED25519;\n    break;\n#endif\n  }\n  return keytype;\n}\n\nstatic CURLcode ssh_knownhost(struct Curl_easy *data)\n{\n  int sshkeytype = 0;\n  size_t keylen = 0;\n  int rc = 0;\n  CURLcode result = CURLE_OK;\n\n#ifdef HAVE_LIBSSH2_KNOWNHOST_API\n  if(data->set.str[STRING_SSH_KNOWNHOSTS]) {\n    /* we're asked to verify the host against a file */\n    struct connectdata *conn = data->conn;\n    struct ssh_conn *sshc = &conn->proto.sshc;\n    struct libssh2_knownhost *host = NULL;\n    const char *remotekey = libssh2_session_hostkey(sshc->ssh_session,\n                                                    &keylen, &sshkeytype);\n    int keycheck = LIBSSH2_KNOWNHOST_CHECK_FAILURE;\n    int keybit = 0;\n\n    if(remotekey) {\n      /*\n       * A subject to figure out is what host name we need to pass in here.\n       * What host name does OpenSSH store in its file if an IDN name is\n       * used?\n       */\n      enum curl_khmatch keymatch;\n      curl_sshkeycallback func =\n        data->set.ssh_keyfunc ? data->set.ssh_keyfunc : sshkeycallback;\n      struct curl_khkey knownkey;\n      struct curl_khkey *knownkeyp = NULL;\n      struct curl_khkey foundkey;\n\n      switch(sshkeytype) {\n      case LIBSSH2_HOSTKEY_TYPE_RSA:\n        keybit = LIBSSH2_KNOWNHOST_KEY_SSHRSA;\n        break;\n      case LIBSSH2_HOSTKEY_TYPE_DSS:\n        keybit = LIBSSH2_KNOWNHOST_KEY_SSHDSS;\n        break;\n#ifdef LIBSSH2_HOSTKEY_TYPE_ECDSA_256\n      case LIBSSH2_HOSTKEY_TYPE_ECDSA_256:\n        keybit = LIBSSH2_KNOWNHOST_KEY_ECDSA_256;\n        break;\n#endif\n#ifdef LIBSSH2_HOSTKEY_TYPE_ECDSA_384\n      case LIBSSH2_HOSTKEY_TYPE_ECDSA_384:\n        keybit = LIBSSH2_KNOWNHOST_KEY_ECDSA_384;\n        break;\n#endif\n#ifdef LIBSSH2_HOSTKEY_TYPE_ECDSA_521\n      case LIBSSH2_HOSTKEY_TYPE_ECDSA_521:\n        keybit = LIBSSH2_KNOWNHOST_KEY_ECDSA_521;\n        break;\n#endif\n#ifdef LIBSSH2_HOSTKEY_TYPE_ED25519\n      case LIBSSH2_HOSTKEY_TYPE_ED25519:\n        keybit = LIBSSH2_KNOWNHOST_KEY_ED25519;\n        break;\n#endif\n      default:\n        infof(data, \"unsupported key type, can't check knownhosts\");\n        keybit = 0;\n        break;\n      }\n      if(!keybit)\n        /* no check means failure! */\n        rc = CURLKHSTAT_REJECT;\n      else {\n#ifdef HAVE_LIBSSH2_KNOWNHOST_CHECKP\n        keycheck = libssh2_knownhost_checkp(sshc->kh,\n                                            conn->host.name,\n                                            (conn->remote_port != PORT_SSH)?\n                                            conn->remote_port:-1,\n                                            remotekey, keylen,\n                                            LIBSSH2_KNOWNHOST_TYPE_PLAIN|\n                                            LIBSSH2_KNOWNHOST_KEYENC_RAW|\n                                            keybit,\n                                            &host);\n#else\n        keycheck = libssh2_knownhost_check(sshc->kh,\n                                           conn->host.name,\n                                           remotekey, keylen,\n                                           LIBSSH2_KNOWNHOST_TYPE_PLAIN|\n                                           LIBSSH2_KNOWNHOST_KEYENC_RAW|\n                                           keybit,\n                                           &host);\n#endif\n\n        infof(data, \"SSH host check: %d, key: %s\", keycheck,\n              (keycheck <= LIBSSH2_KNOWNHOST_CHECK_MISMATCH)?\n              host->key:\"<none>\");\n\n        /* setup 'knownkey' */\n        if(keycheck <= LIBSSH2_KNOWNHOST_CHECK_MISMATCH) {\n          knownkey.key = host->key;\n          knownkey.len = 0;\n          knownkey.keytype = convert_ssh2_keytype(sshkeytype);\n          knownkeyp = &knownkey;\n        }\n\n        /* setup 'foundkey' */\n        foundkey.key = remotekey;\n        foundkey.len = keylen;\n        foundkey.keytype = convert_ssh2_keytype(sshkeytype);\n\n        /*\n         * if any of the LIBSSH2_KNOWNHOST_CHECK_* defines and the\n         * curl_khmatch enum are ever modified, we need to introduce a\n         * translation table here!\n         */\n        keymatch = (enum curl_khmatch)keycheck;\n\n        /* Ask the callback how to behave */\n        Curl_set_in_callback(data, true);\n        rc = func(data, knownkeyp, /* from the knownhosts file */\n                  &foundkey, /* from the remote host */\n                  keymatch, data->set.ssh_keyfunc_userp);\n        Curl_set_in_callback(data, false);\n      }\n    }\n    else\n      /* no remotekey means failure! */\n      rc = CURLKHSTAT_REJECT;\n\n    switch(rc) {\n    default: /* unknown return codes will equal reject */\n    case CURLKHSTAT_REJECT:\n      state(data, SSH_SESSION_FREE);\n      FALLTHROUGH();\n    case CURLKHSTAT_DEFER:\n      /* DEFER means bail out but keep the SSH_HOSTKEY state */\n      result = sshc->actualcode = CURLE_PEER_FAILED_VERIFICATION;\n      break;\n    case CURLKHSTAT_FINE_REPLACE:\n      /* remove old host+key that doesn't match */\n      if(host)\n        libssh2_knownhost_del(sshc->kh, host);\n      FALLTHROUGH();\n    case CURLKHSTAT_FINE:\n    case CURLKHSTAT_FINE_ADD_TO_FILE:\n      /* proceed */\n      if(keycheck != LIBSSH2_KNOWNHOST_CHECK_MATCH) {\n        /* the found host+key didn't match but has been told to be fine\n           anyway so we add it in memory */\n        int addrc = libssh2_knownhost_add(sshc->kh,\n                                          conn->host.name, NULL,\n                                          remotekey, keylen,\n                                          LIBSSH2_KNOWNHOST_TYPE_PLAIN|\n                                          LIBSSH2_KNOWNHOST_KEYENC_RAW|\n                                          keybit, NULL);\n        if(addrc)\n          infof(data, \"WARNING: adding the known host %s failed\",\n                conn->host.name);\n        else if(rc == CURLKHSTAT_FINE_ADD_TO_FILE ||\n                rc == CURLKHSTAT_FINE_REPLACE) {\n          /* now we write the entire in-memory list of known hosts to the\n             known_hosts file */\n          int wrc =\n            libssh2_knownhost_writefile(sshc->kh,\n                                        data->set.str[STRING_SSH_KNOWNHOSTS],\n                                        LIBSSH2_KNOWNHOST_FILE_OPENSSH);\n          if(wrc) {\n            infof(data, \"WARNING: writing %s failed\",\n                  data->set.str[STRING_SSH_KNOWNHOSTS]);\n          }\n        }\n      }\n      break;\n    }\n  }\n#else /* HAVE_LIBSSH2_KNOWNHOST_API */\n  (void)data;\n#endif\n  return result;\n}\n\nstatic CURLcode ssh_check_fingerprint(struct Curl_easy *data)\n{\n  struct connectdata *conn = data->conn;\n  struct ssh_conn *sshc = &conn->proto.sshc;\n  const char *pubkey_md5 = data->set.str[STRING_SSH_HOST_PUBLIC_KEY_MD5];\n  const char *pubkey_sha256 = data->set.str[STRING_SSH_HOST_PUBLIC_KEY_SHA256];\n\n  infof(data, \"SSH MD5 public key: %s\",\n    pubkey_md5 != NULL ? pubkey_md5 : \"NULL\");\n  infof(data, \"SSH SHA256 public key: %s\",\n      pubkey_sha256 != NULL ? pubkey_sha256 : \"NULL\");\n\n  if(pubkey_sha256) {\n    const char *fingerprint = NULL;\n    char *fingerprint_b64 = NULL;\n    size_t fingerprint_b64_len;\n    size_t pub_pos = 0;\n    size_t b64_pos = 0;\n\n#ifdef LIBSSH2_HOSTKEY_HASH_SHA256\n    /* The fingerprint points to static storage (!), don't free() it. */\n    fingerprint = libssh2_hostkey_hash(sshc->ssh_session,\n                                       LIBSSH2_HOSTKEY_HASH_SHA256);\n#else\n    const char *hostkey;\n    size_t len = 0;\n    unsigned char hash[32];\n\n    hostkey = libssh2_session_hostkey(sshc->ssh_session, &len, NULL);\n    if(hostkey) {\n      if(!Curl_sha256it(hash, (const unsigned char *) hostkey, len))\n        fingerprint = (char *) hash;\n    }\n#endif\n\n    if(!fingerprint) {\n      failf(data,\n            \"Denied establishing ssh session: sha256 fingerprint \"\n            \"not available\");\n      state(data, SSH_SESSION_FREE);\n      sshc->actualcode = CURLE_PEER_FAILED_VERIFICATION;\n      return sshc->actualcode;\n    }\n\n    /* The length of fingerprint is 32 bytes for SHA256.\n     * See libssh2_hostkey_hash documentation. */\n    if(Curl_base64_encode(fingerprint, 32, &fingerprint_b64,\n                          &fingerprint_b64_len) != CURLE_OK) {\n      state(data, SSH_SESSION_FREE);\n      sshc->actualcode = CURLE_PEER_FAILED_VERIFICATION;\n      return sshc->actualcode;\n    }\n\n    if(!fingerprint_b64) {\n      failf(data, \"sha256 fingerprint could not be encoded\");\n      state(data, SSH_SESSION_FREE);\n      sshc->actualcode = CURLE_PEER_FAILED_VERIFICATION;\n      return sshc->actualcode;\n    }\n\n    infof(data, \"SSH SHA256 fingerprint: %s\", fingerprint_b64);\n\n    /* Find the position of any = padding characters in the public key */\n    while((pubkey_sha256[pub_pos] != '=') && pubkey_sha256[pub_pos]) {\n      pub_pos++;\n    }\n\n    /* Find the position of any = padding characters in the base64 coded\n     * hostkey fingerprint */\n    while((fingerprint_b64[b64_pos] != '=') && fingerprint_b64[b64_pos]) {\n      b64_pos++;\n    }\n\n    /* Before we authenticate we check the hostkey's sha256 fingerprint\n     * against a known fingerprint, if available.\n     */\n    if((pub_pos != b64_pos) ||\n       strncmp(fingerprint_b64, pubkey_sha256, pub_pos)) {\n      failf(data,\n            \"Denied establishing ssh session: mismatch sha256 fingerprint. \"\n            \"Remote %s is not equal to %s\", fingerprint_b64, pubkey_sha256);\n      free(fingerprint_b64);\n      state(data, SSH_SESSION_FREE);\n      sshc->actualcode = CURLE_PEER_FAILED_VERIFICATION;\n      return sshc->actualcode;\n    }\n\n    free(fingerprint_b64);\n\n    infof(data, \"SHA256 checksum match\");\n  }\n\n  if(pubkey_md5) {\n    char md5buffer[33];\n    const char *fingerprint = NULL;\n\n    fingerprint = libssh2_hostkey_hash(sshc->ssh_session,\n                                       LIBSSH2_HOSTKEY_HASH_MD5);\n\n    if(fingerprint) {\n      /* The fingerprint points to static storage (!), don't free() it. */\n      int i;\n      for(i = 0; i < 16; i++) {\n        msnprintf(&md5buffer[i*2], 3, \"%02x\", (unsigned char) fingerprint[i]);\n      }\n\n      infof(data, \"SSH MD5 fingerprint: %s\", md5buffer);\n    }\n\n    /* This does NOT verify the length of 'pubkey_md5' separately, which will\n       make the comparison below fail unless it is exactly 32 characters */\n    if(!fingerprint || !strcasecompare(md5buffer, pubkey_md5)) {\n      if(fingerprint) {\n        failf(data,\n              \"Denied establishing ssh session: mismatch md5 fingerprint. \"\n              \"Remote %s is not equal to %s\", md5buffer, pubkey_md5);\n      }\n      else {\n        failf(data,\n              \"Denied establishing ssh session: md5 fingerprint \"\n              \"not available\");\n      }\n      state(data, SSH_SESSION_FREE);\n      sshc->actualcode = CURLE_PEER_FAILED_VERIFICATION;\n      return sshc->actualcode;\n    }\n    infof(data, \"MD5 checksum match\");\n  }\n\n  if(!pubkey_md5 && !pubkey_sha256) {\n    if(data->set.ssh_hostkeyfunc) {\n      size_t keylen = 0;\n      int sshkeytype = 0;\n      int rc = 0;\n      /* we handle the process to the callback */\n      const char *remotekey = libssh2_session_hostkey(sshc->ssh_session,\n                                                      &keylen, &sshkeytype);\n      if(remotekey) {\n        int keytype = convert_ssh2_keytype(sshkeytype);\n        Curl_set_in_callback(data, true);\n        rc = data->set.ssh_hostkeyfunc(data->set.ssh_hostkeyfunc_userp,\n                                       keytype, remotekey, keylen);\n        Curl_set_in_callback(data, false);\n        if(rc!= CURLKHMATCH_OK) {\n          state(data, SSH_SESSION_FREE);\n          sshc->actualcode = CURLE_PEER_FAILED_VERIFICATION;\n          return sshc->actualcode;\n        }\n      }\n      else {\n        state(data, SSH_SESSION_FREE);\n        sshc->actualcode = CURLE_PEER_FAILED_VERIFICATION;\n        return sshc->actualcode;\n      }\n      return CURLE_OK;\n    }\n    else {\n      return ssh_knownhost(data);\n    }\n  }\n  else {\n    /* as we already matched, we skip the check for known hosts */\n    return CURLE_OK;\n  }\n}\n\n/*\n * ssh_force_knownhost_key_type() will check the known hosts file and try to\n * force a specific public key type from the server if an entry is found.\n */\nstatic CURLcode ssh_force_knownhost_key_type(struct Curl_easy *data)\n{\n  CURLcode result = CURLE_OK;\n\n#ifdef HAVE_LIBSSH2_KNOWNHOST_API\n\n#ifdef LIBSSH2_KNOWNHOST_KEY_ED25519\n  static const char * const hostkey_method_ssh_ed25519\n    = \"ssh-ed25519\";\n#endif\n#ifdef LIBSSH2_KNOWNHOST_KEY_ECDSA_521\n  static const char * const hostkey_method_ssh_ecdsa_521\n    = \"ecdsa-sha2-nistp521\";\n#endif\n#ifdef LIBSSH2_KNOWNHOST_KEY_ECDSA_384\n  static const char * const hostkey_method_ssh_ecdsa_384\n    = \"ecdsa-sha2-nistp384\";\n#endif\n#ifdef LIBSSH2_KNOWNHOST_KEY_ECDSA_256\n  static const char * const hostkey_method_ssh_ecdsa_256\n    = \"ecdsa-sha2-nistp256\";\n#endif\n  static const char * const hostkey_method_ssh_rsa\n    = \"ssh-rsa\";\n  static const char * const hostkey_method_ssh_rsa_all\n    = \"rsa-sha2-256,rsa-sha2-512,ssh-rsa\";\n  static const char * const hostkey_method_ssh_dss\n    = \"ssh-dss\";\n\n  const char *hostkey_method = NULL;\n  struct connectdata *conn = data->conn;\n  struct ssh_conn *sshc = &conn->proto.sshc;\n  struct libssh2_knownhost* store = NULL;\n  const char *kh_name_end = NULL;\n  size_t kh_name_size = 0;\n  int port = 0;\n  bool found = false;\n\n  if(sshc->kh && !data->set.str[STRING_SSH_HOST_PUBLIC_KEY_MD5]) {\n    /* lets try to find our host in the known hosts file */\n    while(!libssh2_knownhost_get(sshc->kh, &store, store)) {\n      /* For non-standard ports, the name will be enclosed in */\n      /* square brackets, followed by a colon and the port */\n      if(store) {\n        if(store->name) {\n          if(store->name[0] == '[') {\n            kh_name_end = strstr(store->name, \"]:\");\n            if(!kh_name_end) {\n              infof(data, \"Invalid host pattern %s in %s\",\n                    store->name, data->set.str[STRING_SSH_KNOWNHOSTS]);\n              continue;\n            }\n            port = atoi(kh_name_end + 2);\n            if(kh_name_end && (port == conn->remote_port)) {\n              kh_name_size = strlen(store->name) - 1 - strlen(kh_name_end);\n              if(strncmp(store->name + 1,\n                 conn->host.name, kh_name_size) == 0) {\n                found = true;\n                break;\n              }\n            }\n          }\n          else if(strcmp(store->name, conn->host.name) == 0) {\n            found = true;\n            break;\n          }\n        }\n        else {\n          found = true;\n          break;\n        }\n      }\n    }\n\n    if(found) {\n      int rc;\n      infof(data, \"Found host %s in %s\",\n            conn->host.name, data->set.str[STRING_SSH_KNOWNHOSTS]);\n\n      switch(store->typemask & LIBSSH2_KNOWNHOST_KEY_MASK) {\n#ifdef LIBSSH2_KNOWNHOST_KEY_ED25519\n      case LIBSSH2_KNOWNHOST_KEY_ED25519:\n        hostkey_method = hostkey_method_ssh_ed25519;\n        break;\n#endif\n#ifdef LIBSSH2_KNOWNHOST_KEY_ECDSA_521\n      case LIBSSH2_KNOWNHOST_KEY_ECDSA_521:\n        hostkey_method = hostkey_method_ssh_ecdsa_521;\n        break;\n#endif\n#ifdef LIBSSH2_KNOWNHOST_KEY_ECDSA_384\n      case LIBSSH2_KNOWNHOST_KEY_ECDSA_384:\n        hostkey_method = hostkey_method_ssh_ecdsa_384;\n        break;\n#endif\n#ifdef LIBSSH2_KNOWNHOST_KEY_ECDSA_256\n      case LIBSSH2_KNOWNHOST_KEY_ECDSA_256:\n        hostkey_method = hostkey_method_ssh_ecdsa_256;\n        break;\n#endif\n      case LIBSSH2_KNOWNHOST_KEY_SSHRSA:\n#ifdef HAVE_LIBSSH2_VERSION\n        if(libssh2_version(0x010900))\n          /* since 1.9.0 libssh2_session_method_pref() works as expected */\n          hostkey_method = hostkey_method_ssh_rsa_all;\n        else\n#endif\n          /* old libssh2 which cannot correctly remove unsupported methods due\n           * to bug in src/kex.c or does not support the new methods anyways.\n           */\n          hostkey_method = hostkey_method_ssh_rsa;\n        break;\n      case LIBSSH2_KNOWNHOST_KEY_SSHDSS:\n        hostkey_method = hostkey_method_ssh_dss;\n        break;\n      case LIBSSH2_KNOWNHOST_KEY_RSA1:\n        failf(data, \"Found host key type RSA1 which is not supported\");\n        return CURLE_SSH;\n      default:\n        failf(data, \"Unknown host key type: %i\",\n              (store->typemask & LIBSSH2_KNOWNHOST_KEY_MASK));\n        return CURLE_SSH;\n      }\n\n      infof(data, \"Set \\\"%s\\\" as SSH hostkey type\", hostkey_method);\n      rc = libssh2_session_method_pref(sshc->ssh_session,\n                                       LIBSSH2_METHOD_HOSTKEY, hostkey_method);\n      if(rc) {\n        char *errmsg = NULL;\n        int errlen;\n        libssh2_session_last_error(sshc->ssh_session, &errmsg, &errlen, 0);\n        failf(data, \"libssh2: %s\", errmsg);\n        result = libssh2_session_error_to_CURLE(rc);\n      }\n    }\n    else {\n      infof(data, \"Did not find host %s in %s\",\n            conn->host.name, data->set.str[STRING_SSH_KNOWNHOSTS]);\n    }\n  }\n\n#endif /* HAVE_LIBSSH2_KNOWNHOST_API */\n\n  return result;\n}\n\n/*\n * ssh_statemach_act() runs the SSH state machine as far as it can without\n * blocking and without reaching the end.  The data the pointer 'block' points\n * to will be set to TRUE if the libssh2 function returns LIBSSH2_ERROR_EAGAIN\n * meaning it wants to be called again when the socket is ready\n */\n\nstatic CURLcode ssh_statemach_act(struct Curl_easy *data, bool *block)\n{\n  CURLcode result = CURLE_OK;\n  struct connectdata *conn = data->conn;\n  struct SSHPROTO *sshp = data->req.p.ssh;\n  struct ssh_conn *sshc = &conn->proto.sshc;\n  curl_socket_t sock = conn->sock[FIRSTSOCKET];\n  int rc = LIBSSH2_ERROR_NONE;\n  int ssherr;\n  unsigned long sftperr;\n  int seekerr = CURL_SEEKFUNC_OK;\n  size_t readdir_len;\n  *block = 0; /* we're not blocking by default */\n\n  do {\n    switch(sshc->state) {\n    case SSH_INIT:\n      sshc->secondCreateDirs = 0;\n      sshc->nextstate = SSH_NO_STATE;\n      sshc->actualcode = CURLE_OK;\n\n      /* Set libssh2 to non-blocking, since everything internally is\n         non-blocking */\n      libssh2_session_set_blocking(sshc->ssh_session, 0);\n\n      result = ssh_force_knownhost_key_type(data);\n      if(result) {\n        state(data, SSH_SESSION_FREE);\n        sshc->actualcode = result;\n        break;\n      }\n\n      state(data, SSH_S_STARTUP);\n      FALLTHROUGH();\n\n    case SSH_S_STARTUP:\n      rc = session_startup(sshc->ssh_session, sock);\n      if(rc == LIBSSH2_ERROR_EAGAIN) {\n        break;\n      }\n      if(rc) {\n        char *err_msg = NULL;\n        (void)libssh2_session_last_error(sshc->ssh_session, &err_msg, NULL, 0);\n        failf(data, \"Failure establishing ssh session: %d, %s\", rc, err_msg);\n\n        state(data, SSH_SESSION_FREE);\n        sshc->actualcode = CURLE_FAILED_INIT;\n        break;\n      }\n\n      state(data, SSH_HOSTKEY);\n\n      FALLTHROUGH();\n    case SSH_HOSTKEY:\n      /*\n       * Before we authenticate we should check the hostkey's fingerprint\n       * against our known hosts. How that is handled (reading from file,\n       * whatever) is up to us.\n       */\n      result = ssh_check_fingerprint(data);\n      if(!result)\n        state(data, SSH_AUTHLIST);\n      /* ssh_check_fingerprint sets state appropriately on error */\n      break;\n\n    case SSH_AUTHLIST:\n      /*\n       * Figure out authentication methods\n       * NB: As soon as we have provided a username to an openssh server we\n       * must never change it later. Thus, always specify the correct username\n       * here, even though the libssh2 docs kind of indicate that it should be\n       * possible to get a 'generic' list (not user-specific) of authentication\n       * methods, presumably with a blank username. That won't work in my\n       * experience.\n       * So always specify it here.\n       */\n      sshc->authlist = libssh2_userauth_list(sshc->ssh_session,\n                                             conn->user,\n                                             curlx_uztoui(strlen(conn->user)));\n\n      if(!sshc->authlist) {\n        if(libssh2_userauth_authenticated(sshc->ssh_session)) {\n          sshc->authed = TRUE;\n          infof(data, \"SSH user accepted with no authentication\");\n          state(data, SSH_AUTH_DONE);\n          break;\n        }\n        ssherr = libssh2_session_last_errno(sshc->ssh_session);\n        if(ssherr == LIBSSH2_ERROR_EAGAIN)\n          rc = LIBSSH2_ERROR_EAGAIN;\n        else {\n          state(data, SSH_SESSION_FREE);\n          sshc->actualcode = libssh2_session_error_to_CURLE(ssherr);\n        }\n        break;\n      }\n      infof(data, \"SSH authentication methods available: %s\",\n            sshc->authlist);\n\n      state(data, SSH_AUTH_PKEY_INIT);\n      break;\n\n    case SSH_AUTH_PKEY_INIT:\n      /*\n       * Check the supported auth types in the order I feel is most secure\n       * with the requested type of authentication\n       */\n      sshc->authed = FALSE;\n\n      if((data->set.ssh_auth_types & CURLSSH_AUTH_PUBLICKEY) &&\n         (strstr(sshc->authlist, \"publickey\") != NULL)) {\n        bool out_of_memory = FALSE;\n\n        sshc->rsa_pub = sshc->rsa = NULL;\n\n        if(data->set.str[STRING_SSH_PRIVATE_KEY])\n          sshc->rsa = strdup(data->set.str[STRING_SSH_PRIVATE_KEY]);\n        else {\n          /* To ponder about: should really the lib be messing about with the\n             HOME environment variable etc? */\n          char *home = curl_getenv(\"HOME\");\n\n          /* If no private key file is specified, try some common paths. */\n          if(home) {\n            /* Try ~/.ssh first. */\n            sshc->rsa = aprintf(\"%s/.ssh/id_rsa\", home);\n            if(!sshc->rsa)\n              out_of_memory = TRUE;\n            else if(access(sshc->rsa, R_OK) != 0) {\n              Curl_safefree(sshc->rsa);\n              sshc->rsa = aprintf(\"%s/.ssh/id_dsa\", home);\n              if(!sshc->rsa)\n                out_of_memory = TRUE;\n              else if(access(sshc->rsa, R_OK) != 0) {\n                Curl_safefree(sshc->rsa);\n              }\n            }\n            free(home);\n          }\n          if(!out_of_memory && !sshc->rsa) {\n            /* Nothing found; try the current dir. */\n            sshc->rsa = strdup(\"id_rsa\");\n            if(sshc->rsa && access(sshc->rsa, R_OK) != 0) {\n              Curl_safefree(sshc->rsa);\n              sshc->rsa = strdup(\"id_dsa\");\n              if(sshc->rsa && access(sshc->rsa, R_OK) != 0) {\n                Curl_safefree(sshc->rsa);\n                /* Out of guesses. Set to the empty string to avoid\n                 * surprising info messages. */\n                sshc->rsa = strdup(\"\");\n              }\n            }\n          }\n        }\n\n        /*\n         * Unless the user explicitly specifies a public key file, let\n         * libssh2 extract the public key from the private key file.\n         * This is done by simply passing sshc->rsa_pub = NULL.\n         */\n        if(data->set.str[STRING_SSH_PUBLIC_KEY]\n           /* treat empty string the same way as NULL */\n           && data->set.str[STRING_SSH_PUBLIC_KEY][0]) {\n          sshc->rsa_pub = strdup(data->set.str[STRING_SSH_PUBLIC_KEY]);\n          if(!sshc->rsa_pub)\n            out_of_memory = TRUE;\n        }\n\n        if(out_of_memory || !sshc->rsa) {\n          Curl_safefree(sshc->rsa);\n          Curl_safefree(sshc->rsa_pub);\n          state(data, SSH_SESSION_FREE);\n          sshc->actualcode = CURLE_OUT_OF_MEMORY;\n          break;\n        }\n\n        sshc->passphrase = data->set.ssl.key_passwd;\n        if(!sshc->passphrase)\n          sshc->passphrase = \"\";\n\n        if(sshc->rsa_pub)\n          infof(data, \"Using SSH public key file '%s'\", sshc->rsa_pub);\n        infof(data, \"Using SSH private key file '%s'\", sshc->rsa);\n\n        state(data, SSH_AUTH_PKEY);\n      }\n      else {\n        state(data, SSH_AUTH_PASS_INIT);\n      }\n      break;\n\n    case SSH_AUTH_PKEY:\n      /* The function below checks if the files exists, no need to stat() here.\n       */\n      rc = libssh2_userauth_publickey_fromfile_ex(sshc->ssh_session,\n                                                  conn->user,\n                                                  curlx_uztoui(\n                                                    strlen(conn->user)),\n                                                  sshc->rsa_pub,\n                                                  sshc->rsa, sshc->passphrase);\n      if(rc == LIBSSH2_ERROR_EAGAIN) {\n        break;\n      }\n\n      Curl_safefree(sshc->rsa_pub);\n      Curl_safefree(sshc->rsa);\n\n      if(rc == 0) {\n        sshc->authed = TRUE;\n        infof(data, \"Initialized SSH public key authentication\");\n        state(data, SSH_AUTH_DONE);\n      }\n      else {\n        char *err_msg = NULL;\n        char unknown[] = \"Reason unknown (-1)\";\n        if(rc == -1) {\n          /* No error message has been set and the last set error message, if\n             any, is from a previous error so ignore it. #11837 */\n          err_msg = unknown;\n        }\n        else {\n          (void)libssh2_session_last_error(sshc->ssh_session,\n                                           &err_msg, NULL, 0);\n        }\n        infof(data, \"SSH public key authentication failed: %s\", err_msg);\n        state(data, SSH_AUTH_PASS_INIT);\n        rc = 0; /* clear rc and continue */\n      }\n      break;\n\n    case SSH_AUTH_PASS_INIT:\n      if((data->set.ssh_auth_types & CURLSSH_AUTH_PASSWORD) &&\n         (strstr(sshc->authlist, \"password\") != NULL)) {\n        state(data, SSH_AUTH_PASS);\n      }\n      else {\n        state(data, SSH_AUTH_HOST_INIT);\n        rc = 0; /* clear rc and continue */\n      }\n      break;\n\n    case SSH_AUTH_PASS:\n      rc = libssh2_userauth_password_ex(sshc->ssh_session, conn->user,\n                                        curlx_uztoui(strlen(conn->user)),\n                                        conn->passwd,\n                                        curlx_uztoui(strlen(conn->passwd)),\n                                        NULL);\n      if(rc == LIBSSH2_ERROR_EAGAIN) {\n        break;\n      }\n      if(rc == 0) {\n        sshc->authed = TRUE;\n        infof(data, \"Initialized password authentication\");\n        state(data, SSH_AUTH_DONE);\n      }\n      else {\n        state(data, SSH_AUTH_HOST_INIT);\n        rc = 0; /* clear rc and continue */\n      }\n      break;\n\n    case SSH_AUTH_HOST_INIT:\n      if((data->set.ssh_auth_types & CURLSSH_AUTH_HOST) &&\n         (strstr(sshc->authlist, \"hostbased\") != NULL)) {\n        state(data, SSH_AUTH_HOST);\n      }\n      else {\n        state(data, SSH_AUTH_AGENT_INIT);\n      }\n      break;\n\n    case SSH_AUTH_HOST:\n      state(data, SSH_AUTH_AGENT_INIT);\n      break;\n\n    case SSH_AUTH_AGENT_INIT:\n#ifdef HAVE_LIBSSH2_AGENT_API\n      if((data->set.ssh_auth_types & CURLSSH_AUTH_AGENT)\n         && (strstr(sshc->authlist, \"publickey\") != NULL)) {\n\n        /* Connect to the ssh-agent */\n        /* The agent could be shared by a curl thread i believe\n           but nothing obvious as keys can be added/removed at any time */\n        if(!sshc->ssh_agent) {\n          sshc->ssh_agent = libssh2_agent_init(sshc->ssh_session);\n          if(!sshc->ssh_agent) {\n            infof(data, \"Could not create agent object\");\n\n            state(data, SSH_AUTH_KEY_INIT);\n            break;\n          }\n        }\n\n        rc = libssh2_agent_connect(sshc->ssh_agent);\n        if(rc == LIBSSH2_ERROR_EAGAIN)\n          break;\n        if(rc < 0) {\n          infof(data, \"Failure connecting to agent\");\n          state(data, SSH_AUTH_KEY_INIT);\n          rc = 0; /* clear rc and continue */\n        }\n        else {\n          state(data, SSH_AUTH_AGENT_LIST);\n        }\n      }\n      else\n#endif /* HAVE_LIBSSH2_AGENT_API */\n        state(data, SSH_AUTH_KEY_INIT);\n      break;\n\n    case SSH_AUTH_AGENT_LIST:\n#ifdef HAVE_LIBSSH2_AGENT_API\n      rc = libssh2_agent_list_identities(sshc->ssh_agent);\n\n      if(rc == LIBSSH2_ERROR_EAGAIN)\n        break;\n      if(rc < 0) {\n        infof(data, \"Failure requesting identities to agent\");\n        state(data, SSH_AUTH_KEY_INIT);\n        rc = 0; /* clear rc and continue */\n      }\n      else {\n        state(data, SSH_AUTH_AGENT);\n        sshc->sshagent_prev_identity = NULL;\n      }\n#endif\n      break;\n\n    case SSH_AUTH_AGENT:\n#ifdef HAVE_LIBSSH2_AGENT_API\n      /* as prev_identity evolves only after an identity user auth finished we\n         can safely request it again as long as EAGAIN is returned here or by\n         libssh2_agent_userauth */\n      rc = libssh2_agent_get_identity(sshc->ssh_agent,\n                                      &sshc->sshagent_identity,\n                                      sshc->sshagent_prev_identity);\n      if(rc == LIBSSH2_ERROR_EAGAIN)\n        break;\n\n      if(rc == 0) {\n        rc = libssh2_agent_userauth(sshc->ssh_agent, conn->user,\n                                    sshc->sshagent_identity);\n\n        if(rc < 0) {\n          if(rc != LIBSSH2_ERROR_EAGAIN) {\n            /* tried and failed? go to next identity */\n            sshc->sshagent_prev_identity = sshc->sshagent_identity;\n          }\n          break;\n        }\n      }\n\n      if(rc < 0)\n        infof(data, \"Failure requesting identities to agent\");\n      else if(rc == 1)\n        infof(data, \"No identity would match\");\n\n      if(rc == LIBSSH2_ERROR_NONE) {\n        sshc->authed = TRUE;\n        infof(data, \"Agent based authentication successful\");\n        state(data, SSH_AUTH_DONE);\n      }\n      else {\n        state(data, SSH_AUTH_KEY_INIT);\n        rc = 0; /* clear rc and continue */\n      }\n#endif\n      break;\n\n    case SSH_AUTH_KEY_INIT:\n      if((data->set.ssh_auth_types & CURLSSH_AUTH_KEYBOARD)\n         && (strstr(sshc->authlist, \"keyboard-interactive\") != NULL)) {\n        state(data, SSH_AUTH_KEY);\n      }\n      else {\n        state(data, SSH_AUTH_DONE);\n      }\n      break;\n\n    case SSH_AUTH_KEY:\n      /* Authentication failed. Continue with keyboard-interactive now. */\n      rc = libssh2_userauth_keyboard_interactive_ex(sshc->ssh_session,\n                                                    conn->user,\n                                                    curlx_uztoui(\n                                                      strlen(conn->user)),\n                                                    &kbd_callback);\n      if(rc == LIBSSH2_ERROR_EAGAIN) {\n        break;\n      }\n      if(rc == 0) {\n        sshc->authed = TRUE;\n        infof(data, \"Initialized keyboard interactive authentication\");\n      }\n      state(data, SSH_AUTH_DONE);\n      break;\n\n    case SSH_AUTH_DONE:\n      if(!sshc->authed) {\n        failf(data, \"Authentication failure\");\n        state(data, SSH_SESSION_FREE);\n        sshc->actualcode = CURLE_LOGIN_DENIED;\n        break;\n      }\n\n      /*\n       * At this point we have an authenticated ssh session.\n       */\n      infof(data, \"Authentication complete\");\n\n      Curl_pgrsTime(data, TIMER_APPCONNECT); /* SSH is connected */\n\n      conn->sockfd = sock;\n      conn->writesockfd = CURL_SOCKET_BAD;\n\n      if(conn->handler->protocol == CURLPROTO_SFTP) {\n        state(data, SSH_SFTP_INIT);\n        break;\n      }\n      infof(data, \"SSH CONNECT phase done\");\n      state(data, SSH_STOP);\n      break;\n\n    case SSH_SFTP_INIT:\n      /*\n       * Start the libssh2 sftp session\n       */\n      sshc->sftp_session = libssh2_sftp_init(sshc->ssh_session);\n      if(!sshc->sftp_session) {\n        char *err_msg = NULL;\n        if(libssh2_session_last_errno(sshc->ssh_session) ==\n           LIBSSH2_ERROR_EAGAIN) {\n          rc = LIBSSH2_ERROR_EAGAIN;\n          break;\n        }\n\n        (void)libssh2_session_last_error(sshc->ssh_session,\n                                         &err_msg, NULL, 0);\n        failf(data, \"Failure initializing sftp session: %s\", err_msg);\n        state(data, SSH_SESSION_FREE);\n        sshc->actualcode = CURLE_FAILED_INIT;\n        break;\n      }\n      state(data, SSH_SFTP_REALPATH);\n      break;\n\n    case SSH_SFTP_REALPATH:\n    {\n      char tempHome[PATH_MAX];\n\n      /*\n       * Get the \"home\" directory\n       */\n      rc = sftp_libssh2_realpath(sshc->sftp_session, \".\",\n                                 tempHome, PATH_MAX-1);\n      if(rc == LIBSSH2_ERROR_EAGAIN) {\n        break;\n      }\n      if(rc > 0) {\n        /* It seems that this string is not always NULL terminated */\n        tempHome[rc] = '\\0';\n        sshc->homedir = strdup(tempHome);\n        if(!sshc->homedir) {\n          state(data, SSH_SFTP_CLOSE);\n          sshc->actualcode = CURLE_OUT_OF_MEMORY;\n          break;\n        }\n        data->state.most_recent_ftp_entrypath = sshc->homedir;\n      }\n      else {\n        /* Return the error type */\n        sftperr = libssh2_sftp_last_error(sshc->sftp_session);\n        if(sftperr)\n          result = sftp_libssh2_error_to_CURLE(sftperr);\n        else\n          /* in this case, the error wasn't in the SFTP level but for example\n             a time-out or similar */\n          result = CURLE_SSH;\n        sshc->actualcode = result;\n        DEBUGF(infof(data, \"error = %lu makes libcurl = %d\",\n                     sftperr, (int)result));\n        state(data, SSH_STOP);\n        break;\n      }\n    }\n    /* This is the last step in the SFTP connect phase. Do note that while\n       we get the homedir here, we get the \"workingpath\" in the DO action\n       since the homedir will remain the same between request but the\n       working path will not. */\n    DEBUGF(infof(data, \"SSH CONNECT phase done\"));\n    state(data, SSH_STOP);\n    break;\n\n    case SSH_SFTP_QUOTE_INIT:\n\n      result = Curl_getworkingpath(data, sshc->homedir, &sshp->path);\n      if(result) {\n        sshc->actualcode = result;\n        state(data, SSH_STOP);\n        break;\n      }\n\n      if(data->set.quote) {\n        infof(data, \"Sending quote commands\");\n        sshc->quote_item = data->set.quote;\n        state(data, SSH_SFTP_QUOTE);\n      }\n      else {\n        state(data, SSH_SFTP_GETINFO);\n      }\n      break;\n\n    case SSH_SFTP_POSTQUOTE_INIT:\n      if(data->set.postquote) {\n        infof(data, \"Sending quote commands\");\n        sshc->quote_item = data->set.postquote;\n        state(data, SSH_SFTP_QUOTE);\n      }\n      else {\n        state(data, SSH_STOP);\n      }\n      break;\n\n    case SSH_SFTP_QUOTE:\n      /* Send any quote commands */\n    {\n      const char *cp;\n\n      /*\n       * Support some of the \"FTP\" commands\n       *\n       * 'sshc->quote_item' is already verified to be non-NULL before it\n       * switched to this state.\n       */\n      char *cmd = sshc->quote_item->data;\n      sshc->acceptfail = FALSE;\n\n      /* if a command starts with an asterisk, which a legal SFTP command never\n         can, the command will be allowed to fail without it causing any\n         aborts or cancels etc. It will cause libcurl to act as if the command\n         is successful, whatever the server responds. */\n\n      if(cmd[0] == '*') {\n        cmd++;\n        sshc->acceptfail = TRUE;\n      }\n\n      if(strcasecompare(\"pwd\", cmd)) {\n        /* output debug output if that is requested */\n        char *tmp = aprintf(\"257 \\\"%s\\\" is current directory.\\n\",\n                            sshp->path);\n        if(!tmp) {\n          result = CURLE_OUT_OF_MEMORY;\n          state(data, SSH_SFTP_CLOSE);\n          sshc->nextstate = SSH_NO_STATE;\n          break;\n        }\n        Curl_debug(data, CURLINFO_HEADER_OUT, (char *)\"PWD\\n\", 4);\n        Curl_debug(data, CURLINFO_HEADER_IN, tmp, strlen(tmp));\n\n        /* this sends an FTP-like \"header\" to the header callback so that the\n           current directory can be read very similar to how it is read when\n           using ordinary FTP. */\n        result = Curl_client_write(data, CLIENTWRITE_HEADER, tmp, strlen(tmp));\n        free(tmp);\n        if(result) {\n          state(data, SSH_SFTP_CLOSE);\n          sshc->nextstate = SSH_NO_STATE;\n          sshc->actualcode = result;\n        }\n        else\n          state(data, SSH_SFTP_NEXT_QUOTE);\n        break;\n      }\n\n      /*\n       * the arguments following the command must be separated from the\n       * command with a space so we can check for it unconditionally\n       */\n      cp = strchr(cmd, ' ');\n      if(!cp) {\n        failf(data, \"Syntax error command '%s', missing parameter\",\n              cmd);\n        state(data, SSH_SFTP_CLOSE);\n        sshc->nextstate = SSH_NO_STATE;\n        sshc->actualcode = CURLE_QUOTE_ERROR;\n        break;\n      }\n\n      /*\n       * also, every command takes at least one argument so we get that\n       * first argument right now\n       */\n      result = Curl_get_pathname(&cp, &sshc->quote_path1, sshc->homedir);\n      if(result) {\n        if(result == CURLE_OUT_OF_MEMORY)\n          failf(data, \"Out of memory\");\n        else\n          failf(data, \"Syntax error: Bad first parameter to '%s'\", cmd);\n        state(data, SSH_SFTP_CLOSE);\n        sshc->nextstate = SSH_NO_STATE;\n        sshc->actualcode = result;\n        break;\n      }\n\n      /*\n       * SFTP is a binary protocol, so we don't send text commands\n       * to the server. Instead, we scan for commands used by\n       * OpenSSH's sftp program and call the appropriate libssh2\n       * functions.\n       */\n      if(strncasecompare(cmd, \"chgrp \", 6) ||\n         strncasecompare(cmd, \"chmod \", 6) ||\n         strncasecompare(cmd, \"chown \", 6) ||\n         strncasecompare(cmd, \"atime \", 6) ||\n         strncasecompare(cmd, \"mtime \", 6)) {\n        /* attribute change */\n\n        /* sshc->quote_path1 contains the mode to set */\n        /* get the destination */\n        result = Curl_get_pathname(&cp, &sshc->quote_path2, sshc->homedir);\n        if(result) {\n          if(result == CURLE_OUT_OF_MEMORY)\n            failf(data, \"Out of memory\");\n          else\n            failf(data, \"Syntax error in %s: Bad second parameter\", cmd);\n          Curl_safefree(sshc->quote_path1);\n          state(data, SSH_SFTP_CLOSE);\n          sshc->nextstate = SSH_NO_STATE;\n          sshc->actualcode = result;\n          break;\n        }\n        memset(&sshp->quote_attrs, 0, sizeof(LIBSSH2_SFTP_ATTRIBUTES));\n        state(data, SSH_SFTP_QUOTE_STAT);\n        break;\n      }\n      if(strncasecompare(cmd, \"ln \", 3) ||\n         strncasecompare(cmd, \"symlink \", 8)) {\n        /* symbolic linking */\n        /* sshc->quote_path1 is the source */\n        /* get the destination */\n        result = Curl_get_pathname(&cp, &sshc->quote_path2, sshc->homedir);\n        if(result) {\n          if(result == CURLE_OUT_OF_MEMORY)\n            failf(data, \"Out of memory\");\n          else\n            failf(data,\n                  \"Syntax error in ln/symlink: Bad second parameter\");\n          Curl_safefree(sshc->quote_path1);\n          state(data, SSH_SFTP_CLOSE);\n          sshc->nextstate = SSH_NO_STATE;\n          sshc->actualcode = result;\n          break;\n        }\n        state(data, SSH_SFTP_QUOTE_SYMLINK);\n        break;\n      }\n      else if(strncasecompare(cmd, \"mkdir \", 6)) {\n        /* create dir */\n        state(data, SSH_SFTP_QUOTE_MKDIR);\n        break;\n      }\n      else if(strncasecompare(cmd, \"rename \", 7)) {\n        /* rename file */\n        /* first param is the source path */\n        /* second param is the dest. path */\n        result = Curl_get_pathname(&cp, &sshc->quote_path2, sshc->homedir);\n        if(result) {\n          if(result == CURLE_OUT_OF_MEMORY)\n            failf(data, \"Out of memory\");\n          else\n            failf(data, \"Syntax error in rename: Bad second parameter\");\n          Curl_safefree(sshc->quote_path1);\n          state(data, SSH_SFTP_CLOSE);\n          sshc->nextstate = SSH_NO_STATE;\n          sshc->actualcode = result;\n          break;\n        }\n        state(data, SSH_SFTP_QUOTE_RENAME);\n        break;\n      }\n      else if(strncasecompare(cmd, \"rmdir \", 6)) {\n        /* delete dir */\n        state(data, SSH_SFTP_QUOTE_RMDIR);\n        break;\n      }\n      else if(strncasecompare(cmd, \"rm \", 3)) {\n        state(data, SSH_SFTP_QUOTE_UNLINK);\n        break;\n      }\n#ifdef HAS_STATVFS_SUPPORT\n      else if(strncasecompare(cmd, \"statvfs \", 8)) {\n        state(data, SSH_SFTP_QUOTE_STATVFS);\n        break;\n      }\n#endif\n\n      failf(data, \"Unknown SFTP command\");\n      Curl_safefree(sshc->quote_path1);\n      Curl_safefree(sshc->quote_path2);\n      state(data, SSH_SFTP_CLOSE);\n      sshc->nextstate = SSH_NO_STATE;\n      sshc->actualcode = CURLE_QUOTE_ERROR;\n      break;\n    }\n\n    case SSH_SFTP_NEXT_QUOTE:\n      Curl_safefree(sshc->quote_path1);\n      Curl_safefree(sshc->quote_path2);\n\n      sshc->quote_item = sshc->quote_item->next;\n\n      if(sshc->quote_item) {\n        state(data, SSH_SFTP_QUOTE);\n      }\n      else {\n        if(sshc->nextstate != SSH_NO_STATE) {\n          state(data, sshc->nextstate);\n          sshc->nextstate = SSH_NO_STATE;\n        }\n        else {\n          state(data, SSH_SFTP_GETINFO);\n        }\n      }\n      break;\n\n    case SSH_SFTP_QUOTE_STAT:\n    {\n      char *cmd = sshc->quote_item->data;\n      sshc->acceptfail = FALSE;\n\n      /* if a command starts with an asterisk, which a legal SFTP command never\n         can, the command will be allowed to fail without it causing any\n         aborts or cancels etc. It will cause libcurl to act as if the command\n         is successful, whatever the server responds. */\n\n      if(cmd[0] == '*') {\n        cmd++;\n        sshc->acceptfail = TRUE;\n      }\n\n      if(!strncasecompare(cmd, \"chmod\", 5)) {\n        /* Since chown and chgrp only set owner OR group but libssh2 wants to\n         * set them both at once, we need to obtain the current ownership\n         * first.  This takes an extra protocol round trip.\n         */\n        rc = libssh2_sftp_stat_ex(sshc->sftp_session, sshc->quote_path2,\n                                  curlx_uztoui(strlen(sshc->quote_path2)),\n                                  LIBSSH2_SFTP_STAT,\n                                  &sshp->quote_attrs);\n        if(rc == LIBSSH2_ERROR_EAGAIN) {\n          break;\n        }\n        if(rc && !sshc->acceptfail) { /* get those attributes */\n          sftperr = libssh2_sftp_last_error(sshc->sftp_session);\n          Curl_safefree(sshc->quote_path1);\n          Curl_safefree(sshc->quote_path2);\n          failf(data, \"Attempt to get SFTP stats failed: %s\",\n                sftp_libssh2_strerror(sftperr));\n          state(data, SSH_SFTP_CLOSE);\n          sshc->nextstate = SSH_NO_STATE;\n          sshc->actualcode = CURLE_QUOTE_ERROR;\n          break;\n        }\n      }\n\n      /* Now set the new attributes... */\n      if(strncasecompare(cmd, \"chgrp\", 5)) {\n        sshp->quote_attrs.gid = strtoul(sshc->quote_path1, NULL, 10);\n        sshp->quote_attrs.flags = LIBSSH2_SFTP_ATTR_UIDGID;\n        if(sshp->quote_attrs.gid == 0 && !ISDIGIT(sshc->quote_path1[0]) &&\n           !sshc->acceptfail) {\n          Curl_safefree(sshc->quote_path1);\n          Curl_safefree(sshc->quote_path2);\n          failf(data, \"Syntax error: chgrp gid not a number\");\n          state(data, SSH_SFTP_CLOSE);\n          sshc->nextstate = SSH_NO_STATE;\n          sshc->actualcode = CURLE_QUOTE_ERROR;\n          break;\n        }\n      }\n      else if(strncasecompare(cmd, \"chmod\", 5)) {\n        sshp->quote_attrs.permissions = strtoul(sshc->quote_path1, NULL, 8);\n        sshp->quote_attrs.flags = LIBSSH2_SFTP_ATTR_PERMISSIONS;\n        /* permissions are octal */\n        if(sshp->quote_attrs.permissions == 0 &&\n           !ISDIGIT(sshc->quote_path1[0])) {\n          Curl_safefree(sshc->quote_path1);\n          Curl_safefree(sshc->quote_path2);\n          failf(data, \"Syntax error: chmod permissions not a number\");\n          state(data, SSH_SFTP_CLOSE);\n          sshc->nextstate = SSH_NO_STATE;\n          sshc->actualcode = CURLE_QUOTE_ERROR;\n          break;\n        }\n      }\n      else if(strncasecompare(cmd, \"chown\", 5)) {\n        sshp->quote_attrs.uid = strtoul(sshc->quote_path1, NULL, 10);\n        sshp->quote_attrs.flags = LIBSSH2_SFTP_ATTR_UIDGID;\n        if(sshp->quote_attrs.uid == 0 && !ISDIGIT(sshc->quote_path1[0]) &&\n           !sshc->acceptfail) {\n          Curl_safefree(sshc->quote_path1);\n          Curl_safefree(sshc->quote_path2);\n          failf(data, \"Syntax error: chown uid not a number\");\n          state(data, SSH_SFTP_CLOSE);\n          sshc->nextstate = SSH_NO_STATE;\n          sshc->actualcode = CURLE_QUOTE_ERROR;\n          break;\n        }\n      }\n      else if(strncasecompare(cmd, \"atime\", 5) ||\n              strncasecompare(cmd, \"mtime\", 5)) {\n        time_t date = Curl_getdate_capped(sshc->quote_path1);\n        bool fail = FALSE;\n\n        if(date == -1) {\n          failf(data, \"incorrect date format for %.*s\", 5, cmd);\n          fail = TRUE;\n        }\n#if SIZEOF_TIME_T > SIZEOF_LONG\n        if(date > 0xffffffff) {\n          /* if 'long' can't old >32bit, this date cannot be sent */\n          failf(data, \"date overflow\");\n          fail = TRUE;\n        }\n#endif\n        if(fail) {\n          Curl_safefree(sshc->quote_path1);\n          Curl_safefree(sshc->quote_path2);\n          state(data, SSH_SFTP_CLOSE);\n          sshc->nextstate = SSH_NO_STATE;\n          sshc->actualcode = CURLE_QUOTE_ERROR;\n          break;\n        }\n        if(strncasecompare(cmd, \"atime\", 5))\n          sshp->quote_attrs.atime = (unsigned long)date;\n        else /* mtime */\n          sshp->quote_attrs.mtime = (unsigned long)date;\n\n        sshp->quote_attrs.flags = LIBSSH2_SFTP_ATTR_ACMODTIME;\n      }\n\n      /* Now send the completed structure... */\n      state(data, SSH_SFTP_QUOTE_SETSTAT);\n      break;\n    }\n\n    case SSH_SFTP_QUOTE_SETSTAT:\n      rc = libssh2_sftp_stat_ex(sshc->sftp_session, sshc->quote_path2,\n                                curlx_uztoui(strlen(sshc->quote_path2)),\n                                LIBSSH2_SFTP_SETSTAT,\n                                &sshp->quote_attrs);\n      if(rc == LIBSSH2_ERROR_EAGAIN) {\n        break;\n      }\n      if(rc && !sshc->acceptfail) {\n        sftperr = libssh2_sftp_last_error(sshc->sftp_session);\n        Curl_safefree(sshc->quote_path1);\n        Curl_safefree(sshc->quote_path2);\n        failf(data, \"Attempt to set SFTP stats failed: %s\",\n              sftp_libssh2_strerror(sftperr));\n        state(data, SSH_SFTP_CLOSE);\n        sshc->nextstate = SSH_NO_STATE;\n        sshc->actualcode = CURLE_QUOTE_ERROR;\n        break;\n      }\n      state(data, SSH_SFTP_NEXT_QUOTE);\n      break;\n\n    case SSH_SFTP_QUOTE_SYMLINK:\n      rc = libssh2_sftp_symlink_ex(sshc->sftp_session, sshc->quote_path1,\n                                   curlx_uztoui(strlen(sshc->quote_path1)),\n                                   sshc->quote_path2,\n                                   curlx_uztoui(strlen(sshc->quote_path2)),\n                                   LIBSSH2_SFTP_SYMLINK);\n      if(rc == LIBSSH2_ERROR_EAGAIN) {\n        break;\n      }\n      if(rc && !sshc->acceptfail) {\n        sftperr = libssh2_sftp_last_error(sshc->sftp_session);\n        Curl_safefree(sshc->quote_path1);\n        Curl_safefree(sshc->quote_path2);\n        failf(data, \"symlink command failed: %s\",\n              sftp_libssh2_strerror(sftperr));\n        state(data, SSH_SFTP_CLOSE);\n        sshc->nextstate = SSH_NO_STATE;\n        sshc->actualcode = CURLE_QUOTE_ERROR;\n        break;\n      }\n      state(data, SSH_SFTP_NEXT_QUOTE);\n      break;\n\n    case SSH_SFTP_QUOTE_MKDIR:\n      rc = libssh2_sftp_mkdir_ex(sshc->sftp_session, sshc->quote_path1,\n                                 curlx_uztoui(strlen(sshc->quote_path1)),\n                                 data->set.new_directory_perms);\n      if(rc == LIBSSH2_ERROR_EAGAIN) {\n        break;\n      }\n      if(rc && !sshc->acceptfail) {\n        sftperr = libssh2_sftp_last_error(sshc->sftp_session);\n        Curl_safefree(sshc->quote_path1);\n        failf(data, \"mkdir command failed: %s\",\n              sftp_libssh2_strerror(sftperr));\n        state(data, SSH_SFTP_CLOSE);\n        sshc->nextstate = SSH_NO_STATE;\n        sshc->actualcode = CURLE_QUOTE_ERROR;\n        break;\n      }\n      state(data, SSH_SFTP_NEXT_QUOTE);\n      break;\n\n    case SSH_SFTP_QUOTE_RENAME:\n      rc = libssh2_sftp_rename_ex(sshc->sftp_session, sshc->quote_path1,\n                                  curlx_uztoui(strlen(sshc->quote_path1)),\n                                  sshc->quote_path2,\n                                  curlx_uztoui(strlen(sshc->quote_path2)),\n                                  LIBSSH2_SFTP_RENAME_OVERWRITE |\n                                  LIBSSH2_SFTP_RENAME_ATOMIC |\n                                  LIBSSH2_SFTP_RENAME_NATIVE);\n\n      if(rc == LIBSSH2_ERROR_EAGAIN) {\n        break;\n      }\n      if(rc && !sshc->acceptfail) {\n        sftperr = libssh2_sftp_last_error(sshc->sftp_session);\n        Curl_safefree(sshc->quote_path1);\n        Curl_safefree(sshc->quote_path2);\n        failf(data, \"rename command failed: %s\",\n              sftp_libssh2_strerror(sftperr));\n        state(data, SSH_SFTP_CLOSE);\n        sshc->nextstate = SSH_NO_STATE;\n        sshc->actualcode = CURLE_QUOTE_ERROR;\n        break;\n      }\n      state(data, SSH_SFTP_NEXT_QUOTE);\n      break;\n\n    case SSH_SFTP_QUOTE_RMDIR:\n      rc = libssh2_sftp_rmdir_ex(sshc->sftp_session, sshc->quote_path1,\n                                 curlx_uztoui(strlen(sshc->quote_path1)));\n      if(rc == LIBSSH2_ERROR_EAGAIN) {\n        break;\n      }\n      if(rc && !sshc->acceptfail) {\n        sftperr = libssh2_sftp_last_error(sshc->sftp_session);\n        Curl_safefree(sshc->quote_path1);\n        failf(data, \"rmdir command failed: %s\",\n              sftp_libssh2_strerror(sftperr));\n        state(data, SSH_SFTP_CLOSE);\n        sshc->nextstate = SSH_NO_STATE;\n        sshc->actualcode = CURLE_QUOTE_ERROR;\n        break;\n      }\n      state(data, SSH_SFTP_NEXT_QUOTE);\n      break;\n\n    case SSH_SFTP_QUOTE_UNLINK:\n      rc = libssh2_sftp_unlink_ex(sshc->sftp_session, sshc->quote_path1,\n                                  curlx_uztoui(strlen(sshc->quote_path1)));\n      if(rc == LIBSSH2_ERROR_EAGAIN) {\n        break;\n      }\n      if(rc && !sshc->acceptfail) {\n        sftperr = libssh2_sftp_last_error(sshc->sftp_session);\n        Curl_safefree(sshc->quote_path1);\n        failf(data, \"rm command failed: %s\", sftp_libssh2_strerror(sftperr));\n        state(data, SSH_SFTP_CLOSE);\n        sshc->nextstate = SSH_NO_STATE;\n        sshc->actualcode = CURLE_QUOTE_ERROR;\n        break;\n      }\n      state(data, SSH_SFTP_NEXT_QUOTE);\n      break;\n\n#ifdef HAS_STATVFS_SUPPORT\n    case SSH_SFTP_QUOTE_STATVFS:\n    {\n      LIBSSH2_SFTP_STATVFS statvfs;\n      rc = libssh2_sftp_statvfs(sshc->sftp_session, sshc->quote_path1,\n                                curlx_uztoui(strlen(sshc->quote_path1)),\n                                &statvfs);\n\n      if(rc == LIBSSH2_ERROR_EAGAIN) {\n        break;\n      }\n      if(rc && !sshc->acceptfail) {\n        sftperr = libssh2_sftp_last_error(sshc->sftp_session);\n        Curl_safefree(sshc->quote_path1);\n        failf(data, \"statvfs command failed: %s\",\n              sftp_libssh2_strerror(sftperr));\n        state(data, SSH_SFTP_CLOSE);\n        sshc->nextstate = SSH_NO_STATE;\n        sshc->actualcode = CURLE_QUOTE_ERROR;\n        break;\n      }\n      else if(rc == 0) {\n        #ifdef _MSC_VER\n        #define CURL_LIBSSH2_VFS_SIZE_MASK \"I64u\"\n        #else\n        #define CURL_LIBSSH2_VFS_SIZE_MASK \"llu\"\n        #endif\n        char *tmp = aprintf(\"statvfs:\\n\"\n                            \"f_bsize: %\" CURL_LIBSSH2_VFS_SIZE_MASK \"\\n\"\n                            \"f_frsize: %\" CURL_LIBSSH2_VFS_SIZE_MASK \"\\n\"\n                            \"f_blocks: %\" CURL_LIBSSH2_VFS_SIZE_MASK \"\\n\"\n                            \"f_bfree: %\" CURL_LIBSSH2_VFS_SIZE_MASK \"\\n\"\n                            \"f_bavail: %\" CURL_LIBSSH2_VFS_SIZE_MASK \"\\n\"\n                            \"f_files: %\" CURL_LIBSSH2_VFS_SIZE_MASK \"\\n\"\n                            \"f_ffree: %\" CURL_LIBSSH2_VFS_SIZE_MASK \"\\n\"\n                            \"f_favail: %\" CURL_LIBSSH2_VFS_SIZE_MASK \"\\n\"\n                            \"f_fsid: %\" CURL_LIBSSH2_VFS_SIZE_MASK \"\\n\"\n                            \"f_flag: %\" CURL_LIBSSH2_VFS_SIZE_MASK \"\\n\"\n                            \"f_namemax: %\" CURL_LIBSSH2_VFS_SIZE_MASK \"\\n\",\n                            statvfs.f_bsize, statvfs.f_frsize,\n                            statvfs.f_blocks, statvfs.f_bfree,\n                            statvfs.f_bavail, statvfs.f_files,\n                            statvfs.f_ffree, statvfs.f_favail,\n                            statvfs.f_fsid, statvfs.f_flag,\n                            statvfs.f_namemax);\n        if(!tmp) {\n          result = CURLE_OUT_OF_MEMORY;\n          state(data, SSH_SFTP_CLOSE);\n          sshc->nextstate = SSH_NO_STATE;\n          break;\n        }\n\n        result = Curl_client_write(data, CLIENTWRITE_HEADER, tmp, strlen(tmp));\n        free(tmp);\n        if(result) {\n          state(data, SSH_SFTP_CLOSE);\n          sshc->nextstate = SSH_NO_STATE;\n          sshc->actualcode = result;\n        }\n      }\n      state(data, SSH_SFTP_NEXT_QUOTE);\n      break;\n    }\n#endif\n    case SSH_SFTP_GETINFO:\n    {\n      if(data->set.get_filetime) {\n        state(data, SSH_SFTP_FILETIME);\n      }\n      else {\n        state(data, SSH_SFTP_TRANS_INIT);\n      }\n      break;\n    }\n\n    case SSH_SFTP_FILETIME:\n    {\n      LIBSSH2_SFTP_ATTRIBUTES attrs;\n\n      rc = libssh2_sftp_stat_ex(sshc->sftp_session, sshp->path,\n                                curlx_uztoui(strlen(sshp->path)),\n                                LIBSSH2_SFTP_STAT, &attrs);\n      if(rc == LIBSSH2_ERROR_EAGAIN) {\n        break;\n      }\n      if(rc == 0) {\n        data->info.filetime = attrs.mtime;\n      }\n\n      state(data, SSH_SFTP_TRANS_INIT);\n      break;\n    }\n\n    case SSH_SFTP_TRANS_INIT:\n      if(data->state.upload)\n        state(data, SSH_SFTP_UPLOAD_INIT);\n      else {\n        if(sshp->path[strlen(sshp->path)-1] == '/')\n          state(data, SSH_SFTP_READDIR_INIT);\n        else\n          state(data, SSH_SFTP_DOWNLOAD_INIT);\n      }\n      break;\n\n    case SSH_SFTP_UPLOAD_INIT:\n    {\n      unsigned long flags;\n      /*\n       * NOTE!!!  libssh2 requires that the destination path is a full path\n       *          that includes the destination file and name OR ends in a \"/\"\n       *          If this is not done the destination file will be named the\n       *          same name as the last directory in the path.\n       */\n\n      if(data->state.resume_from) {\n        LIBSSH2_SFTP_ATTRIBUTES attrs;\n        if(data->state.resume_from < 0) {\n          rc = libssh2_sftp_stat_ex(sshc->sftp_session, sshp->path,\n                                    curlx_uztoui(strlen(sshp->path)),\n                                    LIBSSH2_SFTP_STAT, &attrs);\n          if(rc == LIBSSH2_ERROR_EAGAIN) {\n            break;\n          }\n          if(rc) {\n            data->state.resume_from = 0;\n          }\n          else {\n            curl_off_t size = attrs.filesize;\n            if(size < 0) {\n              failf(data, \"Bad file size (%\" CURL_FORMAT_CURL_OFF_T \")\", size);\n              return CURLE_BAD_DOWNLOAD_RESUME;\n            }\n            data->state.resume_from = attrs.filesize;\n          }\n        }\n      }\n\n      if(data->set.remote_append)\n        /* Try to open for append, but create if nonexisting */\n        flags = LIBSSH2_FXF_WRITE|LIBSSH2_FXF_CREAT|LIBSSH2_FXF_APPEND;\n      else if(data->state.resume_from > 0)\n        /* If we have restart position then open for append */\n        flags = LIBSSH2_FXF_WRITE|LIBSSH2_FXF_APPEND;\n      else\n        /* Clear file before writing (normal behavior) */\n        flags = LIBSSH2_FXF_WRITE|LIBSSH2_FXF_CREAT|LIBSSH2_FXF_TRUNC;\n\n      sshc->sftp_handle =\n        libssh2_sftp_open_ex(sshc->sftp_session, sshp->path,\n                             curlx_uztoui(strlen(sshp->path)),\n                             flags, data->set.new_file_perms,\n                             LIBSSH2_SFTP_OPENFILE);\n\n      if(!sshc->sftp_handle) {\n        rc = libssh2_session_last_errno(sshc->ssh_session);\n\n        if(LIBSSH2_ERROR_EAGAIN == rc)\n          break;\n\n        if(LIBSSH2_ERROR_SFTP_PROTOCOL == rc)\n          /* only when there was an SFTP protocol error can we extract\n             the sftp error! */\n          sftperr = libssh2_sftp_last_error(sshc->sftp_session);\n        else\n          sftperr = LIBSSH2_FX_OK; /* not an sftp error at all */\n\n        if(sshc->secondCreateDirs) {\n          state(data, SSH_SFTP_CLOSE);\n          sshc->actualcode = sftperr != LIBSSH2_FX_OK ?\n            sftp_libssh2_error_to_CURLE(sftperr):CURLE_SSH;\n          failf(data, \"Creating the dir/file failed: %s\",\n                sftp_libssh2_strerror(sftperr));\n          break;\n        }\n        if(((sftperr == LIBSSH2_FX_NO_SUCH_FILE) ||\n            (sftperr == LIBSSH2_FX_FAILURE) ||\n            (sftperr == LIBSSH2_FX_NO_SUCH_PATH)) &&\n           (data->set.ftp_create_missing_dirs &&\n            (strlen(sshp->path) > 1))) {\n          /* try to create the path remotely */\n          rc = 0; /* clear rc and continue */\n          sshc->secondCreateDirs = 1;\n          state(data, SSH_SFTP_CREATE_DIRS_INIT);\n          break;\n        }\n        state(data, SSH_SFTP_CLOSE);\n        sshc->actualcode = sftperr != LIBSSH2_FX_OK ?\n          sftp_libssh2_error_to_CURLE(sftperr):CURLE_SSH;\n        if(!sshc->actualcode) {\n          /* Sometimes, for some reason libssh2_sftp_last_error() returns zero\n             even though libssh2_sftp_open() failed previously! We need to\n             work around that! */\n          sshc->actualcode = CURLE_SSH;\n          sftperr = LIBSSH2_FX_OK;\n        }\n        failf(data, \"Upload failed: %s (%lu/%d)\",\n              sftperr != LIBSSH2_FX_OK ?\n              sftp_libssh2_strerror(sftperr):\"ssh error\",\n              sftperr, rc);\n        break;\n      }\n\n      /* If we have a restart point then we need to seek to the correct\n         position. */\n      if(data->state.resume_from > 0) {\n        /* Let's read off the proper amount of bytes from the input. */\n        if(data->set.seek_func) {\n          Curl_set_in_callback(data, true);\n          seekerr = data->set.seek_func(data->set.seek_client,\n                                        data->state.resume_from, SEEK_SET);\n          Curl_set_in_callback(data, false);\n        }\n\n        if(seekerr != CURL_SEEKFUNC_OK) {\n          curl_off_t passed = 0;\n\n          if(seekerr != CURL_SEEKFUNC_CANTSEEK) {\n            failf(data, \"Could not seek stream\");\n            return CURLE_FTP_COULDNT_USE_REST;\n          }\n          /* seekerr == CURL_SEEKFUNC_CANTSEEK (can't seek to offset) */\n          do {\n            char scratch[4*1024];\n            size_t readthisamountnow =\n              (data->state.resume_from - passed >\n                (curl_off_t)sizeof(scratch)) ?\n              sizeof(scratch) : curlx_sotouz(data->state.resume_from - passed);\n\n            size_t actuallyread;\n            Curl_set_in_callback(data, true);\n            actuallyread = data->state.fread_func(scratch, 1,\n                                                  readthisamountnow,\n                                                  data->state.in);\n            Curl_set_in_callback(data, false);\n\n            passed += actuallyread;\n            if((actuallyread == 0) || (actuallyread > readthisamountnow)) {\n              /* this checks for greater-than only to make sure that the\n                 CURL_READFUNC_ABORT return code still aborts */\n              failf(data, \"Failed to read data\");\n              return CURLE_FTP_COULDNT_USE_REST;\n            }\n          } while(passed < data->state.resume_from);\n        }\n\n        /* now, decrease the size of the read */\n        if(data->state.infilesize > 0) {\n          data->state.infilesize -= data->state.resume_from;\n          data->req.size = data->state.infilesize;\n          Curl_pgrsSetUploadSize(data, data->state.infilesize);\n        }\n\n        SFTP_SEEK(sshc->sftp_handle, data->state.resume_from);\n      }\n      if(data->state.infilesize > 0) {\n        data->req.size = data->state.infilesize;\n        Curl_pgrsSetUploadSize(data, data->state.infilesize);\n      }\n      /* upload data */\n      Curl_xfer_setup(data, -1, -1, FALSE, FIRSTSOCKET);\n\n      /* not set by Curl_xfer_setup to preserve keepon bits */\n      conn->sockfd = conn->writesockfd;\n\n      if(result) {\n        state(data, SSH_SFTP_CLOSE);\n        sshc->actualcode = result;\n      }\n      else {\n        /* store this original bitmask setup to use later on if we can't\n           figure out a \"real\" bitmask */\n        sshc->orig_waitfor = data->req.keepon;\n\n        /* we want to use the _sending_ function even when the socket turns\n           out readable as the underlying libssh2 sftp send function will deal\n           with both accordingly */\n        data->state.select_bits = CURL_CSELECT_OUT;\n\n        /* since we don't really wait for anything at this point, we want the\n           state machine to move on as soon as possible so we set a very short\n           timeout here */\n        Curl_expire(data, 0, EXPIRE_RUN_NOW);\n\n        state(data, SSH_STOP);\n      }\n      break;\n    }\n\n    case SSH_SFTP_CREATE_DIRS_INIT:\n      if(strlen(sshp->path) > 1) {\n        sshc->slash_pos = sshp->path + 1; /* ignore the leading '/' */\n        state(data, SSH_SFTP_CREATE_DIRS);\n      }\n      else {\n        state(data, SSH_SFTP_UPLOAD_INIT);\n      }\n      break;\n\n    case SSH_SFTP_CREATE_DIRS:\n      sshc->slash_pos = strchr(sshc->slash_pos, '/');\n      if(sshc->slash_pos) {\n        *sshc->slash_pos = 0;\n\n        infof(data, \"Creating directory '%s'\", sshp->path);\n        state(data, SSH_SFTP_CREATE_DIRS_MKDIR);\n        break;\n      }\n      state(data, SSH_SFTP_UPLOAD_INIT);\n      break;\n\n    case SSH_SFTP_CREATE_DIRS_MKDIR:\n      /* 'mode' - parameter is preliminary - default to 0644 */\n      rc = libssh2_sftp_mkdir_ex(sshc->sftp_session, sshp->path,\n                                 curlx_uztoui(strlen(sshp->path)),\n                                 data->set.new_directory_perms);\n      if(rc == LIBSSH2_ERROR_EAGAIN) {\n        break;\n      }\n      *sshc->slash_pos = '/';\n      ++sshc->slash_pos;\n      if(rc < 0) {\n        /*\n         * Abort if failure wasn't that the dir already exists or the\n         * permission was denied (creation might succeed further down the\n         * path) - retry on unspecific FAILURE also\n         */\n        sftperr = libssh2_sftp_last_error(sshc->sftp_session);\n        if((sftperr != LIBSSH2_FX_FILE_ALREADY_EXISTS) &&\n           (sftperr != LIBSSH2_FX_FAILURE) &&\n           (sftperr != LIBSSH2_FX_PERMISSION_DENIED)) {\n          result = sftp_libssh2_error_to_CURLE(sftperr);\n          state(data, SSH_SFTP_CLOSE);\n          sshc->actualcode = result?result:CURLE_SSH;\n          break;\n        }\n        rc = 0; /* clear rc and continue */\n      }\n      state(data, SSH_SFTP_CREATE_DIRS);\n      break;\n\n    case SSH_SFTP_READDIR_INIT:\n      Curl_pgrsSetDownloadSize(data, -1);\n      if(data->req.no_body) {\n        state(data, SSH_STOP);\n        break;\n      }\n\n      /*\n       * This is a directory that we are trying to get, so produce a directory\n       * listing\n       */\n      sshc->sftp_handle = libssh2_sftp_open_ex(sshc->sftp_session,\n                                               sshp->path,\n                                               curlx_uztoui(\n                                                 strlen(sshp->path)),\n                                               0, 0, LIBSSH2_SFTP_OPENDIR);\n      if(!sshc->sftp_handle) {\n        if(libssh2_session_last_errno(sshc->ssh_session) ==\n           LIBSSH2_ERROR_EAGAIN) {\n          rc = LIBSSH2_ERROR_EAGAIN;\n          break;\n        }\n        sftperr = libssh2_sftp_last_error(sshc->sftp_session);\n        failf(data, \"Could not open directory for reading: %s\",\n              sftp_libssh2_strerror(sftperr));\n        state(data, SSH_SFTP_CLOSE);\n        result = sftp_libssh2_error_to_CURLE(sftperr);\n        sshc->actualcode = result?result:CURLE_SSH;\n        break;\n      }\n      sshp->readdir_filename = malloc(PATH_MAX + 1);\n      if(!sshp->readdir_filename) {\n        state(data, SSH_SFTP_CLOSE);\n        sshc->actualcode = CURLE_OUT_OF_MEMORY;\n        break;\n      }\n      sshp->readdir_longentry = malloc(PATH_MAX + 1);\n      if(!sshp->readdir_longentry) {\n        Curl_safefree(sshp->readdir_filename);\n        state(data, SSH_SFTP_CLOSE);\n        sshc->actualcode = CURLE_OUT_OF_MEMORY;\n        break;\n      }\n      Curl_dyn_init(&sshp->readdir, PATH_MAX * 2);\n      state(data, SSH_SFTP_READDIR);\n      break;\n\n    case SSH_SFTP_READDIR:\n      rc = libssh2_sftp_readdir_ex(sshc->sftp_handle,\n                                   sshp->readdir_filename,\n                                   PATH_MAX,\n                                   sshp->readdir_longentry,\n                                   PATH_MAX,\n                                   &sshp->readdir_attrs);\n      if(rc == LIBSSH2_ERROR_EAGAIN) {\n        break;\n      }\n      if(rc > 0) {\n        readdir_len = (size_t) rc;\n        sshp->readdir_filename[readdir_len] = '\\0';\n\n        if(data->set.list_only) {\n          result = Curl_client_write(data, CLIENTWRITE_BODY,\n                                     sshp->readdir_filename,\n                                     readdir_len);\n          if(!result)\n            result = Curl_client_write(data, CLIENTWRITE_BODY,\n                                       (char *)\"\\n\", 1);\n          if(result) {\n            state(data, SSH_STOP);\n            break;\n          }\n\n        }\n        else {\n          result = Curl_dyn_add(&sshp->readdir, sshp->readdir_longentry);\n\n          if(!result) {\n            if((sshp->readdir_attrs.flags & LIBSSH2_SFTP_ATTR_PERMISSIONS) &&\n               ((sshp->readdir_attrs.permissions & LIBSSH2_SFTP_S_IFMT) ==\n                LIBSSH2_SFTP_S_IFLNK)) {\n              Curl_dyn_init(&sshp->readdir_link, PATH_MAX);\n              result = Curl_dyn_addf(&sshp->readdir_link, \"%s%s\", sshp->path,\n                                     sshp->readdir_filename);\n              state(data, SSH_SFTP_READDIR_LINK);\n              if(!result)\n                break;\n            }\n            else {\n              state(data, SSH_SFTP_READDIR_BOTTOM);\n              break;\n            }\n          }\n          sshc->actualcode = result;\n          state(data, SSH_SFTP_CLOSE);\n          break;\n        }\n      }\n      else if(rc == 0) {\n        Curl_safefree(sshp->readdir_filename);\n        Curl_safefree(sshp->readdir_longentry);\n        state(data, SSH_SFTP_READDIR_DONE);\n        break;\n      }\n      else if(rc < 0) {\n        sftperr = libssh2_sftp_last_error(sshc->sftp_session);\n        result = sftp_libssh2_error_to_CURLE(sftperr);\n        sshc->actualcode = result?result:CURLE_SSH;\n        failf(data, \"Could not open remote file for reading: %s :: %d\",\n              sftp_libssh2_strerror(sftperr),\n              libssh2_session_last_errno(sshc->ssh_session));\n        Curl_safefree(sshp->readdir_filename);\n        Curl_safefree(sshp->readdir_longentry);\n        state(data, SSH_SFTP_CLOSE);\n        break;\n      }\n      break;\n\n    case SSH_SFTP_READDIR_LINK:\n      rc =\n        libssh2_sftp_symlink_ex(sshc->sftp_session,\n                                Curl_dyn_ptr(&sshp->readdir_link),\n                                (int)Curl_dyn_len(&sshp->readdir_link),\n                                sshp->readdir_filename,\n                                PATH_MAX, LIBSSH2_SFTP_READLINK);\n      if(rc == LIBSSH2_ERROR_EAGAIN) {\n        break;\n      }\n      Curl_dyn_free(&sshp->readdir_link);\n\n      /* append filename and extra output */\n      result = Curl_dyn_addf(&sshp->readdir, \" -> %s\", sshp->readdir_filename);\n\n      if(result) {\n        Curl_safefree(sshp->readdir_filename);\n        Curl_safefree(sshp->readdir_longentry);\n        state(data, SSH_SFTP_CLOSE);\n        sshc->actualcode = result;\n        break;\n      }\n\n      state(data, SSH_SFTP_READDIR_BOTTOM);\n      break;\n\n    case SSH_SFTP_READDIR_BOTTOM:\n      result = Curl_dyn_addn(&sshp->readdir, \"\\n\", 1);\n      if(!result)\n        result = Curl_client_write(data, CLIENTWRITE_BODY,\n                                   Curl_dyn_ptr(&sshp->readdir),\n                                   Curl_dyn_len(&sshp->readdir));\n\n      if(result) {\n        Curl_dyn_free(&sshp->readdir);\n        state(data, SSH_STOP);\n      }\n      else {\n        Curl_dyn_reset(&sshp->readdir);\n        state(data, SSH_SFTP_READDIR);\n      }\n      break;\n\n    case SSH_SFTP_READDIR_DONE:\n      if(libssh2_sftp_closedir(sshc->sftp_handle) ==\n         LIBSSH2_ERROR_EAGAIN) {\n        rc = LIBSSH2_ERROR_EAGAIN;\n        break;\n      }\n      sshc->sftp_handle = NULL;\n      Curl_safefree(sshp->readdir_filename);\n      Curl_safefree(sshp->readdir_longentry);\n\n      /* no data to transfer */\n      Curl_xfer_setup(data, -1, -1, FALSE, -1);\n      state(data, SSH_STOP);\n      break;\n\n    case SSH_SFTP_DOWNLOAD_INIT:\n      /*\n       * Work on getting the specified file\n       */\n      sshc->sftp_handle =\n        libssh2_sftp_open_ex(sshc->sftp_session, sshp->path,\n                             curlx_uztoui(strlen(sshp->path)),\n                             LIBSSH2_FXF_READ, data->set.new_file_perms,\n                             LIBSSH2_SFTP_OPENFILE);\n      if(!sshc->sftp_handle) {\n        if(libssh2_session_last_errno(sshc->ssh_session) ==\n           LIBSSH2_ERROR_EAGAIN) {\n          rc = LIBSSH2_ERROR_EAGAIN;\n          break;\n        }\n        sftperr = libssh2_sftp_last_error(sshc->sftp_session);\n        failf(data, \"Could not open remote file for reading: %s\",\n              sftp_libssh2_strerror(sftperr));\n        state(data, SSH_SFTP_CLOSE);\n        result = sftp_libssh2_error_to_CURLE(sftperr);\n        sshc->actualcode = result?result:CURLE_SSH;\n        break;\n      }\n      state(data, SSH_SFTP_DOWNLOAD_STAT);\n      break;\n\n    case SSH_SFTP_DOWNLOAD_STAT:\n    {\n      LIBSSH2_SFTP_ATTRIBUTES attrs;\n\n      rc = libssh2_sftp_stat_ex(sshc->sftp_session, sshp->path,\n                                curlx_uztoui(strlen(sshp->path)),\n                                LIBSSH2_SFTP_STAT, &attrs);\n      if(rc == LIBSSH2_ERROR_EAGAIN) {\n        break;\n      }\n      if(rc ||\n         !(attrs.flags & LIBSSH2_SFTP_ATTR_SIZE) ||\n         (attrs.filesize == 0)) {\n        /*\n         * libssh2_sftp_open() didn't return an error, so maybe the server\n         * just doesn't support stat()\n         * OR the server doesn't return a file size with a stat()\n         * OR file size is 0\n         */\n        data->req.size = -1;\n        data->req.maxdownload = -1;\n        Curl_pgrsSetDownloadSize(data, -1);\n      }\n      else {\n        curl_off_t size = attrs.filesize;\n\n        if(size < 0) {\n          failf(data, \"Bad file size (%\" CURL_FORMAT_CURL_OFF_T \")\", size);\n          return CURLE_BAD_DOWNLOAD_RESUME;\n        }\n        if(data->state.use_range) {\n          curl_off_t from, to;\n          char *ptr;\n          char *ptr2;\n          CURLofft to_t;\n          CURLofft from_t;\n\n          from_t = curlx_strtoofft(data->state.range, &ptr, 10, &from);\n          if(from_t == CURL_OFFT_FLOW)\n            return CURLE_RANGE_ERROR;\n          while(*ptr && (ISBLANK(*ptr) || (*ptr == '-')))\n            ptr++;\n          to_t = curlx_strtoofft(ptr, &ptr2, 10, &to);\n          if(to_t == CURL_OFFT_FLOW)\n            return CURLE_RANGE_ERROR;\n          if((to_t == CURL_OFFT_INVAL) /* no \"to\" value given */\n             || (to >= size)) {\n            to = size - 1;\n          }\n          if(from_t) {\n            /* from is relative to end of file */\n            from = size - to;\n            to = size - 1;\n          }\n          if(from > size) {\n            failf(data, \"Offset (%\"\n                  CURL_FORMAT_CURL_OFF_T \") was beyond file size (%\"\n                  CURL_FORMAT_CURL_OFF_T \")\", from,\n                  (curl_off_t)attrs.filesize);\n            return CURLE_BAD_DOWNLOAD_RESUME;\n          }\n          if(from > to) {\n            from = to;\n            size = 0;\n          }\n          else {\n            if((to - from) == CURL_OFF_T_MAX)\n              return CURLE_RANGE_ERROR;\n            size = to - from + 1;\n          }\n\n          SFTP_SEEK(sshc->sftp_handle, from);\n        }\n        data->req.size = size;\n        data->req.maxdownload = size;\n        Curl_pgrsSetDownloadSize(data, size);\n      }\n\n      /* We can resume if we can seek to the resume position */\n      if(data->state.resume_from) {\n        if(data->state.resume_from < 0) {\n          /* We're supposed to download the last abs(from) bytes */\n          if((curl_off_t)attrs.filesize < -data->state.resume_from) {\n            failf(data, \"Offset (%\"\n                  CURL_FORMAT_CURL_OFF_T \") was beyond file size (%\"\n                  CURL_FORMAT_CURL_OFF_T \")\",\n                  data->state.resume_from, (curl_off_t)attrs.filesize);\n            return CURLE_BAD_DOWNLOAD_RESUME;\n          }\n          /* download from where? */\n          data->state.resume_from += attrs.filesize;\n        }\n        else {\n          if((curl_off_t)attrs.filesize < data->state.resume_from) {\n            failf(data, \"Offset (%\" CURL_FORMAT_CURL_OFF_T\n                  \") was beyond file size (%\" CURL_FORMAT_CURL_OFF_T \")\",\n                  data->state.resume_from, (curl_off_t)attrs.filesize);\n            return CURLE_BAD_DOWNLOAD_RESUME;\n          }\n        }\n        /* Now store the number of bytes we are expected to download */\n        data->req.size = attrs.filesize - data->state.resume_from;\n        data->req.maxdownload = attrs.filesize - data->state.resume_from;\n        Curl_pgrsSetDownloadSize(data,\n                                 attrs.filesize - data->state.resume_from);\n        SFTP_SEEK(sshc->sftp_handle, data->state.resume_from);\n      }\n    }\n\n    /* Setup the actual download */\n    if(data->req.size == 0) {\n      /* no data to transfer */\n      Curl_xfer_setup(data, -1, -1, FALSE, -1);\n      infof(data, \"File already completely downloaded\");\n      state(data, SSH_STOP);\n      break;\n    }\n    Curl_xfer_setup(data, FIRSTSOCKET, data->req.size, FALSE, -1);\n\n    /* not set by Curl_xfer_setup to preserve keepon bits */\n    conn->writesockfd = conn->sockfd;\n\n    /* we want to use the _receiving_ function even when the socket turns\n       out writableable as the underlying libssh2 recv function will deal\n       with both accordingly */\n    data->state.select_bits = CURL_CSELECT_IN;\n\n    if(result) {\n      /* this should never occur; the close state should be entered\n         at the time the error occurs */\n      state(data, SSH_SFTP_CLOSE);\n      sshc->actualcode = result;\n    }\n    else {\n      state(data, SSH_STOP);\n    }\n    break;\n\n    case SSH_SFTP_CLOSE:\n      if(sshc->sftp_handle) {\n        rc = libssh2_sftp_close(sshc->sftp_handle);\n        if(rc == LIBSSH2_ERROR_EAGAIN) {\n          break;\n        }\n        if(rc < 0) {\n          char *err_msg = NULL;\n          (void)libssh2_session_last_error(sshc->ssh_session,\n                                           &err_msg, NULL, 0);\n          infof(data, \"Failed to close libssh2 file: %d %s\", rc, err_msg);\n        }\n        sshc->sftp_handle = NULL;\n      }\n\n      Curl_safefree(sshp->path);\n\n      DEBUGF(infof(data, \"SFTP DONE done\"));\n\n      /* Check if nextstate is set and move .nextstate could be POSTQUOTE_INIT\n         After nextstate is executed, the control should come back to\n         SSH_SFTP_CLOSE to pass the correct result back  */\n      if(sshc->nextstate != SSH_NO_STATE &&\n         sshc->nextstate != SSH_SFTP_CLOSE) {\n        state(data, sshc->nextstate);\n        sshc->nextstate = SSH_SFTP_CLOSE;\n      }\n      else {\n        state(data, SSH_STOP);\n        result = sshc->actualcode;\n      }\n      break;\n\n    case SSH_SFTP_SHUTDOWN:\n      /* during times we get here due to a broken transfer and then the\n         sftp_handle might not have been taken down so make sure that is done\n         before we proceed */\n\n      if(sshc->sftp_handle) {\n        rc = libssh2_sftp_close(sshc->sftp_handle);\n        if(rc == LIBSSH2_ERROR_EAGAIN) {\n          break;\n        }\n        if(rc < 0) {\n          char *err_msg = NULL;\n          (void)libssh2_session_last_error(sshc->ssh_session, &err_msg,\n                                           NULL, 0);\n          infof(data, \"Failed to close libssh2 file: %d %s\", rc, err_msg);\n        }\n        sshc->sftp_handle = NULL;\n      }\n      if(sshc->sftp_session) {\n        rc = libssh2_sftp_shutdown(sshc->sftp_session);\n        if(rc == LIBSSH2_ERROR_EAGAIN) {\n          break;\n        }\n        if(rc < 0) {\n          infof(data, \"Failed to stop libssh2 sftp subsystem\");\n        }\n        sshc->sftp_session = NULL;\n      }\n\n      Curl_safefree(sshc->homedir);\n      data->state.most_recent_ftp_entrypath = NULL;\n\n      state(data, SSH_SESSION_DISCONNECT);\n      break;\n\n    case SSH_SCP_TRANS_INIT:\n      result = Curl_getworkingpath(data, sshc->homedir, &sshp->path);\n      if(result) {\n        sshc->actualcode = result;\n        state(data, SSH_STOP);\n        break;\n      }\n\n      if(data->state.upload) {\n        if(data->state.infilesize < 0) {\n          failf(data, \"SCP requires a known file size for upload\");\n          sshc->actualcode = CURLE_UPLOAD_FAILED;\n          state(data, SSH_SCP_CHANNEL_FREE);\n          break;\n        }\n        state(data, SSH_SCP_UPLOAD_INIT);\n      }\n      else {\n        state(data, SSH_SCP_DOWNLOAD_INIT);\n      }\n      break;\n\n    case SSH_SCP_UPLOAD_INIT:\n      /*\n       * libssh2 requires that the destination path is a full path that\n       * includes the destination file and name OR ends in a \"/\" .  If this is\n       * not done the destination file will be named the same name as the last\n       * directory in the path.\n       */\n      sshc->ssh_channel =\n        SCP_SEND(sshc->ssh_session, sshp->path, data->set.new_file_perms,\n                 data->state.infilesize);\n      if(!sshc->ssh_channel) {\n        int ssh_err;\n        char *err_msg = NULL;\n\n        if(libssh2_session_last_errno(sshc->ssh_session) ==\n           LIBSSH2_ERROR_EAGAIN) {\n          rc = LIBSSH2_ERROR_EAGAIN;\n          break;\n        }\n\n        ssh_err = (int)(libssh2_session_last_error(sshc->ssh_session,\n                                                   &err_msg, NULL, 0));\n        failf(data, \"%s\", err_msg);\n        state(data, SSH_SCP_CHANNEL_FREE);\n        sshc->actualcode = libssh2_session_error_to_CURLE(ssh_err);\n        /* Map generic errors to upload failed */\n        if(sshc->actualcode == CURLE_SSH ||\n           sshc->actualcode == CURLE_REMOTE_FILE_NOT_FOUND)\n          sshc->actualcode = CURLE_UPLOAD_FAILED;\n        break;\n      }\n\n      /* upload data */\n      data->req.size = data->state.infilesize;\n      Curl_pgrsSetUploadSize(data, data->state.infilesize);\n      Curl_xfer_setup(data, -1, -1, FALSE, FIRSTSOCKET);\n\n      /* not set by Curl_xfer_setup to preserve keepon bits */\n      conn->sockfd = conn->writesockfd;\n\n      if(result) {\n        state(data, SSH_SCP_CHANNEL_FREE);\n        sshc->actualcode = result;\n      }\n      else {\n        /* store this original bitmask setup to use later on if we can't\n           figure out a \"real\" bitmask */\n        sshc->orig_waitfor = data->req.keepon;\n\n        /* we want to use the _sending_ function even when the socket turns\n           out readable as the underlying libssh2 scp send function will deal\n           with both accordingly */\n        data->state.select_bits = CURL_CSELECT_OUT;\n\n        state(data, SSH_STOP);\n      }\n      break;\n\n    case SSH_SCP_DOWNLOAD_INIT:\n    {\n      curl_off_t bytecount;\n\n      /*\n       * We must check the remote file; if it is a directory no values will\n       * be set in sb\n       */\n\n      /*\n       * If support for >2GB files exists, use it.\n       */\n\n      /* get a fresh new channel from the ssh layer */\n#if LIBSSH2_VERSION_NUM < 0x010700\n      struct stat sb;\n      memset(&sb, 0, sizeof(struct stat));\n      sshc->ssh_channel = libssh2_scp_recv(sshc->ssh_session,\n                                           sshp->path, &sb);\n#else\n      libssh2_struct_stat sb;\n      memset(&sb, 0, sizeof(libssh2_struct_stat));\n      sshc->ssh_channel = libssh2_scp_recv2(sshc->ssh_session,\n                                            sshp->path, &sb);\n#endif\n\n      if(!sshc->ssh_channel) {\n        int ssh_err;\n        char *err_msg = NULL;\n\n        if(libssh2_session_last_errno(sshc->ssh_session) ==\n           LIBSSH2_ERROR_EAGAIN) {\n          rc = LIBSSH2_ERROR_EAGAIN;\n          break;\n        }\n\n\n        ssh_err = (int)(libssh2_session_last_error(sshc->ssh_session,\n                                                   &err_msg, NULL, 0));\n        failf(data, \"%s\", err_msg);\n        state(data, SSH_SCP_CHANNEL_FREE);\n        sshc->actualcode = libssh2_session_error_to_CURLE(ssh_err);\n        break;\n      }\n\n      /* download data */\n      bytecount = (curl_off_t)sb.st_size;\n      data->req.maxdownload = (curl_off_t)sb.st_size;\n      Curl_xfer_setup(data, FIRSTSOCKET, bytecount, FALSE, -1);\n\n      /* not set by Curl_xfer_setup to preserve keepon bits */\n      conn->writesockfd = conn->sockfd;\n\n      /* we want to use the _receiving_ function even when the socket turns\n         out writableable as the underlying libssh2 recv function will deal\n         with both accordingly */\n      data->state.select_bits = CURL_CSELECT_IN;\n\n      if(result) {\n        state(data, SSH_SCP_CHANNEL_FREE);\n        sshc->actualcode = result;\n      }\n      else\n        state(data, SSH_STOP);\n    }\n    break;\n\n    case SSH_SCP_DONE:\n      if(data->state.upload)\n        state(data, SSH_SCP_SEND_EOF);\n      else\n        state(data, SSH_SCP_CHANNEL_FREE);\n      break;\n\n    case SSH_SCP_SEND_EOF:\n      if(sshc->ssh_channel) {\n        rc = libssh2_channel_send_eof(sshc->ssh_channel);\n        if(rc == LIBSSH2_ERROR_EAGAIN) {\n          break;\n        }\n        if(rc) {\n          char *err_msg = NULL;\n          (void)libssh2_session_last_error(sshc->ssh_session,\n                                           &err_msg, NULL, 0);\n          infof(data, \"Failed to send libssh2 channel EOF: %d %s\",\n                rc, err_msg);\n        }\n      }\n      state(data, SSH_SCP_WAIT_EOF);\n      break;\n\n    case SSH_SCP_WAIT_EOF:\n      if(sshc->ssh_channel) {\n        rc = libssh2_channel_wait_eof(sshc->ssh_channel);\n        if(rc == LIBSSH2_ERROR_EAGAIN) {\n          break;\n        }\n        if(rc) {\n          char *err_msg = NULL;\n          (void)libssh2_session_last_error(sshc->ssh_session,\n                                           &err_msg, NULL, 0);\n          infof(data, \"Failed to get channel EOF: %d %s\", rc, err_msg);\n        }\n      }\n      state(data, SSH_SCP_WAIT_CLOSE);\n      break;\n\n    case SSH_SCP_WAIT_CLOSE:\n      if(sshc->ssh_channel) {\n        rc = libssh2_channel_wait_closed(sshc->ssh_channel);\n        if(rc == LIBSSH2_ERROR_EAGAIN) {\n          break;\n        }\n        if(rc) {\n          char *err_msg = NULL;\n          (void)libssh2_session_last_error(sshc->ssh_session,\n                                           &err_msg, NULL, 0);\n          infof(data, \"Channel failed to close: %d %s\", rc, err_msg);\n        }\n      }\n      state(data, SSH_SCP_CHANNEL_FREE);\n      break;\n\n    case SSH_SCP_CHANNEL_FREE:\n      if(sshc->ssh_channel) {\n        rc = libssh2_channel_free(sshc->ssh_channel);\n        if(rc == LIBSSH2_ERROR_EAGAIN) {\n          break;\n        }\n        if(rc < 0) {\n          char *err_msg = NULL;\n          (void)libssh2_session_last_error(sshc->ssh_session,\n                                           &err_msg, NULL, 0);\n          infof(data, \"Failed to free libssh2 scp subsystem: %d %s\",\n                rc, err_msg);\n        }\n        sshc->ssh_channel = NULL;\n      }\n      DEBUGF(infof(data, \"SCP DONE phase complete\"));\n#if 0 /* PREV */\n      state(data, SSH_SESSION_DISCONNECT);\n#endif\n      state(data, SSH_STOP);\n      result = sshc->actualcode;\n      break;\n\n    case SSH_SESSION_DISCONNECT:\n      /* during weird times when we've been prematurely aborted, the channel\n         is still alive when we reach this state and we MUST kill the channel\n         properly first */\n      if(sshc->ssh_channel) {\n        rc = libssh2_channel_free(sshc->ssh_channel);\n        if(rc == LIBSSH2_ERROR_EAGAIN) {\n          break;\n        }\n        if(rc < 0) {\n          char *err_msg = NULL;\n          (void)libssh2_session_last_error(sshc->ssh_session,\n                                           &err_msg, NULL, 0);\n          infof(data, \"Failed to free libssh2 scp subsystem: %d %s\",\n                rc, err_msg);\n        }\n        sshc->ssh_channel = NULL;\n      }\n\n      if(sshc->ssh_session) {\n        rc = libssh2_session_disconnect(sshc->ssh_session, \"Shutdown\");\n        if(rc == LIBSSH2_ERROR_EAGAIN) {\n          break;\n        }\n        if(rc < 0) {\n          char *err_msg = NULL;\n          (void)libssh2_session_last_error(sshc->ssh_session,\n                                           &err_msg, NULL, 0);\n          infof(data, \"Failed to disconnect libssh2 session: %d %s\",\n                rc, err_msg);\n        }\n      }\n\n      Curl_safefree(sshc->homedir);\n      data->state.most_recent_ftp_entrypath = NULL;\n\n      state(data, SSH_SESSION_FREE);\n      break;\n\n    case SSH_SESSION_FREE:\n#ifdef HAVE_LIBSSH2_KNOWNHOST_API\n      if(sshc->kh) {\n        libssh2_knownhost_free(sshc->kh);\n        sshc->kh = NULL;\n      }\n#endif\n\n#ifdef HAVE_LIBSSH2_AGENT_API\n      if(sshc->ssh_agent) {\n        rc = libssh2_agent_disconnect(sshc->ssh_agent);\n        if(rc == LIBSSH2_ERROR_EAGAIN) {\n          break;\n        }\n        if(rc < 0) {\n          char *err_msg = NULL;\n          (void)libssh2_session_last_error(sshc->ssh_session,\n                                           &err_msg, NULL, 0);\n          infof(data, \"Failed to disconnect from libssh2 agent: %d %s\",\n                rc, err_msg);\n        }\n        libssh2_agent_free(sshc->ssh_agent);\n        sshc->ssh_agent = NULL;\n\n        /* NB: there is no need to free identities, they are part of internal\n           agent stuff */\n        sshc->sshagent_identity = NULL;\n        sshc->sshagent_prev_identity = NULL;\n      }\n#endif\n\n      if(sshc->ssh_session) {\n        rc = libssh2_session_free(sshc->ssh_session);\n        if(rc == LIBSSH2_ERROR_EAGAIN) {\n          break;\n        }\n        if(rc < 0) {\n          char *err_msg = NULL;\n          (void)libssh2_session_last_error(sshc->ssh_session,\n                                           &err_msg, NULL, 0);\n          infof(data, \"Failed to free libssh2 session: %d %s\", rc, err_msg);\n        }\n        sshc->ssh_session = NULL;\n      }\n\n      /* worst-case scenario cleanup */\n\n      DEBUGASSERT(sshc->ssh_session == NULL);\n      DEBUGASSERT(sshc->ssh_channel == NULL);\n      DEBUGASSERT(sshc->sftp_session == NULL);\n      DEBUGASSERT(sshc->sftp_handle == NULL);\n#ifdef HAVE_LIBSSH2_KNOWNHOST_API\n      DEBUGASSERT(sshc->kh == NULL);\n#endif\n#ifdef HAVE_LIBSSH2_AGENT_API\n      DEBUGASSERT(sshc->ssh_agent == NULL);\n#endif\n\n      Curl_safefree(sshc->rsa_pub);\n      Curl_safefree(sshc->rsa);\n      Curl_safefree(sshc->quote_path1);\n      Curl_safefree(sshc->quote_path2);\n      Curl_safefree(sshc->homedir);\n\n      /* the code we are about to return */\n      result = sshc->actualcode;\n\n      memset(sshc, 0, sizeof(struct ssh_conn));\n\n      connclose(conn, \"SSH session free\");\n      sshc->state = SSH_SESSION_FREE; /* current */\n      sshc->nextstate = SSH_NO_STATE;\n      state(data, SSH_STOP);\n      break;\n\n    case SSH_QUIT:\n    default:\n      /* internal error */\n      sshc->nextstate = SSH_NO_STATE;\n      state(data, SSH_STOP);\n      break;\n    }\n\n  } while(!rc && (sshc->state != SSH_STOP));\n\n  if(rc == LIBSSH2_ERROR_EAGAIN) {\n    /* we would block, we need to wait for the socket to be ready (in the\n       right direction too)! */\n    *block = TRUE;\n  }\n\n  return result;\n}\n\n/* called by the multi interface to figure out what socket(s) to wait for and\n   for what actions in the DO_DONE, PERFORM and WAITPERFORM states */\nstatic int ssh_getsock(struct Curl_easy *data,\n                       struct connectdata *conn,\n                       curl_socket_t *sock)\n{\n  int bitmap = GETSOCK_BLANK;\n  (void)data;\n\n  sock[0] = conn->sock[FIRSTSOCKET];\n\n  if(conn->waitfor & KEEP_RECV)\n    bitmap |= GETSOCK_READSOCK(FIRSTSOCKET);\n\n  if(conn->waitfor & KEEP_SEND)\n    bitmap |= GETSOCK_WRITESOCK(FIRSTSOCKET);\n\n  return bitmap;\n}\n\n/*\n * When one of the libssh2 functions has returned LIBSSH2_ERROR_EAGAIN this\n * function is used to figure out in what direction and stores this info so\n * that the multi interface can take advantage of it. Make sure to call this\n * function in all cases so that when it _doesn't_ return EAGAIN we can\n * restore the default wait bits.\n */\nstatic void ssh_block2waitfor(struct Curl_easy *data, bool block)\n{\n  struct connectdata *conn = data->conn;\n  struct ssh_conn *sshc = &conn->proto.sshc;\n  int dir = 0;\n  if(block) {\n    dir = libssh2_session_block_directions(sshc->ssh_session);\n    if(dir) {\n      /* translate the libssh2 define bits into our own bit defines */\n      conn->waitfor = ((dir&LIBSSH2_SESSION_BLOCK_INBOUND)?KEEP_RECV:0) |\n        ((dir&LIBSSH2_SESSION_BLOCK_OUTBOUND)?KEEP_SEND:0);\n    }\n  }\n  if(!dir)\n    /* It didn't block or libssh2 didn't reveal in which direction, put back\n       the original set */\n    conn->waitfor = sshc->orig_waitfor;\n}\n\n/* called repeatedly until done from multi.c */\nstatic CURLcode ssh_multi_statemach(struct Curl_easy *data, bool *done)\n{\n  struct connectdata *conn = data->conn;\n  struct ssh_conn *sshc = &conn->proto.sshc;\n  CURLcode result = CURLE_OK;\n  bool block; /* we store the status and use that to provide a ssh_getsock()\n                 implementation */\n  do {\n    result = ssh_statemach_act(data, &block);\n    *done = (sshc->state == SSH_STOP) ? TRUE : FALSE;\n    /* if there's no error, it isn't done and it didn't EWOULDBLOCK, then\n       try again */\n  } while(!result && !*done && !block);\n  ssh_block2waitfor(data, block);\n\n  return result;\n}\n\nstatic CURLcode ssh_block_statemach(struct Curl_easy *data,\n                                    struct connectdata *conn,\n                                    bool disconnect)\n{\n  struct ssh_conn *sshc = &conn->proto.sshc;\n  CURLcode result = CURLE_OK;\n  struct curltime dis = Curl_now();\n\n  while((sshc->state != SSH_STOP) && !result) {\n    bool block;\n    timediff_t left = 1000;\n    struct curltime now = Curl_now();\n\n    result = ssh_statemach_act(data, &block);\n    if(result)\n      break;\n\n    if(!disconnect) {\n      if(Curl_pgrsUpdate(data))\n        return CURLE_ABORTED_BY_CALLBACK;\n\n      result = Curl_speedcheck(data, now);\n      if(result)\n        break;\n\n      left = Curl_timeleft(data, NULL, FALSE);\n      if(left < 0) {\n        failf(data, \"Operation timed out\");\n        return CURLE_OPERATION_TIMEDOUT;\n      }\n    }\n    else if(Curl_timediff(now, dis) > 1000) {\n      /* disconnect timeout */\n      failf(data, \"Disconnect timed out\");\n      result = CURLE_OK;\n      break;\n    }\n\n    if(block) {\n      int dir = libssh2_session_block_directions(sshc->ssh_session);\n      curl_socket_t sock = conn->sock[FIRSTSOCKET];\n      curl_socket_t fd_read = CURL_SOCKET_BAD;\n      curl_socket_t fd_write = CURL_SOCKET_BAD;\n      if(LIBSSH2_SESSION_BLOCK_INBOUND & dir)\n        fd_read = sock;\n      if(LIBSSH2_SESSION_BLOCK_OUTBOUND & dir)\n        fd_write = sock;\n      /* wait for the socket to become ready */\n      (void)Curl_socket_check(fd_read, CURL_SOCKET_BAD, fd_write,\n                              left>1000?1000:left);\n    }\n  }\n\n  return result;\n}\n\n/*\n * SSH setup and connection\n */\nstatic CURLcode ssh_setup_connection(struct Curl_easy *data,\n                                     struct connectdata *conn)\n{\n  struct SSHPROTO *ssh;\n  (void)conn;\n\n  data->req.p.ssh = ssh = calloc(1, sizeof(struct SSHPROTO));\n  if(!ssh)\n    return CURLE_OUT_OF_MEMORY;\n\n  return CURLE_OK;\n}\n\nstatic Curl_recv scp_recv, sftp_recv;\nstatic Curl_send scp_send, sftp_send;\n\n#ifndef CURL_DISABLE_PROXY\nstatic ssize_t ssh_tls_recv(libssh2_socket_t sock, void *buffer,\n                            size_t length, int flags, void **abstract)\n{\n  struct Curl_easy *data = (struct Curl_easy *)*abstract;\n  ssize_t nread;\n  CURLcode result;\n  struct connectdata *conn = data->conn;\n  Curl_recv *backup = conn->recv[0];\n  struct ssh_conn *ssh = &conn->proto.sshc;\n  int socknum = Curl_conn_sockindex(data, sock);\n  (void)flags;\n\n  /* swap in the TLS reader function for this call only, and then swap back\n     the SSH one again */\n  conn->recv[0] = ssh->tls_recv;\n  result = Curl_conn_recv(data, socknum, buffer, length, &nread);\n  conn->recv[0] = backup;\n  if(result == CURLE_AGAIN)\n    return -EAGAIN; /* magic return code for libssh2 */\n  else if(result)\n    return -1; /* generic error */\n  Curl_debug(data, CURLINFO_DATA_IN, (char *)buffer, (size_t)nread);\n  return nread;\n}\n\nstatic ssize_t ssh_tls_send(libssh2_socket_t sock, const void *buffer,\n                            size_t length, int flags, void **abstract)\n{\n  struct Curl_easy *data = (struct Curl_easy *)*abstract;\n  size_t nwrite;\n  CURLcode result;\n  struct connectdata *conn = data->conn;\n  Curl_send *backup = conn->send[0];\n  struct ssh_conn *ssh = &conn->proto.sshc;\n  int socknum = Curl_conn_sockindex(data, sock);\n  (void)flags;\n\n  /* swap in the TLS writer function for this call only, and then swap back\n     the SSH one again */\n  conn->send[0] = ssh->tls_send;\n  result = Curl_conn_send(data, socknum, buffer, length, &nwrite);\n  conn->send[0] = backup;\n  if(result == CURLE_AGAIN)\n    return -EAGAIN; /* magic return code for libssh2 */\n  else if(result)\n    return -1; /* error */\n  Curl_debug(data, CURLINFO_DATA_OUT, (char *)buffer, nwrite);\n  return (ssize_t)nwrite;\n}\n#endif\n\n/*\n * Curl_ssh_connect() gets called from Curl_protocol_connect() to allow us to\n * do protocol-specific actions at connect-time.\n */\nstatic CURLcode ssh_connect(struct Curl_easy *data, bool *done)\n{\n#ifdef CURL_LIBSSH2_DEBUG\n  curl_socket_t sock;\n#endif\n  struct ssh_conn *sshc;\n  CURLcode result;\n  struct connectdata *conn = data->conn;\n\n  /* initialize per-handle data if not already */\n  if(!data->req.p.ssh) {\n    result = ssh_setup_connection(data, conn);\n    if(result)\n      return result;\n  }\n\n  /* We default to persistent connections. We set this already in this connect\n     function to make the reuse checks properly be able to check this bit. */\n  connkeep(conn, \"SSH default\");\n\n  sshc = &conn->proto.sshc;\n\n#ifdef CURL_LIBSSH2_DEBUG\n  if(conn->user) {\n    infof(data, \"User: %s\", conn->user);\n  }\n  if(conn->passwd) {\n    infof(data, \"Password: %s\", conn->passwd);\n  }\n  sock = conn->sock[FIRSTSOCKET];\n#endif /* CURL_LIBSSH2_DEBUG */\n\n  /* libcurl MUST to set custom memory functions so that the kbd_callback\n     function's memory allocations can be properly freed */\n  sshc->ssh_session = libssh2_session_init_ex(my_libssh2_malloc,\n                                              my_libssh2_free,\n                                              my_libssh2_realloc, data);\n\n  if(!sshc->ssh_session) {\n    failf(data, \"Failure initialising ssh session\");\n    return CURLE_FAILED_INIT;\n  }\n\n#ifdef HAVE_LIBSSH2_VERSION\n  /* Set the packet read timeout if the libssh2 version supports it */\n#if LIBSSH2_VERSION_NUM >= 0x010B00\n  if(data->set.server_response_timeout > 0) {\n    libssh2_session_set_read_timeout(sshc->ssh_session,\n                                     data->set.server_response_timeout / 1000);\n  }\n#endif\n#endif\n\n#ifndef CURL_DISABLE_PROXY\n  if(conn->http_proxy.proxytype == CURLPROXY_HTTPS) {\n    /*\n      Setup libssh2 callbacks to make it read/write TLS from the socket.\n\n      ssize_t\n      recvcb(libssh2_socket_t sock, void *buffer, size_t length,\n      int flags, void **abstract);\n\n      ssize_t\n      sendcb(libssh2_socket_t sock, const void *buffer, size_t length,\n      int flags, void **abstract);\n\n    */\n#if LIBSSH2_VERSION_NUM >= 0x010b01\n    infof(data, \"Uses HTTPS proxy\");\n    libssh2_session_callback_set2(sshc->ssh_session,\n                                  LIBSSH2_CALLBACK_RECV,\n                                  (libssh2_cb_generic *)ssh_tls_recv);\n    libssh2_session_callback_set2(sshc->ssh_session,\n                                  LIBSSH2_CALLBACK_SEND,\n                                  (libssh2_cb_generic *)ssh_tls_send);\n#else\n    /*\n     * This crazy union dance is here to avoid assigning a void pointer a\n     * function pointer as it is invalid C. The problem is of course that\n     * libssh2 has such an API...\n     */\n    union receive {\n      void *recvp;\n      ssize_t (*recvptr)(libssh2_socket_t, void *, size_t, int, void **);\n    };\n    union transfer {\n      void *sendp;\n      ssize_t (*sendptr)(libssh2_socket_t, const void *, size_t, int, void **);\n    };\n    union receive sshrecv;\n    union transfer sshsend;\n\n    sshrecv.recvptr = ssh_tls_recv;\n    sshsend.sendptr = ssh_tls_send;\n\n    infof(data, \"Uses HTTPS proxy\");\n    libssh2_session_callback_set(sshc->ssh_session,\n                                 LIBSSH2_CALLBACK_RECV, sshrecv.recvp);\n    libssh2_session_callback_set(sshc->ssh_session,\n                                 LIBSSH2_CALLBACK_SEND, sshsend.sendp);\n#endif\n\n    /* Store the underlying TLS recv/send function pointers to be used when\n       reading from the proxy */\n    sshc->tls_recv = conn->recv[FIRSTSOCKET];\n    sshc->tls_send = conn->send[FIRSTSOCKET];\n  }\n\n#endif /* CURL_DISABLE_PROXY */\n  if(conn->handler->protocol & CURLPROTO_SCP) {\n    conn->recv[FIRSTSOCKET] = scp_recv;\n    conn->send[FIRSTSOCKET] = scp_send;\n  }\n  else {\n    conn->recv[FIRSTSOCKET] = sftp_recv;\n    conn->send[FIRSTSOCKET] = sftp_send;\n  }\n\n  if(data->set.ssh_compression) {\n#if LIBSSH2_VERSION_NUM >= 0x010208\n    if(libssh2_session_flag(sshc->ssh_session, LIBSSH2_FLAG_COMPRESS, 1) < 0)\n#endif\n      infof(data, \"Failed to enable compression for ssh session\");\n  }\n\n#ifdef HAVE_LIBSSH2_KNOWNHOST_API\n  if(data->set.str[STRING_SSH_KNOWNHOSTS]) {\n    int rc;\n    sshc->kh = libssh2_knownhost_init(sshc->ssh_session);\n    if(!sshc->kh) {\n      libssh2_session_free(sshc->ssh_session);\n      sshc->ssh_session = NULL;\n      return CURLE_FAILED_INIT;\n    }\n\n    /* read all known hosts from there */\n    rc = libssh2_knownhost_readfile(sshc->kh,\n                                    data->set.str[STRING_SSH_KNOWNHOSTS],\n                                    LIBSSH2_KNOWNHOST_FILE_OPENSSH);\n    if(rc < 0)\n      infof(data, \"Failed to read known hosts from %s\",\n            data->set.str[STRING_SSH_KNOWNHOSTS]);\n  }\n#endif /* HAVE_LIBSSH2_KNOWNHOST_API */\n\n#ifdef CURL_LIBSSH2_DEBUG\n  libssh2_trace(sshc->ssh_session, ~0);\n  infof(data, \"SSH socket: %d\", (int)sock);\n#endif /* CURL_LIBSSH2_DEBUG */\n\n  state(data, SSH_INIT);\n\n  result = ssh_multi_statemach(data, done);\n\n  return result;\n}\n\n/*\n ***********************************************************************\n *\n * scp_perform()\n *\n * This is the actual DO function for SCP. Get a file according to\n * the options previously setup.\n */\n\nstatic\nCURLcode scp_perform(struct Curl_easy *data,\n                     bool *connected,\n                     bool *dophase_done)\n{\n  CURLcode result = CURLE_OK;\n\n  DEBUGF(infof(data, \"DO phase starts\"));\n\n  *dophase_done = FALSE; /* not done yet */\n\n  /* start the first command in the DO phase */\n  state(data, SSH_SCP_TRANS_INIT);\n\n  /* run the state-machine */\n  result = ssh_multi_statemach(data, dophase_done);\n\n  *connected = Curl_conn_is_connected(data->conn, FIRSTSOCKET);\n\n  if(*dophase_done) {\n    DEBUGF(infof(data, \"DO phase is complete\"));\n  }\n\n  return result;\n}\n\n/* called from multi.c while DOing */\nstatic CURLcode scp_doing(struct Curl_easy *data,\n                          bool *dophase_done)\n{\n  CURLcode result;\n  result = ssh_multi_statemach(data, dophase_done);\n\n  if(*dophase_done) {\n    DEBUGF(infof(data, \"DO phase is complete\"));\n  }\n  return result;\n}\n\n/*\n * The DO function is generic for both protocols. There was previously two\n * separate ones but this way means less duplicated code.\n */\n\nstatic CURLcode ssh_do(struct Curl_easy *data, bool *done)\n{\n  CURLcode result;\n  bool connected = 0;\n  struct connectdata *conn = data->conn;\n  struct ssh_conn *sshc = &conn->proto.sshc;\n\n  *done = FALSE; /* default to false */\n\n  data->req.size = -1; /* make sure this is unknown at this point */\n\n  sshc->actualcode = CURLE_OK; /* reset error code */\n  sshc->secondCreateDirs = 0;   /* reset the create dir attempt state\n                                   variable */\n\n  Curl_pgrsSetUploadCounter(data, 0);\n  Curl_pgrsSetDownloadCounter(data, 0);\n  Curl_pgrsSetUploadSize(data, -1);\n  Curl_pgrsSetDownloadSize(data, -1);\n\n  if(conn->handler->protocol & CURLPROTO_SCP)\n    result = scp_perform(data, &connected,  done);\n  else\n    result = sftp_perform(data, &connected,  done);\n\n  return result;\n}\n\n/* BLOCKING, but the function is using the state machine so the only reason\n   this is still blocking is that the multi interface code has no support for\n   disconnecting operations that takes a while */\nstatic CURLcode scp_disconnect(struct Curl_easy *data,\n                               struct connectdata *conn,\n                               bool dead_connection)\n{\n  CURLcode result = CURLE_OK;\n  struct ssh_conn *sshc = &conn->proto.sshc;\n  (void) dead_connection;\n\n  if(sshc->ssh_session) {\n    /* only if there's a session still around to use! */\n    state(data, SSH_SESSION_DISCONNECT);\n    result = ssh_block_statemach(data, conn, TRUE);\n  }\n\n  return result;\n}\n\n/* generic done function for both SCP and SFTP called from their specific\n   done functions */\nstatic CURLcode ssh_done(struct Curl_easy *data, CURLcode status)\n{\n  CURLcode result = CURLE_OK;\n  struct SSHPROTO *sshp = data->req.p.ssh;\n  struct connectdata *conn = data->conn;\n\n  if(!status)\n    /* run the state-machine */\n    result = ssh_block_statemach(data, conn, FALSE);\n  else\n    result = status;\n\n  Curl_safefree(sshp->path);\n  Curl_safefree(sshp->readdir_filename);\n  Curl_safefree(sshp->readdir_longentry);\n  Curl_dyn_free(&sshp->readdir);\n\n  if(Curl_pgrsDone(data))\n    return CURLE_ABORTED_BY_CALLBACK;\n\n  data->req.keepon = 0; /* clear all bits */\n  return result;\n}\n\n\nstatic CURLcode scp_done(struct Curl_easy *data, CURLcode status,\n                         bool premature)\n{\n  (void)premature; /* not used */\n\n  if(!status)\n    state(data, SSH_SCP_DONE);\n\n  return ssh_done(data, status);\n\n}\n\nstatic ssize_t scp_send(struct Curl_easy *data, int sockindex,\n                        const void *mem, size_t len, CURLcode *err)\n{\n  ssize_t nwrite;\n  struct connectdata *conn = data->conn;\n  struct ssh_conn *sshc = &conn->proto.sshc;\n  (void)sockindex; /* we only support SCP on the fixed known primary socket */\n\n  /* libssh2_channel_write() returns int! */\n  nwrite = (ssize_t) libssh2_channel_write(sshc->ssh_channel, mem, len);\n\n  ssh_block2waitfor(data, (nwrite == LIBSSH2_ERROR_EAGAIN)?TRUE:FALSE);\n\n  if(nwrite == LIBSSH2_ERROR_EAGAIN) {\n    *err = CURLE_AGAIN;\n    nwrite = 0;\n  }\n  else if(nwrite < LIBSSH2_ERROR_NONE) {\n    *err = libssh2_session_error_to_CURLE((int)nwrite);\n    nwrite = -1;\n  }\n\n  return nwrite;\n}\n\nstatic ssize_t scp_recv(struct Curl_easy *data, int sockindex,\n                        char *mem, size_t len, CURLcode *err)\n{\n  ssize_t nread;\n  struct connectdata *conn = data->conn;\n  struct ssh_conn *sshc = &conn->proto.sshc;\n  (void)sockindex; /* we only support SCP on the fixed known primary socket */\n\n  /* libssh2_channel_read() returns int */\n  nread = (ssize_t) libssh2_channel_read(sshc->ssh_channel, mem, len);\n\n  ssh_block2waitfor(data, (nread == LIBSSH2_ERROR_EAGAIN)?TRUE:FALSE);\n  if(nread == LIBSSH2_ERROR_EAGAIN) {\n    *err = CURLE_AGAIN;\n    nread = -1;\n  }\n\n  return nread;\n}\n\n/*\n * =============== SFTP ===============\n */\n\n/*\n ***********************************************************************\n *\n * sftp_perform()\n *\n * This is the actual DO function for SFTP. Get a file/directory according to\n * the options previously setup.\n */\n\nstatic\nCURLcode sftp_perform(struct Curl_easy *data,\n                      bool *connected,\n                      bool *dophase_done)\n{\n  CURLcode result = CURLE_OK;\n\n  DEBUGF(infof(data, \"DO phase starts\"));\n\n  *dophase_done = FALSE; /* not done yet */\n\n  /* start the first command in the DO phase */\n  state(data, SSH_SFTP_QUOTE_INIT);\n\n  /* run the state-machine */\n  result = ssh_multi_statemach(data, dophase_done);\n\n  *connected = Curl_conn_is_connected(data->conn, FIRSTSOCKET);\n\n  if(*dophase_done) {\n    DEBUGF(infof(data, \"DO phase is complete\"));\n  }\n\n  return result;\n}\n\n/* called from multi.c while DOing */\nstatic CURLcode sftp_doing(struct Curl_easy *data,\n                           bool *dophase_done)\n{\n  CURLcode result = ssh_multi_statemach(data, dophase_done);\n\n  if(*dophase_done) {\n    DEBUGF(infof(data, \"DO phase is complete\"));\n  }\n  return result;\n}\n\n/* BLOCKING, but the function is using the state machine so the only reason\n   this is still blocking is that the multi interface code has no support for\n   disconnecting operations that takes a while */\nstatic CURLcode sftp_disconnect(struct Curl_easy *data,\n                                struct connectdata *conn, bool dead_connection)\n{\n  CURLcode result = CURLE_OK;\n  struct ssh_conn *sshc = &conn->proto.sshc;\n  (void) dead_connection;\n\n  DEBUGF(infof(data, \"SSH DISCONNECT starts now\"));\n\n  if(sshc->ssh_session) {\n    /* only if there's a session still around to use! */\n    state(data, SSH_SFTP_SHUTDOWN);\n    result = ssh_block_statemach(data, conn, TRUE);\n  }\n\n  DEBUGF(infof(data, \"SSH DISCONNECT is done\"));\n\n  return result;\n\n}\n\nstatic CURLcode sftp_done(struct Curl_easy *data, CURLcode status,\n                               bool premature)\n{\n  struct connectdata *conn = data->conn;\n  struct ssh_conn *sshc = &conn->proto.sshc;\n\n  if(!status) {\n    /* Post quote commands are executed after the SFTP_CLOSE state to avoid\n       errors that could happen due to open file handles during POSTQUOTE\n       operation */\n    if(!premature && data->set.postquote && !conn->bits.retry)\n      sshc->nextstate = SSH_SFTP_POSTQUOTE_INIT;\n    state(data, SSH_SFTP_CLOSE);\n  }\n  return ssh_done(data, status);\n}\n\n/* return number of sent bytes */\nstatic ssize_t sftp_send(struct Curl_easy *data, int sockindex,\n                         const void *mem, size_t len, CURLcode *err)\n{\n  ssize_t nwrite;\n  struct connectdata *conn = data->conn;\n  struct ssh_conn *sshc = &conn->proto.sshc;\n  (void)sockindex;\n\n  nwrite = libssh2_sftp_write(sshc->sftp_handle, mem, len);\n\n  ssh_block2waitfor(data, (nwrite == LIBSSH2_ERROR_EAGAIN)?TRUE:FALSE);\n\n  if(nwrite == LIBSSH2_ERROR_EAGAIN) {\n    *err = CURLE_AGAIN;\n    nwrite = 0;\n  }\n  else if(nwrite < LIBSSH2_ERROR_NONE) {\n    *err = libssh2_session_error_to_CURLE((int)nwrite);\n    nwrite = -1;\n  }\n\n  return nwrite;\n}\n\n/*\n * Return number of received (decrypted) bytes\n * or <0 on error\n */\nstatic ssize_t sftp_recv(struct Curl_easy *data, int sockindex,\n                         char *mem, size_t len, CURLcode *err)\n{\n  ssize_t nread;\n  struct connectdata *conn = data->conn;\n  struct ssh_conn *sshc = &conn->proto.sshc;\n  (void)sockindex;\n\n  nread = libssh2_sftp_read(sshc->sftp_handle, mem, len);\n\n  ssh_block2waitfor(data, (nread == LIBSSH2_ERROR_EAGAIN)?TRUE:FALSE);\n\n  if(nread == LIBSSH2_ERROR_EAGAIN) {\n    *err = CURLE_AGAIN;\n    nread = -1;\n\n  }\n  else if(nread < 0) {\n    *err = libssh2_session_error_to_CURLE((int)nread);\n  }\n  return nread;\n}\n\nstatic const char *sftp_libssh2_strerror(unsigned long err)\n{\n  switch(err) {\n    case LIBSSH2_FX_NO_SUCH_FILE:\n      return \"No such file or directory\";\n\n    case LIBSSH2_FX_PERMISSION_DENIED:\n      return \"Permission denied\";\n\n    case LIBSSH2_FX_FAILURE:\n      return \"Operation failed\";\n\n    case LIBSSH2_FX_BAD_MESSAGE:\n      return \"Bad message from SFTP server\";\n\n    case LIBSSH2_FX_NO_CONNECTION:\n      return \"Not connected to SFTP server\";\n\n    case LIBSSH2_FX_CONNECTION_LOST:\n      return \"Connection to SFTP server lost\";\n\n    case LIBSSH2_FX_OP_UNSUPPORTED:\n      return \"Operation not supported by SFTP server\";\n\n    case LIBSSH2_FX_INVALID_HANDLE:\n      return \"Invalid handle\";\n\n    case LIBSSH2_FX_NO_SUCH_PATH:\n      return \"No such file or directory\";\n\n    case LIBSSH2_FX_FILE_ALREADY_EXISTS:\n      return \"File already exists\";\n\n    case LIBSSH2_FX_WRITE_PROTECT:\n      return \"File is write protected\";\n\n    case LIBSSH2_FX_NO_MEDIA:\n      return \"No media\";\n\n    case LIBSSH2_FX_NO_SPACE_ON_FILESYSTEM:\n      return \"Disk full\";\n\n    case LIBSSH2_FX_QUOTA_EXCEEDED:\n      return \"User quota exceeded\";\n\n    case LIBSSH2_FX_UNKNOWN_PRINCIPLE:\n      return \"Unknown principle\";\n\n    case LIBSSH2_FX_LOCK_CONFlICT:\n      return \"File lock conflict\";\n\n    case LIBSSH2_FX_DIR_NOT_EMPTY:\n      return \"Directory not empty\";\n\n    case LIBSSH2_FX_NOT_A_DIRECTORY:\n      return \"Not a directory\";\n\n    case LIBSSH2_FX_INVALID_FILENAME:\n      return \"Invalid filename\";\n\n    case LIBSSH2_FX_LINK_LOOP:\n      return \"Link points to itself\";\n  }\n  return \"Unknown error in libssh2\";\n}\n\nCURLcode Curl_ssh_init(void)\n{\n#ifdef HAVE_LIBSSH2_INIT\n  if(libssh2_init(0)) {\n    DEBUGF(fprintf(stderr, \"Error: libssh2_init failed\\n\"));\n    return CURLE_FAILED_INIT;\n  }\n#endif\n  return CURLE_OK;\n}\n\nvoid Curl_ssh_cleanup(void)\n{\n#ifdef HAVE_LIBSSH2_EXIT\n  (void)libssh2_exit();\n#endif\n}\n\nvoid Curl_ssh_version(char *buffer, size_t buflen)\n{\n  (void)msnprintf(buffer, buflen, \"libssh2/%s\", CURL_LIBSSH2_VERSION);\n}\n\n/* The SSH session is associated with the *CONNECTION* but the callback user\n * pointer is an easy handle pointer. This function allows us to reassign the\n * user pointer to the *CURRENT* (new) easy handle.\n */\nstatic void ssh_attach(struct Curl_easy *data, struct connectdata *conn)\n{\n  DEBUGASSERT(data);\n  DEBUGASSERT(conn);\n  if(conn->handler->protocol & PROTO_FAMILY_SSH) {\n    struct ssh_conn *sshc = &conn->proto.sshc;\n    if(sshc->ssh_session) {\n      /* only re-attach if the session already exists */\n      void **abstract = libssh2_session_abstract(sshc->ssh_session);\n      *abstract = data;\n    }\n  }\n}\n#endif /* USE_LIBSSH2 */\n` was unexpected","path":"/home/qqq/curl-8.7.0/lib/vssh/libssh2.c"},{"code":3,"level":"warn","type":["PartialParsing",[{"path":"/home/qqq/curl-8.7.0/docs/examples/evhiperfifo.c","start":{"line":78,"col":16,"offset":0},"end":{"line":78,"col":17,"offset":1}},{"path":"/home/qqq/curl-8.7.0/docs/examples/evhiperfifo.c","start":{"line":117,"col":28,"offset":0},"end":{"line":117,"col":43,"offset":15}},{"path":"/home/qqq/curl-8.7.0/docs/examples/evhiperfifo.c","start":{"line":202,"col":28,"offset":0},"end":{"line":202,"col":40,"offset":12}},{"path":"/home/qqq/curl-8.7.0/docs/examples/evhiperfifo.c","start":{"line":220,"col":28,"offset":0},"end":{"line":220,"col":43,"offset":15}},{"path":"/home/qqq/curl-8.7.0/docs/examples/evhiperfifo.c","start":{"line":372,"col":27,"offset":0},"end":{"line":372,"col":39,"offset":12}}]],"message":"Syntax error at line /home/qqq/curl-8.7.0/docs/examples/evhiperfifo.c:78:\n `x` was unexpected","path":"/home/qqq/curl-8.7.0/docs/examples/evhiperfifo.c","spans":[{"file":"/home/qqq/curl-8.7.0/docs/examples/evhiperfifo.c","start":{"line":78,"col":16,"offset":0},"end":{"line":78,"col":17,"offset":1}},{"file":"/home/qqq/curl-8.7.0/docs/examples/evhiperfifo.c","start":{"line":117,"col":28,"offset":0},"end":{"line":117,"col":43,"offset":15}},{"file":"/home/qqq/curl-8.7.0/docs/examples/evhiperfifo.c","start":{"line":202,"col":28,"offset":0},"end":{"line":202,"col":40,"offset":12}},{"file":"/home/qqq/curl-8.7.0/docs/examples/evhiperfifo.c","start":{"line":220,"col":28,"offset":0},"end":{"line":220,"col":43,"offset":15}},{"file":"/home/qqq/curl-8.7.0/docs/examples/evhiperfifo.c","start":{"line":372,"col":27,"offset":0},"end":{"line":372,"col":39,"offset":12}}]},{"code":3,"level":"warn","type":"Syntax error","message":"Syntax error at line /home/qqq/curl-8.7.0/lib/getinfo.c:1:\n `/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n * SPDX-License-Identifier: curl\n *\n ***************************************************************************/\n\n#include \"curl_setup.h\"\n\n#include <curl/curl.h>\n\n#include \"urldata.h\"\n#include \"getinfo.h\"\n\n#include \"vtls/vtls.h\"\n#include \"connect.h\" /* Curl_getconnectinfo() */\n#include \"progress.h\"\n\n/* The last #include files should be: */\n#include \"curl_memory.h\"\n#include \"memdebug.h\"\n\n/*\n * Initialize statistical and informational data.\n *\n * This function is called in curl_easy_reset, curl_easy_duphandle and at the\n * beginning of a perform session. It must reset the session-info variables,\n * in particular all variables in struct PureInfo.\n */\nCURLcode Curl_initinfo(struct Curl_easy *data)\n{\n  struct Progress *pro = &data->progress;\n  struct PureInfo *info = &data->info;\n\n  pro->t_nslookup = 0;\n  pro->t_connect = 0;\n  pro->t_appconnect = 0;\n  pro->t_pretransfer = 0;\n  pro->t_starttransfer = 0;\n  pro->timespent = 0;\n  pro->t_redirect = 0;\n  pro->is_t_startransfer_set = false;\n\n  info->httpcode = 0;\n  info->httpproxycode = 0;\n  info->httpversion = 0;\n  info->filetime = -1; /* -1 is an illegal time and thus means unknown */\n  info->timecond = FALSE;\n\n  info->header_size = 0;\n  info->request_size = 0;\n  info->proxyauthavail = 0;\n  info->httpauthavail = 0;\n  info->numconnects = 0;\n\n  free(info->contenttype);\n  info->contenttype = NULL;\n\n  free(info->wouldredirect);\n  info->wouldredirect = NULL;\n\n  info->primary.remote_ip[0] = '\\0';\n  info->primary.local_ip[0] = '\\0';\n  info->primary.remote_port = 0;\n  info->primary.local_port = 0;\n  info->retry_after = 0;\n\n  info->conn_scheme = 0;\n  info->conn_protocol = 0;\n\n#ifdef USE_SSL\n  Curl_ssl_free_certinfo(data);\n#endif\n  return CURLE_OK;\n}\n\nstatic CURLcode getinfo_char(struct Curl_easy *data, CURLINFO info,\n                             const char **param_charp)\n{\n  switch(info) {\n  case CURLINFO_EFFECTIVE_URL:\n    *param_charp = data->state.url?data->state.url:(char *)\"\";\n    break;\n  case CURLINFO_EFFECTIVE_METHOD: {\n    const char *m = data->set.str[STRING_CUSTOMREQUEST];\n    if(!m) {\n      if(data->set.opt_no_body)\n        m = \"HEAD\";\n#ifndef CURL_DISABLE_HTTP\n      else {\n        switch(data->state.httpreq) {\n        case HTTPREQ_POST:\n        case HTTPREQ_POST_FORM:\n        case HTTPREQ_POST_MIME:\n          m = \"POST\";\n          break;\n        case HTTPREQ_PUT:\n          m = \"PUT\";\n          break;\n        default: /* this should never happen */\n        case HTTPREQ_GET:\n          m = \"GET\";\n          break;\n        case HTTPREQ_HEAD:\n          m = \"HEAD\";\n          break;\n        }\n      }\n#endif\n    }\n    *param_charp = m;\n  }\n    break;\n  case CURLINFO_CONTENT_TYPE:\n    *param_charp = data->info.contenttype;\n    break;\n  case CURLINFO_PRIVATE:\n    *param_charp = (char *) data->set.private_data;\n    break;\n  case CURLINFO_FTP_ENTRY_PATH:\n    /* Return the entrypath string from the most recent connection.\n       This pointer was copied from the connectdata structure by FTP.\n       The actual string may be free()ed by subsequent libcurl calls so\n       it must be copied to a safer area before the next libcurl call.\n       Callers must never free it themselves. */\n    *param_charp = data->state.most_recent_ftp_entrypath;\n    break;\n  case CURLINFO_REDIRECT_URL:\n    /* Return the URL this request would have been redirected to if that\n       option had been enabled! */\n    *param_charp = data->info.wouldredirect;\n    break;\n  case CURLINFO_REFERER:\n    /* Return the referrer header for this request, or NULL if unset */\n    *param_charp = data->state.referer;\n    break;\n  case CURLINFO_PRIMARY_IP:\n    /* Return the ip address of the most recent (primary) connection */\n    *param_charp = data->info.primary.remote_ip;\n    break;\n  case CURLINFO_LOCAL_IP:\n    /* Return the source/local ip address of the most recent (primary)\n       connection */\n    *param_charp = data->info.primary.local_ip;\n    break;\n  case CURLINFO_RTSP_SESSION_ID:\n    *param_charp = data->set.str[STRING_RTSP_SESSION_ID];\n    break;\n  case CURLINFO_SCHEME:\n    *param_charp = data->info.conn_scheme;\n    break;\n  case CURLINFO_CAPATH:\n#ifdef CURL_CA_PATH\n    *param_charp = CURL_CA_PATH;\n#else\n    *param_charp = NULL;\n#endif\n    break;\n  case CURLINFO_CAINFO:\n#ifdef CURL_CA_BUNDLE\n    *param_charp = CURL_CA_BUNDLE;\n#else\n    *param_charp = NULL;\n#endif\n    break;\n  default:\n    return CURLE_UNKNOWN_OPTION;\n  }\n\n  return CURLE_OK;\n}\n\nstatic CURLcode getinfo_long(struct Curl_easy *data, CURLINFO info,\n                             long *param_longp)\n{\n  curl_socket_t sockfd;\n\n  union {\n    unsigned long *to_ulong;\n    long          *to_long;\n  } lptr;\n\n#ifdef DEBUGBUILD\n  char *timestr = getenv(\"CURL_TIME\");\n  if(timestr) {\n    unsigned long val = strtol(timestr, NULL, 10);\n    switch(info) {\n    case CURLINFO_LOCAL_PORT:\n      *param_longp = (long)val;\n      return CURLE_OK;\n    default:\n      break;\n    }\n  }\n  /* use another variable for this to allow different values */\n  timestr = getenv(\"CURL_DEBUG_SIZE\");\n  if(timestr) {\n    unsigned long val = strtol(timestr, NULL, 10);\n    switch(info) {\n    case CURLINFO_HEADER_SIZE:\n    case CURLINFO_REQUEST_SIZE:\n      *param_longp = (long)val;\n      return CURLE_OK;\n    default:\n      break;\n    }\n  }\n#endif\n\n  switch(info) {\n  case CURLINFO_RESPONSE_CODE:\n    *param_longp = data->info.httpcode;\n    break;\n  case CURLINFO_HTTP_CONNECTCODE:\n    *param_longp = data->info.httpproxycode;\n    break;\n  case CURLINFO_FILETIME:\n    if(data->info.filetime > LONG_MAX)\n      *param_longp = LONG_MAX;\n    else if(data->info.filetime < LONG_MIN)\n      *param_longp = LONG_MIN;\n    else\n      *param_longp = (long)data->info.filetime;\n    break;\n  case CURLINFO_HEADER_SIZE:\n    *param_longp = (long)data->info.header_size;\n    break;\n  case CURLINFO_REQUEST_SIZE:\n    *param_longp = (long)data->info.request_size;\n    break;\n  case CURLINFO_SSL_VERIFYRESULT:\n    *param_longp = data->set.ssl.certverifyresult;\n    break;\n#ifndef CURL_DISABLE_PROXY\n  case CURLINFO_PROXY_SSL_VERIFYRESULT:\n    *param_longp = data->set.proxy_ssl.certverifyresult;\n    break;\n#endif\n  case CURLINFO_REDIRECT_COUNT:\n    *param_longp = data->state.followlocation;\n    break;\n  case CURLINFO_HTTPAUTH_AVAIL:\n    lptr.to_long = param_longp;\n    *lptr.to_ulong = data->info.httpauthavail;\n    break;\n  case CURLINFO_PROXYAUTH_AVAIL:\n    lptr.to_long = param_longp;\n    *lptr.to_ulong = data->info.proxyauthavail;\n    break;\n  case CURLINFO_OS_ERRNO:\n    *param_longp = data->state.os_errno;\n    break;\n  case CURLINFO_NUM_CONNECTS:\n    *param_longp = data->info.numconnects;\n    break;\n  case CURLINFO_LASTSOCKET:\n    sockfd = Curl_getconnectinfo(data, NULL);\n\n    /* note: this is not a good conversion for systems with 64 bit sockets and\n       32 bit longs */\n    if(sockfd != CURL_SOCKET_BAD)\n      *param_longp = (long)sockfd;\n    else\n      /* this interface is documented to return -1 in case of badness, which\n         may not be the same as the CURL_SOCKET_BAD value */\n      *param_longp = -1;\n    break;\n  case CURLINFO_PRIMARY_PORT:\n    /* Return the (remote) port of the most recent (primary) connection */\n    *param_longp = data->info.primary.remote_port;\n    break;\n  case CURLINFO_LOCAL_PORT:\n    /* Return the local port of the most recent (primary) connection */\n    *param_longp = data->info.primary.local_port;\n    break;\n  case CURLINFO_PROXY_ERROR:\n    *param_longp = (long)data->info.pxcode;\n    break;\n  case CURLINFO_CONDITION_UNMET:\n    if(data->info.httpcode == 304)\n      *param_longp = 1L;\n    else\n      /* return if the condition prevented the document to get transferred */\n      *param_longp = data->info.timecond ? 1L : 0L;\n    break;\n#ifndef CURL_DISABLE_RTSP\n  case CURLINFO_RTSP_CLIENT_CSEQ:\n    *param_longp = data->state.rtsp_next_client_CSeq;\n    break;\n  case CURLINFO_RTSP_SERVER_CSEQ:\n    *param_longp = data->state.rtsp_next_server_CSeq;\n    break;\n  case CURLINFO_RTSP_CSEQ_RECV:\n    *param_longp = data->state.rtsp_CSeq_recv;\n    break;\n#endif\n  case CURLINFO_HTTP_VERSION:\n    switch(data->info.httpversion) {\n    case 10:\n      *param_longp = CURL_HTTP_VERSION_1_0;\n      break;\n    case 11:\n      *param_longp = CURL_HTTP_VERSION_1_1;\n      break;\n    case 20:\n      *param_longp = CURL_HTTP_VERSION_2_0;\n      break;\n    case 30:\n      *param_longp = CURL_HTTP_VERSION_3;\n      break;\n    default:\n      *param_longp = CURL_HTTP_VERSION_NONE;\n      break;\n    }\n    break;\n  case CURLINFO_PROTOCOL:\n    *param_longp = data->info.conn_protocol;\n    break;\n  case CURLINFO_USED_PROXY:\n    *param_longp =\n#ifdef CURL_DISABLE_PROXY\n      0\n#else\n      data->info.used_proxy\n#endif\n      ;\n    break;\n  default:\n    return CURLE_UNKNOWN_OPTION;\n  }\n\n  return CURLE_OK;\n}\n\n#define DOUBLE_SECS(x) (double)(x)/1000000\n\nstatic CURLcode getinfo_offt(struct Curl_easy *data, CURLINFO info,\n                             curl_off_t *param_offt)\n{\n#ifdef DEBUGBUILD\n  char *timestr = getenv(\"CURL_TIME\");\n  if(timestr) {\n    unsigned long val = strtol(timestr, NULL, 10);\n    switch(info) {\n    case CURLINFO_TOTAL_TIME_T:\n    case CURLINFO_NAMELOOKUP_TIME_T:\n    case CURLINFO_CONNECT_TIME_T:\n    case CURLINFO_APPCONNECT_TIME_T:\n    case CURLINFO_PRETRANSFER_TIME_T:\n    case CURLINFO_STARTTRANSFER_TIME_T:\n    case CURLINFO_REDIRECT_TIME_T:\n    case CURLINFO_SPEED_DOWNLOAD_T:\n    case CURLINFO_SPEED_UPLOAD_T:\n      *param_offt = (curl_off_t)val;\n      return CURLE_OK;\n    default:\n      break;\n    }\n  }\n#endif\n  switch(info) {\n  case CURLINFO_FILETIME_T:\n    *param_offt = (curl_off_t)data->info.filetime;\n    break;\n  case CURLINFO_SIZE_UPLOAD_T:\n    *param_offt = data->progress.uploaded;\n    break;\n  case CURLINFO_SIZE_DOWNLOAD_T:\n    *param_offt = data->progress.downloaded;\n    break;\n  case CURLINFO_SPEED_DOWNLOAD_T:\n    *param_offt = data->progress.dlspeed;\n    break;\n  case CURLINFO_SPEED_UPLOAD_T:\n    *param_offt = data->progress.ulspeed;\n    break;\n  case CURLINFO_CONTENT_LENGTH_DOWNLOAD_T:\n    *param_offt = (data->progress.flags & PGRS_DL_SIZE_KNOWN)?\n      data->progress.size_dl:-1;\n    break;\n  case CURLINFO_CONTENT_LENGTH_UPLOAD_T:\n    *param_offt = (data->progress.flags & PGRS_UL_SIZE_KNOWN)?\n      data->progress.size_ul:-1;\n    break;\n   case CURLINFO_TOTAL_TIME_T:\n    *param_offt = data->progress.timespent;\n    break;\n  case CURLINFO_NAMELOOKUP_TIME_T:\n    *param_offt = data->progress.t_nslookup;\n    break;\n  case CURLINFO_CONNECT_TIME_T:\n    *param_offt = data->progress.t_connect;\n    break;\n  case CURLINFO_APPCONNECT_TIME_T:\n    *param_offt = data->progress.t_appconnect;\n    break;\n  case CURLINFO_PRETRANSFER_TIME_T:\n    *param_offt = data->progress.t_pretransfer;\n    break;\n  case CURLINFO_STARTTRANSFER_TIME_T:\n    *param_offt = data->progress.t_starttransfer;\n    break;\n  case CURLINFO_QUEUE_TIME_T:\n    *param_offt = data->progress.t_postqueue;\n    break;\n  case CURLINFO_REDIRECT_TIME_T:\n    *param_offt = data->progress.t_redirect;\n    break;\n  case CURLINFO_RETRY_AFTER:\n    *param_offt = data->info.retry_after;\n    break;\n  case CURLINFO_XFER_ID:\n    *param_offt = data->id;\n    break;\n  case CURLINFO_CONN_ID:\n    *param_offt = data->conn?\n      data->conn->connection_id : data->state.recent_conn_id;\n    break;\n  default:\n    return CURLE_UNKNOWN_OPTION;\n  }\n\n  return CURLE_OK;\n}\n\nstatic CURLcode getinfo_double(struct Curl_easy *data, CURLINFO info,\n                               double *param_doublep)\n{\n#ifdef DEBUGBUILD\n  char *timestr = getenv(\"CURL_TIME\");\n  if(timestr) {\n    unsigned long val = strtol(timestr, NULL, 10);\n    switch(info) {\n    case CURLINFO_TOTAL_TIME:\n    case CURLINFO_NAMELOOKUP_TIME:\n    case CURLINFO_CONNECT_TIME:\n    case CURLINFO_APPCONNECT_TIME:\n    case CURLINFO_PRETRANSFER_TIME:\n    case CURLINFO_STARTTRANSFER_TIME:\n    case CURLINFO_REDIRECT_TIME:\n    case CURLINFO_SPEED_DOWNLOAD:\n    case CURLINFO_SPEED_UPLOAD:\n      *param_doublep = (double)val;\n      return CURLE_OK;\n    default:\n      break;\n    }\n  }\n#endif\n  switch(info) {\n  case CURLINFO_TOTAL_TIME:\n    *param_doublep = DOUBLE_SECS(data->progress.timespent);\n    break;\n  case CURLINFO_NAMELOOKUP_TIME:\n    *param_doublep = DOUBLE_SECS(data->progress.t_nslookup);\n    break;\n  case CURLINFO_CONNECT_TIME:\n    *param_doublep = DOUBLE_SECS(data->progress.t_connect);\n    break;\n  case CURLINFO_APPCONNECT_TIME:\n    *param_doublep = DOUBLE_SECS(data->progress.t_appconnect);\n    break;\n  case CURLINFO_PRETRANSFER_TIME:\n    *param_doublep = DOUBLE_SECS(data->progress.t_pretransfer);\n    break;\n  case CURLINFO_STARTTRANSFER_TIME:\n    *param_doublep = DOUBLE_SECS(data->progress.t_starttransfer);\n    break;\n  case CURLINFO_SIZE_UPLOAD:\n    *param_doublep = (double)data->progress.uploaded;\n    break;\n  case CURLINFO_SIZE_DOWNLOAD:\n    *param_doublep = (double)data->progress.downloaded;\n    break;\n  case CURLINFO_SPEED_DOWNLOAD:\n    *param_doublep = (double)data->progress.dlspeed;\n    break;\n  case CURLINFO_SPEED_UPLOAD:\n    *param_doublep = (double)data->progress.ulspeed;\n    break;\n  case CURLINFO_CONTENT_LENGTH_DOWNLOAD:\n    *param_doublep = (data->progress.flags & PGRS_DL_SIZE_KNOWN)?\n      (double)data->progress.size_dl:-1;\n    break;\n  case CURLINFO_CONTENT_LENGTH_UPLOAD:\n    *param_doublep = (data->progress.flags & PGRS_UL_SIZE_KNOWN)?\n      (double)data->progress.size_ul:-1;\n    break;\n  case CURLINFO_REDIRECT_TIME:\n    *param_doublep = DOUBLE_SECS(data->progress.t_redirect);\n    break;\n\n  default:\n    return CURLE_UNKNOWN_OPTION;\n  }\n\n  return CURLE_OK;\n}\n\nstatic CURLcode getinfo_slist(struct Curl_easy *data, CURLINFO info,\n                              struct curl_slist **param_slistp)\n{\n  union {\n    struct curl_certinfo *to_certinfo;\n    struct curl_slist    *to_slist;\n  } ptr;\n\n  switch(info) {\n  case CURLINFO_SSL_ENGINES:\n    *param_slistp = Curl_ssl_engines_list(data);\n    break;\n  case CURLINFO_COOKIELIST:\n    *param_slistp = Curl_cookie_list(data);\n    break;\n  case CURLINFO_CERTINFO:\n    /* Return the a pointer to the certinfo struct. Not really an slist\n       pointer but we can pretend it is here */\n    ptr.to_certinfo = &data->info.certs;\n    *param_slistp = ptr.to_slist;\n    break;\n  case CURLINFO_TLS_SESSION:\n  case CURLINFO_TLS_SSL_PTR:\n    {\n      struct curl_tlssessioninfo **tsip = (struct curl_tlssessioninfo **)\n                                          param_slistp;\n      struct curl_tlssessioninfo *tsi = &data->tsi;\n#ifdef USE_SSL\n      struct connectdata *conn = data->conn;\n#endif\n\n      *tsip = tsi;\n      tsi->backend = Curl_ssl_backend();\n      tsi->internals = NULL;\n\n#ifdef USE_SSL\n      if(conn && tsi->backend != CURLSSLBACKEND_NONE) {\n        tsi->internals = Curl_ssl_get_internals(data, FIRSTSOCKET, info, 0);\n      }\n#endif\n    }\n    break;\n  default:\n    return CURLE_UNKNOWN_OPTION;\n  }\n\n  return CURLE_OK;\n}\n\nstatic CURLcode getinfo_socket(struct Curl_easy *data, CURLINFO info,\n                               curl_socket_t *param_socketp)\n{\n  switch(info) {\n  case CURLINFO_ACTIVESOCKET:\n    *param_socketp = Curl_getconnectinfo(data, NULL);\n    break;\n  default:\n    return CURLE_UNKNOWN_OPTION;\n  }\n\n  return CURLE_OK;\n}\n\nCURLcode Curl_getinfo(struct Curl_easy *data, CURLINFO info, ...)\n{\n  va_list arg;\n  long *param_longp = NULL;\n  double *param_doublep = NULL;\n  curl_off_t *param_offt = NULL;\n  const char **param_charp = NULL;\n  struct curl_slist **param_slistp = NULL;\n  curl_socket_t *param_socketp = NULL;\n  int type;\n  CURLcode result = CURLE_UNKNOWN_OPTION;\n\n  if(!data)\n    return CURLE_BAD_FUNCTION_ARGUMENT;\n\n  va_start(arg, info);\n\n  type = CURLINFO_TYPEMASK & (int)info;\n  switch(type) {\n  case CURLINFO_STRING:\n    param_charp = va_arg(arg, const char **);\n    if(param_charp)\n      result = getinfo_char(data, info, param_charp);\n    break;\n  case CURLINFO_LONG:\n    param_longp = va_arg(arg, long *);\n    if(param_longp)\n      result = getinfo_long(data, info, param_longp);\n    break;\n  case CURLINFO_DOUBLE:\n    param_doublep = va_arg(arg, double *);\n    if(param_doublep)\n      result = getinfo_double(data, info, param_doublep);\n    break;\n  case CURLINFO_OFF_T:\n    param_offt = va_arg(arg, curl_off_t *);\n    if(param_offt)\n      result = getinfo_offt(data, info, param_offt);\n    break;\n  case CURLINFO_SLIST:\n    param_slistp = va_arg(arg, struct curl_slist **);\n    if(param_slistp)\n      result = getinfo_slist(data, info, param_slistp);\n    break;\n  case CURLINFO_SOCKET:\n    param_socketp = va_arg(arg, curl_socket_t *);\n    if(param_socketp)\n      result = getinfo_socket(data, info, param_socketp);\n    break;\n  default:\n    break;\n  }\n\n  va_end(arg);\n\n  return result;\n}\n` was unexpected","path":"/home/qqq/curl-8.7.0/lib/getinfo.c"},{"code":3,"level":"warn","type":"Syntax error","message":"Syntax error at line /home/qqq/curl-8.7.0/lib/strerror.c:1:\n `/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n * SPDX-License-Identifier: curl\n *\n ***************************************************************************/\n\n#include \"curl_setup.h\"\n\n#ifdef HAVE_STRERROR_R\n#  if (!defined(HAVE_POSIX_STRERROR_R) && \\\n       !defined(HAVE_GLIBC_STRERROR_R)) || \\\n      (defined(HAVE_POSIX_STRERROR_R) && defined(HAVE_GLIBC_STRERROR_R))\n#    error \"strerror_r MUST be either POSIX, glibc style\"\n#  endif\n#endif\n\n#include <curl/curl.h>\n\n#ifdef USE_LIBIDN2\n#include <idn2.h>\n#endif\n\n#ifdef USE_WINDOWS_SSPI\n#include \"curl_sspi.h\"\n#endif\n\n#include \"strerror.h\"\n/* The last 3 #include files should be in this order */\n#include \"curl_printf.h\"\n#include \"curl_memory.h\"\n#include \"memdebug.h\"\n\n#if defined(_WIN32) || defined(_WIN32_WCE)\n#define PRESERVE_WINDOWS_ERROR_CODE\n#endif\n\nconst char *\ncurl_easy_strerror(CURLcode error)\n{\n#ifndef CURL_DISABLE_VERBOSE_STRINGS\n  switch(error) {\n  case CURLE_OK:\n    return \"No error\";\n\n  case CURLE_UNSUPPORTED_PROTOCOL:\n    return \"Unsupported protocol\";\n\n  case CURLE_FAILED_INIT:\n    return \"Failed initialization\";\n\n  case CURLE_URL_MALFORMAT:\n    return \"URL using bad/illegal format or missing URL\";\n\n  case CURLE_NOT_BUILT_IN:\n    return \"A requested feature, protocol or option was not found built-in in\"\n      \" this libcurl due to a build-time decision.\";\n\n  case CURLE_COULDNT_RESOLVE_PROXY:\n    return \"Couldn't resolve proxy name\";\n\n  case CURLE_COULDNT_RESOLVE_HOST:\n    return \"Couldn't resolve host name\";\n\n  case CURLE_COULDNT_CONNECT:\n    return \"Couldn't connect to server\";\n\n  case CURLE_WEIRD_SERVER_REPLY:\n    return \"Weird server reply\";\n\n  case CURLE_REMOTE_ACCESS_DENIED:\n    return \"Access denied to remote resource\";\n\n  case CURLE_FTP_ACCEPT_FAILED:\n    return \"FTP: The server failed to connect to data port\";\n\n  case CURLE_FTP_ACCEPT_TIMEOUT:\n    return \"FTP: Accepting server connect has timed out\";\n\n  case CURLE_FTP_PRET_FAILED:\n    return \"FTP: The server did not accept the PRET command.\";\n\n  case CURLE_FTP_WEIRD_PASS_REPLY:\n    return \"FTP: unknown PASS reply\";\n\n  case CURLE_FTP_WEIRD_PASV_REPLY:\n    return \"FTP: unknown PASV reply\";\n\n  case CURLE_FTP_WEIRD_227_FORMAT:\n    return \"FTP: unknown 227 response format\";\n\n  case CURLE_FTP_CANT_GET_HOST:\n    return \"FTP: can't figure out the host in the PASV response\";\n\n  case CURLE_HTTP2:\n    return \"Error in the HTTP2 framing layer\";\n\n  case CURLE_FTP_COULDNT_SET_TYPE:\n    return \"FTP: couldn't set file type\";\n\n  case CURLE_PARTIAL_FILE:\n    return \"Transferred a partial file\";\n\n  case CURLE_FTP_COULDNT_RETR_FILE:\n    return \"FTP: couldn't retrieve (RETR failed) the specified file\";\n\n  case CURLE_QUOTE_ERROR:\n    return \"Quote command returned error\";\n\n  case CURLE_HTTP_RETURNED_ERROR:\n    return \"HTTP response code said error\";\n\n  case CURLE_WRITE_ERROR:\n    return \"Failed writing received data to disk/application\";\n\n  case CURLE_UPLOAD_FAILED:\n    return \"Upload failed (at start/before it took off)\";\n\n  case CURLE_READ_ERROR:\n    return \"Failed to open/read local data from file/application\";\n\n  case CURLE_OUT_OF_MEMORY:\n    return \"Out of memory\";\n\n  case CURLE_OPERATION_TIMEDOUT:\n    return \"Timeout was reached\";\n\n  case CURLE_FTP_PORT_FAILED:\n    return \"FTP: command PORT failed\";\n\n  case CURLE_FTP_COULDNT_USE_REST:\n    return \"FTP: command REST failed\";\n\n  case CURLE_RANGE_ERROR:\n    return \"Requested range was not delivered by the server\";\n\n  case CURLE_HTTP_POST_ERROR:\n    return \"Internal problem setting up the POST\";\n\n  case CURLE_SSL_CONNECT_ERROR:\n    return \"SSL connect error\";\n\n  case CURLE_BAD_DOWNLOAD_RESUME:\n    return \"Couldn't resume download\";\n\n  case CURLE_FILE_COULDNT_READ_FILE:\n    return \"Couldn't read a file:// file\";\n\n  case CURLE_LDAP_CANNOT_BIND:\n    return \"LDAP: cannot bind\";\n\n  case CURLE_LDAP_SEARCH_FAILED:\n    return \"LDAP: search failed\";\n\n  case CURLE_FUNCTION_NOT_FOUND:\n    return \"A required function in the library was not found\";\n\n  case CURLE_ABORTED_BY_CALLBACK:\n    return \"Operation was aborted by an application callback\";\n\n  case CURLE_BAD_FUNCTION_ARGUMENT:\n    return \"A libcurl function was given a bad argument\";\n\n  case CURLE_INTERFACE_FAILED:\n    return \"Failed binding local connection end\";\n\n  case CURLE_TOO_MANY_REDIRECTS:\n    return \"Number of redirects hit maximum amount\";\n\n  case CURLE_UNKNOWN_OPTION:\n    return \"An unknown option was passed in to libcurl\";\n\n  case CURLE_SETOPT_OPTION_SYNTAX:\n    return \"Malformed option provided in a setopt\";\n\n  case CURLE_GOT_NOTHING:\n    return \"Server returned nothing (no headers, no data)\";\n\n  case CURLE_SSL_ENGINE_NOTFOUND:\n    return \"SSL crypto engine not found\";\n\n  case CURLE_SSL_ENGINE_SETFAILED:\n    return \"Can not set SSL crypto engine as default\";\n\n  case CURLE_SSL_ENGINE_INITFAILED:\n    return \"Failed to initialise SSL crypto engine\";\n\n  case CURLE_SEND_ERROR:\n    return \"Failed sending data to the peer\";\n\n  case CURLE_RECV_ERROR:\n    return \"Failure when receiving data from the peer\";\n\n  case CURLE_SSL_CERTPROBLEM:\n    return \"Problem with the local SSL certificate\";\n\n  case CURLE_SSL_CIPHER:\n    return \"Couldn't use specified SSL cipher\";\n\n  case CURLE_PEER_FAILED_VERIFICATION:\n    return \"SSL peer certificate or SSH remote key was not OK\";\n\n  case CURLE_SSL_CACERT_BADFILE:\n    return \"Problem with the SSL CA cert (path? access rights?)\";\n\n  case CURLE_BAD_CONTENT_ENCODING:\n    return \"Unrecognized or bad HTTP Content or Transfer-Encoding\";\n\n  case CURLE_FILESIZE_EXCEEDED:\n    return \"Maximum file size exceeded\";\n\n  case CURLE_USE_SSL_FAILED:\n    return \"Requested SSL level failed\";\n\n  case CURLE_SSL_SHUTDOWN_FAILED:\n    return \"Failed to shut down the SSL connection\";\n\n  case CURLE_SSL_CRL_BADFILE:\n    return \"Failed to load CRL file (path? access rights?, format?)\";\n\n  case CURLE_SSL_ISSUER_ERROR:\n    return \"Issuer check against peer certificate failed\";\n\n  case CURLE_SEND_FAIL_REWIND:\n    return \"Send failed since rewinding of the data stream failed\";\n\n  case CURLE_LOGIN_DENIED:\n    return \"Login denied\";\n\n  case CURLE_TFTP_NOTFOUND:\n    return \"TFTP: File Not Found\";\n\n  case CURLE_TFTP_PERM:\n    return \"TFTP: Access Violation\";\n\n  case CURLE_REMOTE_DISK_FULL:\n    return \"Disk full or allocation exceeded\";\n\n  case CURLE_TFTP_ILLEGAL:\n    return \"TFTP: Illegal operation\";\n\n  case CURLE_TFTP_UNKNOWNID:\n    return \"TFTP: Unknown transfer ID\";\n\n  case CURLE_REMOTE_FILE_EXISTS:\n    return \"Remote file already exists\";\n\n  case CURLE_TFTP_NOSUCHUSER:\n    return \"TFTP: No such user\";\n\n  case CURLE_REMOTE_FILE_NOT_FOUND:\n    return \"Remote file not found\";\n\n  case CURLE_SSH:\n    return \"Error in the SSH layer\";\n\n  case CURLE_AGAIN:\n    return \"Socket not ready for send/recv\";\n\n  case CURLE_RTSP_CSEQ_ERROR:\n    return \"RTSP CSeq mismatch or invalid CSeq\";\n\n  case CURLE_RTSP_SESSION_ERROR:\n    return \"RTSP session error\";\n\n  case CURLE_FTP_BAD_FILE_LIST:\n    return \"Unable to parse FTP file list\";\n\n  case CURLE_CHUNK_FAILED:\n    return \"Chunk callback failed\";\n\n  case CURLE_NO_CONNECTION_AVAILABLE:\n    return \"The max connection limit is reached\";\n\n  case CURLE_SSL_PINNEDPUBKEYNOTMATCH:\n    return \"SSL public key does not match pinned public key\";\n\n  case CURLE_SSL_INVALIDCERTSTATUS:\n    return \"SSL server certificate status verification FAILED\";\n\n  case CURLE_HTTP2_STREAM:\n    return \"Stream error in the HTTP/2 framing layer\";\n\n  case CURLE_RECURSIVE_API_CALL:\n    return \"API function called from within callback\";\n\n  case CURLE_AUTH_ERROR:\n    return \"An authentication function returned an error\";\n\n  case CURLE_HTTP3:\n    return \"HTTP/3 error\";\n\n  case CURLE_QUIC_CONNECT_ERROR:\n    return \"QUIC connection error\";\n\n  case CURLE_PROXY:\n    return \"proxy handshake error\";\n\n  case CURLE_SSL_CLIENTCERT:\n    return \"SSL Client Certificate required\";\n\n  case CURLE_UNRECOVERABLE_POLL:\n    return \"Unrecoverable error in select/poll\";\n\n  case CURLE_TOO_LARGE:\n    return \"A value or data field grew larger than allowed\";\n\n    /* error codes not used by current libcurl */\n  case CURLE_OBSOLETE20:\n  case CURLE_OBSOLETE24:\n  case CURLE_OBSOLETE29:\n  case CURLE_OBSOLETE32:\n  case CURLE_OBSOLETE40:\n  case CURLE_OBSOLETE44:\n  case CURLE_OBSOLETE46:\n  case CURLE_OBSOLETE50:\n  case CURLE_OBSOLETE51:\n  case CURLE_OBSOLETE57:\n  case CURLE_OBSOLETE62:\n  case CURLE_OBSOLETE75:\n  case CURLE_OBSOLETE76:\n  case CURL_LAST:\n    break;\n  }\n  /*\n   * By using a switch, gcc -Wall will complain about enum values\n   * which do not appear, helping keep this function up-to-date.\n   * By using gcc -Wall -Werror, you can't forget.\n   *\n   * A table would not have the same benefit.  Most compilers will\n   * generate code very similar to a table in any case, so there\n   * is little performance gain from a table.  And something is broken\n   * for the user's application, anyways, so does it matter how fast\n   * it _doesn't_ work?\n   *\n   * The line number for the error will be near this comment, which\n   * is why it is here, and not at the start of the switch.\n   */\n  return \"Unknown error\";\n#else\n  if(!error)\n    return \"No error\";\n  else\n    return \"Error\";\n#endif\n}\n\nconst char *\ncurl_multi_strerror(CURLMcode error)\n{\n#ifndef CURL_DISABLE_VERBOSE_STRINGS\n  switch(error) {\n  case CURLM_CALL_MULTI_PERFORM:\n    return \"Please call curl_multi_perform() soon\";\n\n  case CURLM_OK:\n    return \"No error\";\n\n  case CURLM_BAD_HANDLE:\n    return \"Invalid multi handle\";\n\n  case CURLM_BAD_EASY_HANDLE:\n    return \"Invalid easy handle\";\n\n  case CURLM_OUT_OF_MEMORY:\n    return \"Out of memory\";\n\n  case CURLM_INTERNAL_ERROR:\n    return \"Internal error\";\n\n  case CURLM_BAD_SOCKET:\n    return \"Invalid socket argument\";\n\n  case CURLM_UNKNOWN_OPTION:\n    return \"Unknown option\";\n\n  case CURLM_ADDED_ALREADY:\n    return \"The easy handle is already added to a multi handle\";\n\n  case CURLM_RECURSIVE_API_CALL:\n    return \"API function called from within callback\";\n\n  case CURLM_WAKEUP_FAILURE:\n    return \"Wakeup is unavailable or failed\";\n\n  case CURLM_BAD_FUNCTION_ARGUMENT:\n    return \"A libcurl function was given a bad argument\";\n\n  case CURLM_ABORTED_BY_CALLBACK:\n    return \"Operation was aborted by an application callback\";\n\n  case CURLM_UNRECOVERABLE_POLL:\n    return \"Unrecoverable error in select/poll\";\n\n  case CURLM_LAST:\n    break;\n  }\n\n  return \"Unknown error\";\n#else\n  if(error == CURLM_OK)\n    return \"No error\";\n  else\n    return \"Error\";\n#endif\n}\n\nconst char *\ncurl_share_strerror(CURLSHcode error)\n{\n#ifndef CURL_DISABLE_VERBOSE_STRINGS\n  switch(error) {\n  case CURLSHE_OK:\n    return \"No error\";\n\n  case CURLSHE_BAD_OPTION:\n    return \"Unknown share option\";\n\n  case CURLSHE_IN_USE:\n    return \"Share currently in use\";\n\n  case CURLSHE_INVALID:\n    return \"Invalid share handle\";\n\n  case CURLSHE_NOMEM:\n    return \"Out of memory\";\n\n  case CURLSHE_NOT_BUILT_IN:\n    return \"Feature not enabled in this library\";\n\n  case CURLSHE_LAST:\n    break;\n  }\n\n  return \"CURLSHcode unknown\";\n#else\n  if(error == CURLSHE_OK)\n    return \"No error\";\n  else\n    return \"Error\";\n#endif\n}\n\nconst char *\ncurl_url_strerror(CURLUcode error)\n{\n#ifndef CURL_DISABLE_VERBOSE_STRINGS\n  switch(error) {\n  case CURLUE_OK:\n    return \"No error\";\n\n  case CURLUE_BAD_HANDLE:\n    return \"An invalid CURLU pointer was passed as argument\";\n\n  case CURLUE_BAD_PARTPOINTER:\n    return \"An invalid 'part' argument was passed as argument\";\n\n  case CURLUE_MALFORMED_INPUT:\n    return \"Malformed input to a URL function\";\n\n  case CURLUE_BAD_PORT_NUMBER:\n    return \"Port number was not a decimal number between 0 and 65535\";\n\n  case CURLUE_UNSUPPORTED_SCHEME:\n    return \"Unsupported URL scheme\";\n\n  case CURLUE_URLDECODE:\n    return \"URL decode error, most likely because of rubbish in the input\";\n\n  case CURLUE_OUT_OF_MEMORY:\n    return \"A memory function failed\";\n\n  case CURLUE_USER_NOT_ALLOWED:\n    return \"Credentials was passed in the URL when prohibited\";\n\n  case CURLUE_UNKNOWN_PART:\n    return \"An unknown part ID was passed to a URL API function\";\n\n  case CURLUE_NO_SCHEME:\n    return \"No scheme part in the URL\";\n\n  case CURLUE_NO_USER:\n    return \"No user part in the URL\";\n\n  case CURLUE_NO_PASSWORD:\n    return \"No password part in the URL\";\n\n  case CURLUE_NO_OPTIONS:\n    return \"No options part in the URL\";\n\n  case CURLUE_NO_HOST:\n    return \"No host part in the URL\";\n\n  case CURLUE_NO_PORT:\n    return \"No port part in the URL\";\n\n  case CURLUE_NO_QUERY:\n    return \"No query part in the URL\";\n\n  case CURLUE_NO_FRAGMENT:\n    return \"No fragment part in the URL\";\n\n  case CURLUE_NO_ZONEID:\n    return \"No zoneid part in the URL\";\n\n  case CURLUE_BAD_LOGIN:\n    return \"Bad login part\";\n\n  case CURLUE_BAD_IPV6:\n    return \"Bad IPv6 address\";\n\n  case CURLUE_BAD_HOSTNAME:\n    return \"Bad hostname\";\n\n  case CURLUE_BAD_FILE_URL:\n    return \"Bad file:// URL\";\n\n  case CURLUE_BAD_SLASHES:\n    return \"Unsupported number of slashes following scheme\";\n\n  case CURLUE_BAD_SCHEME:\n    return \"Bad scheme\";\n\n  case CURLUE_BAD_PATH:\n    return \"Bad path\";\n\n  case CURLUE_BAD_FRAGMENT:\n    return \"Bad fragment\";\n\n  case CURLUE_BAD_QUERY:\n    return \"Bad query\";\n\n  case CURLUE_BAD_PASSWORD:\n    return \"Bad password\";\n\n  case CURLUE_BAD_USER:\n    return \"Bad user\";\n\n  case CURLUE_LACKS_IDN:\n    return \"libcurl lacks IDN support\";\n\n  case CURLUE_TOO_LARGE:\n    return \"A value or data field is larger than allowed\";\n\n  case CURLUE_LAST:\n    break;\n  }\n\n  return \"CURLUcode unknown\";\n#else\n  if(error == CURLUE_OK)\n    return \"No error\";\n  else\n    return \"Error\";\n#endif\n}\n\n#ifdef USE_WINSOCK\n/* This is a helper function for Curl_strerror that converts Winsock error\n * codes (WSAGetLastError) to error messages.\n * Returns NULL if no error message was found for error code.\n */\nstatic const char *\nget_winsock_error(int err, char *buf, size_t len)\n{\n#ifndef CURL_DISABLE_VERBOSE_STRINGS\n  const char *p;\n  size_t alen;\n#endif\n\n  if(!len)\n    return NULL;\n\n  *buf = '\\0';\n\n#ifdef CURL_DISABLE_VERBOSE_STRINGS\n  (void)err;\n  return NULL;\n#else\n  switch(err) {\n  case WSAEINTR:\n    p = \"Call interrupted\";\n    break;\n  case WSAEBADF:\n    p = \"Bad file\";\n    break;\n  case WSAEACCES:\n    p = \"Bad access\";\n    break;\n  case WSAEFAULT:\n    p = \"Bad argument\";\n    break;\n  case WSAEINVAL:\n    p = \"Invalid arguments\";\n    break;\n  case WSAEMFILE:\n    p = \"Out of file descriptors\";\n    break;\n  case WSAEWOULDBLOCK:\n    p = \"Call would block\";\n    break;\n  case WSAEINPROGRESS:\n  case WSAEALREADY:\n    p = \"Blocking call in progress\";\n    break;\n  case WSAENOTSOCK:\n    p = \"Descriptor is not a socket\";\n    break;\n  case WSAEDESTADDRREQ:\n    p = \"Need destination address\";\n    break;\n  case WSAEMSGSIZE:\n    p = \"Bad message size\";\n    break;\n  case WSAEPROTOTYPE:\n    p = \"Bad protocol\";\n    break;\n  case WSAENOPROTOOPT:\n    p = \"Protocol option is unsupported\";\n    break;\n  case WSAEPROTONOSUPPORT:\n    p = \"Protocol is unsupported\";\n    break;\n  case WSAESOCKTNOSUPPORT:\n    p = \"Socket is unsupported\";\n    break;\n  case WSAEOPNOTSUPP:\n    p = \"Operation not supported\";\n    break;\n  case WSAEAFNOSUPPORT:\n    p = \"Address family not supported\";\n    break;\n  case WSAEPFNOSUPPORT:\n    p = \"Protocol family not supported\";\n    break;\n  case WSAEADDRINUSE:\n    p = \"Address already in use\";\n    break;\n  case WSAEADDRNOTAVAIL:\n    p = \"Address not available\";\n    break;\n  case WSAENETDOWN:\n    p = \"Network down\";\n    break;\n  case WSAENETUNREACH:\n    p = \"Network unreachable\";\n    break;\n  case WSAENETRESET:\n    p = \"Network has been reset\";\n    break;\n  case WSAECONNABORTED:\n    p = \"Connection was aborted\";\n    break;\n  case WSAECONNRESET:\n    p = \"Connection was reset\";\n    break;\n  case WSAENOBUFS:\n    p = \"No buffer space\";\n    break;\n  case WSAEISCONN:\n    p = \"Socket is already connected\";\n    break;\n  case WSAENOTCONN:\n    p = \"Socket is not connected\";\n    break;\n  case WSAESHUTDOWN:\n    p = \"Socket has been shut down\";\n    break;\n  case WSAETOOMANYREFS:\n    p = \"Too many references\";\n    break;\n  case WSAETIMEDOUT:\n    p = \"Timed out\";\n    break;\n  case WSAECONNREFUSED:\n    p = \"Connection refused\";\n    break;\n  case WSAELOOP:\n    p = \"Loop??\";\n    break;\n  case WSAENAMETOOLONG:\n    p = \"Name too long\";\n    break;\n  case WSAEHOSTDOWN:\n    p = \"Host down\";\n    break;\n  case WSAEHOSTUNREACH:\n    p = \"Host unreachable\";\n    break;\n  case WSAENOTEMPTY:\n    p = \"Not empty\";\n    break;\n  case WSAEPROCLIM:\n    p = \"Process limit reached\";\n    break;\n  case WSAEUSERS:\n    p = \"Too many users\";\n    break;\n  case WSAEDQUOT:\n    p = \"Bad quota\";\n    break;\n  case WSAESTALE:\n    p = \"Something is stale\";\n    break;\n  case WSAEREMOTE:\n    p = \"Remote error\";\n    break;\n#ifdef WSAEDISCON  /* missing in SalfordC! */\n  case WSAEDISCON:\n    p = \"Disconnected\";\n    break;\n#endif\n    /* Extended Winsock errors */\n  case WSASYSNOTREADY:\n    p = \"Winsock library is not ready\";\n    break;\n  case WSANOTINITIALISED:\n    p = \"Winsock library not initialised\";\n    break;\n  case WSAVERNOTSUPPORTED:\n    p = \"Winsock version not supported\";\n    break;\n\n    /* getXbyY() errors (already handled in herrmsg):\n     * Authoritative Answer: Host not found */\n  case WSAHOST_NOT_FOUND:\n    p = \"Host not found\";\n    break;\n\n    /* Non-Authoritative: Host not found, or SERVERFAIL */\n  case WSATRY_AGAIN:\n    p = \"Host not found, try again\";\n    break;\n\n    /* Non recoverable errors, FORMERR, REFUSED, NOTIMP */\n  case WSANO_RECOVERY:\n    p = \"Unrecoverable error in call to nameserver\";\n    break;\n\n    /* Valid name, no data record of requested type */\n  case WSANO_DATA:\n    p = \"No data record of requested type\";\n    break;\n\n  default:\n    return NULL;\n  }\n  alen = strlen(p);\n  if(alen < len)\n    strcpy(buf, p);\n  return buf;\n#endif\n}\n#endif   /* USE_WINSOCK */\n\n#if defined(_WIN32) || defined(_WIN32_WCE)\n/* This is a helper function for Curl_strerror that converts Windows API error\n * codes (GetLastError) to error messages.\n * Returns NULL if no error message was found for error code.\n */\nstatic const char *\nget_winapi_error(int err, char *buf, size_t buflen)\n{\n  char *p;\n  wchar_t wbuf[256];\n\n  if(!buflen)\n    return NULL;\n\n  *buf = '\\0';\n  *wbuf = L'\\0';\n\n  /* We return the local codepage version of the error string because if it is\n     output to the user's terminal it will likely be with functions which\n     expect the local codepage (eg fprintf, failf, infof).\n     FormatMessageW -> wcstombs is used for Windows CE compatibility. */\n  if(FormatMessageW((FORMAT_MESSAGE_FROM_SYSTEM |\n                     FORMAT_MESSAGE_IGNORE_INSERTS), NULL, err,\n                    LANG_NEUTRAL, wbuf, sizeof(wbuf)/sizeof(wchar_t), NULL)) {\n    size_t written = wcstombs(buf, wbuf, buflen - 1);\n    if(written != (size_t)-1)\n      buf[written] = '\\0';\n    else\n      *buf = '\\0';\n  }\n\n  /* Truncate multiple lines */\n  p = strchr(buf, '\\n');\n  if(p) {\n    if(p > buf && *(p-1) == '\\r')\n      *(p-1) = '\\0';\n    else\n      *p = '\\0';\n  }\n\n  return (*buf ? buf : NULL);\n}\n#endif /* _WIN32 || _WIN32_WCE */\n\n/*\n * Our thread-safe and smart strerror() replacement.\n *\n * The 'err' argument passed in to this function MUST be a true errno number\n * as reported on this system. We do no range checking on the number before\n * we pass it to the \"number-to-message\" conversion function and there might\n * be systems that don't do proper range checking in there themselves.\n *\n * We don't do range checking (on systems other than Windows) since there is\n * no good reliable and portable way to do it.\n *\n * On Windows different types of error codes overlap. This function has an\n * order of preference when trying to match error codes:\n * CRT (errno), Winsock (WSAGetLastError), Windows API (GetLastError).\n *\n * It may be more correct to call one of the variant functions instead:\n * Call Curl_sspi_strerror if the error code is definitely Windows SSPI.\n * Call Curl_winapi_strerror if the error code is definitely Windows API.\n */\nconst char *Curl_strerror(int err, char *buf, size_t buflen)\n{\n#ifdef PRESERVE_WINDOWS_ERROR_CODE\n  DWORD old_win_err = GetLastError();\n#endif\n  int old_errno = errno;\n  char *p;\n\n  if(!buflen)\n    return NULL;\n\n#ifndef _WIN32\n  DEBUGASSERT(err >= 0);\n#endif\n\n  *buf = '\\0';\n\n#if defined(_WIN32) || defined(_WIN32_WCE)\n#if defined(_WIN32)\n  /* 'sys_nerr' is the maximum errno number, it is not widely portable */\n  if(err >= 0 && err < sys_nerr)\n    msnprintf(buf, buflen, \"%s\", sys_errlist[err]);\n  else\n#endif\n  {\n    if(\n#ifdef USE_WINSOCK\n       !get_winsock_error(err, buf, buflen) &&\n#endif\n       !get_winapi_error((DWORD)err, buf, buflen))\n      msnprintf(buf, buflen, \"Unknown error %d (%#x)\", err, err);\n  }\n#else /* not Windows coming up */\n\n#if defined(HAVE_STRERROR_R) && defined(HAVE_POSIX_STRERROR_R)\n /*\n  * The POSIX-style strerror_r() may set errno to ERANGE if insufficient\n  * storage is supplied via 'strerrbuf' and 'buflen' to hold the generated\n  * message string, or EINVAL if 'errnum' is not a valid error number.\n  */\n  if(0 != strerror_r(err, buf, buflen)) {\n    if('\\0' == buf[0])\n      msnprintf(buf, buflen, \"Unknown error %d\", err);\n  }\n#elif defined(HAVE_STRERROR_R) && defined(HAVE_GLIBC_STRERROR_R)\n /*\n  * The glibc-style strerror_r() only *might* use the buffer we pass to\n  * the function, but it always returns the error message as a pointer,\n  * so we must copy that string unconditionally (if non-NULL).\n  */\n  {\n    char buffer[256];\n    char *msg = strerror_r(err, buffer, sizeof(buffer));\n    if(msg)\n      msnprintf(buf, buflen, \"%s\", msg);\n    else\n      msnprintf(buf, buflen, \"Unknown error %d\", err);\n  }\n#else\n  {\n    /* !checksrc! disable STRERROR 1 */\n    const char *msg = strerror(err);\n    if(msg)\n      msnprintf(buf, buflen, \"%s\", msg);\n    else\n      msnprintf(buf, buflen, \"Unknown error %d\", err);\n  }\n#endif\n\n#endif /* end of not Windows */\n\n  /* strip trailing '\\r\\n' or '\\n'. */\n  p = strrchr(buf, '\\n');\n  if(p && (p - buf) >= 2)\n    *p = '\\0';\n  p = strrchr(buf, '\\r');\n  if(p && (p - buf) >= 1)\n    *p = '\\0';\n\n  if(errno != old_errno)\n    errno = old_errno;\n\n#ifdef PRESERVE_WINDOWS_ERROR_CODE\n  if(old_win_err != GetLastError())\n    SetLastError(old_win_err);\n#endif\n\n  return buf;\n}\n\n/*\n * Curl_winapi_strerror:\n * Variant of Curl_strerror if the error code is definitely Windows API.\n */\n#if defined(_WIN32) || defined(_WIN32_WCE)\nconst char *Curl_winapi_strerror(DWORD err, char *buf, size_t buflen)\n{\n#ifdef PRESERVE_WINDOWS_ERROR_CODE\n  DWORD old_win_err = GetLastError();\n#endif\n  int old_errno = errno;\n\n  if(!buflen)\n    return NULL;\n\n  *buf = '\\0';\n\n#ifndef CURL_DISABLE_VERBOSE_STRINGS\n  if(!get_winapi_error(err, buf, buflen)) {\n    msnprintf(buf, buflen, \"Unknown error %lu (0x%08lX)\", err, err);\n  }\n#else\n  {\n    const char *txt = (err == ERROR_SUCCESS) ? \"No error\" : \"Error\";\n    if(strlen(txt) < buflen)\n      strcpy(buf, txt);\n  }\n#endif\n\n  if(errno != old_errno)\n    errno = old_errno;\n\n#ifdef PRESERVE_WINDOWS_ERROR_CODE\n  if(old_win_err != GetLastError())\n    SetLastError(old_win_err);\n#endif\n\n  return buf;\n}\n#endif /* _WIN32 || _WIN32_WCE */\n\n#ifdef USE_WINDOWS_SSPI\n/*\n * Curl_sspi_strerror:\n * Variant of Curl_strerror if the error code is definitely Windows SSPI.\n */\nconst char *Curl_sspi_strerror(int err, char *buf, size_t buflen)\n{\n#ifdef PRESERVE_WINDOWS_ERROR_CODE\n  DWORD old_win_err = GetLastError();\n#endif\n  int old_errno = errno;\n  const char *txt;\n\n  if(!buflen)\n    return NULL;\n\n  *buf = '\\0';\n\n#ifndef CURL_DISABLE_VERBOSE_STRINGS\n\n  switch(err) {\n    case SEC_E_OK:\n      txt = \"No error\";\n      break;\n#define SEC2TXT(sec) case sec: txt = #sec; break\n    SEC2TXT(CRYPT_E_REVOKED);\n    SEC2TXT(CRYPT_E_NO_REVOCATION_DLL);\n    SEC2TXT(CRYPT_E_NO_REVOCATION_CHECK);\n    SEC2TXT(CRYPT_E_REVOCATION_OFFLINE);\n    SEC2TXT(CRYPT_E_NOT_IN_REVOCATION_DATABASE);\n    SEC2TXT(SEC_E_ALGORITHM_MISMATCH);\n    SEC2TXT(SEC_E_BAD_BINDINGS);\n    SEC2TXT(SEC_E_BAD_PKGID);\n    SEC2TXT(SEC_E_BUFFER_TOO_SMALL);\n    SEC2TXT(SEC_E_CANNOT_INSTALL);\n    SEC2TXT(SEC_E_CANNOT_PACK);\n    SEC2TXT(SEC_E_CERT_EXPIRED);\n    SEC2TXT(SEC_E_CERT_UNKNOWN);\n    SEC2TXT(SEC_E_CERT_WRONG_USAGE);\n    SEC2TXT(SEC_E_CONTEXT_EXPIRED);\n    SEC2TXT(SEC_E_CROSSREALM_DELEGATION_FAILURE);\n    SEC2TXT(SEC_E_CRYPTO_SYSTEM_INVALID);\n    SEC2TXT(SEC_E_DECRYPT_FAILURE);\n    SEC2TXT(SEC_E_DELEGATION_POLICY);\n    SEC2TXT(SEC_E_DELEGATION_REQUIRED);\n    SEC2TXT(SEC_E_DOWNGRADE_DETECTED);\n    SEC2TXT(SEC_E_ENCRYPT_FAILURE);\n    SEC2TXT(SEC_E_ILLEGAL_MESSAGE);\n    SEC2TXT(SEC_E_INCOMPLETE_CREDENTIALS);\n    SEC2TXT(SEC_E_INCOMPLETE_MESSAGE);\n    SEC2TXT(SEC_E_INSUFFICIENT_MEMORY);\n    SEC2TXT(SEC_E_INTERNAL_ERROR);\n    SEC2TXT(SEC_E_INVALID_HANDLE);\n    SEC2TXT(SEC_E_INVALID_PARAMETER);\n    SEC2TXT(SEC_E_INVALID_TOKEN);\n    SEC2TXT(SEC_E_ISSUING_CA_UNTRUSTED);\n    SEC2TXT(SEC_E_ISSUING_CA_UNTRUSTED_KDC);\n    SEC2TXT(SEC_E_KDC_CERT_EXPIRED);\n    SEC2TXT(SEC_E_KDC_CERT_REVOKED);\n    SEC2TXT(SEC_E_KDC_INVALID_REQUEST);\n    SEC2TXT(SEC_E_KDC_UNABLE_TO_REFER);\n    SEC2TXT(SEC_E_KDC_UNKNOWN_ETYPE);\n    SEC2TXT(SEC_E_LOGON_DENIED);\n    SEC2TXT(SEC_E_MAX_REFERRALS_EXCEEDED);\n    SEC2TXT(SEC_E_MESSAGE_ALTERED);\n    SEC2TXT(SEC_E_MULTIPLE_ACCOUNTS);\n    SEC2TXT(SEC_E_MUST_BE_KDC);\n    SEC2TXT(SEC_E_NOT_OWNER);\n    SEC2TXT(SEC_E_NO_AUTHENTICATING_AUTHORITY);\n    SEC2TXT(SEC_E_NO_CREDENTIALS);\n    SEC2TXT(SEC_E_NO_IMPERSONATION);\n    SEC2TXT(SEC_E_NO_IP_ADDRESSES);\n    SEC2TXT(SEC_E_NO_KERB_KEY);\n    SEC2TXT(SEC_E_NO_PA_DATA);\n    SEC2TXT(SEC_E_NO_S4U_PROT_SUPPORT);\n    SEC2TXT(SEC_E_NO_TGT_REPLY);\n    SEC2TXT(SEC_E_OUT_OF_SEQUENCE);\n    SEC2TXT(SEC_E_PKINIT_CLIENT_FAILURE);\n    SEC2TXT(SEC_E_PKINIT_NAME_MISMATCH);\n    SEC2TXT(SEC_E_POLICY_NLTM_ONLY);\n    SEC2TXT(SEC_E_QOP_NOT_SUPPORTED);\n    SEC2TXT(SEC_E_REVOCATION_OFFLINE_C);\n    SEC2TXT(SEC_E_REVOCATION_OFFLINE_KDC);\n    SEC2TXT(SEC_E_SECPKG_NOT_FOUND);\n    SEC2TXT(SEC_E_SECURITY_QOS_FAILED);\n    SEC2TXT(SEC_E_SHUTDOWN_IN_PROGRESS);\n    SEC2TXT(SEC_E_SMARTCARD_CERT_EXPIRED);\n    SEC2TXT(SEC_E_SMARTCARD_CERT_REVOKED);\n    SEC2TXT(SEC_E_SMARTCARD_LOGON_REQUIRED);\n    SEC2TXT(SEC_E_STRONG_CRYPTO_NOT_SUPPORTED);\n    SEC2TXT(SEC_E_TARGET_UNKNOWN);\n    SEC2TXT(SEC_E_TIME_SKEW);\n    SEC2TXT(SEC_E_TOO_MANY_PRINCIPALS);\n    SEC2TXT(SEC_E_UNFINISHED_CONTEXT_DELETED);\n    SEC2TXT(SEC_E_UNKNOWN_CREDENTIALS);\n    SEC2TXT(SEC_E_UNSUPPORTED_FUNCTION);\n    SEC2TXT(SEC_E_UNSUPPORTED_PREAUTH);\n    SEC2TXT(SEC_E_UNTRUSTED_ROOT);\n    SEC2TXT(SEC_E_WRONG_CREDENTIAL_HANDLE);\n    SEC2TXT(SEC_E_WRONG_PRINCIPAL);\n    SEC2TXT(SEC_I_COMPLETE_AND_CONTINUE);\n    SEC2TXT(SEC_I_COMPLETE_NEEDED);\n    SEC2TXT(SEC_I_CONTEXT_EXPIRED);\n    SEC2TXT(SEC_I_CONTINUE_NEEDED);\n    SEC2TXT(SEC_I_INCOMPLETE_CREDENTIALS);\n    SEC2TXT(SEC_I_LOCAL_LOGON);\n    SEC2TXT(SEC_I_NO_LSA_CONTEXT);\n    SEC2TXT(SEC_I_RENEGOTIATE);\n    SEC2TXT(SEC_I_SIGNATURE_NEEDED);\n    default:\n      txt = \"Unknown error\";\n  }\n\n  if(err == SEC_E_ILLEGAL_MESSAGE) {\n    msnprintf(buf, buflen,\n              \"SEC_E_ILLEGAL_MESSAGE (0x%08X) - This error usually occurs \"\n              \"when a fatal SSL/TLS alert is received (e.g. handshake failed).\"\n              \" More detail may be available in the Windows System event log.\",\n              err);\n  }\n  else {\n    char msgbuf[256];\n    if(get_winapi_error(err, msgbuf, sizeof(msgbuf)))\n      msnprintf(buf, buflen, \"%s (0x%08X) - %s\", txt, err, msgbuf);\n    else\n      msnprintf(buf, buflen, \"%s (0x%08X)\", txt, err);\n  }\n\n#else\n  if(err == SEC_E_OK)\n    txt = \"No error\";\n  else\n    txt = \"Error\";\n  if(buflen > strlen(txt))\n    strcpy(buf, txt);\n#endif\n\n  if(errno != old_errno)\n    errno = old_errno;\n\n#ifdef PRESERVE_WINDOWS_ERROR_CODE\n  if(old_win_err != GetLastError())\n    SetLastError(old_win_err);\n#endif\n\n  return buf;\n}\n#endif /* USE_WINDOWS_SSPI */\n` was unexpected","path":"/home/qqq/curl-8.7.0/lib/strerror.c"},{"code":3,"level":"warn","type":["PartialParsing",[{"path":"/home/qqq/curl-8.7.0/lib/vtls/bearssl.c","start":{"line":456,"col":1,"offset":0},"end":{"line":456,"col":35,"offset":34}},{"path":"/home/qqq/curl-8.7.0/lib/vtls/bearssl.c","start":{"line":479,"col":1,"offset":0},"end":{"line":479,"col":7,"offset":6}},{"path":"/home/qqq/curl-8.7.0/lib/vtls/bearssl.c","start":{"line":1104,"col":50,"offset":0},"end":{"line":1104,"col":54,"offset":4}},{"path":"/home/qqq/curl-8.7.0/lib/vtls/bearssl.c","start":{"line":1147,"col":45,"offset":0},"end":{"line":1147,"col":49,"offset":4}},{"path":"/home/qqq/curl-8.7.0/lib/vtls/bearssl.c","start":{"line":1184,"col":42,"offset":0},"end":{"line":1184,"col":51,"offset":9}}]],"message":"Syntax error at line /home/qqq/curl-8.7.0/lib/vtls/bearssl.c:456:\n `#ifdef BR_TLS_RSA_WITH_AES_128_CCM` was unexpected","path":"/home/qqq/curl-8.7.0/lib/vtls/bearssl.c","spans":[{"file":"/home/qqq/curl-8.7.0/lib/vtls/bearssl.c","start":{"line":456,"col":1,"offset":0},"end":{"line":456,"col":35,"offset":34}},{"file":"/home/qqq/curl-8.7.0/lib/vtls/bearssl.c","start":{"line":479,"col":1,"offset":0},"end":{"line":479,"col":7,"offset":6}},{"file":"/home/qqq/curl-8.7.0/lib/vtls/bearssl.c","start":{"line":1104,"col":50,"offset":0},"end":{"line":1104,"col":54,"offset":4}},{"file":"/home/qqq/curl-8.7.0/lib/vtls/bearssl.c","start":{"line":1147,"col":45,"offset":0},"end":{"line":1147,"col":49,"offset":4}},{"file":"/home/qqq/curl-8.7.0/lib/vtls/bearssl.c","start":{"line":1184,"col":42,"offset":0},"end":{"line":1184,"col":51,"offset":9}}]},{"code":3,"level":"warn","type":["PartialParsing",[{"path":"/home/qqq/curl-8.7.0/lib/smtp.c","start":{"line":715,"col":1,"offset":0},"end":{"line":715,"col":7,"offset":6}},{"path":"/home/qqq/curl-8.7.0/lib/smtp.c","start":{"line":724,"col":20,"offset":0},"end":{"line":724,"col":23,"offset":3}},{"path":"/home/qqq/curl-8.7.0/lib/smtp.c","start":{"line":1879,"col":17,"offset":0},"end":{"line":1879,"col":20,"offset":3}}]],"message":"Syntax error at line /home/qqq/curl-8.7.0/lib/smtp.c:715:\n `#endif` was unexpected","path":"/home/qqq/curl-8.7.0/lib/smtp.c","spans":[{"file":"/home/qqq/curl-8.7.0/lib/smtp.c","start":{"line":715,"col":1,"offset":0},"end":{"line":715,"col":7,"offset":6}},{"file":"/home/qqq/curl-8.7.0/lib/smtp.c","start":{"line":724,"col":20,"offset":0},"end":{"line":724,"col":23,"offset":3}},{"file":"/home/qqq/curl-8.7.0/lib/smtp.c","start":{"line":1879,"col":17,"offset":0},"end":{"line":1879,"col":20,"offset":3}}]},{"code":3,"level":"warn","type":"Syntax error","message":"Syntax error at line /home/qqq/curl-8.7.0/lib/url.c:1:\n `/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n * SPDX-License-Identifier: curl\n *\n ***************************************************************************/\n\n#include \"curl_setup.h\"\n\n#ifdef HAVE_NETINET_IN_H\n#include <netinet/in.h>\n#endif\n#ifdef HAVE_NETDB_H\n#include <netdb.h>\n#endif\n#ifdef HAVE_ARPA_INET_H\n#include <arpa/inet.h>\n#endif\n#ifdef HAVE_NET_IF_H\n#include <net/if.h>\n#endif\n#ifdef HAVE_IPHLPAPI_H\n#include <Iphlpapi.h>\n#endif\n#ifdef HAVE_SYS_IOCTL_H\n#include <sys/ioctl.h>\n#endif\n#ifdef HAVE_SYS_PARAM_H\n#include <sys/param.h>\n#endif\n\n#ifdef __VMS\n#include <in.h>\n#include <inet.h>\n#endif\n\n#ifdef HAVE_SYS_UN_H\n#include <sys/un.h>\n#endif\n\n#ifndef HAVE_SOCKET\n#error \"We can't compile without socket() support!\"\n#endif\n\n#include <limits.h>\n\n#include \"doh.h\"\n#include \"urldata.h\"\n#include \"netrc.h\"\n#include \"formdata.h\"\n#include \"mime.h\"\n#include \"vtls/vtls.h\"\n#include \"hostip.h\"\n#include \"transfer.h\"\n#include \"sendf.h\"\n#include \"progress.h\"\n#include \"cookie.h\"\n#include \"strcase.h\"\n#include \"strerror.h\"\n#include \"escape.h\"\n#include \"strtok.h\"\n#include \"share.h\"\n#include \"content_encoding.h\"\n#include \"http_digest.h\"\n#include \"http_negotiate.h\"\n#include \"select.h\"\n#include \"multiif.h\"\n#include \"easyif.h\"\n#include \"speedcheck.h\"\n#include \"warnless.h\"\n#include \"getinfo.h\"\n#include \"urlapi-int.h\"\n#include \"system_win32.h\"\n#include \"hsts.h\"\n#include \"noproxy.h\"\n#include \"cfilters.h\"\n#include \"idn.h\"\n\n/* And now for the protocols */\n#include \"ftp.h\"\n#include \"dict.h\"\n#include \"telnet.h\"\n#include \"tftp.h\"\n#include \"http.h\"\n#include \"http2.h\"\n#include \"file.h\"\n#include \"curl_ldap.h\"\n#include \"vssh/ssh.h\"\n#include \"imap.h\"\n#include \"url.h\"\n#include \"connect.h\"\n#include \"inet_ntop.h\"\n#include \"http_ntlm.h\"\n#include \"curl_rtmp.h\"\n#include \"gopher.h\"\n#include \"mqtt.h\"\n#include \"http_proxy.h\"\n#include \"conncache.h\"\n#include \"multihandle.h\"\n#include \"strdup.h\"\n#include \"setopt.h\"\n#include \"altsvc.h\"\n#include \"dynbuf.h\"\n#include \"headers.h\"\n\n/* The last 3 #include files should be in this order */\n#include \"curl_printf.h\"\n#include \"curl_memory.h\"\n#include \"memdebug.h\"\n\n#ifndef ARRAYSIZE\n#define ARRAYSIZE(A) (sizeof(A)/sizeof((A)[0]))\n#endif\n\n#ifdef USE_NGHTTP2\nstatic void data_priority_cleanup(struct Curl_easy *data);\n#else\n#define data_priority_cleanup(x)\n#endif\n\n/* Some parts of the code (e.g. chunked encoding) assume this buffer has at\n * more than just a few bytes to play with. Don't let it become too small or\n * bad things will happen.\n */\n#if READBUFFER_SIZE < READBUFFER_MIN\n# error READBUFFER_SIZE is too small\n#endif\n\n#ifdef USE_UNIX_SOCKETS\n#define UNIX_SOCKET_PREFIX \"localhost\"\n#endif\n\n/* Reject URLs exceeding this length */\n#define MAX_URL_LEN 0xffff\n\n/*\n* get_protocol_family()\n*\n* This is used to return the protocol family for a given protocol.\n*\n* Parameters:\n*\n* 'h'  [in]  - struct Curl_handler pointer.\n*\n* Returns the family as a single bit protocol identifier.\n*/\nstatic curl_prot_t get_protocol_family(const struct Curl_handler *h)\n{\n  DEBUGASSERT(h);\n  DEBUGASSERT(h->family);\n  return h->family;\n}\n\nvoid Curl_freeset(struct Curl_easy *data)\n{\n  /* Free all dynamic strings stored in the data->set substructure. */\n  enum dupstring i;\n  enum dupblob j;\n\n  for(i = (enum dupstring)0; i < STRING_LAST; i++) {\n    Curl_safefree(data->set.str[i]);\n  }\n\n  for(j = (enum dupblob)0; j < BLOB_LAST; j++) {\n    Curl_safefree(data->set.blobs[j]);\n  }\n\n  if(data->state.referer_alloc) {\n    Curl_safefree(data->state.referer);\n    data->state.referer_alloc = FALSE;\n  }\n  data->state.referer = NULL;\n  if(data->state.url_alloc) {\n    Curl_safefree(data->state.url);\n    data->state.url_alloc = FALSE;\n  }\n  data->state.url = NULL;\n\n  Curl_mime_cleanpart(&data->set.mimepost);\n\n#ifndef CURL_DISABLE_COOKIES\n  curl_slist_free_all(data->state.cookielist);\n  data->state.cookielist = NULL;\n#endif\n}\n\n/* free the URL pieces */\nstatic void up_free(struct Curl_easy *data)\n{\n  struct urlpieces *up = &data->state.up;\n  Curl_safefree(up->scheme);\n  Curl_safefree(up->hostname);\n  Curl_safefree(up->port);\n  Curl_safefree(up->user);\n  Curl_safefree(up->password);\n  Curl_safefree(up->options);\n  Curl_safefree(up->path);\n  Curl_safefree(up->query);\n  curl_url_cleanup(data->state.uh);\n  data->state.uh = NULL;\n}\n\n/*\n * This is the internal function curl_easy_cleanup() calls. This should\n * cleanup and free all resources associated with this sessionhandle.\n *\n * We ignore SIGPIPE when this is called from curl_easy_cleanup.\n */\n\nCURLcode Curl_close(struct Curl_easy **datap)\n{\n  struct Curl_easy *data;\n\n  if(!datap || !*datap)\n    return CURLE_OK;\n\n  data = *datap;\n  *datap = NULL;\n\n  Curl_expire_clear(data); /* shut off timers */\n\n  /* Detach connection if any is left. This should not be normal, but can be\n     the case for example with CONNECT_ONLY + recv/send (test 556) */\n  Curl_detach_connection(data);\n  if(!data->state.internal) {\n    if(data->multi)\n      /* This handle is still part of a multi handle, take care of this first\n         and detach this handle from there. */\n      curl_multi_remove_handle(data->multi, data);\n\n    if(data->multi_easy) {\n      /* when curl_easy_perform() is used, it creates its own multi handle to\n         use and this is the one */\n      curl_multi_cleanup(data->multi_easy);\n      data->multi_easy = NULL;\n    }\n  }\n\n  data->magic = 0; /* force a clear AFTER the possibly enforced removal from\n                      the multi handle, since that function uses the magic\n                      field! */\n\n  if(data->state.rangestringalloc)\n    free(data->state.range);\n\n  /* freed here just in case DONE wasn't called */\n  Curl_req_free(&data->req, data);\n\n  /* Close down all open SSL info and sessions */\n  Curl_ssl_close_all(data);\n  Curl_safefree(data->state.first_host);\n  Curl_safefree(data->state.scratch);\n  Curl_ssl_free_certinfo(data);\n\n  if(data->state.referer_alloc) {\n    Curl_safefree(data->state.referer);\n    data->state.referer_alloc = FALSE;\n  }\n  data->state.referer = NULL;\n\n  up_free(data);\n  Curl_dyn_free(&data->state.headerb);\n  Curl_flush_cookies(data, TRUE);\n  Curl_altsvc_save(data, data->asi, data->set.str[STRING_ALTSVC]);\n  Curl_altsvc_cleanup(&data->asi);\n  Curl_hsts_save(data, data->hsts, data->set.str[STRING_HSTS]);\n#ifndef CURL_DISABLE_HSTS\n  if(!data->share || !data->share->hsts)\n    Curl_hsts_cleanup(&data->hsts);\n  curl_slist_free_all(data->state.hstslist); /* clean up list */\n#endif\n#if !defined(CURL_DISABLE_HTTP) && !defined(CURL_DISABLE_DIGEST_AUTH)\n  Curl_http_auth_cleanup_digest(data);\n#endif\n  Curl_safefree(data->info.contenttype);\n  Curl_safefree(data->info.wouldredirect);\n\n  /* this destroys the channel and we cannot use it anymore after this */\n  Curl_resolver_cancel(data);\n  Curl_resolver_cleanup(data->state.async.resolver);\n\n  data_priority_cleanup(data);\n\n  /* No longer a dirty share, if it exists */\n  if(data->share) {\n    Curl_share_lock(data, CURL_LOCK_DATA_SHARE, CURL_LOCK_ACCESS_SINGLE);\n    data->share->dirty--;\n    Curl_share_unlock(data, CURL_LOCK_DATA_SHARE);\n  }\n\n  Curl_safefree(data->state.aptr.proxyuserpwd);\n  Curl_safefree(data->state.aptr.uagent);\n  Curl_safefree(data->state.aptr.userpwd);\n  Curl_safefree(data->state.aptr.accept_encoding);\n  Curl_safefree(data->state.aptr.te);\n  Curl_safefree(data->state.aptr.rangeline);\n  Curl_safefree(data->state.aptr.ref);\n  Curl_safefree(data->state.aptr.host);\n  Curl_safefree(data->state.aptr.cookiehost);\n  Curl_safefree(data->state.aptr.rtsp_transport);\n  Curl_safefree(data->state.aptr.user);\n  Curl_safefree(data->state.aptr.passwd);\n  Curl_safefree(data->state.aptr.proxyuser);\n  Curl_safefree(data->state.aptr.proxypasswd);\n\n#if !defined(CURL_DISABLE_HTTP) && !defined(CURL_DISABLE_FORM_API)\n  Curl_mime_cleanpart(data->state.formp);\n  Curl_safefree(data->state.formp);\n#endif\n\n  /* destruct wildcard structures if it is needed */\n  Curl_wildcard_dtor(&data->wildcard);\n  Curl_freeset(data);\n  Curl_headers_cleanup(data);\n  free(data);\n  return CURLE_OK;\n}\n\n/*\n * Initialize the UserDefined fields within a Curl_easy.\n * This may be safely called on a new or existing Curl_easy.\n */\nCURLcode Curl_init_userdefined(struct Curl_easy *data)\n{\n  struct UserDefined *set = &data->set;\n  CURLcode result = CURLE_OK;\n\n  set->out = stdout; /* default output to stdout */\n  set->in_set = stdin;  /* default input from stdin */\n  set->err  = stderr;  /* default stderr to stderr */\n\n  /* use fwrite as default function to store output */\n  set->fwrite_func = (curl_write_callback)fwrite;\n\n  /* use fread as default function to read input */\n  set->fread_func_set = (curl_read_callback)fread;\n  set->is_fread_set = 0;\n\n  set->seek_client = ZERO_NULL;\n\n  set->filesize = -1;        /* we don't know the size */\n  set->postfieldsize = -1;   /* unknown size */\n  set->maxredirs = 30;       /* sensible default */\n\n  set->method = HTTPREQ_GET; /* Default HTTP request */\n#ifndef CURL_DISABLE_RTSP\n  set->rtspreq = RTSPREQ_OPTIONS; /* Default RTSP request */\n#endif\n#ifndef CURL_DISABLE_FTP\n  set->ftp_use_epsv = TRUE;   /* FTP defaults to EPSV operations */\n  set->ftp_use_eprt = TRUE;   /* FTP defaults to EPRT operations */\n  set->ftp_use_pret = FALSE;  /* mainly useful for drftpd servers */\n  set->ftp_filemethod = FTPFILE_MULTICWD;\n  set->ftp_skip_ip = TRUE;    /* skip PASV IP by default */\n#endif\n  set->dns_cache_timeout = 60; /* Timeout every 60 seconds by default */\n\n  /* Set the default size of the SSL session ID cache */\n  set->general_ssl.max_ssl_sessions = 5;\n  /* Timeout every 24 hours by default */\n  set->general_ssl.ca_cache_timeout = 24 * 60 * 60;\n\n  set->httpauth = CURLAUTH_BASIC;  /* defaults to basic */\n\n#ifndef CURL_DISABLE_PROXY\n  set->proxyport = 0;\n  set->proxytype = CURLPROXY_HTTP; /* defaults to HTTP proxy */\n  set->proxyauth = CURLAUTH_BASIC; /* defaults to basic */\n  /* SOCKS5 proxy auth defaults to username/password + GSS-API */\n  set->socks5auth = CURLAUTH_BASIC | CURLAUTH_GSSAPI;\n#endif\n\n  /* make libcurl quiet by default: */\n  set->hide_progress = TRUE;  /* CURLOPT_NOPROGRESS changes these */\n\n  Curl_mime_initpart(&set->mimepost);\n\n  Curl_ssl_easy_config_init(data);\n#ifndef CURL_DISABLE_DOH\n  set->doh_verifyhost = TRUE;\n  set->doh_verifypeer = TRUE;\n#endif\n#ifdef USE_SSH\n  /* defaults to any auth type */\n  set->ssh_auth_types = CURLSSH_AUTH_DEFAULT;\n  set->new_directory_perms = 0755; /* Default permissions */\n#endif\n\n  set->new_file_perms = 0644;    /* Default permissions */\n  set->allowed_protocols = (curl_prot_t) CURLPROTO_ALL;\n  set->redir_protocols = CURLPROTO_HTTP | CURLPROTO_HTTPS | CURLPROTO_FTP |\n                         CURLPROTO_FTPS;\n\n#if defined(HAVE_GSSAPI) || defined(USE_WINDOWS_SSPI)\n  /*\n   * disallow unprotected protection negotiation NEC reference implementation\n   * seem not to follow rfc1961 section 4.3/4.4\n   */\n  set->socks5_gssapi_nec = FALSE;\n#endif\n\n  /* Set the default CA cert bundle/path detected/specified at build time.\n   *\n   * If Schannel or SecureTransport is the selected SSL backend then these\n   * locations are ignored. We allow setting CA location for schannel and\n   * securetransport when explicitly specified by the user via\n   *  CURLOPT_CAINFO / --cacert.\n   */\n  if(Curl_ssl_backend() != CURLSSLBACKEND_SCHANNEL &&\n     Curl_ssl_backend() != CURLSSLBACKEND_SECURETRANSPORT) {\n#if defined(CURL_CA_BUNDLE)\n    result = Curl_setstropt(&set->str[STRING_SSL_CAFILE], CURL_CA_BUNDLE);\n    if(result)\n      return result;\n\n    result = Curl_setstropt(&set->str[STRING_SSL_CAFILE_PROXY],\n                            CURL_CA_BUNDLE);\n    if(result)\n      return result;\n#endif\n#if defined(CURL_CA_PATH)\n    result = Curl_setstropt(&set->str[STRING_SSL_CAPATH], CURL_CA_PATH);\n    if(result)\n      return result;\n\n    result = Curl_setstropt(&set->str[STRING_SSL_CAPATH_PROXY], CURL_CA_PATH);\n    if(result)\n      return result;\n#endif\n  }\n\n#ifndef CURL_DISABLE_FTP\n  set->wildcard_enabled = FALSE;\n  set->chunk_bgn      = ZERO_NULL;\n  set->chunk_end      = ZERO_NULL;\n  set->fnmatch = ZERO_NULL;\n#endif\n  set->tcp_keepalive = FALSE;\n  set->tcp_keepintvl = 60;\n  set->tcp_keepidle = 60;\n  set->tcp_fastopen = FALSE;\n  set->tcp_nodelay = TRUE;\n  set->ssl_enable_alpn = TRUE;\n  set->expect_100_timeout = 1000L; /* Wait for a second by default. */\n  set->sep_headers = TRUE; /* separated header lists by default */\n  set->buffer_size = READBUFFER_SIZE;\n  set->upload_buffer_size = UPLOADBUFFER_DEFAULT;\n  set->happy_eyeballs_timeout = CURL_HET_DEFAULT;\n  set->upkeep_interval_ms = CURL_UPKEEP_INTERVAL_DEFAULT;\n  set->maxconnects = DEFAULT_CONNCACHE_SIZE; /* for easy handles */\n  set->maxage_conn = 118;\n  set->maxlifetime_conn = 0;\n  set->http09_allowed = FALSE;\n#ifdef USE_HTTP2\n  set->httpwant = CURL_HTTP_VERSION_2TLS\n#else\n  set->httpwant = CURL_HTTP_VERSION_1_1\n#endif\n    ;\n#if defined(USE_HTTP2) || defined(USE_HTTP3)\n  memset(&set->priority, 0, sizeof(set->priority));\n#endif\n  set->quick_exit = 0L;\n  return result;\n}\n\n/**\n * Curl_open()\n *\n * @param curl is a pointer to a sessionhandle pointer that gets set by this\n * function.\n * @return CURLcode\n */\n\nCURLcode Curl_open(struct Curl_easy **curl)\n{\n  CURLcode result;\n  struct Curl_easy *data;\n\n  /* Very simple start-up: alloc the struct, init it with zeroes and return */\n  data = calloc(1, sizeof(struct Curl_easy));\n  if(!data) {\n    /* this is a very serious error */\n    DEBUGF(fprintf(stderr, \"Error: calloc of Curl_easy failed\\n\"));\n    return CURLE_OUT_OF_MEMORY;\n  }\n\n  data->magic = CURLEASY_MAGIC_NUMBER;\n\n  result = Curl_req_init(&data->req);\n  if(result) {\n    DEBUGF(fprintf(stderr, \"Error: request init failed\\n\"));\n    free(data);\n    return result;\n  }\n\n  result = Curl_resolver_init(data, &data->state.async.resolver);\n  if(result) {\n    DEBUGF(fprintf(stderr, \"Error: resolver_init failed\\n\"));\n    Curl_req_free(&data->req, data);\n    free(data);\n    return result;\n  }\n\n  result = Curl_init_userdefined(data);\n  if(!result) {\n    Curl_dyn_init(&data->state.headerb, CURL_MAX_HTTP_HEADER);\n    Curl_initinfo(data);\n\n    /* most recent connection is not yet defined */\n    data->state.lastconnect_id = -1;\n    data->state.recent_conn_id = -1;\n    /* and not assigned an id yet */\n    data->id = -1;\n\n    data->progress.flags |= PGRS_HIDE;\n    data->state.current_speed = -1; /* init to negative == impossible */\n  }\n\n  if(result) {\n    Curl_resolver_cleanup(data->state.async.resolver);\n    Curl_dyn_free(&data->state.headerb);\n    Curl_freeset(data);\n    Curl_req_free(&data->req, data);\n    free(data);\n    data = NULL;\n  }\n  else\n    *curl = data;\n\n  return result;\n}\n\nstatic void conn_shutdown(struct Curl_easy *data)\n{\n  DEBUGASSERT(data);\n  infof(data, \"Closing connection\");\n\n  /* possible left-overs from the async name resolvers */\n  Curl_resolver_cancel(data);\n\n  Curl_conn_close(data, SECONDARYSOCKET);\n  Curl_conn_close(data, FIRSTSOCKET);\n}\n\nstatic void conn_free(struct Curl_easy *data, struct connectdata *conn)\n{\n  size_t i;\n\n  DEBUGASSERT(conn);\n\n  for(i = 0; i < ARRAYSIZE(conn->cfilter); ++i) {\n    Curl_conn_cf_discard_all(data, conn, (int)i);\n  }\n\n  Curl_free_idnconverted_hostname(&conn->host);\n  Curl_free_idnconverted_hostname(&conn->conn_to_host);\n#ifndef CURL_DISABLE_PROXY\n  Curl_free_idnconverted_hostname(&conn->http_proxy.host);\n  Curl_free_idnconverted_hostname(&conn->socks_proxy.host);\n  Curl_safefree(conn->http_proxy.user);\n  Curl_safefree(conn->socks_proxy.user);\n  Curl_safefree(conn->http_proxy.passwd);\n  Curl_safefree(conn->socks_proxy.passwd);\n  Curl_safefree(conn->http_proxy.host.rawalloc); /* http proxy name buffer */\n  Curl_safefree(conn->socks_proxy.host.rawalloc); /* socks proxy name buffer */\n#endif\n  Curl_safefree(conn->user);\n  Curl_safefree(conn->passwd);\n  Curl_safefree(conn->sasl_authzid);\n  Curl_safefree(conn->options);\n  Curl_safefree(conn->oauth_bearer);\n  Curl_safefree(conn->host.rawalloc); /* host name buffer */\n  Curl_safefree(conn->conn_to_host.rawalloc); /* host name buffer */\n  Curl_safefree(conn->hostname_resolve);\n  Curl_safefree(conn->secondaryhostname);\n  Curl_safefree(conn->localdev);\n  Curl_ssl_conn_config_cleanup(conn);\n\n#ifdef USE_UNIX_SOCKETS\n  Curl_safefree(conn->unix_domain_socket);\n#endif\n\n  free(conn); /* free all the connection oriented data */\n}\n\n/*\n * Disconnects the given connection. Note the connection may not be the\n * primary connection, like when freeing room in the connection cache or\n * killing of a dead old connection.\n *\n * A connection needs an easy handle when closing down. We support this passed\n * in separately since the connection to get closed here is often already\n * disassociated from an easy handle.\n *\n * This function MUST NOT reset state in the Curl_easy struct if that\n * isn't strictly bound to the life-time of *this* particular connection.\n *\n */\n\nvoid Curl_disconnect(struct Curl_easy *data,\n                     struct connectdata *conn, bool dead_connection)\n{\n  /* there must be a connection to close */\n  DEBUGASSERT(conn);\n\n  /* it must be removed from the connection cache */\n  DEBUGASSERT(!conn->bundle);\n\n  /* there must be an associated transfer */\n  DEBUGASSERT(data);\n\n  /* the transfer must be detached from the connection */\n  DEBUGASSERT(!data->conn);\n\n  DEBUGF(infof(data, \"Curl_disconnect(conn #%\"\n         CURL_FORMAT_CURL_OFF_T \", dead=%d)\",\n         conn->connection_id, dead_connection));\n  /*\n   * If this connection isn't marked to force-close, leave it open if there\n   * are other users of it\n   */\n  if(CONN_INUSE(conn) && !dead_connection) {\n    DEBUGF(infof(data, \"Curl_disconnect when inuse: %zu\", CONN_INUSE(conn)));\n    return;\n  }\n\n  if(conn->dns_entry) {\n    Curl_resolv_unlock(data, conn->dns_entry);\n    conn->dns_entry = NULL;\n  }\n\n  /* Cleanup NTLM connection-related data */\n  Curl_http_auth_cleanup_ntlm(conn);\n\n  /* Cleanup NEGOTIATE connection-related data */\n  Curl_http_auth_cleanup_negotiate(conn);\n\n  if(conn->connect_only)\n    /* treat the connection as dead in CONNECT_ONLY situations */\n    dead_connection = TRUE;\n\n  /* temporarily attach the connection to this transfer handle for the\n     disconnect and shutdown */\n  Curl_attach_connection(data, conn);\n\n  if(conn->handler && conn->handler->disconnect)\n    /* This is set if protocol-specific cleanups should be made */\n    conn->handler->disconnect(data, conn, dead_connection);\n\n  conn_shutdown(data);\n\n  /* detach it again */\n  Curl_detach_connection(data);\n\n  conn_free(data, conn);\n}\n\n/*\n * IsMultiplexingPossible()\n *\n * Return a bitmask with the available multiplexing options for the given\n * requested connection.\n */\nstatic int IsMultiplexingPossible(const struct Curl_easy *handle,\n                                  const struct connectdata *conn)\n{\n  int avail = 0;\n\n  /* If an HTTP protocol and multiplexing is enabled */\n  if((conn->handler->protocol & PROTO_FAMILY_HTTP) &&\n     (!conn->bits.protoconnstart || !conn->bits.close)) {\n\n    if(Curl_multiplex_wanted(handle->multi) &&\n       (handle->state.httpwant >= CURL_HTTP_VERSION_2))\n      /* allows HTTP/2 */\n      avail |= CURLPIPE_MULTIPLEX;\n  }\n  return avail;\n}\n\n#ifndef CURL_DISABLE_PROXY\nstatic bool\nproxy_info_matches(const struct proxy_info *data,\n                   const struct proxy_info *needle)\n{\n  if((data->proxytype == needle->proxytype) &&\n     (data->port == needle->port) &&\n     strcasecompare(data->host.name, needle->host.name))\n    return TRUE;\n\n  return FALSE;\n}\n\nstatic bool\nsocks_proxy_info_matches(const struct proxy_info *data,\n                         const struct proxy_info *needle)\n{\n  if(!proxy_info_matches(data, needle))\n    return FALSE;\n\n  /* the user information is case-sensitive\n     or at least it is not defined as case-insensitive\n     see https://datatracker.ietf.org/doc/html/rfc3986#section-3.2.1 */\n\n  /* curl_strequal does a case insensitive comparison,\n     so do not use it here! */\n  if(Curl_timestrcmp(data->user, needle->user) ||\n     Curl_timestrcmp(data->passwd, needle->passwd))\n    return FALSE;\n  return TRUE;\n}\n#else\n/* disabled, won't get called */\n#define proxy_info_matches(x,y) FALSE\n#define socks_proxy_info_matches(x,y) FALSE\n#endif\n\n/* A connection has to have been idle for a shorter time than 'maxage_conn'\n   (the success rate is just too low after this), or created less than\n   'maxlifetime_conn' ago, to be subject for reuse. */\n\nstatic bool conn_maxage(struct Curl_easy *data,\n                        struct connectdata *conn,\n                        struct curltime now)\n{\n  timediff_t idletime, lifetime;\n\n  idletime = Curl_timediff(now, conn->lastused);\n  idletime /= 1000; /* integer seconds is fine */\n\n  if(idletime > data->set.maxage_conn) {\n    infof(data, \"Too old connection (%\" CURL_FORMAT_TIMEDIFF_T\n          \" seconds idle), disconnect it\", idletime);\n    return TRUE;\n  }\n\n  lifetime = Curl_timediff(now, conn->created);\n  lifetime /= 1000; /* integer seconds is fine */\n\n  if(data->set.maxlifetime_conn && lifetime > data->set.maxlifetime_conn) {\n    infof(data,\n          \"Too old connection (%\" CURL_FORMAT_TIMEDIFF_T\n          \" seconds since creation), disconnect it\", lifetime);\n    return TRUE;\n  }\n\n\n  return FALSE;\n}\n\n/*\n * This function checks if the given connection is dead and extracts it from\n * the connection cache if so.\n *\n * When this is called as a Curl_conncache_foreach() callback, the connection\n * cache lock is held!\n *\n * Returns TRUE if the connection was dead and extracted.\n */\nstatic bool extract_if_dead(struct connectdata *conn,\n                            struct Curl_easy *data)\n{\n  if(!CONN_INUSE(conn)) {\n    /* The check for a dead socket makes sense only if the connection isn't in\n       use */\n    bool dead;\n    struct curltime now = Curl_now();\n    if(conn_maxage(data, conn, now)) {\n      /* avoid check if already too old */\n      dead = TRUE;\n    }\n    else if(conn->handler->connection_check) {\n      /* The protocol has a special method for checking the state of the\n         connection. Use it to check if the connection is dead. */\n      unsigned int state;\n\n      /* briefly attach the connection to this transfer for the purpose of\n         checking it */\n      Curl_attach_connection(data, conn);\n\n      state = conn->handler->connection_check(data, conn, CONNCHECK_ISDEAD);\n      dead = (state & CONNRESULT_DEAD);\n      /* detach the connection again */\n      Curl_detach_connection(data);\n\n    }\n    else {\n      bool input_pending;\n\n      Curl_attach_connection(data, conn);\n      dead = !Curl_conn_is_alive(data, conn, &input_pending);\n      if(input_pending) {\n        /* For reuse, we want a \"clean\" connection state. The includes\n         * that we expect - in general - no waiting input data. Input\n         * waiting might be a TLS Notify Close, for example. We reject\n         * that.\n         * For protocols where data from other end may arrive at\n         * any time (HTTP/2 PING for example), the protocol handler needs\n         * to install its own `connection_check` callback.\n         */\n        dead = TRUE;\n      }\n      Curl_detach_connection(data);\n    }\n\n    if(dead) {\n      infof(data, \"Connection %\" CURL_FORMAT_CURL_OFF_T \" seems to be dead\",\n            conn->connection_id);\n      Curl_conncache_remove_conn(data, conn, FALSE);\n      return TRUE;\n    }\n  }\n  return FALSE;\n}\n\nstruct prunedead {\n  struct Curl_easy *data;\n  struct connectdata *extracted;\n};\n\n/*\n * Wrapper to use extract_if_dead() function in Curl_conncache_foreach()\n *\n */\nstatic int call_extract_if_dead(struct Curl_easy *data,\n                                struct connectdata *conn, void *param)\n{\n  struct prunedead *p = (struct prunedead *)param;\n  if(extract_if_dead(conn, data)) {\n    /* stop the iteration here, pass back the connection that was extracted */\n    p->extracted = conn;\n    return 1;\n  }\n  return 0; /* continue iteration */\n}\n\n/*\n * This function scans the connection cache for half-open/dead connections,\n * closes and removes them. The cleanup is done at most once per second.\n *\n * When called, this transfer has no connection attached.\n */\nstatic void prune_dead_connections(struct Curl_easy *data)\n{\n  struct curltime now = Curl_now();\n  timediff_t elapsed;\n\n  DEBUGASSERT(!data->conn); /* no connection */\n  CONNCACHE_LOCK(data);\n  elapsed =\n    Curl_timediff(now, data->state.conn_cache->last_cleanup);\n  CONNCACHE_UNLOCK(data);\n\n  if(elapsed >= 1000L) {\n    struct prunedead prune;\n    prune.data = data;\n    prune.extracted = NULL;\n    while(Curl_conncache_foreach(data, data->state.conn_cache, &prune,\n                                 call_extract_if_dead)) {\n      /* unlocked */\n\n      /* remove connection from cache */\n      Curl_conncache_remove_conn(data, prune.extracted, TRUE);\n\n      /* disconnect it */\n      Curl_disconnect(data, prune.extracted, TRUE);\n    }\n    CONNCACHE_LOCK(data);\n    data->state.conn_cache->last_cleanup = now;\n    CONNCACHE_UNLOCK(data);\n  }\n}\n\n#ifdef USE_SSH\nstatic bool ssh_config_matches(struct connectdata *one,\n                               struct connectdata *two)\n{\n  return (Curl_safecmp(one->proto.sshc.rsa, two->proto.sshc.rsa) &&\n          Curl_safecmp(one->proto.sshc.rsa_pub, two->proto.sshc.rsa_pub));\n}\n#else\n#define ssh_config_matches(x,y) FALSE\n#endif\n\n/*\n * Given one filled in connection struct (named needle), this function should\n * detect if there already is one that has all the significant details\n * exactly the same and thus should be used instead.\n *\n * If there is a match, this function returns TRUE - and has marked the\n * connection as 'in-use'. It must later be called with ConnectionDone() to\n * return back to 'idle' (unused) state.\n *\n * The force_reuse flag is set if the connection must be used.\n */\nstatic bool\nConnectionExists(struct Curl_easy *data,\n                 struct connectdata *needle,\n                 struct connectdata **usethis,\n                 bool *force_reuse,\n                 bool *waitpipe)\n{\n  struct connectdata *chosen = NULL;\n  bool foundPendingCandidate = FALSE;\n  bool canmultiplex = FALSE;\n  struct connectbundle *bundle;\n  struct Curl_llist_element *curr;\n\n#ifdef USE_NTLM\n  bool wantNTLMhttp = ((data->state.authhost.want &\n                        (CURLAUTH_NTLM | CURLAUTH_NTLM_WB)) &&\n                       (needle->handler->protocol & PROTO_FAMILY_HTTP));\n#ifndef CURL_DISABLE_PROXY\n  bool wantProxyNTLMhttp = (needle->bits.proxy_user_passwd &&\n                            ((data->state.authproxy.want &\n                              (CURLAUTH_NTLM | CURLAUTH_NTLM_WB)) &&\n                             (needle->handler->protocol & PROTO_FAMILY_HTTP)));\n#else\n  bool wantProxyNTLMhttp = FALSE;\n#endif\n#endif\n  /* plain HTTP with upgrade */\n  bool h2upgrade = (data->state.httpwant == CURL_HTTP_VERSION_2_0) &&\n    (needle->handler->protocol & CURLPROTO_HTTP);\n\n  *usethis = NULL;\n  *force_reuse = FALSE;\n  *waitpipe = FALSE;\n\n  /* Look up the bundle with all the connections to this particular host.\n     Locks the connection cache, beware of early returns! */\n  bundle = Curl_conncache_find_bundle(data, needle, data->state.conn_cache);\n  if(!bundle) {\n    CONNCACHE_UNLOCK(data);\n    return FALSE;\n  }\n  infof(data, \"Found bundle for host: %p [%s]\",\n        (void *)bundle, (bundle->multiuse == BUNDLE_MULTIPLEX ?\n                         \"can multiplex\" : \"serially\"));\n\n  /* We can only multiplex iff the transfer allows it AND we know\n   * that the server we want to talk to supports it as well. */\n  canmultiplex = FALSE;\n  if(IsMultiplexingPossible(data, needle)) {\n    if(bundle->multiuse == BUNDLE_UNKNOWN) {\n      if(data->set.pipewait) {\n        infof(data, \"Server doesn't support multiplex yet, wait\");\n        *waitpipe = TRUE;\n        CONNCACHE_UNLOCK(data);\n        return FALSE; /* no reuse */\n      }\n      infof(data, \"Server doesn't support multiplex (yet)\");\n    }\n    else if(bundle->multiuse == BUNDLE_MULTIPLEX) {\n      if(Curl_multiplex_wanted(data->multi))\n        canmultiplex = TRUE;\n      else\n        infof(data, \"Could multiplex, but not asked to\");\n    }\n    else if(bundle->multiuse == BUNDLE_NO_MULTIUSE) {\n      infof(data, \"Can not multiplex, even if we wanted to\");\n    }\n  }\n\n  curr = bundle->conn_list.head;\n  while(curr) {\n    struct connectdata *check = curr->ptr;\n    /* Get next node now. We might remove a dead `check` connection which\n     * would invalidate `curr` as well. */\n    curr = curr->next;\n\n    /* Note that if we use an HTTP proxy in normal mode (no tunneling), we\n     * check connections to that proxy and not to the actual remote server.\n     */\n    if(check->connect_only || check->bits.close)\n      /* connect-only or to-be-closed connections will not be reused */\n      continue;\n\n    if(data->set.ipver != CURL_IPRESOLVE_WHATEVER\n       && data->set.ipver != check->ip_version) {\n      /* skip because the connection is not via the requested IP version */\n      continue;\n    }\n\n    if(!canmultiplex) {\n      if(Curl_resolver_asynch() &&\n         /* remote_ip[0] is NUL only if the resolving of the name hasn't\n            completed yet and until then we don't reuse this connection */\n         !check->primary.remote_ip[0])\n        continue;\n    }\n\n    if(CONN_INUSE(check)) {\n      if(!canmultiplex) {\n        /* transfer can't be multiplexed and check is in use */\n        continue;\n      }\n      else {\n        /* Could multiplex, but not when check belongs to another multi */\n        struct Curl_llist_element *e = check->easyq.head;\n        struct Curl_easy *entry = e->ptr;\n        if(entry->multi != data->multi)\n          continue;\n      }\n    }\n\n    if(!Curl_conn_is_connected(check, FIRSTSOCKET)) {\n      foundPendingCandidate = TRUE;\n      /* Don't pick a connection that hasn't connected yet */\n      infof(data, \"Connection #%\" CURL_FORMAT_CURL_OFF_T\n            \" isn't open enough, can't reuse\", check->connection_id);\n      continue;\n    }\n\n    /* `check` is connected. if it is in use and does not support multiplex,\n     * we cannot use it. */\n    if(!check->bits.multiplex && CONN_INUSE(check))\n      continue;\n\n#ifdef USE_UNIX_SOCKETS\n    if(needle->unix_domain_socket) {\n      if(!check->unix_domain_socket)\n        continue;\n      if(strcmp(needle->unix_domain_socket, check->unix_domain_socket))\n        continue;\n      if(needle->bits.abstract_unix_socket !=\n         check->bits.abstract_unix_socket)\n        continue;\n    }\n    else if(check->unix_domain_socket)\n      continue;\n#endif\n\n    if((needle->handler->flags&PROTOPT_SSL) !=\n       (check->handler->flags&PROTOPT_SSL))\n      /* don't do mixed SSL and non-SSL connections */\n      if(get_protocol_family(check->handler) !=\n         needle->handler->protocol || !check->bits.tls_upgraded)\n        /* except protocols that have been upgraded via TLS */\n        continue;\n\n    if(needle->bits.conn_to_host != check->bits.conn_to_host)\n      /* don't mix connections that use the \"connect to host\" feature and\n       * connections that don't use this feature */\n      continue;\n\n    if(needle->bits.conn_to_port != check->bits.conn_to_port)\n      /* don't mix connections that use the \"connect to port\" feature and\n       * connections that don't use this feature */\n      continue;\n\n#ifndef CURL_DISABLE_PROXY\n    if(needle->bits.httpproxy != check->bits.httpproxy ||\n       needle->bits.socksproxy != check->bits.socksproxy)\n      continue;\n\n    if(needle->bits.socksproxy &&\n      !socks_proxy_info_matches(&needle->socks_proxy,\n                                &check->socks_proxy))\n      continue;\n\n    if(needle->bits.httpproxy) {\n      if(needle->bits.tunnel_proxy != check->bits.tunnel_proxy)\n        continue;\n\n      if(!proxy_info_matches(&needle->http_proxy, &check->http_proxy))\n        continue;\n\n      if(IS_HTTPS_PROXY(needle->http_proxy.proxytype)) {\n        /* https proxies come in different types, http/1.1, h2, ... */\n        if(needle->http_proxy.proxytype != check->http_proxy.proxytype)\n          continue;\n        /* match SSL config to proxy */\n        if(!Curl_ssl_conn_config_match(data, check, TRUE)) {\n          DEBUGF(infof(data,\n            \"Connection #%\" CURL_FORMAT_CURL_OFF_T\n            \" has different SSL proxy parameters, can't reuse\",\n            check->connection_id));\n          continue;\n        }\n        /* the SSL config to the server, which may apply here is checked\n         * further below */\n      }\n    }\n#endif\n\n    if(h2upgrade && !check->httpversion && canmultiplex) {\n      if(data->set.pipewait) {\n        infof(data, \"Server upgrade doesn't support multiplex yet, wait\");\n        *waitpipe = TRUE;\n        CONNCACHE_UNLOCK(data);\n        return FALSE; /* no reuse */\n      }\n      infof(data, \"Server upgrade cannot be used\");\n      continue; /* can't be used atm */\n    }\n\n    if(needle->localdev || needle->localport) {\n      /* If we are bound to a specific local end (IP+port), we must not\n         reuse a random other one, although if we didn't ask for a\n         particular one we can reuse one that was bound.\n\n         This comparison is a bit rough and too strict. Since the input\n         parameters can be specified in numerous ways and still end up the\n         same it would take a lot of processing to make it really accurate.\n         Instead, this matching will assume that reuses of bound connections\n         will most likely also reuse the exact same binding parameters and\n         missing out a few edge cases shouldn't hurt anyone very much.\n      */\n      if((check->localport != needle->localport) ||\n         (check->localportrange != needle->localportrange) ||\n         (needle->localdev &&\n          (!check->localdev || strcmp(check->localdev, needle->localdev))))\n        continue;\n    }\n\n    if(!(needle->handler->flags & PROTOPT_CREDSPERREQUEST)) {\n      /* This protocol requires credentials per connection,\n         so verify that we're using the same name and password as well */\n      if(Curl_timestrcmp(needle->user, check->user) ||\n         Curl_timestrcmp(needle->passwd, check->passwd) ||\n         Curl_timestrcmp(needle->sasl_authzid, check->sasl_authzid) ||\n         Curl_timestrcmp(needle->oauth_bearer, check->oauth_bearer)) {\n        /* one of them was different */\n        continue;\n      }\n    }\n\n    /* GSS delegation differences do not actually affect every connection\n       and auth method, but this check takes precaution before efficiency */\n    if(needle->gssapi_delegation != check->gssapi_delegation)\n      continue;\n\n    /* If looking for HTTP and the HTTP version  we want is less\n     * than the HTTP version of the check connection, continue looking */\n    if((needle->handler->protocol & PROTO_FAMILY_HTTP) &&\n       (((check->httpversion >= 20) &&\n         (data->state.httpwant < CURL_HTTP_VERSION_2_0))\n        || ((check->httpversion >= 30) &&\n            (data->state.httpwant < CURL_HTTP_VERSION_3))))\n      continue;\n#ifdef USE_SSH\n    else if(get_protocol_family(needle->handler) & PROTO_FAMILY_SSH) {\n      if(!ssh_config_matches(needle, check))\n        continue;\n    }\n#endif\n#ifndef CURL_DISABLE_FTP\n    else if(get_protocol_family(needle->handler) & PROTO_FAMILY_FTP) {\n      /* Also match ACCOUNT, ALTERNATIVE-TO-USER, USE_SSL and CCC options */\n      if(Curl_timestrcmp(needle->proto.ftpc.account,\n                         check->proto.ftpc.account) ||\n         Curl_timestrcmp(needle->proto.ftpc.alternative_to_user,\n                         check->proto.ftpc.alternative_to_user) ||\n         (needle->proto.ftpc.use_ssl != check->proto.ftpc.use_ssl) ||\n         (needle->proto.ftpc.ccc != check->proto.ftpc.ccc))\n        continue;\n    }\n#endif\n\n    /* Additional match requirements if talking TLS OR\n     * not talking to a HTTP proxy OR using a tunnel through a proxy */\n    if((needle->handler->flags&PROTOPT_SSL)\n#ifndef CURL_DISABLE_PROXY\n       || !needle->bits.httpproxy || needle->bits.tunnel_proxy\n#endif\n      ) {\n      /* Talking the same protocol scheme or a TLS upgraded protocol in the\n       * same protocol family? */\n      if(!strcasecompare(needle->handler->scheme, check->handler->scheme) &&\n         (get_protocol_family(check->handler) !=\n          needle->handler->protocol || !check->bits.tls_upgraded))\n        continue;\n\n      /* If needle has \"conn_to_*\" set, check must match this */\n      if((needle->bits.conn_to_host && !strcasecompare(\n          needle->conn_to_host.name, check->conn_to_host.name)) ||\n         (needle->bits.conn_to_port &&\n           needle->conn_to_port != check->conn_to_port))\n        continue;\n\n      /* hostname and port must match */\n      if(!strcasecompare(needle->host.name, check->host.name) ||\n         needle->remote_port != check->remote_port)\n        continue;\n\n      /* If talking TLS, check needs to use the same SSL options. */\n      if((needle->handler->flags & PROTOPT_SSL) &&\n         !Curl_ssl_conn_config_match(data, check, FALSE)) {\n        DEBUGF(infof(data,\n                     \"Connection #%\" CURL_FORMAT_CURL_OFF_T\n                     \" has different SSL parameters, can't reuse\",\n                     check->connection_id));\n        continue;\n      }\n    }\n\n#if defined(USE_NTLM)\n    /* If we are looking for an HTTP+NTLM connection, check if this is\n       already authenticating with the right credentials. If not, keep\n       looking so that we can reuse NTLM connections if\n       possible. (Especially we must not reuse the same connection if\n       partway through a handshake!) */\n    if(wantNTLMhttp) {\n      if(Curl_timestrcmp(needle->user, check->user) ||\n         Curl_timestrcmp(needle->passwd, check->passwd)) {\n\n        /* we prefer a credential match, but this is at least a connection\n           that can be reused and \"upgraded\" to NTLM */\n        if(check->http_ntlm_state == NTLMSTATE_NONE)\n          chosen = check;\n        continue;\n      }\n    }\n    else if(check->http_ntlm_state != NTLMSTATE_NONE) {\n      /* Connection is using NTLM auth but we don't want NTLM */\n      continue;\n    }\n\n#ifndef CURL_DISABLE_PROXY\n    /* Same for Proxy NTLM authentication */\n    if(wantProxyNTLMhttp) {\n      /* Both check->http_proxy.user and check->http_proxy.passwd can be\n       * NULL */\n      if(!check->http_proxy.user || !check->http_proxy.passwd)\n        continue;\n\n      if(Curl_timestrcmp(needle->http_proxy.user,\n                         check->http_proxy.user) ||\n         Curl_timestrcmp(needle->http_proxy.passwd,\n                         check->http_proxy.passwd))\n        continue;\n    }\n    else if(check->proxy_ntlm_state != NTLMSTATE_NONE) {\n      /* Proxy connection is using NTLM auth but we don't want NTLM */\n      continue;\n    }\n#endif\n    if(wantNTLMhttp || wantProxyNTLMhttp) {\n      /* Credentials are already checked, we may use this connection.\n       * With NTLM being weird as it is, we MUST use a\n       * connection where it has already been fully negotiated.\n       * If it has not, we keep on looking for a better one. */\n      chosen = check;\n\n      if((wantNTLMhttp &&\n         (check->http_ntlm_state != NTLMSTATE_NONE)) ||\n          (wantProxyNTLMhttp &&\n           (check->proxy_ntlm_state != NTLMSTATE_NONE))) {\n        /* We must use this connection, no other */\n        *force_reuse = TRUE;\n        break;\n      }\n      /* Continue look up for a better connection */\n      continue;\n    }\n#endif\n\n    if(CONN_INUSE(check)) {\n      DEBUGASSERT(canmultiplex);\n      DEBUGASSERT(check->bits.multiplex);\n      /* If multiplexed, make sure we don't go over concurrency limit */\n      if(CONN_INUSE(check) >=\n              Curl_multi_max_concurrent_streams(data->multi)) {\n        infof(data, \"client side MAX_CONCURRENT_STREAMS reached\"\n              \", skip (%zu)\", CONN_INUSE(check));\n        continue;\n      }\n      if(CONN_INUSE(check) >=\n              Curl_conn_get_max_concurrent(data, check, FIRSTSOCKET)) {\n        infof(data, \"MAX_CONCURRENT_STREAMS reached, skip (%zu)\",\n              CONN_INUSE(check));\n        continue;\n      }\n      /* When not multiplexed, we have a match here! */\n      infof(data, \"Multiplexed connection found\");\n    }\n    else if(extract_if_dead(check, data)) {\n      /* disconnect it */\n      Curl_disconnect(data, check, TRUE);\n      continue;\n    }\n\n    /* We have found a connection. Let's stop searching. */\n    chosen = check;\n    break;\n  } /* loop over connection bundle */\n\n  if(chosen) {\n    /* mark it as used before releasing the lock */\n    Curl_attach_connection(data, chosen);\n    CONNCACHE_UNLOCK(data);\n    *usethis = chosen;\n    return TRUE; /* yes, we found one to use! */\n  }\n  CONNCACHE_UNLOCK(data);\n\n  if(foundPendingCandidate && data->set.pipewait) {\n    infof(data,\n          \"Found pending candidate for reuse and CURLOPT_PIPEWAIT is set\");\n    *waitpipe = TRUE;\n  }\n\n  return FALSE; /* no matching connecting exists */\n}\n\n/*\n * verboseconnect() displays verbose information after a connect\n */\n#ifndef CURL_DISABLE_VERBOSE_STRINGS\nvoid Curl_verboseconnect(struct Curl_easy *data,\n                         struct connectdata *conn, int sockindex)\n{\n  if(data->set.verbose && sockindex == SECONDARYSOCKET)\n    infof(data, \"Connected 2nd connection to %s port %u\",\n          conn->secondary.remote_ip, conn->secondary.remote_port);\n  else\n    infof(data, \"Connected to %s (%s) port %u\",\n          CURL_CONN_HOST_DISPNAME(conn), conn->primary.remote_ip,\n          conn->primary.remote_port);\n}\n#endif\n\n/*\n * Allocate and initialize a new connectdata object.\n */\nstatic struct connectdata *allocate_conn(struct Curl_easy *data)\n{\n  struct connectdata *conn = calloc(1, sizeof(struct connectdata));\n  if(!conn)\n    return NULL;\n\n  /* and we setup a few fields in case we end up actually using this struct */\n\n  conn->sock[FIRSTSOCKET] = CURL_SOCKET_BAD;     /* no file descriptor */\n  conn->sock[SECONDARYSOCKET] = CURL_SOCKET_BAD; /* no file descriptor */\n  conn->sockfd = CURL_SOCKET_BAD;\n  conn->writesockfd = CURL_SOCKET_BAD;\n  conn->connection_id = -1;    /* no ID */\n  conn->primary.remote_port = -1; /* unknown at this point */\n  conn->remote_port = -1; /* unknown at this point */\n\n  /* Default protocol-independent behavior doesn't support persistent\n     connections, so we set this to force-close. Protocols that support\n     this need to set this to FALSE in their \"curl_do\" functions. */\n  connclose(conn, \"Default to force-close\");\n\n  /* Store creation time to help future close decision making */\n  conn->created = Curl_now();\n\n  /* Store current time to give a baseline to keepalive connection times. */\n  conn->keepalive = conn->created;\n\n#ifndef CURL_DISABLE_PROXY\n  conn->http_proxy.proxytype = data->set.proxytype;\n  conn->socks_proxy.proxytype = CURLPROXY_SOCKS4;\n\n  /* note that these two proxy bits are now just on what looks to be\n     requested, they may be altered down the road */\n  conn->bits.proxy = (data->set.str[STRING_PROXY] &&\n                      *data->set.str[STRING_PROXY]) ? TRUE : FALSE;\n  conn->bits.httpproxy = (conn->bits.proxy &&\n                          (conn->http_proxy.proxytype == CURLPROXY_HTTP ||\n                           conn->http_proxy.proxytype == CURLPROXY_HTTP_1_0 ||\n                           IS_HTTPS_PROXY(conn->http_proxy.proxytype))) ?\n    TRUE : FALSE;\n  conn->bits.socksproxy = (conn->bits.proxy &&\n                           !conn->bits.httpproxy) ? TRUE : FALSE;\n\n  if(data->set.str[STRING_PRE_PROXY] && *data->set.str[STRING_PRE_PROXY]) {\n    conn->bits.proxy = TRUE;\n    conn->bits.socksproxy = TRUE;\n  }\n\n  conn->bits.proxy_user_passwd =\n    (data->state.aptr.proxyuser) ? TRUE : FALSE;\n  conn->bits.tunnel_proxy = data->set.tunnel_thru_httpproxy;\n#endif /* CURL_DISABLE_PROXY */\n\n#ifndef CURL_DISABLE_FTP\n  conn->bits.ftp_use_epsv = data->set.ftp_use_epsv;\n  conn->bits.ftp_use_eprt = data->set.ftp_use_eprt;\n#endif\n  conn->ip_version = data->set.ipver;\n  conn->connect_only = data->set.connect_only;\n  conn->transport = TRNSPRT_TCP; /* most of them are TCP streams */\n\n#if !defined(CURL_DISABLE_HTTP) && defined(USE_NTLM) && \\\n    defined(NTLM_WB_ENABLED)\n  conn->ntlm.ntlm_auth_hlpr_socket = CURL_SOCKET_BAD;\n  conn->proxyntlm.ntlm_auth_hlpr_socket = CURL_SOCKET_BAD;\n#endif\n\n  /* Initialize the easy handle list */\n  Curl_llist_init(&conn->easyq, NULL);\n\n#ifdef HAVE_GSSAPI\n  conn->data_prot = PROT_CLEAR;\n#endif\n\n  /* Store the local bind parameters that will be used for this connection */\n  if(data->set.str[STRING_DEVICE]) {\n    conn->localdev = strdup(data->set.str[STRING_DEVICE]);\n    if(!conn->localdev)\n      goto error;\n  }\n#ifndef CURL_DISABLE_BINDLOCAL\n  conn->localportrange = data->set.localportrange;\n  conn->localport = data->set.localport;\n#endif\n\n  /* the close socket stuff needs to be copied to the connection struct as\n     it may live on without (this specific) Curl_easy */\n  conn->fclosesocket = data->set.fclosesocket;\n  conn->closesocket_client = data->set.closesocket_client;\n  conn->lastused = conn->created;\n  conn->gssapi_delegation = data->set.gssapi_delegation;\n\n  return conn;\nerror:\n\n  free(conn->localdev);\n  free(conn);\n  return NULL;\n}\n\nconst struct Curl_handler *Curl_get_scheme_handler(const char *scheme)\n{\n  return Curl_getn_scheme_handler(scheme, strlen(scheme));\n}\n\n/* returns the handler if the given scheme is built-in */\nconst struct Curl_handler *Curl_getn_scheme_handler(const char *scheme,\n                                                    size_t len)\n{\n  /* table generated by schemetable.c:\n     1. gcc schemetable.c && ./a.out\n     2. check how small the table gets\n     3. tweak the hash algorithm, then rerun from 1\n     4. when the table is good enough\n     5. copy the table into this source code\n     6. make sure this function uses the same hash function that worked for\n     schemetable.c\n     7. if needed, adjust the #ifdefs in schemetable.c and rerun\n     */\n  static const struct Curl_handler * const protocols[67] = {\n#ifndef CURL_DISABLE_FILE\n    &Curl_handler_file,\n#else\n    NULL,\n#endif\n    NULL, NULL,\n#if defined(USE_SSL) && !defined(CURL_DISABLE_GOPHER)\n    &Curl_handler_gophers,\n#else\n    NULL,\n#endif\n    NULL,\n#ifdef USE_LIBRTMP\n    &Curl_handler_rtmpe,\n#else\n    NULL,\n#endif\n#ifndef CURL_DISABLE_SMTP\n    &Curl_handler_smtp,\n#else\n    NULL,\n#endif\n#if defined(USE_SSH)\n    &Curl_handler_sftp,\n#else\n    NULL,\n#endif\n#if !defined(CURL_DISABLE_SMB) && defined(USE_CURL_NTLM_CORE) && \\\n  (SIZEOF_CURL_OFF_T > 4)\n    &Curl_handler_smb,\n#else\n    NULL,\n#endif\n#if defined(USE_SSL) && !defined(CURL_DISABLE_SMTP)\n    &Curl_handler_smtps,\n#else\n    NULL,\n#endif\n#ifndef CURL_DISABLE_TELNET\n    &Curl_handler_telnet,\n#else\n    NULL,\n#endif\n#ifndef CURL_DISABLE_GOPHER\n    &Curl_handler_gopher,\n#else\n    NULL,\n#endif\n#ifndef CURL_DISABLE_TFTP\n    &Curl_handler_tftp,\n#else\n    NULL,\n#endif\n    NULL, NULL, NULL,\n#if defined(USE_SSL) && !defined(CURL_DISABLE_FTP)\n    &Curl_handler_ftps,\n#else\n    NULL,\n#endif\n#ifndef CURL_DISABLE_HTTP\n    &Curl_handler_http,\n#else\n    NULL,\n#endif\n#ifndef CURL_DISABLE_IMAP\n    &Curl_handler_imap,\n#else\n    NULL,\n#endif\n#ifdef USE_LIBRTMP\n    &Curl_handler_rtmps,\n#else\n    NULL,\n#endif\n#ifdef USE_LIBRTMP\n    &Curl_handler_rtmpt,\n#else\n    NULL,\n#endif\n    NULL, NULL, NULL,\n#if !defined(CURL_DISABLE_LDAP) && \\\n  !defined(CURL_DISABLE_LDAPS) && \\\n  ((defined(USE_OPENLDAP) && defined(USE_SSL)) || \\\n   (!defined(USE_OPENLDAP) && defined(HAVE_LDAP_SSL)))\n    &Curl_handler_ldaps,\n#else\n    NULL,\n#endif\n#if defined(USE_WEBSOCKETS) && \\\n  defined(USE_SSL) && !defined(CURL_DISABLE_HTTP)\n    &Curl_handler_wss,\n#else\n    NULL,\n#endif\n#if defined(USE_SSL) && !defined(CURL_DISABLE_HTTP)\n    &Curl_handler_https,\n#else\n    NULL,\n#endif\n    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n#ifndef CURL_DISABLE_RTSP\n    &Curl_handler_rtsp,\n#else\n    NULL,\n#endif\n#if defined(USE_SSL) && !defined(CURL_DISABLE_SMB) && \\\n  defined(USE_CURL_NTLM_CORE) && (SIZEOF_CURL_OFF_T > 4)\n    &Curl_handler_smbs,\n#else\n    NULL,\n#endif\n#if defined(USE_SSH) && !defined(USE_WOLFSSH)\n    &Curl_handler_scp,\n#else\n    NULL,\n#endif\n    NULL, NULL, NULL,\n#ifndef CURL_DISABLE_POP3\n    &Curl_handler_pop3,\n#else\n    NULL,\n#endif\n    NULL, NULL,\n#ifdef USE_LIBRTMP\n    &Curl_handler_rtmp,\n#else\n    NULL,\n#endif\n    NULL, NULL, NULL,\n#ifdef USE_LIBRTMP\n    &Curl_handler_rtmpte,\n#else\n    NULL,\n#endif\n    NULL, NULL, NULL,\n#ifndef CURL_DISABLE_DICT\n    &Curl_handler_dict,\n#else\n    NULL,\n#endif\n    NULL, NULL, NULL,\n#ifndef CURL_DISABLE_MQTT\n    &Curl_handler_mqtt,\n#else\n    NULL,\n#endif\n#if defined(USE_SSL) && !defined(CURL_DISABLE_POP3)\n    &Curl_handler_pop3s,\n#else\n    NULL,\n#endif\n#if defined(USE_SSL) && !defined(CURL_DISABLE_IMAP)\n    &Curl_handler_imaps,\n#else\n    NULL,\n#endif\n    NULL,\n#if defined(USE_WEBSOCKETS) && !defined(CURL_DISABLE_HTTP)\n    &Curl_handler_ws,\n#else\n    NULL,\n#endif\n    NULL,\n#ifdef USE_LIBRTMP\n    &Curl_handler_rtmpts,\n#else\n    NULL,\n#endif\n#ifndef CURL_DISABLE_LDAP\n    &Curl_handler_ldap,\n#else\n    NULL,\n#endif\n    NULL, NULL,\n#ifndef CURL_DISABLE_FTP\n    &Curl_handler_ftp,\n#else\n    NULL,\n#endif\n  };\n\n  if(len && (len <= 7)) {\n    const char *s = scheme;\n    size_t l = len;\n    const struct Curl_handler *h;\n    unsigned int c = 978;\n    while(l) {\n      c <<= 5;\n      c += Curl_raw_tolower(*s);\n      s++;\n      l--;\n    }\n\n    h = protocols[c % 67];\n    if(h && strncasecompare(scheme, h->scheme, len) && !h->scheme[len])\n      return h;\n  }\n  return NULL;\n}\n\nstatic CURLcode findprotocol(struct Curl_easy *data,\n                             struct connectdata *conn,\n                             const char *protostr)\n{\n  const struct Curl_handler *p = Curl_get_scheme_handler(protostr);\n\n  if(p && /* Protocol found in table. Check if allowed */\n     (data->set.allowed_protocols & p->protocol)) {\n\n    /* it is allowed for \"normal\" request, now do an extra check if this is\n       the result of a redirect */\n    if(data->state.this_is_a_follow &&\n       !(data->set.redir_protocols & p->protocol))\n      /* nope, get out */\n      ;\n    else {\n      /* Perform setup complement if some. */\n      conn->handler = conn->given = p;\n      /* 'port' and 'remote_port' are set in setup_connection_internals() */\n      return CURLE_OK;\n    }\n  }\n\n  /* The protocol was not found in the table, but we don't have to assign it\n     to anything since it is already assigned to a dummy-struct in the\n     create_conn() function when the connectdata struct is allocated. */\n  failf(data, \"Protocol \\\"%s\\\" %s%s\", protostr,\n        p ? \"disabled\" : \"not supported\",\n        data->state.this_is_a_follow ? \" (in redirect)\":\"\");\n\n  return CURLE_UNSUPPORTED_PROTOCOL;\n}\n\n\nCURLcode Curl_uc_to_curlcode(CURLUcode uc)\n{\n  switch(uc) {\n  default:\n    return CURLE_URL_MALFORMAT;\n  case CURLUE_UNSUPPORTED_SCHEME:\n    return CURLE_UNSUPPORTED_PROTOCOL;\n  case CURLUE_OUT_OF_MEMORY:\n    return CURLE_OUT_OF_MEMORY;\n  case CURLUE_USER_NOT_ALLOWED:\n    return CURLE_LOGIN_DENIED;\n  }\n}\n\n#ifdef ENABLE_IPV6\n/*\n * If the URL was set with an IPv6 numerical address with a zone id part, set\n * the scope_id based on that!\n */\n\nstatic void zonefrom_url(CURLU *uh, struct Curl_easy *data,\n                         struct connectdata *conn)\n{\n  char *zoneid;\n  CURLUcode uc = curl_url_get(uh, CURLUPART_ZONEID, &zoneid, 0);\n#ifdef CURL_DISABLE_VERBOSE_STRINGS\n  (void)data;\n#endif\n\n  if(!uc && zoneid) {\n    char *endp;\n    unsigned long scope = strtoul(zoneid, &endp, 10);\n    if(!*endp && (scope < UINT_MAX))\n      /* A plain number, use it directly as a scope id. */\n      conn->scope_id = (unsigned int)scope;\n#if defined(HAVE_IF_NAMETOINDEX)\n    else {\n#elif defined(_WIN32)\n    else if(Curl_if_nametoindex) {\n#endif\n\n#if defined(HAVE_IF_NAMETOINDEX) || defined(_WIN32)\n      /* Zone identifier is not numeric */\n      unsigned int scopeidx = 0;\n#if defined(_WIN32)\n      scopeidx = Curl_if_nametoindex(zoneid);\n#else\n      scopeidx = if_nametoindex(zoneid);\n#endif\n      if(!scopeidx) {\n#ifndef CURL_DISABLE_VERBOSE_STRINGS\n        char buffer[STRERROR_LEN];\n        infof(data, \"Invalid zoneid: %s; %s\", zoneid,\n              Curl_strerror(errno, buffer, sizeof(buffer)));\n#endif\n      }\n      else\n        conn->scope_id = scopeidx;\n    }\n#endif /* HAVE_IF_NAMETOINDEX || _WIN32 */\n\n    free(zoneid);\n  }\n}\n#else\n#define zonefrom_url(a,b,c) Curl_nop_stmt\n#endif\n\n/*\n * Parse URL and fill in the relevant members of the connection struct.\n */\nstatic CURLcode parseurlandfillconn(struct Curl_easy *data,\n                                    struct connectdata *conn)\n{\n  CURLcode result;\n  CURLU *uh;\n  CURLUcode uc;\n  char *hostname;\n  bool use_set_uh = (data->set.uh && !data->state.this_is_a_follow);\n\n  up_free(data); /* cleanup previous leftovers first */\n\n  /* parse the URL */\n  if(use_set_uh) {\n    uh = data->state.uh = curl_url_dup(data->set.uh);\n  }\n  else {\n    uh = data->state.uh = curl_url();\n  }\n\n  if(!uh)\n    return CURLE_OUT_OF_MEMORY;\n\n  if(data->set.str[STRING_DEFAULT_PROTOCOL] &&\n     !Curl_is_absolute_url(data->state.url, NULL, 0, TRUE)) {\n    char *url = aprintf(\"%s://%s\", data->set.str[STRING_DEFAULT_PROTOCOL],\n                        data->state.url);\n    if(!url)\n      return CURLE_OUT_OF_MEMORY;\n    if(data->state.url_alloc)\n      free(data->state.url);\n    data->state.url = url;\n    data->state.url_alloc = TRUE;\n  }\n\n  if(!use_set_uh) {\n    char *newurl;\n    uc = curl_url_set(uh, CURLUPART_URL, data->state.url,\n                      CURLU_GUESS_SCHEME |\n                      CURLU_NON_SUPPORT_SCHEME |\n                      (data->set.disallow_username_in_url ?\n                       CURLU_DISALLOW_USER : 0) |\n                      (data->set.path_as_is ? CURLU_PATH_AS_IS : 0));\n    if(uc) {\n      failf(data, \"URL rejected: %s\", curl_url_strerror(uc));\n      return Curl_uc_to_curlcode(uc);\n    }\n\n    /* after it was parsed, get the generated normalized version */\n    uc = curl_url_get(uh, CURLUPART_URL, &newurl, 0);\n    if(uc)\n      return Curl_uc_to_curlcode(uc);\n    if(data->state.url_alloc)\n      free(data->state.url);\n    data->state.url = newurl;\n    data->state.url_alloc = TRUE;\n  }\n\n  uc = curl_url_get(uh, CURLUPART_SCHEME, &data->state.up.scheme, 0);\n  if(uc)\n    return Curl_uc_to_curlcode(uc);\n\n  uc = curl_url_get(uh, CURLUPART_HOST, &data->state.up.hostname, 0);\n  if(uc) {\n    if(!strcasecompare(\"file\", data->state.up.scheme))\n      return CURLE_OUT_OF_MEMORY;\n  }\n  else if(strlen(data->state.up.hostname) > MAX_URL_LEN) {\n    failf(data, \"Too long host name (maximum is %d)\", MAX_URL_LEN);\n    return CURLE_URL_MALFORMAT;\n  }\n  hostname = data->state.up.hostname;\n\n  if(hostname && hostname[0] == '[') {\n    /* This looks like an IPv6 address literal. See if there is an address\n       scope. */\n    size_t hlen;\n    conn->bits.ipv6_ip = TRUE;\n    /* cut off the brackets! */\n    hostname++;\n    hlen = strlen(hostname);\n    hostname[hlen - 1] = 0;\n\n    zonefrom_url(uh, data, conn);\n  }\n\n  /* make sure the connect struct gets its own copy of the host name */\n  conn->host.rawalloc = strdup(hostname ? hostname : \"\");\n  if(!conn->host.rawalloc)\n    return CURLE_OUT_OF_MEMORY;\n  conn->host.name = conn->host.rawalloc;\n\n  /*************************************************************\n   * IDN-convert the hostnames\n   *************************************************************/\n  result = Curl_idnconvert_hostname(&conn->host);\n  if(result)\n    return result;\n\n#ifndef CURL_DISABLE_HSTS\n  /* HSTS upgrade */\n  if(data->hsts && strcasecompare(\"http\", data->state.up.scheme)) {\n    /* This MUST use the IDN decoded name */\n    if(Curl_hsts(data->hsts, conn->host.name, TRUE)) {\n      char *url;\n      Curl_safefree(data->state.up.scheme);\n      uc = curl_url_set(uh, CURLUPART_SCHEME, \"https\", 0);\n      if(uc)\n        return Curl_uc_to_curlcode(uc);\n      if(data->state.url_alloc)\n        Curl_safefree(data->state.url);\n      /* after update, get the updated version */\n      uc = curl_url_get(uh, CURLUPART_URL, &url, 0);\n      if(uc)\n        return Curl_uc_to_curlcode(uc);\n      uc = curl_url_get(uh, CURLUPART_SCHEME, &data->state.up.scheme, 0);\n      if(uc) {\n        free(url);\n        return Curl_uc_to_curlcode(uc);\n      }\n      data->state.url = url;\n      data->state.url_alloc = TRUE;\n      infof(data, \"Switched from HTTP to HTTPS due to HSTS => %s\",\n            data->state.url);\n    }\n  }\n#endif\n\n  result = findprotocol(data, conn, data->state.up.scheme);\n  if(result)\n    return result;\n\n  /*\n   * User name and password set with their own options override the\n   * credentials possibly set in the URL.\n   */\n  if(!data->set.str[STRING_PASSWORD]) {\n    uc = curl_url_get(uh, CURLUPART_PASSWORD, &data->state.up.password, 0);\n    if(!uc) {\n      char *decoded;\n      result = Curl_urldecode(data->state.up.password, 0, &decoded, NULL,\n                              conn->handler->flags&PROTOPT_USERPWDCTRL ?\n                              REJECT_ZERO : REJECT_CTRL);\n      if(result)\n        return result;\n      conn->passwd = decoded;\n      result = Curl_setstropt(&data->state.aptr.passwd, decoded);\n      if(result)\n        return result;\n    }\n    else if(uc != CURLUE_NO_PASSWORD)\n      return Curl_uc_to_curlcode(uc);\n  }\n\n  if(!data->set.str[STRING_USERNAME]) {\n    /* we don't use the URL API's URL decoder option here since it rejects\n       control codes and we want to allow them for some schemes in the user\n       and password fields */\n    uc = curl_url_get(uh, CURLUPART_USER, &data->state.up.user, 0);\n    if(!uc) {\n      char *decoded;\n      result = Curl_urldecode(data->state.up.user, 0, &decoded, NULL,\n                              conn->handler->flags&PROTOPT_USERPWDCTRL ?\n                              REJECT_ZERO : REJECT_CTRL);\n      if(result)\n        return result;\n      conn->user = decoded;\n      result = Curl_setstropt(&data->state.aptr.user, decoded);\n    }\n    else if(uc != CURLUE_NO_USER)\n      return Curl_uc_to_curlcode(uc);\n    else if(data->state.aptr.passwd) {\n      /* no user was set but a password, set a blank user */\n      result = Curl_setstropt(&data->state.aptr.user, \"\");\n    }\n    if(result)\n      return result;\n  }\n\n  uc = curl_url_get(uh, CURLUPART_OPTIONS, &data->state.up.options,\n                    CURLU_URLDECODE);\n  if(!uc) {\n    conn->options = strdup(data->state.up.options);\n    if(!conn->options)\n      return CURLE_OUT_OF_MEMORY;\n  }\n  else if(uc != CURLUE_NO_OPTIONS)\n    return Curl_uc_to_curlcode(uc);\n\n  uc = curl_url_get(uh, CURLUPART_PATH, &data->state.up.path,\n                    CURLU_URLENCODE);\n  if(uc)\n    return Curl_uc_to_curlcode(uc);\n\n  uc = curl_url_get(uh, CURLUPART_PORT, &data->state.up.port,\n                    CURLU_DEFAULT_PORT);\n  if(uc) {\n    if(!strcasecompare(\"file\", data->state.up.scheme))\n      return CURLE_OUT_OF_MEMORY;\n  }\n  else {\n    unsigned long port = strtoul(data->state.up.port, NULL, 10);\n    conn->primary.remote_port = conn->remote_port =\n      (data->set.use_port && data->state.allow_port) ?\n      data->set.use_port : curlx_ultous(port);\n  }\n\n  (void)curl_url_get(uh, CURLUPART_QUERY, &data->state.up.query, 0);\n\n#ifdef ENABLE_IPV6\n  if(data->set.scope_id)\n    /* Override any scope that was set above.  */\n    conn->scope_id = data->set.scope_id;\n#endif\n\n  return CURLE_OK;\n}\n\n\n/*\n * If we're doing a resumed transfer, we need to setup our stuff\n * properly.\n */\nstatic CURLcode setup_range(struct Curl_easy *data)\n{\n  struct UrlState *s = &data->state;\n  s->resume_from = data->set.set_resume_from;\n  if(s->resume_from || data->set.str[STRING_SET_RANGE]) {\n    if(s->rangestringalloc)\n      free(s->range);\n\n    if(s->resume_from)\n      s->range = aprintf(\"%\" CURL_FORMAT_CURL_OFF_T \"-\", s->resume_from);\n    else\n      s->range = strdup(data->set.str[STRING_SET_RANGE]);\n\n    s->rangestringalloc = (s->range) ? TRUE : FALSE;\n\n    if(!s->range)\n      return CURLE_OUT_OF_MEMORY;\n\n    /* tell ourselves to fetch this range */\n    s->use_range = TRUE;        /* enable range download */\n  }\n  else\n    s->use_range = FALSE; /* disable range download */\n\n  return CURLE_OK;\n}\n\n\n/*\n * setup_connection_internals() -\n *\n * Setup connection internals specific to the requested protocol in the\n * Curl_easy. This is inited and setup before the connection is made but\n * is about the particular protocol that is to be used.\n *\n * This MUST get called after proxy magic has been figured out.\n */\nstatic CURLcode setup_connection_internals(struct Curl_easy *data,\n                                           struct connectdata *conn)\n{\n  const struct Curl_handler *p;\n  CURLcode result;\n\n  /* Perform setup complement if some. */\n  p = conn->handler;\n\n  if(p->setup_connection) {\n    result = (*p->setup_connection)(data, conn);\n\n    if(result)\n      return result;\n\n    p = conn->handler;              /* May have changed. */\n  }\n\n  if(conn->primary.remote_port < 0)\n    /* we check for -1 here since if proxy was detected already, this\n       was very likely already set to the proxy port */\n    conn->primary.remote_port = p->defport;\n\n  return CURLE_OK;\n}\n\n\n#ifndef CURL_DISABLE_PROXY\n\n#ifndef CURL_DISABLE_HTTP\n/****************************************************************\n* Detect what (if any) proxy to use. Remember that this selects a host\n* name and is not limited to HTTP proxies only.\n* The returned pointer must be freed by the caller (unless NULL)\n****************************************************************/\nstatic char *detect_proxy(struct Curl_easy *data,\n                          struct connectdata *conn)\n{\n  char *proxy = NULL;\n\n  /* If proxy was not specified, we check for default proxy environment\n   * variables, to enable i.e Lynx compliance:\n   *\n   * http_proxy=http://some.server.dom:port/\n   * https_proxy=http://some.server.dom:port/\n   * ftp_proxy=http://some.server.dom:port/\n   * no_proxy=domain1.dom,host.domain2.dom\n   *   (a comma-separated list of hosts which should\n   *   not be proxied, or an asterisk to override\n   *   all proxy variables)\n   * all_proxy=http://some.server.dom:port/\n   *   (seems to exist for the CERN www lib. Probably\n   *   the first to check for.)\n   *\n   * For compatibility, the all-uppercase versions of these variables are\n   * checked if the lowercase versions don't exist.\n   */\n  char proxy_env[128];\n  const char *protop = conn->handler->scheme;\n  char *envp = proxy_env;\n#ifdef CURL_DISABLE_VERBOSE_STRINGS\n  (void)data;\n#endif\n\n  /* Now, build <protocol>_proxy and check for such a one to use */\n  while(*protop)\n    *envp++ = Curl_raw_tolower(*protop++);\n\n  /* append _proxy */\n  strcpy(envp, \"_proxy\");\n\n  /* read the protocol proxy: */\n  proxy = curl_getenv(proxy_env);\n\n  /*\n   * We don't try the uppercase version of HTTP_PROXY because of\n   * security reasons:\n   *\n   * When curl is used in a webserver application\n   * environment (cgi or php), this environment variable can\n   * be controlled by the web server user by setting the\n   * http header 'Proxy:' to some value.\n   *\n   * This can cause 'internal' http/ftp requests to be\n   * arbitrarily redirected by any external attacker.\n   */\n  if(!proxy && !strcasecompare(\"http_proxy\", proxy_env)) {\n    /* There was no lowercase variable, try the uppercase version: */\n    Curl_strntoupper(proxy_env, proxy_env, sizeof(proxy_env));\n    proxy = curl_getenv(proxy_env);\n  }\n\n  envp = proxy_env;\n  if(!proxy) {\n#ifdef USE_WEBSOCKETS\n    /* websocket proxy fallbacks */\n    if(strcasecompare(\"ws_proxy\", proxy_env)) {\n      proxy = curl_getenv(\"http_proxy\");\n    }\n    else if(strcasecompare(\"wss_proxy\", proxy_env)) {\n      proxy = curl_getenv(\"https_proxy\");\n      if(!proxy)\n        proxy = curl_getenv(\"HTTPS_PROXY\");\n    }\n    if(!proxy) {\n#endif\n      envp = (char *)\"all_proxy\";\n      proxy = curl_getenv(envp); /* default proxy to use */\n      if(!proxy) {\n        envp = (char *)\"ALL_PROXY\";\n        proxy = curl_getenv(envp);\n      }\n#ifdef USE_WEBSOCKETS\n    }\n#endif\n  }\n  if(proxy)\n    infof(data, \"Uses proxy env variable %s == '%s'\", envp, proxy);\n\n  return proxy;\n}\n#endif /* CURL_DISABLE_HTTP */\n\n/*\n * If this is supposed to use a proxy, we need to figure out the proxy\n * host name, so that we can reuse an existing connection\n * that may exist registered to the same proxy host.\n */\nstatic CURLcode parse_proxy(struct Curl_easy *data,\n                            struct connectdata *conn, char *proxy,\n                            curl_proxytype proxytype)\n{\n  char *portptr = NULL;\n  int port = -1;\n  char *proxyuser = NULL;\n  char *proxypasswd = NULL;\n  char *host = NULL;\n  bool sockstype;\n  CURLUcode uc;\n  struct proxy_info *proxyinfo;\n  CURLU *uhp = curl_url();\n  CURLcode result = CURLE_OK;\n  char *scheme = NULL;\n#ifdef USE_UNIX_SOCKETS\n  char *path = NULL;\n  bool is_unix_proxy = FALSE;\n#endif\n\n\n  if(!uhp) {\n    result = CURLE_OUT_OF_MEMORY;\n    goto error;\n  }\n\n  /* When parsing the proxy, allowing non-supported schemes since we have\n     these made up ones for proxies. Guess scheme for URLs without it. */\n  uc = curl_url_set(uhp, CURLUPART_URL, proxy,\n                    CURLU_NON_SUPPORT_SCHEME|CURLU_GUESS_SCHEME);\n  if(!uc) {\n    /* parsed okay as a URL */\n    uc = curl_url_get(uhp, CURLUPART_SCHEME, &scheme, 0);\n    if(uc) {\n      result = CURLE_OUT_OF_MEMORY;\n      goto error;\n    }\n\n    if(strcasecompare(\"https\", scheme)) {\n      if(proxytype != CURLPROXY_HTTPS2)\n        proxytype = CURLPROXY_HTTPS;\n      else\n        proxytype = CURLPROXY_HTTPS2;\n    }\n    else if(strcasecompare(\"socks5h\", scheme))\n      proxytype = CURLPROXY_SOCKS5_HOSTNAME;\n    else if(strcasecompare(\"socks5\", scheme))\n      proxytype = CURLPROXY_SOCKS5;\n    else if(strcasecompare(\"socks4a\", scheme))\n      proxytype = CURLPROXY_SOCKS4A;\n    else if(strcasecompare(\"socks4\", scheme) ||\n            strcasecompare(\"socks\", scheme))\n      proxytype = CURLPROXY_SOCKS4;\n    else if(strcasecompare(\"http\", scheme))\n      ; /* leave it as HTTP or HTTP/1.0 */\n    else {\n      /* Any other xxx:// reject! */\n      failf(data, \"Unsupported proxy scheme for \\'%s\\'\", proxy);\n      result = CURLE_COULDNT_CONNECT;\n      goto error;\n    }\n  }\n  else {\n    failf(data, \"Unsupported proxy syntax in \\'%s\\': %s\", proxy,\n          curl_url_strerror(uc));\n    result = CURLE_COULDNT_RESOLVE_PROXY;\n    goto error;\n  }\n\n#ifdef USE_SSL\n  if(!Curl_ssl_supports(data, SSLSUPP_HTTPS_PROXY))\n#endif\n    if(IS_HTTPS_PROXY(proxytype)) {\n      failf(data, \"Unsupported proxy \\'%s\\', libcurl is built without the \"\n            \"HTTPS-proxy support.\", proxy);\n      result = CURLE_NOT_BUILT_IN;\n      goto error;\n    }\n\n  sockstype =\n    proxytype == CURLPROXY_SOCKS5_HOSTNAME ||\n    proxytype == CURLPROXY_SOCKS5 ||\n    proxytype == CURLPROXY_SOCKS4A ||\n    proxytype == CURLPROXY_SOCKS4;\n\n  proxyinfo = sockstype ? &conn->socks_proxy : &conn->http_proxy;\n  proxyinfo->proxytype = (unsigned char)proxytype;\n\n  /* Is there a username and password given in this proxy url? */\n  uc = curl_url_get(uhp, CURLUPART_USER, &proxyuser, CURLU_URLDECODE);\n  if(uc && (uc != CURLUE_NO_USER))\n    goto error;\n  uc = curl_url_get(uhp, CURLUPART_PASSWORD, &proxypasswd, CURLU_URLDECODE);\n  if(uc && (uc != CURLUE_NO_PASSWORD))\n    goto error;\n\n  if(proxyuser || proxypasswd) {\n    Curl_safefree(proxyinfo->user);\n    proxyinfo->user = proxyuser;\n    result = Curl_setstropt(&data->state.aptr.proxyuser, proxyuser);\n    proxyuser = NULL;\n    if(result)\n      goto error;\n    Curl_safefree(proxyinfo->passwd);\n    if(!proxypasswd) {\n      proxypasswd = strdup(\"\");\n      if(!proxypasswd) {\n        result = CURLE_OUT_OF_MEMORY;\n        goto error;\n      }\n    }\n    proxyinfo->passwd = proxypasswd;\n    result = Curl_setstropt(&data->state.aptr.proxypasswd, proxypasswd);\n    proxypasswd = NULL;\n    if(result)\n      goto error;\n    conn->bits.proxy_user_passwd = TRUE; /* enable it */\n  }\n\n  (void)curl_url_get(uhp, CURLUPART_PORT, &portptr, 0);\n\n  if(portptr) {\n    port = (int)strtol(portptr, NULL, 10);\n    free(portptr);\n  }\n  else {\n    if(data->set.proxyport)\n      /* None given in the proxy string, then get the default one if it is\n         given */\n      port = (int)data->set.proxyport;\n    else {\n      if(IS_HTTPS_PROXY(proxytype))\n        port = CURL_DEFAULT_HTTPS_PROXY_PORT;\n      else\n        port = CURL_DEFAULT_PROXY_PORT;\n    }\n  }\n  if(port >= 0) {\n    proxyinfo->port = port;\n    if(conn->primary.remote_port < 0 || sockstype ||\n       !conn->socks_proxy.host.rawalloc)\n      conn->primary.remote_port = port;\n  }\n\n  /* now, clone the proxy host name */\n  uc = curl_url_get(uhp, CURLUPART_HOST, &host, CURLU_URLDECODE);\n  if(uc) {\n    result = CURLE_OUT_OF_MEMORY;\n    goto error;\n  }\n#ifdef USE_UNIX_SOCKETS\n  if(sockstype && strcasecompare(UNIX_SOCKET_PREFIX, host)) {\n    uc = curl_url_get(uhp, CURLUPART_PATH, &path, CURLU_URLDECODE);\n    if(uc) {\n      result = CURLE_OUT_OF_MEMORY;\n      goto error;\n    }\n    /* path will be \"/\", if no path was found */\n    if(strcmp(\"/\", path)) {\n      is_unix_proxy = TRUE;\n      free(host);\n      host = aprintf(UNIX_SOCKET_PREFIX\"%s\", path);\n      if(!host) {\n        result = CURLE_OUT_OF_MEMORY;\n        goto error;\n      }\n      Curl_safefree(proxyinfo->host.rawalloc);\n      proxyinfo->host.rawalloc = host;\n      proxyinfo->host.name = host;\n      host = NULL;\n    }\n  }\n\n  if(!is_unix_proxy) {\n#endif\n    Curl_safefree(proxyinfo->host.rawalloc);\n    proxyinfo->host.rawalloc = host;\n    if(host[0] == '[') {\n      /* this is a numerical IPv6, strip off the brackets */\n      size_t len = strlen(host);\n      host[len-1] = 0; /* clear the trailing bracket */\n      host++;\n      zonefrom_url(uhp, data, conn);\n    }\n    proxyinfo->host.name = host;\n    host = NULL;\n#ifdef USE_UNIX_SOCKETS\n  }\n#endif\n\nerror:\n  free(proxyuser);\n  free(proxypasswd);\n  free(host);\n  free(scheme);\n#ifdef USE_UNIX_SOCKETS\n  free(path);\n#endif\n  curl_url_cleanup(uhp);\n  return result;\n}\n\n/*\n * Extract the user and password from the authentication string\n */\nstatic CURLcode parse_proxy_auth(struct Curl_easy *data,\n                                 struct connectdata *conn)\n{\n  const char *proxyuser = data->state.aptr.proxyuser ?\n    data->state.aptr.proxyuser : \"\";\n  const char *proxypasswd = data->state.aptr.proxypasswd ?\n    data->state.aptr.proxypasswd : \"\";\n  CURLcode result = Curl_urldecode(proxyuser, 0, &conn->http_proxy.user, NULL,\n                                   REJECT_ZERO);\n  if(!result)\n    result = Curl_setstropt(&data->state.aptr.proxyuser,\n                            conn->http_proxy.user);\n  if(!result)\n    result = Curl_urldecode(proxypasswd, 0, &conn->http_proxy.passwd,\n                            NULL, REJECT_ZERO);\n  if(!result)\n    result = Curl_setstropt(&data->state.aptr.proxypasswd,\n                            conn->http_proxy.passwd);\n  return result;\n}\n\n/* create_conn helper to parse and init proxy values. to be called after unix\n   socket init but before any proxy vars are evaluated. */\nstatic CURLcode create_conn_helper_init_proxy(struct Curl_easy *data,\n                                              struct connectdata *conn)\n{\n  char *proxy = NULL;\n  char *socksproxy = NULL;\n  char *no_proxy = NULL;\n  CURLcode result = CURLE_OK;\n  bool spacesep = FALSE;\n\n  /*************************************************************\n   * Extract the user and password from the authentication string\n   *************************************************************/\n  if(conn->bits.proxy_user_passwd) {\n    result = parse_proxy_auth(data, conn);\n    if(result)\n      goto out;\n  }\n\n  /*************************************************************\n   * Detect what (if any) proxy to use\n   *************************************************************/\n  if(data->set.str[STRING_PROXY]) {\n    proxy = strdup(data->set.str[STRING_PROXY]);\n    /* if global proxy is set, this is it */\n    if(!proxy) {\n      failf(data, \"memory shortage\");\n      result = CURLE_OUT_OF_MEMORY;\n      goto out;\n    }\n  }\n\n  if(data->set.str[STRING_PRE_PROXY]) {\n    socksproxy = strdup(data->set.str[STRING_PRE_PROXY]);\n    /* if global socks proxy is set, this is it */\n    if(!socksproxy) {\n      failf(data, \"memory shortage\");\n      result = CURLE_OUT_OF_MEMORY;\n      goto out;\n    }\n  }\n\n  if(!data->set.str[STRING_NOPROXY]) {\n    const char *p = \"no_proxy\";\n    no_proxy = curl_getenv(p);\n    if(!no_proxy) {\n      p = \"NO_PROXY\";\n      no_proxy = curl_getenv(p);\n    }\n    if(no_proxy) {\n      infof(data, \"Uses proxy env variable %s == '%s'\", p, no_proxy);\n    }\n  }\n\n  if(Curl_check_noproxy(conn->host.name, data->set.str[STRING_NOPROXY] ?\n                        data->set.str[STRING_NOPROXY] : no_proxy,\n                        &spacesep)) {\n    Curl_safefree(proxy);\n    Curl_safefree(socksproxy);\n  }\n#ifndef CURL_DISABLE_HTTP\n  else if(!proxy && !socksproxy)\n    /* if the host is not in the noproxy list, detect proxy. */\n    proxy = detect_proxy(data, conn);\n#endif /* CURL_DISABLE_HTTP */\n  if(spacesep)\n    infof(data, \"space-separated NOPROXY patterns are deprecated\");\n\n  Curl_safefree(no_proxy);\n\n#ifdef USE_UNIX_SOCKETS\n  /* For the time being do not mix proxy and unix domain sockets. See #1274 */\n  if(proxy && conn->unix_domain_socket) {\n    free(proxy);\n    proxy = NULL;\n  }\n#endif\n\n  if(proxy && (!*proxy || (conn->handler->flags & PROTOPT_NONETWORK))) {\n    free(proxy);  /* Don't bother with an empty proxy string or if the\n                     protocol doesn't work with network */\n    proxy = NULL;\n  }\n  if(socksproxy && (!*socksproxy ||\n                    (conn->handler->flags & PROTOPT_NONETWORK))) {\n    free(socksproxy);  /* Don't bother with an empty socks proxy string or if\n                          the protocol doesn't work with network */\n    socksproxy = NULL;\n  }\n\n  /***********************************************************************\n   * If this is supposed to use a proxy, we need to figure out the proxy host\n   * name, proxy type and port number, so that we can reuse an existing\n   * connection that may exist registered to the same proxy host.\n   ***********************************************************************/\n  if(proxy || socksproxy) {\n    curl_proxytype ptype = (curl_proxytype)conn->http_proxy.proxytype;\n    if(proxy) {\n      result = parse_proxy(data, conn, proxy, ptype);\n      Curl_safefree(proxy); /* parse_proxy copies the proxy string */\n      if(result)\n        goto out;\n    }\n\n    if(socksproxy) {\n      result = parse_proxy(data, conn, socksproxy, ptype);\n      /* parse_proxy copies the socks proxy string */\n      Curl_safefree(socksproxy);\n      if(result)\n        goto out;\n    }\n\n    if(conn->http_proxy.host.rawalloc) {\n#ifdef CURL_DISABLE_HTTP\n      /* asking for an HTTP proxy is a bit funny when HTTP is disabled... */\n      result = CURLE_UNSUPPORTED_PROTOCOL;\n      goto out;\n#else\n      /* force this connection's protocol to become HTTP if compatible */\n      if(!(conn->handler->protocol & PROTO_FAMILY_HTTP)) {\n        if((conn->handler->flags & PROTOPT_PROXY_AS_HTTP) &&\n           !conn->bits.tunnel_proxy)\n          conn->handler = &Curl_handler_http;\n        else\n          /* if not converting to HTTP over the proxy, enforce tunneling */\n          conn->bits.tunnel_proxy = TRUE;\n      }\n      conn->bits.httpproxy = TRUE;\n#endif\n    }\n    else {\n      conn->bits.httpproxy = FALSE; /* not an HTTP proxy */\n      conn->bits.tunnel_proxy = FALSE; /* no tunneling if not HTTP */\n    }\n\n    if(conn->socks_proxy.host.rawalloc) {\n      if(!conn->http_proxy.host.rawalloc) {\n        /* once a socks proxy */\n        if(!conn->socks_proxy.user) {\n          conn->socks_proxy.user = conn->http_proxy.user;\n          conn->http_proxy.user = NULL;\n          Curl_safefree(conn->socks_proxy.passwd);\n          conn->socks_proxy.passwd = conn->http_proxy.passwd;\n          conn->http_proxy.passwd = NULL;\n        }\n      }\n      conn->bits.socksproxy = TRUE;\n    }\n    else\n      conn->bits.socksproxy = FALSE; /* not a socks proxy */\n  }\n  else {\n    conn->bits.socksproxy = FALSE;\n    conn->bits.httpproxy = FALSE;\n  }\n  conn->bits.proxy = conn->bits.httpproxy || conn->bits.socksproxy;\n\n  if(!conn->bits.proxy) {\n    /* we aren't using the proxy after all... */\n    conn->bits.proxy = FALSE;\n    conn->bits.httpproxy = FALSE;\n    conn->bits.socksproxy = FALSE;\n    conn->bits.proxy_user_passwd = FALSE;\n    conn->bits.tunnel_proxy = FALSE;\n    /* CURLPROXY_HTTPS does not have its own flag in conn->bits, yet we need\n       to signal that CURLPROXY_HTTPS is not used for this connection */\n    conn->http_proxy.proxytype = CURLPROXY_HTTP;\n  }\n\nout:\n\n  free(socksproxy);\n  free(proxy);\n  return result;\n}\n#endif /* CURL_DISABLE_PROXY */\n\n/*\n * Curl_parse_login_details()\n *\n * This is used to parse a login string for user name, password and options in\n * the following formats:\n *\n *   user\n *   user:password\n *   user:password;options\n *   user;options\n *   user;options:password\n *   :password\n *   :password;options\n *   ;options\n *   ;options:password\n *\n * Parameters:\n *\n * login    [in]     - The login string.\n * len      [in]     - The length of the login string.\n * userp    [in/out] - The address where a pointer to newly allocated memory\n *                     holding the user will be stored upon completion.\n * passwdp  [in/out] - The address where a pointer to newly allocated memory\n *                     holding the password will be stored upon completion.\n * optionsp [in/out] - The address where a pointer to newly allocated memory\n *                     holding the options will be stored upon completion.\n *\n * Returns CURLE_OK on success.\n */\nCURLcode Curl_parse_login_details(const char *login, const size_t len,\n                                  char **userp, char **passwdp,\n                                  char **optionsp)\n{\n  CURLcode result = CURLE_OK;\n  char *ubuf = NULL;\n  char *pbuf = NULL;\n  char *obuf = NULL;\n  const char *psep = NULL;\n  const char *osep = NULL;\n  size_t ulen;\n  size_t plen;\n  size_t olen;\n\n  /* Attempt to find the password separator */\n  if(passwdp)\n    psep = memchr(login, ':', len);\n\n  /* Attempt to find the options separator */\n  if(optionsp)\n    osep = memchr(login, ';', len);\n\n  /* Calculate the portion lengths */\n  ulen = (psep ?\n          (size_t)(osep && psep > osep ? osep - login : psep - login) :\n          (osep ? (size_t)(osep - login) : len));\n  plen = (psep ?\n          (osep && osep > psep ? (size_t)(osep - psep) :\n                                 (size_t)(login + len - psep)) - 1 : 0);\n  olen = (osep ?\n          (psep && psep > osep ? (size_t)(psep - osep) :\n                                 (size_t)(login + len - osep)) - 1 : 0);\n\n  /* Allocate the user portion buffer, which can be zero length */\n  if(userp) {\n    ubuf = malloc(ulen + 1);\n    if(!ubuf)\n      result = CURLE_OUT_OF_MEMORY;\n  }\n\n  /* Allocate the password portion buffer */\n  if(!result && passwdp && psep) {\n    pbuf = malloc(plen + 1);\n    if(!pbuf) {\n      free(ubuf);\n      result = CURLE_OUT_OF_MEMORY;\n    }\n  }\n\n  /* Allocate the options portion buffer */\n  if(!result && optionsp && olen) {\n    obuf = malloc(olen + 1);\n    if(!obuf) {\n      free(pbuf);\n      free(ubuf);\n      result = CURLE_OUT_OF_MEMORY;\n    }\n  }\n\n  if(!result) {\n    /* Store the user portion if necessary */\n    if(ubuf) {\n      memcpy(ubuf, login, ulen);\n      ubuf[ulen] = '\\0';\n      Curl_safefree(*userp);\n      *userp = ubuf;\n    }\n\n    /* Store the password portion if necessary */\n    if(pbuf) {\n      memcpy(pbuf, psep + 1, plen);\n      pbuf[plen] = '\\0';\n      Curl_safefree(*passwdp);\n      *passwdp = pbuf;\n    }\n\n    /* Store the options portion if necessary */\n    if(obuf) {\n      memcpy(obuf, osep + 1, olen);\n      obuf[olen] = '\\0';\n      Curl_safefree(*optionsp);\n      *optionsp = obuf;\n    }\n  }\n\n  return result;\n}\n\n/*************************************************************\n * Figure out the remote port number and fix it in the URL\n *\n * No matter if we use a proxy or not, we have to figure out the remote\n * port number of various reasons.\n *\n * The port number embedded in the URL is replaced, if necessary.\n *************************************************************/\nstatic CURLcode parse_remote_port(struct Curl_easy *data,\n                                  struct connectdata *conn)\n{\n\n  if(data->set.use_port && data->state.allow_port) {\n    /* if set, we use this instead of the port possibly given in the URL */\n    char portbuf[16];\n    CURLUcode uc;\n    conn->remote_port = data->set.use_port;\n    msnprintf(portbuf, sizeof(portbuf), \"%d\", conn->remote_port);\n    uc = curl_url_set(data->state.uh, CURLUPART_PORT, portbuf, 0);\n    if(uc)\n      return CURLE_OUT_OF_MEMORY;\n  }\n\n  return CURLE_OK;\n}\n\n/*\n * Override the login details from the URL with that in the CURLOPT_USERPWD\n * option or a .netrc file, if applicable.\n */\nstatic CURLcode override_login(struct Curl_easy *data,\n                               struct connectdata *conn)\n{\n  CURLUcode uc;\n  char **userp = &conn->user;\n  char **passwdp = &conn->passwd;\n  char **optionsp = &conn->options;\n\n  if(data->set.str[STRING_OPTIONS]) {\n    free(*optionsp);\n    *optionsp = strdup(data->set.str[STRING_OPTIONS]);\n    if(!*optionsp)\n      return CURLE_OUT_OF_MEMORY;\n  }\n\n#ifndef CURL_DISABLE_NETRC\n  if(data->set.use_netrc == CURL_NETRC_REQUIRED) {\n    Curl_safefree(*userp);\n    Curl_safefree(*passwdp);\n  }\n  conn->bits.netrc = FALSE;\n  if(data->set.use_netrc && !data->set.str[STRING_USERNAME]) {\n    int ret;\n    bool url_provided = FALSE;\n\n    if(data->state.aptr.user) {\n      /* there was a user name in the URL. Use the URL decoded version */\n      userp = &data->state.aptr.user;\n      url_provided = TRUE;\n    }\n\n    ret = Curl_parsenetrc(conn->host.name,\n                          userp, passwdp,\n                          data->set.str[STRING_NETRC_FILE]);\n    if(ret > 0) {\n      infof(data, \"Couldn't find host %s in the %s file; using defaults\",\n            conn->host.name,\n            (data->set.str[STRING_NETRC_FILE] ?\n             data->set.str[STRING_NETRC_FILE] : \".netrc\"));\n    }\n    else if(ret < 0) {\n      failf(data, \".netrc parser error\");\n      return CURLE_READ_ERROR;\n    }\n    else {\n      /* set bits.netrc TRUE to remember that we got the name from a .netrc\n         file, so that it is safe to use even if we followed a Location: to a\n         different host or similar. */\n      conn->bits.netrc = TRUE;\n    }\n    if(url_provided) {\n      Curl_safefree(conn->user);\n      conn->user = strdup(*userp);\n      if(!conn->user)\n        return CURLE_OUT_OF_MEMORY;\n    }\n    /* no user was set but a password, set a blank user */\n    if(!*userp && *passwdp) {\n      *userp = strdup(\"\");\n      if(!*userp)\n        return CURLE_OUT_OF_MEMORY;\n    }\n  }\n#endif\n\n  /* for updated strings, we update them in the URL */\n  if(*userp) {\n    CURLcode result;\n    if(data->state.aptr.user != *userp) {\n      /* nothing to do then */\n      result = Curl_setstropt(&data->state.aptr.user, *userp);\n      if(result)\n        return result;\n    }\n  }\n  if(data->state.aptr.user) {\n    uc = curl_url_set(data->state.uh, CURLUPART_USER, data->state.aptr.user,\n                      CURLU_URLENCODE);\n    if(uc)\n      return Curl_uc_to_curlcode(uc);\n    if(!*userp) {\n      *userp = strdup(data->state.aptr.user);\n      if(!*userp)\n        return CURLE_OUT_OF_MEMORY;\n    }\n  }\n  if(*passwdp) {\n    CURLcode result = Curl_setstropt(&data->state.aptr.passwd, *passwdp);\n    if(result)\n      return result;\n  }\n  if(data->state.aptr.passwd) {\n    uc = curl_url_set(data->state.uh, CURLUPART_PASSWORD,\n                      data->state.aptr.passwd, CURLU_URLENCODE);\n    if(uc)\n      return Curl_uc_to_curlcode(uc);\n    if(!*passwdp) {\n      *passwdp = strdup(data->state.aptr.passwd);\n      if(!*passwdp)\n        return CURLE_OUT_OF_MEMORY;\n    }\n  }\n\n  return CURLE_OK;\n}\n\n/*\n * Set the login details so they're available in the connection\n */\nstatic CURLcode set_login(struct Curl_easy *data,\n                          struct connectdata *conn)\n{\n  CURLcode result = CURLE_OK;\n  const char *setuser = CURL_DEFAULT_USER;\n  const char *setpasswd = CURL_DEFAULT_PASSWORD;\n\n  /* If our protocol needs a password and we have none, use the defaults */\n  if((conn->handler->flags & PROTOPT_NEEDSPWD) && !data->state.aptr.user)\n    ;\n  else {\n    setuser = \"\";\n    setpasswd = \"\";\n  }\n  /* Store the default user */\n  if(!conn->user) {\n    conn->user = strdup(setuser);\n    if(!conn->user)\n      return CURLE_OUT_OF_MEMORY;\n  }\n\n  /* Store the default password */\n  if(!conn->passwd) {\n    conn->passwd = strdup(setpasswd);\n    if(!conn->passwd)\n      result = CURLE_OUT_OF_MEMORY;\n  }\n\n  return result;\n}\n\n/*\n * Parses a \"host:port\" string to connect to.\n * The hostname and the port may be empty; in this case, NULL is returned for\n * the hostname and -1 for the port.\n */\nstatic CURLcode parse_connect_to_host_port(struct Curl_easy *data,\n                                           const char *host,\n                                           char **hostname_result,\n                                           int *port_result)\n{\n  char *host_dup;\n  char *hostptr;\n  char *host_portno;\n  char *portptr;\n  int port = -1;\n  CURLcode result = CURLE_OK;\n\n#if defined(CURL_DISABLE_VERBOSE_STRINGS)\n  (void) data;\n#endif\n\n  *hostname_result = NULL;\n  *port_result = -1;\n\n  if(!host || !*host)\n    return CURLE_OK;\n\n  host_dup = strdup(host);\n  if(!host_dup)\n    return CURLE_OUT_OF_MEMORY;\n\n  hostptr = host_dup;\n\n  /* start scanning for port number at this point */\n  portptr = hostptr;\n\n  /* detect and extract RFC6874-style IPv6-addresses */\n  if(*hostptr == '[') {\n#ifdef ENABLE_IPV6\n    char *ptr = ++hostptr; /* advance beyond the initial bracket */\n    while(*ptr && (ISXDIGIT(*ptr) || (*ptr == ':') || (*ptr == '.')))\n      ptr++;\n    if(*ptr == '%') {\n      /* There might be a zone identifier */\n      if(strncmp(\"%25\", ptr, 3))\n        infof(data, \"Please URL encode %% as %%25, see RFC 6874.\");\n      ptr++;\n      /* Allow unreserved characters as defined in RFC 3986 */\n      while(*ptr && (ISALPHA(*ptr) || ISXDIGIT(*ptr) || (*ptr == '-') ||\n                     (*ptr == '.') || (*ptr == '_') || (*ptr == '~')))\n        ptr++;\n    }\n    if(*ptr == ']')\n      /* yeps, it ended nicely with a bracket as well */\n      *ptr++ = '\\0';\n    else\n      infof(data, \"Invalid IPv6 address format\");\n    portptr = ptr;\n    /* Note that if this didn't end with a bracket, we still advanced the\n     * hostptr first, but I can't see anything wrong with that as no host\n     * name nor a numeric can legally start with a bracket.\n     */\n#else\n    failf(data, \"Use of IPv6 in *_CONNECT_TO without IPv6 support built-in\");\n    result = CURLE_NOT_BUILT_IN;\n    goto error;\n#endif\n  }\n\n  /* Get port number off server.com:1080 */\n  host_portno = strchr(portptr, ':');\n  if(host_portno) {\n    char *endp = NULL;\n    *host_portno = '\\0'; /* cut off number from host name */\n    host_portno++;\n    if(*host_portno) {\n      long portparse = strtol(host_portno, &endp, 10);\n      if((endp && *endp) || (portparse < 0) || (portparse > 65535)) {\n        failf(data, \"No valid port number in connect to host string (%s)\",\n              host_portno);\n        result = CURLE_SETOPT_OPTION_SYNTAX;\n        goto error;\n      }\n      else\n        port = (int)portparse; /* we know it will fit */\n    }\n  }\n\n  /* now, clone the cleaned host name */\n  DEBUGASSERT(hostptr);\n  *hostname_result = strdup(hostptr);\n  if(!*hostname_result) {\n    result = CURLE_OUT_OF_MEMORY;\n    goto error;\n  }\n\n  *port_result = port;\n\nerror:\n  free(host_dup);\n  return result;\n}\n\n/*\n * Parses one \"connect to\" string in the form:\n * \"HOST:PORT:CONNECT-TO-HOST:CONNECT-TO-PORT\".\n */\nstatic CURLcode parse_connect_to_string(struct Curl_easy *data,\n                                        struct connectdata *conn,\n                                        const char *conn_to_host,\n                                        char **host_result,\n                                        int *port_result)\n{\n  CURLcode result = CURLE_OK;\n  const char *ptr = conn_to_host;\n  int host_match = FALSE;\n  int port_match = FALSE;\n\n  *host_result = NULL;\n  *port_result = -1;\n\n  if(*ptr == ':') {\n    /* an empty hostname always matches */\n    host_match = TRUE;\n    ptr++;\n  }\n  else {\n    /* check whether the URL's hostname matches */\n    size_t hostname_to_match_len;\n    char *hostname_to_match = aprintf(\"%s%s%s\",\n                                      conn->bits.ipv6_ip ? \"[\" : \"\",\n                                      conn->host.name,\n                                      conn->bits.ipv6_ip ? \"]\" : \"\");\n    if(!hostname_to_match)\n      return CURLE_OUT_OF_MEMORY;\n    hostname_to_match_len = strlen(hostname_to_match);\n    host_match = strncasecompare(ptr, hostname_to_match,\n                                 hostname_to_match_len);\n    free(hostname_to_match);\n    ptr += hostname_to_match_len;\n\n    host_match = host_match && *ptr == ':';\n    ptr++;\n  }\n\n  if(host_match) {\n    if(*ptr == ':') {\n      /* an empty port always matches */\n      port_match = TRUE;\n      ptr++;\n    }\n    else {\n      /* check whether the URL's port matches */\n      char *ptr_next = strchr(ptr, ':');\n      if(ptr_next) {\n        char *endp = NULL;\n        long port_to_match = strtol(ptr, &endp, 10);\n        if((endp == ptr_next) && (port_to_match == conn->remote_port)) {\n          port_match = TRUE;\n          ptr = ptr_next + 1;\n        }\n      }\n    }\n  }\n\n  if(host_match && port_match) {\n    /* parse the hostname and port to connect to */\n    result = parse_connect_to_host_port(data, ptr, host_result, port_result);\n  }\n\n  return result;\n}\n\n/*\n * Processes all strings in the \"connect to\" slist, and uses the \"connect\n * to host\" and \"connect to port\" of the first string that matches.\n */\nstatic CURLcode parse_connect_to_slist(struct Curl_easy *data,\n                                       struct connectdata *conn,\n                                       struct curl_slist *conn_to_host)\n{\n  CURLcode result = CURLE_OK;\n  char *host = NULL;\n  int port = -1;\n\n  while(conn_to_host && !host && port == -1) {\n    result = parse_connect_to_string(data, conn, conn_to_host->data,\n                                     &host, &port);\n    if(result)\n      return result;\n\n    if(host && *host) {\n      conn->conn_to_host.rawalloc = host;\n      conn->conn_to_host.name = host;\n      conn->bits.conn_to_host = TRUE;\n\n      infof(data, \"Connecting to hostname: %s\", host);\n    }\n    else {\n      /* no \"connect to host\" */\n      conn->bits.conn_to_host = FALSE;\n      Curl_safefree(host);\n    }\n\n    if(port >= 0) {\n      conn->conn_to_port = port;\n      conn->bits.conn_to_port = TRUE;\n      infof(data, \"Connecting to port: %d\", port);\n    }\n    else {\n      /* no \"connect to port\" */\n      conn->bits.conn_to_port = FALSE;\n      port = -1;\n    }\n\n    conn_to_host = conn_to_host->next;\n  }\n\n#ifndef CURL_DISABLE_ALTSVC\n  if(data->asi && !host && (port == -1) &&\n     ((conn->handler->protocol == CURLPROTO_HTTPS) ||\n#ifdef CURLDEBUG\n      /* allow debug builds to circumvent the HTTPS restriction */\n      getenv(\"CURL_ALTSVC_HTTP\")\n#else\n      0\n#endif\n       )) {\n    /* no connect_to match, try alt-svc! */\n    enum alpnid srcalpnid;\n    bool hit;\n    struct altsvc *as;\n    const int allowed_versions = ( ALPN_h1\n#ifdef USE_HTTP2\n                                   | ALPN_h2\n#endif\n#ifdef ENABLE_QUIC\n                                   | ALPN_h3\n#endif\n      ) & data->asi->flags;\n\n    host = conn->host.rawalloc;\n#ifdef USE_HTTP2\n    /* with h2 support, check that first */\n    srcalpnid = ALPN_h2;\n    hit = Curl_altsvc_lookup(data->asi,\n                             srcalpnid, host, conn->remote_port, /* from */\n                             &as /* to */,\n                             allowed_versions);\n    if(!hit)\n#endif\n    {\n      srcalpnid = ALPN_h1;\n      hit = Curl_altsvc_lookup(data->asi,\n                               srcalpnid, host, conn->remote_port, /* from */\n                               &as /* to */,\n                               allowed_versions);\n    }\n    if(hit) {\n      char *hostd = strdup((char *)as->dst.host);\n      if(!hostd)\n        return CURLE_OUT_OF_MEMORY;\n      conn->conn_to_host.rawalloc = hostd;\n      conn->conn_to_host.name = hostd;\n      conn->bits.conn_to_host = TRUE;\n      conn->conn_to_port = as->dst.port;\n      conn->bits.conn_to_port = TRUE;\n      conn->bits.altused = TRUE;\n      infof(data, \"Alt-svc connecting from [%s]%s:%d to [%s]%s:%d\",\n            Curl_alpnid2str(srcalpnid), host, conn->remote_port,\n            Curl_alpnid2str(as->dst.alpnid), hostd, as->dst.port);\n      if(srcalpnid != as->dst.alpnid) {\n        /* protocol version switch */\n        switch(as->dst.alpnid) {\n        case ALPN_h1:\n          conn->httpversion = 11;\n          break;\n        case ALPN_h2:\n          conn->httpversion = 20;\n          break;\n        case ALPN_h3:\n          conn->transport = TRNSPRT_QUIC;\n          conn->httpversion = 30;\n          break;\n        default: /* shouldn't be possible */\n          break;\n        }\n      }\n    }\n  }\n#endif\n\n  return result;\n}\n\n#ifdef USE_UNIX_SOCKETS\nstatic CURLcode resolve_unix(struct Curl_easy *data,\n                             struct connectdata *conn,\n                             char *unix_path)\n{\n  struct Curl_dns_entry *hostaddr = NULL;\n  bool longpath = FALSE;\n\n  DEBUGASSERT(unix_path);\n  DEBUGASSERT(conn->dns_entry == NULL);\n\n  /* Unix domain sockets are local. The host gets ignored, just use the\n   * specified domain socket address. Do not cache \"DNS entries\". There is\n   * no DNS involved and we already have the filesystem path available. */\n  hostaddr = calloc(1, sizeof(struct Curl_dns_entry));\n  if(!hostaddr)\n    return CURLE_OUT_OF_MEMORY;\n\n  hostaddr->addr = Curl_unix2addr(unix_path, &longpath,\n                                  conn->bits.abstract_unix_socket);\n  if(!hostaddr->addr) {\n    if(longpath)\n      /* Long paths are not supported for now */\n      failf(data, \"Unix socket path too long: '%s'\", unix_path);\n    free(hostaddr);\n    return longpath ? CURLE_COULDNT_RESOLVE_HOST : CURLE_OUT_OF_MEMORY;\n  }\n\n  hostaddr->inuse++;\n  conn->dns_entry = hostaddr;\n  return CURLE_OK;\n}\n#endif\n\n#ifndef CURL_DISABLE_PROXY\nstatic CURLcode resolve_proxy(struct Curl_easy *data,\n                              struct connectdata *conn,\n                              bool *async)\n{\n  struct Curl_dns_entry *hostaddr = NULL;\n  struct hostname *host;\n  timediff_t timeout_ms = Curl_timeleft(data, NULL, TRUE);\n  int rc;\n\n  DEBUGASSERT(conn->dns_entry == NULL);\n\n  host = conn->bits.socksproxy ? &conn->socks_proxy.host :\n    &conn->http_proxy.host;\n\n  conn->hostname_resolve = strdup(host->name);\n  if(!conn->hostname_resolve)\n    return CURLE_OUT_OF_MEMORY;\n\n  rc = Curl_resolv_timeout(data, conn->hostname_resolve,\n                           conn->primary.remote_port, &hostaddr, timeout_ms);\n  conn->dns_entry = hostaddr;\n  if(rc == CURLRESOLV_PENDING)\n    *async = TRUE;\n  else if(rc == CURLRESOLV_TIMEDOUT)\n    return CURLE_OPERATION_TIMEDOUT;\n  else if(!hostaddr) {\n    failf(data, \"Couldn't resolve proxy '%s'\", host->dispname);\n    return CURLE_COULDNT_RESOLVE_PROXY;\n  }\n\n  return CURLE_OK;\n}\n#endif\n\nstatic CURLcode resolve_host(struct Curl_easy *data,\n                             struct connectdata *conn,\n                             bool *async)\n{\n  struct Curl_dns_entry *hostaddr = NULL;\n  struct hostname *connhost;\n  timediff_t timeout_ms = Curl_timeleft(data, NULL, TRUE);\n  int rc;\n\n  DEBUGASSERT(conn->dns_entry == NULL);\n\n  connhost = conn->bits.conn_to_host ? &conn->conn_to_host : &conn->host;\n\n  /* If not connecting via a proxy, extract the port from the URL, if it is\n   * there, thus overriding any defaults that might have been set above. */\n  conn->primary.remote_port = conn->bits.conn_to_port ? conn->conn_to_port :\n    conn->remote_port;\n\n  /* Resolve target host right on */\n  conn->hostname_resolve = strdup(connhost->name);\n  if(!conn->hostname_resolve)\n    return CURLE_OUT_OF_MEMORY;\n\n  rc = Curl_resolv_timeout(data, conn->hostname_resolve,\n                           conn->primary.remote_port, &hostaddr, timeout_ms);\n  conn->dns_entry = hostaddr;\n  if(rc == CURLRESOLV_PENDING)\n    *async = TRUE;\n  else if(rc == CURLRESOLV_TIMEDOUT) {\n    failf(data, \"Failed to resolve host '%s' with timeout after %\"\n          CURL_FORMAT_TIMEDIFF_T \" ms\", connhost->dispname,\n          Curl_timediff(Curl_now(), data->progress.t_startsingle));\n    return CURLE_OPERATION_TIMEDOUT;\n  }\n  else if(!hostaddr) {\n    failf(data, \"Could not resolve host: %s\", connhost->dispname);\n    return CURLE_COULDNT_RESOLVE_HOST;\n  }\n\n  return CURLE_OK;\n}\n\n/* Perform a fresh resolve */\nstatic CURLcode resolve_fresh(struct Curl_easy *data,\n                              struct connectdata *conn,\n                              bool *async)\n{\n#ifdef USE_UNIX_SOCKETS\n  char *unix_path = conn->unix_domain_socket;\n\n#ifndef CURL_DISABLE_PROXY\n  if(!unix_path && conn->socks_proxy.host.name &&\n     !strncmp(UNIX_SOCKET_PREFIX\"/\",\n              conn->socks_proxy.host.name, sizeof(UNIX_SOCKET_PREFIX)))\n    unix_path = conn->socks_proxy.host.name + sizeof(UNIX_SOCKET_PREFIX) - 1;\n#endif\n\n  if(unix_path) {\n    conn->transport = TRNSPRT_UNIX;\n    return resolve_unix(data, conn, unix_path);\n  }\n#endif\n\n#ifndef CURL_DISABLE_PROXY\n  if(CONN_IS_PROXIED(conn))\n    return resolve_proxy(data, conn, async);\n#endif\n\n  return resolve_host(data, conn, async);\n}\n\n/*************************************************************\n * Resolve the address of the server or proxy\n *************************************************************/\nstatic CURLcode resolve_server(struct Curl_easy *data,\n                               struct connectdata *conn,\n                               bool *async)\n{\n  DEBUGASSERT(conn);\n  DEBUGASSERT(data);\n\n  /* Resolve the name of the server or proxy */\n  if(conn->bits.reuse) {\n    /* We're reusing the connection - no need to resolve anything, and\n       idnconvert_hostname() was called already in create_conn() for the reuse\n       case. */\n    *async = FALSE;\n    return CURLE_OK;\n  }\n\n  return resolve_fresh(data, conn, async);\n}\n\n/*\n * Cleanup the connection `temp`, just allocated for `data`, before using the\n * previously `existing` one for `data`.  All relevant info is copied over\n * and `temp` is freed.\n */\nstatic void reuse_conn(struct Curl_easy *data,\n                       struct connectdata *temp,\n                       struct connectdata *existing)\n{\n  /* get the user+password information from the temp struct since it may\n   * be new for this request even when we reuse an existing connection */\n  if(temp->user) {\n    /* use the new user name and password though */\n    Curl_safefree(existing->user);\n    Curl_safefree(existing->passwd);\n    existing->user = temp->user;\n    existing->passwd = temp->passwd;\n    temp->user = NULL;\n    temp->passwd = NULL;\n  }\n\n#ifndef CURL_DISABLE_PROXY\n  existing->bits.proxy_user_passwd = temp->bits.proxy_user_passwd;\n  if(existing->bits.proxy_user_passwd) {\n    /* use the new proxy user name and proxy password though */\n    Curl_safefree(existing->http_proxy.user);\n    Curl_safefree(existing->socks_proxy.user);\n    Curl_safefree(existing->http_proxy.passwd);\n    Curl_safefree(existing->socks_proxy.passwd);\n    existing->http_proxy.user = temp->http_proxy.user;\n    existing->socks_proxy.user = temp->socks_proxy.user;\n    existing->http_proxy.passwd = temp->http_proxy.passwd;\n    existing->socks_proxy.passwd = temp->socks_proxy.passwd;\n    temp->http_proxy.user = NULL;\n    temp->socks_proxy.user = NULL;\n    temp->http_proxy.passwd = NULL;\n    temp->socks_proxy.passwd = NULL;\n  }\n#endif\n\n  /* Finding a connection for reuse in the cache matches, among other\n   * things on the \"remote-relevant\" hostname. This is not necessarily\n   * the authority of the URL, e.g. conn->host. For example:\n   * - we use a proxy (not tunneling). we want to send all requests\n   *   that use the same proxy on this connection.\n   * - we have a \"connect-to\" setting that may redirect the hostname of\n   *   a new request to the same remote endpoint of an existing conn.\n   *   We want to reuse an existing conn to the remote endpoint.\n   * Since connection reuse does not match on conn->host necessarily, we\n   * switch `existing` conn to `temp` conn's host settings.\n   * TODO: is this correct in the case of TLS connections that have\n   *       used the original hostname in SNI to negotiate? Do we send\n   *       requests for another host through the different SNI?\n   */\n  Curl_free_idnconverted_hostname(&existing->host);\n  Curl_free_idnconverted_hostname(&existing->conn_to_host);\n  Curl_safefree(existing->host.rawalloc);\n  Curl_safefree(existing->conn_to_host.rawalloc);\n  existing->host = temp->host;\n  temp->host.rawalloc = NULL;\n  temp->host.encalloc = NULL;\n  existing->conn_to_host = temp->conn_to_host;\n  temp->conn_to_host.rawalloc = NULL;\n  existing->conn_to_port = temp->conn_to_port;\n  existing->remote_port = temp->remote_port;\n  Curl_safefree(existing->hostname_resolve);\n\n  existing->hostname_resolve = temp->hostname_resolve;\n  temp->hostname_resolve = NULL;\n\n  /* reuse init */\n  existing->bits.reuse = TRUE; /* yes, we're reusing here */\n\n  conn_free(data, temp);\n}\n\n/**\n * create_conn() sets up a new connectdata struct, or reuses an already\n * existing one, and resolves host name.\n *\n * if this function returns CURLE_OK and *async is set to TRUE, the resolve\n * response will be coming asynchronously. If *async is FALSE, the name is\n * already resolved.\n *\n * @param data The sessionhandle pointer\n * @param in_connect is set to the next connection data pointer\n * @param async is set TRUE when an async DNS resolution is pending\n * @see Curl_setup_conn()\n *\n */\n\nstatic CURLcode create_conn(struct Curl_easy *data,\n                            struct connectdata **in_connect,\n                            bool *async)\n{\n  CURLcode result = CURLE_OK;\n  struct connectdata *conn;\n  struct connectdata *existing = NULL;\n  bool reuse;\n  bool connections_available = TRUE;\n  bool force_reuse = FALSE;\n  bool waitpipe = FALSE;\n  size_t max_host_connections = Curl_multi_max_host_connections(data->multi);\n  size_t max_total_connections = Curl_multi_max_total_connections(data->multi);\n\n  *async = FALSE;\n  *in_connect = NULL;\n\n  /*************************************************************\n   * Check input data\n   *************************************************************/\n  if(!data->state.url) {\n    result = CURLE_URL_MALFORMAT;\n    goto out;\n  }\n\n  /* First, split up the current URL in parts so that we can use the\n     parts for checking against the already present connections. In order\n     to not have to modify everything at once, we allocate a temporary\n     connection data struct and fill in for comparison purposes. */\n  conn = allocate_conn(data);\n\n  if(!conn) {\n    result = CURLE_OUT_OF_MEMORY;\n    goto out;\n  }\n\n  /* We must set the return variable as soon as possible, so that our\n     parent can cleanup any possible allocs we may have done before\n     any failure */\n  *in_connect = conn;\n\n  result = parseurlandfillconn(data, conn);\n  if(result)\n    goto out;\n\n  if(data->set.str[STRING_SASL_AUTHZID]) {\n    conn->sasl_authzid = strdup(data->set.str[STRING_SASL_AUTHZID]);\n    if(!conn->sasl_authzid) {\n      result = CURLE_OUT_OF_MEMORY;\n      goto out;\n    }\n  }\n\n  if(data->set.str[STRING_BEARER]) {\n    conn->oauth_bearer = strdup(data->set.str[STRING_BEARER]);\n    if(!conn->oauth_bearer) {\n      result = CURLE_OUT_OF_MEMORY;\n      goto out;\n    }\n  }\n\n#ifdef USE_UNIX_SOCKETS\n  if(data->set.str[STRING_UNIX_SOCKET_PATH]) {\n    conn->unix_domain_socket = strdup(data->set.str[STRING_UNIX_SOCKET_PATH]);\n    if(!conn->unix_domain_socket) {\n      result = CURLE_OUT_OF_MEMORY;\n      goto out;\n    }\n    conn->bits.abstract_unix_socket = data->set.abstract_unix_socket;\n  }\n#endif\n\n  /* After the unix socket init but before the proxy vars are used, parse and\n     initialize the proxy vars */\n#ifndef CURL_DISABLE_PROXY\n  result = create_conn_helper_init_proxy(data, conn);\n  if(result)\n    goto out;\n\n  /*************************************************************\n   * If the protocol is using SSL and HTTP proxy is used, we set\n   * the tunnel_proxy bit.\n   *************************************************************/\n  if((conn->given->flags&PROTOPT_SSL) && conn->bits.httpproxy)\n    conn->bits.tunnel_proxy = TRUE;\n#endif\n\n  /*************************************************************\n   * Figure out the remote port number and fix it in the URL\n   *************************************************************/\n  result = parse_remote_port(data, conn);\n  if(result)\n    goto out;\n\n  /* Check for overridden login details and set them accordingly so that\n     they are known when protocol->setup_connection is called! */\n  result = override_login(data, conn);\n  if(result)\n    goto out;\n\n  result = set_login(data, conn); /* default credentials */\n  if(result)\n    goto out;\n\n  /*************************************************************\n   * Process the \"connect to\" linked list of hostname/port mappings.\n   * Do this after the remote port number has been fixed in the URL.\n   *************************************************************/\n  result = parse_connect_to_slist(data, conn, data->set.connect_to);\n  if(result)\n    goto out;\n\n  /*************************************************************\n   * IDN-convert the proxy hostnames\n   *************************************************************/\n#ifndef CURL_DISABLE_PROXY\n  if(conn->bits.httpproxy) {\n    result = Curl_idnconvert_hostname(&conn->http_proxy.host);\n    if(result)\n      return result;\n  }\n  if(conn->bits.socksproxy) {\n    result = Curl_idnconvert_hostname(&conn->socks_proxy.host);\n    if(result)\n      return result;\n  }\n#endif\n  if(conn->bits.conn_to_host) {\n    result = Curl_idnconvert_hostname(&conn->conn_to_host);\n    if(result)\n      return result;\n  }\n\n  /*************************************************************\n   * Check whether the host and the \"connect to host\" are equal.\n   * Do this after the hostnames have been IDN-converted.\n   *************************************************************/\n  if(conn->bits.conn_to_host &&\n     strcasecompare(conn->conn_to_host.name, conn->host.name)) {\n    conn->bits.conn_to_host = FALSE;\n  }\n\n  /*************************************************************\n   * Check whether the port and the \"connect to port\" are equal.\n   * Do this after the remote port number has been fixed in the URL.\n   *************************************************************/\n  if(conn->bits.conn_to_port && conn->conn_to_port == conn->remote_port) {\n    conn->bits.conn_to_port = FALSE;\n  }\n\n#ifndef CURL_DISABLE_PROXY\n  /*************************************************************\n   * If the \"connect to\" feature is used with an HTTP proxy,\n   * we set the tunnel_proxy bit.\n   *************************************************************/\n  if((conn->bits.conn_to_host || conn->bits.conn_to_port) &&\n      conn->bits.httpproxy)\n    conn->bits.tunnel_proxy = TRUE;\n#endif\n\n  /*************************************************************\n   * Setup internals depending on protocol. Needs to be done after\n   * we figured out what/if proxy to use.\n   *************************************************************/\n  result = setup_connection_internals(data, conn);\n  if(result)\n    goto out;\n\n  /***********************************************************************\n   * file: is a special case in that it doesn't need a network connection\n   ***********************************************************************/\n#ifndef CURL_DISABLE_FILE\n  if(conn->handler->flags & PROTOPT_NONETWORK) {\n    bool done;\n    /* this is supposed to be the connect function so we better at least check\n       that the file is present here! */\n    DEBUGASSERT(conn->handler->connect_it);\n    Curl_persistconninfo(data, conn, NULL);\n    result = conn->handler->connect_it(data, &done);\n\n    /* Setup a \"faked\" transfer that'll do nothing */\n    if(!result) {\n      Curl_attach_connection(data, conn);\n      result = Curl_conncache_add_conn(data);\n      if(result)\n        goto out;\n\n      /*\n       * Setup whatever necessary for a resumed transfer\n       */\n      result = setup_range(data);\n      if(result) {\n        DEBUGASSERT(conn->handler->done);\n        /* we ignore the return code for the protocol-specific DONE */\n        (void)conn->handler->done(data, result, FALSE);\n        goto out;\n      }\n      Curl_xfer_setup(data, -1, -1, FALSE, -1);\n    }\n\n    /* since we skip do_init() */\n    Curl_init_do(data, conn);\n\n    goto out;\n  }\n#endif\n\n  /* Setup filter for network connections */\n  conn->recv[FIRSTSOCKET] = Curl_cf_recv;\n  conn->send[FIRSTSOCKET] = Curl_cf_send;\n  conn->recv[SECONDARYSOCKET] = Curl_cf_recv;\n  conn->send[SECONDARYSOCKET] = Curl_cf_send;\n  conn->bits.tcp_fastopen = data->set.tcp_fastopen;\n\n  /* Complete the easy's SSL configuration for connection cache matching */\n  result = Curl_ssl_easy_config_complete(data);\n  if(result)\n    goto out;\n\n  prune_dead_connections(data);\n\n  /*************************************************************\n   * Check the current list of connections to see if we can\n   * reuse an already existing one or if we have to create a\n   * new one.\n   *************************************************************/\n\n  DEBUGASSERT(conn->user);\n  DEBUGASSERT(conn->passwd);\n\n  /* reuse_fresh is TRUE if we are told to use a new connection by force, but\n     we only acknowledge this option if this is not a reused connection\n     already (which happens due to follow-location or during an HTTP\n     authentication phase). CONNECT_ONLY transfers also refuse reuse. */\n  if((data->set.reuse_fresh && !data->state.followlocation) ||\n     data->set.connect_only)\n    reuse = FALSE;\n  else\n    reuse = ConnectionExists(data, conn, &existing, &force_reuse, &waitpipe);\n\n  if(reuse) {\n    /*\n     * We already have a connection for this, we got the former connection in\n     * `existing` and thus we need to cleanup the one we just\n     * allocated before we can move along and use `existing`.\n     */\n    reuse_conn(data, conn, existing);\n    conn = existing;\n    *in_connect = conn;\n\n#ifndef CURL_DISABLE_PROXY\n    infof(data, \"Re-using existing connection with %s %s\",\n          conn->bits.proxy?\"proxy\":\"host\",\n          conn->socks_proxy.host.name ? conn->socks_proxy.host.dispname :\n          conn->http_proxy.host.name ? conn->http_proxy.host.dispname :\n          conn->host.dispname);\n#else\n    infof(data, \"Re-using existing connection with host %s\",\n          conn->host.dispname);\n#endif\n  }\n  else {\n    /* We have decided that we want a new connection. However, we may not\n       be able to do that if we have reached the limit of how many\n       connections we are allowed to open. */\n\n    if(conn->handler->flags & PROTOPT_ALPN) {\n      /* The protocol wants it, so set the bits if enabled in the easy handle\n         (default) */\n      if(data->set.ssl_enable_alpn)\n        conn->bits.tls_enable_alpn = TRUE;\n    }\n\n    if(waitpipe)\n      /* There is a connection that *might* become usable for multiplexing\n         \"soon\", and we wait for that */\n      connections_available = FALSE;\n    else {\n      /* this gets a lock on the conncache */\n      struct connectbundle *bundle =\n        Curl_conncache_find_bundle(data, conn, data->state.conn_cache);\n\n      if(max_host_connections > 0 && bundle &&\n         (bundle->num_connections >= max_host_connections)) {\n        struct connectdata *conn_candidate;\n\n        /* The bundle is full. Extract the oldest connection. */\n        conn_candidate = Curl_conncache_extract_bundle(data, bundle);\n        CONNCACHE_UNLOCK(data);\n\n        if(conn_candidate)\n          Curl_disconnect(data, conn_candidate, FALSE);\n        else {\n          infof(data, \"No more connections allowed to host: %zu\",\n                max_host_connections);\n          connections_available = FALSE;\n        }\n      }\n      else\n        CONNCACHE_UNLOCK(data);\n\n    }\n\n    if(connections_available &&\n       (max_total_connections > 0) &&\n       (Curl_conncache_size(data) >= max_total_connections)) {\n      struct connectdata *conn_candidate;\n\n      /* The cache is full. Let's see if we can kill a connection. */\n      conn_candidate = Curl_conncache_extract_oldest(data);\n      if(conn_candidate)\n        Curl_disconnect(data, conn_candidate, FALSE);\n      else {\n        infof(data, \"No connections available in cache\");\n        connections_available = FALSE;\n      }\n    }\n\n    if(!connections_available) {\n      infof(data, \"No connections available.\");\n\n      conn_free(data, conn);\n      *in_connect = NULL;\n\n      result = CURLE_NO_CONNECTION_AVAILABLE;\n      goto out;\n    }\n    else {\n      /*\n       * This is a brand new connection, so let's store it in the connection\n       * cache of ours!\n       */\n      result = Curl_ssl_conn_config_init(data, conn);\n      if(result) {\n        DEBUGF(fprintf(stderr, \"Error: init connection ssl config\\n\"));\n        goto out;\n      }\n\n      Curl_attach_connection(data, conn);\n      result = Curl_conncache_add_conn(data);\n      if(result)\n        goto out;\n    }\n\n#if defined(USE_NTLM)\n    /* If NTLM is requested in a part of this connection, make sure we don't\n       assume the state is fine as this is a fresh connection and NTLM is\n       connection based. */\n    if((data->state.authhost.picked & (CURLAUTH_NTLM | CURLAUTH_NTLM_WB)) &&\n       data->state.authhost.done) {\n      infof(data, \"NTLM picked AND auth done set, clear picked\");\n      data->state.authhost.picked = CURLAUTH_NONE;\n      data->state.authhost.done = FALSE;\n    }\n\n    if((data->state.authproxy.picked & (CURLAUTH_NTLM | CURLAUTH_NTLM_WB)) &&\n       data->state.authproxy.done) {\n      infof(data, \"NTLM-proxy picked AND auth done set, clear picked\");\n      data->state.authproxy.picked = CURLAUTH_NONE;\n      data->state.authproxy.done = FALSE;\n    }\n#endif\n  }\n\n  /* Setup and init stuff before DO starts, in preparing for the transfer. */\n  Curl_init_do(data, conn);\n\n  /*\n   * Setup whatever necessary for a resumed transfer\n   */\n  result = setup_range(data);\n  if(result)\n    goto out;\n\n  /* Continue connectdata initialization here. */\n\n  /*************************************************************\n   * Resolve the address of the server or proxy\n   *************************************************************/\n  result = resolve_server(data, conn, async);\n  if(result)\n    goto out;\n\n  /* Everything general done, inform filters that they need\n   * to prepare for a data transfer.\n   */\n  result = Curl_conn_ev_data_setup(data);\n\nout:\n  return result;\n}\n\n/* Curl_setup_conn() is called after the name resolve initiated in\n * create_conn() is all done.\n *\n * Curl_setup_conn() also handles reused connections\n */\nCURLcode Curl_setup_conn(struct Curl_easy *data,\n                         bool *protocol_done)\n{\n  CURLcode result = CURLE_OK;\n  struct connectdata *conn = data->conn;\n\n  Curl_pgrsTime(data, TIMER_NAMELOOKUP);\n\n  if(conn->handler->flags & PROTOPT_NONETWORK) {\n    /* nothing to setup when not using a network */\n    *protocol_done = TRUE;\n    return result;\n  }\n\n#ifndef CURL_DISABLE_PROXY\n  /* set proxy_connect_closed to false unconditionally already here since it\n     is used strictly to provide extra information to a parent function in the\n     case of proxy CONNECT failures and we must make sure we don't have it\n     lingering set from a previous invoke */\n  conn->bits.proxy_connect_closed = FALSE;\n#endif\n\n#ifdef CURL_DO_LINEEND_CONV\n  data->state.crlf_conversions = 0; /* reset CRLF conversion counter */\n#endif /* CURL_DO_LINEEND_CONV */\n\n  /* set start time here for timeout purposes in the connect procedure, it\n     is later set again for the progress meter purpose */\n  conn->now = Curl_now();\n  if(!conn->bits.reuse)\n    result = Curl_conn_setup(data, conn, FIRSTSOCKET, conn->dns_entry,\n                             CURL_CF_SSL_DEFAULT);\n  if(!result)\n    result = Curl_headers_init(data);\n\n  /* not sure we need this flag to be passed around any more */\n  *protocol_done = FALSE;\n  return result;\n}\n\nCURLcode Curl_connect(struct Curl_easy *data,\n                      bool *asyncp,\n                      bool *protocol_done)\n{\n  CURLcode result;\n  struct connectdata *conn;\n\n  *asyncp = FALSE; /* assume synchronous resolves by default */\n\n  /* Set the request to virgin state based on transfer settings */\n  Curl_req_hard_reset(&data->req, data);\n\n  /* call the stuff that needs to be called */\n  result = create_conn(data, &conn, asyncp);\n\n  if(!result) {\n    if(CONN_INUSE(conn) > 1)\n      /* multiplexed */\n      *protocol_done = TRUE;\n    else if(!*asyncp) {\n      /* DNS resolution is done: that's either because this is a reused\n         connection, in which case DNS was unnecessary, or because DNS\n         really did finish already (synch resolver/fast async resolve) */\n      result = Curl_setup_conn(data, protocol_done);\n    }\n  }\n\n  if(result == CURLE_NO_CONNECTION_AVAILABLE) {\n    return result;\n  }\n  else if(result && conn) {\n    /* We're not allowed to return failure with memory left allocated in the\n       connectdata struct, free those here */\n    Curl_detach_connection(data);\n    Curl_conncache_remove_conn(data, conn, TRUE);\n    Curl_disconnect(data, conn, TRUE);\n  }\n\n  return result;\n}\n\n/*\n * Curl_init_do() inits the readwrite session. This is inited each time (in\n * the DO function before the protocol-specific DO functions are invoked) for\n * a transfer, sometimes multiple times on the same Curl_easy. Make sure\n * nothing in here depends on stuff that are setup dynamically for the\n * transfer.\n *\n * Allow this function to get called with 'conn' set to NULL.\n */\n\nCURLcode Curl_init_do(struct Curl_easy *data, struct connectdata *conn)\n{\n  /* if this is a pushed stream, we need this: */\n  CURLcode result = Curl_preconnect(data);\n  if(result)\n    return result;\n\n  if(conn) {\n    conn->bits.do_more = FALSE; /* by default there's no curl_do_more() to\n                                   use */\n    /* if the protocol used doesn't support wildcards, switch it off */\n    if(data->state.wildcardmatch &&\n       !(conn->handler->flags & PROTOPT_WILDCARD))\n      data->state.wildcardmatch = FALSE;\n  }\n\n  data->state.done = FALSE; /* *_done() is not called yet */\n\n  if(data->req.no_body)\n    /* in HTTP lingo, no body means using the HEAD request... */\n    data->state.httpreq = HTTPREQ_HEAD;\n\n  result = Curl_req_start(&data->req, data);\n  if(result)\n    return result;\n\n  Curl_speedinit(data);\n  Curl_pgrsSetUploadCounter(data, 0);\n  Curl_pgrsSetDownloadCounter(data, 0);\n\n  return CURLE_OK;\n}\n\n#if defined(USE_HTTP2) || defined(USE_HTTP3)\n\n#ifdef USE_NGHTTP2\n\nstatic void priority_remove_child(struct Curl_easy *parent,\n                                  struct Curl_easy *child)\n{\n  struct Curl_data_prio_node **pnext = &parent->set.priority.children;\n  struct Curl_data_prio_node *pnode = parent->set.priority.children;\n\n  DEBUGASSERT(child->set.priority.parent == parent);\n  while(pnode && pnode->data != child) {\n    pnext = &pnode->next;\n    pnode = pnode->next;\n  }\n\n  DEBUGASSERT(pnode);\n  if(pnode) {\n    *pnext = pnode->next;\n    free(pnode);\n  }\n\n  child->set.priority.parent = 0;\n  child->set.priority.exclusive = FALSE;\n}\n\nCURLcode Curl_data_priority_add_child(struct Curl_easy *parent,\n                                      struct Curl_easy *child,\n                                      bool exclusive)\n{\n  if(child->set.priority.parent) {\n    priority_remove_child(child->set.priority.parent, child);\n  }\n\n  if(parent) {\n    struct Curl_data_prio_node **tail;\n    struct Curl_data_prio_node *pnode;\n\n    pnode = calloc(1, sizeof(*pnode));\n    if(!pnode)\n      return CURLE_OUT_OF_MEMORY;\n    pnode->data = child;\n\n    if(parent->set.priority.children && exclusive) {\n      /* exclusive: move all existing children underneath the new child */\n      struct Curl_data_prio_node *node = parent->set.priority.children;\n      while(node) {\n        node->data->set.priority.parent = child;\n        node = node->next;\n      }\n\n      tail = &child->set.priority.children;\n      while(*tail)\n        tail = &(*tail)->next;\n\n      DEBUGASSERT(!*tail);\n      *tail = parent->set.priority.children;\n      parent->set.priority.children = 0;\n    }\n\n    tail = &parent->set.priority.children;\n    while(*tail) {\n      (*tail)->data->set.priority.exclusive = FALSE;\n      tail = &(*tail)->next;\n    }\n\n    DEBUGASSERT(!*tail);\n    *tail = pnode;\n  }\n\n  child->set.priority.parent = parent;\n  child->set.priority.exclusive = exclusive;\n  return CURLE_OK;\n}\n\n#endif /* USE_NGHTTP2 */\n\n#ifdef USE_NGHTTP2\nstatic void data_priority_cleanup(struct Curl_easy *data)\n{\n  while(data->set.priority.children) {\n    struct Curl_easy *tmp = data->set.priority.children->data;\n    priority_remove_child(data, tmp);\n    if(data->set.priority.parent)\n      Curl_data_priority_add_child(data->set.priority.parent, tmp, FALSE);\n  }\n\n  if(data->set.priority.parent)\n    priority_remove_child(data->set.priority.parent, data);\n}\n#endif\n\nvoid Curl_data_priority_clear_state(struct Curl_easy *data)\n{\n  memset(&data->state.priority, 0, sizeof(data->state.priority));\n}\n\n#endif /* defined(USE_HTTP2) || defined(USE_HTTP3) */\n` was unexpected","path":"/home/qqq/curl-8.7.0/lib/url.c"}],"paths":{"scanned":["/home/qqq/curl-8.7.0/CMake/CurlTests.c","/home/qqq/curl-8.7.0/docs/examples/10-at-a-time.c","/home/qqq/curl-8.7.0/docs/examples/address-scope.c","/home/qqq/curl-8.7.0/docs/examples/altsvc.c","/home/qqq/curl-8.7.0/docs/examples/anyauthput.c","/home/qqq/curl-8.7.0/docs/examples/cacertinmem.c","/home/qqq/curl-8.7.0/docs/examples/certinfo.c","/home/qqq/curl-8.7.0/docs/examples/chkspeed.c","/home/qqq/curl-8.7.0/docs/examples/connect-to.c","/home/qqq/curl-8.7.0/docs/examples/cookie_interface.c","/home/qqq/curl-8.7.0/docs/examples/crawler.c","/home/qqq/curl-8.7.0/docs/examples/debug.c","/home/qqq/curl-8.7.0/docs/examples/default-scheme.c","/home/qqq/curl-8.7.0/docs/examples/ephiperfifo.c","/home/qqq/curl-8.7.0/docs/examples/evhiperfifo.c","/home/qqq/curl-8.7.0/docs/examples/externalsocket.c","/home/qqq/curl-8.7.0/docs/examples/fileupload.c","/home/qqq/curl-8.7.0/docs/examples/ftp-wildcard.c","/home/qqq/curl-8.7.0/docs/examples/ftpget.c","/home/qqq/curl-8.7.0/docs/examples/ftpgetinfo.c","/home/qqq/curl-8.7.0/docs/examples/ftpgetresp.c","/home/qqq/curl-8.7.0/docs/examples/ftpsget.c","/home/qqq/curl-8.7.0/docs/examples/ftpupload.c","/home/qqq/curl-8.7.0/docs/examples/ftpuploadfrommem.c","/home/qqq/curl-8.7.0/docs/examples/ftpuploadresume.c","/home/qqq/curl-8.7.0/docs/examples/getinfo.c","/home/qqq/curl-8.7.0/docs/examples/getinmemory.c","/home/qqq/curl-8.7.0/docs/examples/getredirect.c","/home/qqq/curl-8.7.0/docs/examples/getreferrer.c","/home/qqq/curl-8.7.0/docs/examples/ghiper.c","/home/qqq/curl-8.7.0/docs/examples/headerapi.c","/home/qqq/curl-8.7.0/docs/examples/hiperfifo.c","/home/qqq/curl-8.7.0/docs/examples/href_extractor.c","/home/qqq/curl-8.7.0/docs/examples/hsts-preload.c","/home/qqq/curl-8.7.0/docs/examples/htmltidy.c","/home/qqq/curl-8.7.0/docs/examples/htmltitle.cpp","/home/qqq/curl-8.7.0/docs/examples/http-options.c","/home/qqq/curl-8.7.0/docs/examples/http-post.c","/home/qqq/curl-8.7.0/docs/examples/http2-download.c","/home/qqq/curl-8.7.0/docs/examples/http2-pushinmemory.c","/home/qqq/curl-8.7.0/docs/examples/http2-serverpush.c","/home/qqq/curl-8.7.0/docs/examples/http2-upload.c","/home/qqq/curl-8.7.0/docs/examples/http3-present.c","/home/qqq/curl-8.7.0/docs/examples/http3.c","/home/qqq/curl-8.7.0/docs/examples/httpcustomheader.c","/home/qqq/curl-8.7.0/docs/examples/httpput-postfields.c","/home/qqq/curl-8.7.0/docs/examples/httpput.c","/home/qqq/curl-8.7.0/docs/examples/https.c","/home/qqq/curl-8.7.0/docs/examples/imap-append.c","/home/qqq/curl-8.7.0/docs/examples/imap-authzid.c","/home/qqq/curl-8.7.0/docs/examples/imap-copy.c","/home/qqq/curl-8.7.0/docs/examples/imap-create.c","/home/qqq/curl-8.7.0/docs/examples/imap-delete.c","/home/qqq/curl-8.7.0/docs/examples/imap-examine.c","/home/qqq/curl-8.7.0/docs/examples/imap-fetch.c","/home/qqq/curl-8.7.0/docs/examples/imap-list.c","/home/qqq/curl-8.7.0/docs/examples/imap-lsub.c","/home/qqq/curl-8.7.0/docs/examples/imap-multi.c","/home/qqq/curl-8.7.0/docs/examples/imap-noop.c","/home/qqq/curl-8.7.0/docs/examples/imap-search.c","/home/qqq/curl-8.7.0/docs/examples/imap-ssl.c","/home/qqq/curl-8.7.0/docs/examples/imap-store.c","/home/qqq/curl-8.7.0/docs/examples/imap-tls.c","/home/qqq/curl-8.7.0/docs/examples/interface.c","/home/qqq/curl-8.7.0/docs/examples/ipv6.c","/home/qqq/curl-8.7.0/docs/examples/keepalive.c","/home/qqq/curl-8.7.0/docs/examples/localport.c","/home/qqq/curl-8.7.0/docs/examples/maxconnects.c","/home/qqq/curl-8.7.0/docs/examples/multi-app.c","/home/qqq/curl-8.7.0/docs/examples/multi-debugcallback.c","/home/qqq/curl-8.7.0/docs/examples/multi-double.c","/home/qqq/curl-8.7.0/docs/examples/multi-event.c","/home/qqq/curl-8.7.0/docs/examples/multi-formadd.c","/home/qqq/curl-8.7.0/docs/examples/multi-legacy.c","/home/qqq/curl-8.7.0/docs/examples/multi-post.c","/home/qqq/curl-8.7.0/docs/examples/multi-single.c","/home/qqq/curl-8.7.0/docs/examples/multi-uv.c","/home/qqq/curl-8.7.0/docs/examples/multithread.c","/home/qqq/curl-8.7.0/docs/examples/netrc.c","/home/qqq/curl-8.7.0/docs/examples/parseurl.c","/home/qqq/curl-8.7.0/docs/examples/persistent.c","/home/qqq/curl-8.7.0/docs/examples/pop3-authzid.c","/home/qqq/curl-8.7.0/docs/examples/pop3-dele.c","/home/qqq/curl-8.7.0/docs/examples/pop3-list.c","/home/qqq/curl-8.7.0/docs/examples/pop3-multi.c","/home/qqq/curl-8.7.0/docs/examples/pop3-noop.c","/home/qqq/curl-8.7.0/docs/examples/pop3-retr.c","/home/qqq/curl-8.7.0/docs/examples/pop3-ssl.c","/home/qqq/curl-8.7.0/docs/examples/pop3-stat.c","/home/qqq/curl-8.7.0/docs/examples/pop3-tls.c","/home/qqq/curl-8.7.0/docs/examples/pop3-top.c","/home/qqq/curl-8.7.0/docs/examples/pop3-uidl.c","/home/qqq/curl-8.7.0/docs/examples/post-callback.c","/home/qqq/curl-8.7.0/docs/examples/postinmemory.c","/home/qqq/curl-8.7.0/docs/examples/postit2-formadd.c","/home/qqq/curl-8.7.0/docs/examples/postit2.c","/home/qqq/curl-8.7.0/docs/examples/progressfunc.c","/home/qqq/curl-8.7.0/docs/examples/protofeats.c","/home/qqq/curl-8.7.0/docs/examples/range.c","/home/qqq/curl-8.7.0/docs/examples/resolve.c","/home/qqq/curl-8.7.0/docs/examples/rtsp-options.c","/home/qqq/curl-8.7.0/docs/examples/sendrecv.c","/home/qqq/curl-8.7.0/docs/examples/sepheaders.c","/home/qqq/curl-8.7.0/docs/examples/sessioninfo.c","/home/qqq/curl-8.7.0/docs/examples/sftpget.c","/home/qqq/curl-8.7.0/docs/examples/sftpuploadresume.c","/home/qqq/curl-8.7.0/docs/examples/shared-connection-cache.c","/home/qqq/curl-8.7.0/docs/examples/simple.c","/home/qqq/curl-8.7.0/docs/examples/simplepost.c","/home/qqq/curl-8.7.0/docs/examples/simplessl.c","/home/qqq/curl-8.7.0/docs/examples/smooth-gtk-thread.c","/home/qqq/curl-8.7.0/docs/examples/smtp-authzid.c","/home/qqq/curl-8.7.0/docs/examples/smtp-expn.c","/home/qqq/curl-8.7.0/docs/examples/smtp-mail.c","/home/qqq/curl-8.7.0/docs/examples/smtp-mime.c","/home/qqq/curl-8.7.0/docs/examples/smtp-multi.c","/home/qqq/curl-8.7.0/docs/examples/smtp-ssl.c","/home/qqq/curl-8.7.0/docs/examples/smtp-tls.c","/home/qqq/curl-8.7.0/docs/examples/smtp-vrfy.c","/home/qqq/curl-8.7.0/docs/examples/sslbackend.c","/home/qqq/curl-8.7.0/docs/examples/synctime.c","/home/qqq/curl-8.7.0/docs/examples/threaded-ssl.c","/home/qqq/curl-8.7.0/docs/examples/unixsocket.c","/home/qqq/curl-8.7.0/docs/examples/url2file.c","/home/qqq/curl-8.7.0/docs/examples/urlapi.c","/home/qqq/curl-8.7.0/docs/examples/usercertinmem.c","/home/qqq/curl-8.7.0/docs/examples/websocket-cb.c","/home/qqq/curl-8.7.0/docs/examples/websocket.c","/home/qqq/curl-8.7.0/docs/examples/xmlstream.c","/home/qqq/curl-8.7.0/include/curl/curl.h","/home/qqq/curl-8.7.0/include/curl/curlver.h","/home/qqq/curl-8.7.0/include/curl/easy.h","/home/qqq/curl-8.7.0/include/curl/header.h","/home/qqq/curl-8.7.0/include/curl/mprintf.h","/home/qqq/curl-8.7.0/include/curl/multi.h","/home/qqq/curl-8.7.0/include/curl/options.h","/home/qqq/curl-8.7.0/include/curl/stdcheaders.h","/home/qqq/curl-8.7.0/include/curl/system.h","/home/qqq/curl-8.7.0/include/curl/typecheck-gcc.h","/home/qqq/curl-8.7.0/include/curl/urlapi.h","/home/qqq/curl-8.7.0/include/curl/websockets.h","/home/qqq/curl-8.7.0/lib/altsvc.c","/home/qqq/curl-8.7.0/lib/altsvc.h","/home/qqq/curl-8.7.0/lib/amigaos.c","/home/qqq/curl-8.7.0/lib/amigaos.h","/home/qqq/curl-8.7.0/lib/arpa_telnet.h","/home/qqq/curl-8.7.0/lib/asyn-ares.c","/home/qqq/curl-8.7.0/lib/asyn-thread.c","/home/qqq/curl-8.7.0/lib/asyn.h","/home/qqq/curl-8.7.0/lib/base64.c","/home/qqq/curl-8.7.0/lib/bufq.c","/home/qqq/curl-8.7.0/lib/bufq.h","/home/qqq/curl-8.7.0/lib/bufref.c","/home/qqq/curl-8.7.0/lib/bufref.h","/home/qqq/curl-8.7.0/lib/c-hyper.c","/home/qqq/curl-8.7.0/lib/c-hyper.h","/home/qqq/curl-8.7.0/lib/cf-h1-proxy.c","/home/qqq/curl-8.7.0/lib/cf-h1-proxy.h","/home/qqq/curl-8.7.0/lib/cf-h2-proxy.c","/home/qqq/curl-8.7.0/lib/cf-h2-proxy.h","/home/qqq/curl-8.7.0/lib/cf-haproxy.c","/home/qqq/curl-8.7.0/lib/cf-haproxy.h","/home/qqq/curl-8.7.0/lib/cf-https-connect.c","/home/qqq/curl-8.7.0/lib/cf-https-connect.h","/home/qqq/curl-8.7.0/lib/cf-socket.c","/home/qqq/curl-8.7.0/lib/cf-socket.h","/home/qqq/curl-8.7.0/lib/cfilters.c","/home/qqq/curl-8.7.0/lib/cfilters.h","/home/qqq/curl-8.7.0/lib/config-amigaos.h","/home/qqq/curl-8.7.0/lib/config-dos.h","/home/qqq/curl-8.7.0/lib/config-mac.h","/home/qqq/curl-8.7.0/lib/config-os400.h","/home/qqq/curl-8.7.0/lib/config-plan9.h","/home/qqq/curl-8.7.0/lib/config-riscos.h","/home/qqq/curl-8.7.0/lib/config-win32.h","/home/qqq/curl-8.7.0/lib/config-win32ce.h","/home/qqq/curl-8.7.0/lib/conncache.c","/home/qqq/curl-8.7.0/lib/conncache.h","/home/qqq/curl-8.7.0/lib/connect.c","/home/qqq/curl-8.7.0/lib/connect.h","/home/qqq/curl-8.7.0/lib/content_encoding.c","/home/qqq/curl-8.7.0/lib/content_encoding.h","/home/qqq/curl-8.7.0/lib/cookie.c","/home/qqq/curl-8.7.0/lib/cookie.h","/home/qqq/curl-8.7.0/lib/curl_addrinfo.c","/home/qqq/curl-8.7.0/lib/curl_addrinfo.h","/home/qqq/curl-8.7.0/lib/curl_base64.h","/home/qqq/curl-8.7.0/lib/curl_ctype.h","/home/qqq/curl-8.7.0/lib/curl_des.c","/home/qqq/curl-8.7.0/lib/curl_des.h","/home/qqq/curl-8.7.0/lib/curl_endian.c","/home/qqq/curl-8.7.0/lib/curl_endian.h","/home/qqq/curl-8.7.0/lib/curl_fnmatch.c","/home/qqq/curl-8.7.0/lib/curl_fnmatch.h","/home/qqq/curl-8.7.0/lib/curl_get_line.c","/home/qqq/curl-8.7.0/lib/curl_get_line.h","/home/qqq/curl-8.7.0/lib/curl_gethostname.c","/home/qqq/curl-8.7.0/lib/curl_gethostname.h","/home/qqq/curl-8.7.0/lib/curl_gssapi.c","/home/qqq/curl-8.7.0/lib/curl_gssapi.h","/home/qqq/curl-8.7.0/lib/curl_hmac.h","/home/qqq/curl-8.7.0/lib/curl_krb5.h","/home/qqq/curl-8.7.0/lib/curl_ldap.h","/home/qqq/curl-8.7.0/lib/curl_md4.h","/home/qqq/curl-8.7.0/lib/curl_md5.h","/home/qqq/curl-8.7.0/lib/curl_memory.h","/home/qqq/curl-8.7.0/lib/curl_memrchr.c","/home/qqq/curl-8.7.0/lib/curl_memrchr.h","/home/qqq/curl-8.7.0/lib/curl_multibyte.c","/home/qqq/curl-8.7.0/lib/curl_multibyte.h","/home/qqq/curl-8.7.0/lib/curl_ntlm_core.c","/home/qqq/curl-8.7.0/lib/curl_ntlm_core.h","/home/qqq/curl-8.7.0/lib/curl_ntlm_wb.c","/home/qqq/curl-8.7.0/lib/curl_ntlm_wb.h","/home/qqq/curl-8.7.0/lib/curl_path.c","/home/qqq/curl-8.7.0/lib/curl_path.h","/home/qqq/curl-8.7.0/lib/curl_printf.h","/home/qqq/curl-8.7.0/lib/curl_range.c","/home/qqq/curl-8.7.0/lib/curl_range.h","/home/qqq/curl-8.7.0/lib/curl_rtmp.c","/home/qqq/curl-8.7.0/lib/curl_rtmp.h","/home/qqq/curl-8.7.0/lib/curl_sasl.c","/home/qqq/curl-8.7.0/lib/curl_sasl.h","/home/qqq/curl-8.7.0/lib/curl_setup.h","/home/qqq/curl-8.7.0/lib/curl_setup_once.h","/home/qqq/curl-8.7.0/lib/curl_sha256.h","/home/qqq/curl-8.7.0/lib/curl_sha512_256.c","/home/qqq/curl-8.7.0/lib/curl_sha512_256.h","/home/qqq/curl-8.7.0/lib/curl_sspi.c","/home/qqq/curl-8.7.0/lib/curl_sspi.h","/home/qqq/curl-8.7.0/lib/curl_threads.c","/home/qqq/curl-8.7.0/lib/curl_threads.h","/home/qqq/curl-8.7.0/lib/curl_trc.c","/home/qqq/curl-8.7.0/lib/curl_trc.h","/home/qqq/curl-8.7.0/lib/curlx.h","/home/qqq/curl-8.7.0/lib/cw-out.c","/home/qqq/curl-8.7.0/lib/cw-out.h","/home/qqq/curl-8.7.0/lib/dict.c","/home/qqq/curl-8.7.0/lib/dict.h","/home/qqq/curl-8.7.0/lib/doh.c","/home/qqq/curl-8.7.0/lib/doh.h","/home/qqq/curl-8.7.0/lib/dynbuf.c","/home/qqq/curl-8.7.0/lib/dynbuf.h","/home/qqq/curl-8.7.0/lib/dynhds.c","/home/qqq/curl-8.7.0/lib/dynhds.h","/home/qqq/curl-8.7.0/lib/easy.c","/home/qqq/curl-8.7.0/lib/easy_lock.h","/home/qqq/curl-8.7.0/lib/easygetopt.c","/home/qqq/curl-8.7.0/lib/easyif.h","/home/qqq/curl-8.7.0/lib/easyoptions.c","/home/qqq/curl-8.7.0/lib/easyoptions.h","/home/qqq/curl-8.7.0/lib/escape.c","/home/qqq/curl-8.7.0/lib/escape.h","/home/qqq/curl-8.7.0/lib/file.c","/home/qqq/curl-8.7.0/lib/file.h","/home/qqq/curl-8.7.0/lib/fileinfo.c","/home/qqq/curl-8.7.0/lib/fileinfo.h","/home/qqq/curl-8.7.0/lib/fopen.c","/home/qqq/curl-8.7.0/lib/fopen.h","/home/qqq/curl-8.7.0/lib/formdata.c","/home/qqq/curl-8.7.0/lib/formdata.h","/home/qqq/curl-8.7.0/lib/ftp.c","/home/qqq/curl-8.7.0/lib/ftp.h","/home/qqq/curl-8.7.0/lib/ftplistparser.c","/home/qqq/curl-8.7.0/lib/ftplistparser.h","/home/qqq/curl-8.7.0/lib/functypes.h","/home/qqq/curl-8.7.0/lib/getenv.c","/home/qqq/curl-8.7.0/lib/getinfo.c","/home/qqq/curl-8.7.0/lib/getinfo.h","/home/qqq/curl-8.7.0/lib/gopher.c","/home/qqq/curl-8.7.0/lib/gopher.h","/home/qqq/curl-8.7.0/lib/hash.c","/home/qqq/curl-8.7.0/lib/hash.h","/home/qqq/curl-8.7.0/lib/headers.c","/home/qqq/curl-8.7.0/lib/headers.h","/home/qqq/curl-8.7.0/lib/hmac.c","/home/qqq/curl-8.7.0/lib/hostasyn.c","/home/qqq/curl-8.7.0/lib/hostip.c","/home/qqq/curl-8.7.0/lib/hostip.h","/home/qqq/curl-8.7.0/lib/hostip4.c","/home/qqq/curl-8.7.0/lib/hostip6.c","/home/qqq/curl-8.7.0/lib/hostsyn.c","/home/qqq/curl-8.7.0/lib/hsts.c","/home/qqq/curl-8.7.0/lib/hsts.h","/home/qqq/curl-8.7.0/lib/http.c","/home/qqq/curl-8.7.0/lib/http.h","/home/qqq/curl-8.7.0/lib/http1.c","/home/qqq/curl-8.7.0/lib/http1.h","/home/qqq/curl-8.7.0/lib/http2.c","/home/qqq/curl-8.7.0/lib/http2.h","/home/qqq/curl-8.7.0/lib/http_aws_sigv4.c","/home/qqq/curl-8.7.0/lib/http_aws_sigv4.h","/home/qqq/curl-8.7.0/lib/http_chunks.c","/home/qqq/curl-8.7.0/lib/http_chunks.h","/home/qqq/curl-8.7.0/lib/http_digest.c","/home/qqq/curl-8.7.0/lib/http_digest.h","/home/qqq/curl-8.7.0/lib/http_negotiate.c","/home/qqq/curl-8.7.0/lib/http_negotiate.h","/home/qqq/curl-8.7.0/lib/http_ntlm.c","/home/qqq/curl-8.7.0/lib/http_ntlm.h","/home/qqq/curl-8.7.0/lib/http_proxy.c","/home/qqq/curl-8.7.0/lib/http_proxy.h","/home/qqq/curl-8.7.0/lib/idn.c","/home/qqq/curl-8.7.0/lib/idn.h","/home/qqq/curl-8.7.0/lib/if2ip.c","/home/qqq/curl-8.7.0/lib/if2ip.h","/home/qqq/curl-8.7.0/lib/imap.c","/home/qqq/curl-8.7.0/lib/imap.h","/home/qqq/curl-8.7.0/lib/inet_ntop.c","/home/qqq/curl-8.7.0/lib/inet_ntop.h","/home/qqq/curl-8.7.0/lib/inet_pton.c","/home/qqq/curl-8.7.0/lib/inet_pton.h","/home/qqq/curl-8.7.0/lib/krb5.c","/home/qqq/curl-8.7.0/lib/ldap.c","/home/qqq/curl-8.7.0/lib/llist.c","/home/qqq/curl-8.7.0/lib/llist.h","/home/qqq/curl-8.7.0/lib/macos.c","/home/qqq/curl-8.7.0/lib/macos.h","/home/qqq/curl-8.7.0/lib/md4.c","/home/qqq/curl-8.7.0/lib/md5.c","/home/qqq/curl-8.7.0/lib/memdebug.c","/home/qqq/curl-8.7.0/lib/memdebug.h","/home/qqq/curl-8.7.0/lib/mime.c","/home/qqq/curl-8.7.0/lib/mime.h","/home/qqq/curl-8.7.0/lib/mprintf.c","/home/qqq/curl-8.7.0/lib/mqtt.c","/home/qqq/curl-8.7.0/lib/mqtt.h","/home/qqq/curl-8.7.0/lib/multi.c","/home/qqq/curl-8.7.0/lib/multihandle.h","/home/qqq/curl-8.7.0/lib/multiif.h","/home/qqq/curl-8.7.0/lib/netrc.c","/home/qqq/curl-8.7.0/lib/netrc.h","/home/qqq/curl-8.7.0/lib/nonblock.c","/home/qqq/curl-8.7.0/lib/nonblock.h","/home/qqq/curl-8.7.0/lib/noproxy.c","/home/qqq/curl-8.7.0/lib/noproxy.h","/home/qqq/curl-8.7.0/lib/openldap.c","/home/qqq/curl-8.7.0/lib/parsedate.c","/home/qqq/curl-8.7.0/lib/parsedate.h","/home/qqq/curl-8.7.0/lib/pingpong.c","/home/qqq/curl-8.7.0/lib/pingpong.h","/home/qqq/curl-8.7.0/lib/pop3.c","/home/qqq/curl-8.7.0/lib/pop3.h","/home/qqq/curl-8.7.0/lib/progress.c","/home/qqq/curl-8.7.0/lib/progress.h","/home/qqq/curl-8.7.0/lib/psl.c","/home/qqq/curl-8.7.0/lib/psl.h","/home/qqq/curl-8.7.0/lib/rand.c","/home/qqq/curl-8.7.0/lib/rand.h","/home/qqq/curl-8.7.0/lib/rename.c","/home/qqq/curl-8.7.0/lib/rename.h","/home/qqq/curl-8.7.0/lib/request.c","/home/qqq/curl-8.7.0/lib/request.h","/home/qqq/curl-8.7.0/lib/rtsp.c","/home/qqq/curl-8.7.0/lib/rtsp.h","/home/qqq/curl-8.7.0/lib/select.c","/home/qqq/curl-8.7.0/lib/select.h","/home/qqq/curl-8.7.0/lib/sendf.c","/home/qqq/curl-8.7.0/lib/sendf.h","/home/qqq/curl-8.7.0/lib/setopt.c","/home/qqq/curl-8.7.0/lib/setopt.h","/home/qqq/curl-8.7.0/lib/setup-os400.h","/home/qqq/curl-8.7.0/lib/setup-vms.h","/home/qqq/curl-8.7.0/lib/setup-win32.h","/home/qqq/curl-8.7.0/lib/sha256.c","/home/qqq/curl-8.7.0/lib/share.c","/home/qqq/curl-8.7.0/lib/share.h","/home/qqq/curl-8.7.0/lib/sigpipe.h","/home/qqq/curl-8.7.0/lib/slist.c","/home/qqq/curl-8.7.0/lib/slist.h","/home/qqq/curl-8.7.0/lib/smb.c","/home/qqq/curl-8.7.0/lib/smb.h","/home/qqq/curl-8.7.0/lib/smtp.c","/home/qqq/curl-8.7.0/lib/smtp.h","/home/qqq/curl-8.7.0/lib/sockaddr.h","/home/qqq/curl-8.7.0/lib/socketpair.c","/home/qqq/curl-8.7.0/lib/socketpair.h","/home/qqq/curl-8.7.0/lib/socks.c","/home/qqq/curl-8.7.0/lib/socks.h","/home/qqq/curl-8.7.0/lib/socks_gssapi.c","/home/qqq/curl-8.7.0/lib/socks_sspi.c","/home/qqq/curl-8.7.0/lib/speedcheck.c","/home/qqq/curl-8.7.0/lib/speedcheck.h","/home/qqq/curl-8.7.0/lib/splay.c","/home/qqq/curl-8.7.0/lib/splay.h","/home/qqq/curl-8.7.0/lib/strcase.c","/home/qqq/curl-8.7.0/lib/strcase.h","/home/qqq/curl-8.7.0/lib/strdup.c","/home/qqq/curl-8.7.0/lib/strdup.h","/home/qqq/curl-8.7.0/lib/strerror.c","/home/qqq/curl-8.7.0/lib/strerror.h","/home/qqq/curl-8.7.0/lib/strtok.c","/home/qqq/curl-8.7.0/lib/strtok.h","/home/qqq/curl-8.7.0/lib/strtoofft.c","/home/qqq/curl-8.7.0/lib/strtoofft.h","/home/qqq/curl-8.7.0/lib/system_win32.c","/home/qqq/curl-8.7.0/lib/system_win32.h","/home/qqq/curl-8.7.0/lib/telnet.c","/home/qqq/curl-8.7.0/lib/telnet.h","/home/qqq/curl-8.7.0/lib/tftp.c","/home/qqq/curl-8.7.0/lib/tftp.h","/home/qqq/curl-8.7.0/lib/timediff.c","/home/qqq/curl-8.7.0/lib/timediff.h","/home/qqq/curl-8.7.0/lib/timeval.c","/home/qqq/curl-8.7.0/lib/timeval.h","/home/qqq/curl-8.7.0/lib/transfer.c","/home/qqq/curl-8.7.0/lib/transfer.h","/home/qqq/curl-8.7.0/lib/url.c","/home/qqq/curl-8.7.0/lib/url.h","/home/qqq/curl-8.7.0/lib/urlapi-int.h","/home/qqq/curl-8.7.0/lib/urlapi.c","/home/qqq/curl-8.7.0/lib/urldata.h","/home/qqq/curl-8.7.0/lib/vauth/cleartext.c","/home/qqq/curl-8.7.0/lib/vauth/cram.c","/home/qqq/curl-8.7.0/lib/vauth/digest.c","/home/qqq/curl-8.7.0/lib/vauth/digest.h","/home/qqq/curl-8.7.0/lib/vauth/digest_sspi.c","/home/qqq/curl-8.7.0/lib/vauth/gsasl.c","/home/qqq/curl-8.7.0/lib/vauth/krb5_gssapi.c","/home/qqq/curl-8.7.0/lib/vauth/krb5_sspi.c","/home/qqq/curl-8.7.0/lib/vauth/ntlm.c","/home/qqq/curl-8.7.0/lib/vauth/ntlm.h","/home/qqq/curl-8.7.0/lib/vauth/ntlm_sspi.c","/home/qqq/curl-8.7.0/lib/vauth/oauth2.c","/home/qqq/curl-8.7.0/lib/vauth/spnego_gssapi.c","/home/qqq/curl-8.7.0/lib/vauth/spnego_sspi.c","/home/qqq/curl-8.7.0/lib/vauth/vauth.c","/home/qqq/curl-8.7.0/lib/vauth/vauth.h","/home/qqq/curl-8.7.0/lib/version.c","/home/qqq/curl-8.7.0/lib/version_win32.c","/home/qqq/curl-8.7.0/lib/version_win32.h","/home/qqq/curl-8.7.0/lib/vquic/curl_msh3.c","/home/qqq/curl-8.7.0/lib/vquic/curl_msh3.h","/home/qqq/curl-8.7.0/lib/vquic/curl_ngtcp2.c","/home/qqq/curl-8.7.0/lib/vquic/curl_ngtcp2.h","/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.c","/home/qqq/curl-8.7.0/lib/vquic/curl_osslq.h","/home/qqq/curl-8.7.0/lib/vquic/curl_quiche.c","/home/qqq/curl-8.7.0/lib/vquic/curl_quiche.h","/home/qqq/curl-8.7.0/lib/vquic/vquic-tls.c","/home/qqq/curl-8.7.0/lib/vquic/vquic-tls.h","/home/qqq/curl-8.7.0/lib/vquic/vquic.c","/home/qqq/curl-8.7.0/lib/vquic/vquic.h","/home/qqq/curl-8.7.0/lib/vquic/vquic_int.h","/home/qqq/curl-8.7.0/lib/vssh/libssh.c","/home/qqq/curl-8.7.0/lib/vssh/libssh2.c","/home/qqq/curl-8.7.0/lib/vssh/ssh.h","/home/qqq/curl-8.7.0/lib/vssh/wolfssh.c","/home/qqq/curl-8.7.0/lib/vtls/bearssl.c","/home/qqq/curl-8.7.0/lib/vtls/bearssl.h","/home/qqq/curl-8.7.0/lib/vtls/gtls.c","/home/qqq/curl-8.7.0/lib/vtls/gtls.h","/home/qqq/curl-8.7.0/lib/vtls/hostcheck.c","/home/qqq/curl-8.7.0/lib/vtls/hostcheck.h","/home/qqq/curl-8.7.0/lib/vtls/keylog.c","/home/qqq/curl-8.7.0/lib/vtls/keylog.h","/home/qqq/curl-8.7.0/lib/vtls/mbedtls.c","/home/qqq/curl-8.7.0/lib/vtls/mbedtls.h","/home/qqq/curl-8.7.0/lib/vtls/mbedtls_threadlock.c","/home/qqq/curl-8.7.0/lib/vtls/mbedtls_threadlock.h","/home/qqq/curl-8.7.0/lib/vtls/openssl.c","/home/qqq/curl-8.7.0/lib/vtls/openssl.h","/home/qqq/curl-8.7.0/lib/vtls/rustls.c","/home/qqq/curl-8.7.0/lib/vtls/rustls.h","/home/qqq/curl-8.7.0/lib/vtls/schannel.c","/home/qqq/curl-8.7.0/lib/vtls/schannel.h","/home/qqq/curl-8.7.0/lib/vtls/schannel_int.h","/home/qqq/curl-8.7.0/lib/vtls/schannel_verify.c","/home/qqq/curl-8.7.0/lib/vtls/sectransp.c","/home/qqq/curl-8.7.0/lib/vtls/sectransp.h","/home/qqq/curl-8.7.0/lib/vtls/vtls.c","/home/qqq/curl-8.7.0/lib/vtls/vtls.h","/home/qqq/curl-8.7.0/lib/vtls/vtls_int.h","/home/qqq/curl-8.7.0/lib/vtls/wolfssl.c","/home/qqq/curl-8.7.0/lib/vtls/wolfssl.h","/home/qqq/curl-8.7.0/lib/vtls/x509asn1.c","/home/qqq/curl-8.7.0/lib/vtls/x509asn1.h","/home/qqq/curl-8.7.0/lib/warnless.c","/home/qqq/curl-8.7.0/lib/warnless.h","/home/qqq/curl-8.7.0/lib/ws.c","/home/qqq/curl-8.7.0/lib/ws.h","/home/qqq/curl-8.7.0/packages/OS400/ccsidcurl.c","/home/qqq/curl-8.7.0/packages/OS400/ccsidcurl.h","/home/qqq/curl-8.7.0/packages/OS400/curlcl.c","/home/qqq/curl-8.7.0/packages/OS400/curlmain.c","/home/qqq/curl-8.7.0/packages/OS400/os400sys.c","/home/qqq/curl-8.7.0/packages/OS400/os400sys.h","/home/qqq/curl-8.7.0/packages/vms/curl_crtl_init.c","/home/qqq/curl-8.7.0/packages/vms/curlmsg.h","/home/qqq/curl-8.7.0/packages/vms/curlmsg_vms.h","/home/qqq/curl-8.7.0/packages/vms/report_openssl_version.c","/home/qqq/curl-8.7.0/packages/vms/vms_eco_level.h","/home/qqq/curl-8.7.0/projects/wolfssl_options.h","/home/qqq/curl-8.7.0/scripts/schemetable.c","/home/qqq/curl-8.7.0/src/slist_wc.c","/home/qqq/curl-8.7.0/src/slist_wc.h","/home/qqq/curl-8.7.0/src/tool_binmode.c","/home/qqq/curl-8.7.0/src/tool_binmode.h","/home/qqq/curl-8.7.0/src/tool_bname.c","/home/qqq/curl-8.7.0/src/tool_bname.h","/home/qqq/curl-8.7.0/src/tool_cb_dbg.c","/home/qqq/curl-8.7.0/src/tool_cb_dbg.h","/home/qqq/curl-8.7.0/src/tool_cb_hdr.c","/home/qqq/curl-8.7.0/src/tool_cb_hdr.h","/home/qqq/curl-8.7.0/src/tool_cb_prg.c","/home/qqq/curl-8.7.0/src/tool_cb_prg.h","/home/qqq/curl-8.7.0/src/tool_cb_rea.c","/home/qqq/curl-8.7.0/src/tool_cb_rea.h","/home/qqq/curl-8.7.0/src/tool_cb_see.c","/home/qqq/curl-8.7.0/src/tool_cb_see.h","/home/qqq/curl-8.7.0/src/tool_cb_wrt.c","/home/qqq/curl-8.7.0/src/tool_cb_wrt.h","/home/qqq/curl-8.7.0/src/tool_cfgable.c","/home/qqq/curl-8.7.0/src/tool_cfgable.h","/home/qqq/curl-8.7.0/src/tool_dirhie.c","/home/qqq/curl-8.7.0/src/tool_dirhie.h","/home/qqq/curl-8.7.0/src/tool_doswin.c","/home/qqq/curl-8.7.0/src/tool_doswin.h","/home/qqq/curl-8.7.0/src/tool_easysrc.c","/home/qqq/curl-8.7.0/src/tool_easysrc.h","/home/qqq/curl-8.7.0/src/tool_filetime.c","/home/qqq/curl-8.7.0/src/tool_filetime.h","/home/qqq/curl-8.7.0/src/tool_findfile.c","/home/qqq/curl-8.7.0/src/tool_findfile.h","/home/qqq/curl-8.7.0/src/tool_formparse.c","/home/qqq/curl-8.7.0/src/tool_formparse.h","/home/qqq/curl-8.7.0/src/tool_getparam.c","/home/qqq/curl-8.7.0/src/tool_getparam.h","/home/qqq/curl-8.7.0/src/tool_getpass.c","/home/qqq/curl-8.7.0/src/tool_getpass.h","/home/qqq/curl-8.7.0/src/tool_help.c","/home/qqq/curl-8.7.0/src/tool_help.h","/home/qqq/curl-8.7.0/src/tool_helpers.c","/home/qqq/curl-8.7.0/src/tool_helpers.h","/home/qqq/curl-8.7.0/src/tool_hugehelp.c","/home/qqq/curl-8.7.0/src/tool_hugehelp.h","/home/qqq/curl-8.7.0/src/tool_ipfs.c","/home/qqq/curl-8.7.0/src/tool_ipfs.h","/home/qqq/curl-8.7.0/src/tool_libinfo.c","/home/qqq/curl-8.7.0/src/tool_libinfo.h","/home/qqq/curl-8.7.0/src/tool_listhelp.c","/home/qqq/curl-8.7.0/src/tool_main.c","/home/qqq/curl-8.7.0/src/tool_main.h","/home/qqq/curl-8.7.0/src/tool_msgs.c","/home/qqq/curl-8.7.0/src/tool_msgs.h","/home/qqq/curl-8.7.0/src/tool_operate.c","/home/qqq/curl-8.7.0/src/tool_operate.h","/home/qqq/curl-8.7.0/src/tool_operhlp.c","/home/qqq/curl-8.7.0/src/tool_operhlp.h","/home/qqq/curl-8.7.0/src/tool_paramhlp.c","/home/qqq/curl-8.7.0/src/tool_paramhlp.h","/home/qqq/curl-8.7.0/src/tool_parsecfg.c","/home/qqq/curl-8.7.0/src/tool_parsecfg.h","/home/qqq/curl-8.7.0/src/tool_progress.c","/home/qqq/curl-8.7.0/src/tool_progress.h","/home/qqq/curl-8.7.0/src/tool_sdecls.h","/home/qqq/curl-8.7.0/src/tool_setopt.c","/home/qqq/curl-8.7.0/src/tool_setopt.h","/home/qqq/curl-8.7.0/src/tool_setup.h","/home/qqq/curl-8.7.0/src/tool_sleep.c","/home/qqq/curl-8.7.0/src/tool_sleep.h","/home/qqq/curl-8.7.0/src/tool_stderr.c","/home/qqq/curl-8.7.0/src/tool_stderr.h","/home/qqq/curl-8.7.0/src/tool_strdup.c","/home/qqq/curl-8.7.0/src/tool_strdup.h","/home/qqq/curl-8.7.0/src/tool_urlglob.c","/home/qqq/curl-8.7.0/src/tool_urlglob.h","/home/qqq/curl-8.7.0/src/tool_util.c","/home/qqq/curl-8.7.0/src/tool_util.h","/home/qqq/curl-8.7.0/src/tool_version.h","/home/qqq/curl-8.7.0/src/tool_vms.c","/home/qqq/curl-8.7.0/src/tool_vms.h","/home/qqq/curl-8.7.0/src/tool_writeout.c","/home/qqq/curl-8.7.0/src/tool_writeout.h","/home/qqq/curl-8.7.0/src/tool_writeout_json.c","/home/qqq/curl-8.7.0/src/tool_writeout_json.h","/home/qqq/curl-8.7.0/src/tool_xattr.c","/home/qqq/curl-8.7.0/src/tool_xattr.h","/home/qqq/curl-8.7.0/src/var.c","/home/qqq/curl-8.7.0/src/var.h","/home/qqq/curl-8.7.0/test.c"]},"interfile_languages_used":[],"skipped_rules":[]}
